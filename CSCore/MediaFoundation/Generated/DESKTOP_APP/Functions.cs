// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.MediaFoundation namespace.
//     This code was generated by a tool.
//     Date : 2017/7/15 0:31:26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.MediaFoundation
{

#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574

    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.AsfProfileAttributeKeys']/*"/>	
    public static partial class AsfProfileAttributeKeys
    {

        /// <summary>Constant Maxpacketsize.</summary>
        /// <unmanaged>MF_ASFPROFILE_MAXPACKETSIZE</unmanaged>
        public static readonly MediaAttributeKey<int> Maxpacketsize = new MediaAttributeKey<int>("22587627-47de-4168-87f5-b5aa9b12a8f0", "Maxpacketsize");

        /// <summary>Constant Minpacketsize.</summary>
        /// <unmanaged>MF_ASFPROFILE_MINPACKETSIZE</unmanaged>
        public static readonly MediaAttributeKey<int> Minpacketsize = new MediaAttributeKey<int>("22587626-47de-4168-87f5-b5aa9b12a8f0", "Minpacketsize");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.AsfSplitterAttributeKeys']/*"/>	
    public static partial class AsfSplitterAttributeKeys
    {

        /// <summary>Constant PacketBoundary.</summary>
        /// <unmanaged>MFASFSPLITTER_PACKET_BOUNDARY</unmanaged>
        public static readonly MediaAttributeKey<bool> PacketBoundary = new MediaAttributeKey<bool>("fe584a05-e8d6-42e3-b176-f1211705fb6f", "PacketBoundary");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.AsfStreamConfigAttributeKeys']/*"/>	
    public static partial class AsfStreamConfigAttributeKeys
    {

        /// <summary>Constant LeakyBucket1.</summary>
        /// <unmanaged>MF_ASFSTREAMCONFIG_LEAKYBUCKET1</unmanaged>
        public static readonly MediaAttributeKey<byte[]> LeakyBucket1 = new MediaAttributeKey<byte[]>("c69b5901-ea1a-4c9b-b692-e2a0d29a8add", "LeakyBucket1");

        /// <summary>Constant LeakyBucket2.</summary>
        /// <unmanaged>MF_ASFSTREAMCONFIG_LEAKYBUCKET2</unmanaged>
        public static readonly MediaAttributeKey<byte[]> LeakyBucket2 = new MediaAttributeKey<byte[]>("c69b5902-ea1a-4c9b-b692-e2a0d29a8add", "LeakyBucket2");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.AudioFormatGuids']/*"/>	
    public static partial class AudioFormatGuids
    {

        /// <summary>Constant Base.</summary>
        /// <unmanaged>MFAudioFormat_Base</unmanaged>
        public static readonly System.Guid Base = new Guid("00000000-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Pcm.</summary>
        /// <unmanaged>MFAudioFormat_PCM</unmanaged>
        public static readonly System.Guid Pcm = new Guid("00000001-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Float.</summary>
        /// <unmanaged>MFAudioFormat_Float</unmanaged>
        public static readonly System.Guid Float = new Guid("00000003-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Dts.</summary>
        /// <unmanaged>MFAudioFormat_DTS</unmanaged>
        public static readonly System.Guid Dts = new Guid("00000008-0000-0010-8000-00aa00389b71");

        /// <summary>Constant DolbyAc3Spdif.</summary>
        /// <unmanaged>MFAudioFormat_Dolby_AC3_SPDIF</unmanaged>
        public static readonly System.Guid DolbyAc3Spdif = new Guid("00000092-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Drm.</summary>
        /// <unmanaged>MFAudioFormat_DRM</unmanaged>
        public static readonly System.Guid Drm = new Guid("00000009-0000-0010-8000-00aa00389b71");

        /// <summary>Constant WMAudioV8.</summary>
        /// <unmanaged>MFAudioFormat_WMAudioV8</unmanaged>
        public static readonly System.Guid WMAudioV8 = new Guid("00000161-0000-0010-8000-00aa00389b71");

        /// <summary>Constant WMAudioV9.</summary>
        /// <unmanaged>MFAudioFormat_WMAudioV9</unmanaged>
        public static readonly System.Guid WMAudioV9 = new Guid("00000162-0000-0010-8000-00aa00389b71");

        /// <summary>Constant WMAudioLossless.</summary>
        /// <unmanaged>MFAudioFormat_WMAudio_Lossless</unmanaged>
        public static readonly System.Guid WMAudioLossless = new Guid("00000163-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Wmaspdif.</summary>
        /// <unmanaged>MFAudioFormat_WMASPDIF</unmanaged>
        public static readonly System.Guid Wmaspdif = new Guid("00000164-0000-0010-8000-00aa00389b71");

        /// <summary>Constant MultisampledP1.</summary>
        /// <unmanaged>MFAudioFormat_MSP1</unmanaged>
        public static readonly System.Guid MultisampledP1 = new Guid("0000000a-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Mp3.</summary>
        /// <unmanaged>MFAudioFormat_MP3</unmanaged>
        public static readonly System.Guid Mp3 = new Guid("00000055-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Mpeg.</summary>
        /// <unmanaged>MFAudioFormat_MPEG</unmanaged>
        public static readonly System.Guid Mpeg = new Guid("00000050-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Aac.</summary>
        /// <unmanaged>MFAudioFormat_AAC</unmanaged>
        public static readonly System.Guid Aac = new Guid("00001610-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Adts.</summary>
        /// <unmanaged>MFAudioFormat_ADTS</unmanaged>
        public static readonly System.Guid Adts = new Guid("00001600-0000-0010-8000-00aa00389b71");

        /// <summary>Constant AmrNb.</summary>
        /// <unmanaged>MFAudioFormat_AMR_NB</unmanaged>
        public static readonly System.Guid AmrNb = new Guid("00007361-0000-0010-8000-00aa00389b71");

        /// <summary>Constant AmrWb.</summary>
        /// <unmanaged>MFAudioFormat_AMR_WB</unmanaged>
        public static readonly System.Guid AmrWb = new Guid("00007362-0000-0010-8000-00aa00389b71");

        /// <summary>Constant AmrWp.</summary>
        /// <unmanaged>MFAudioFormat_AMR_WP</unmanaged>
        public static readonly System.Guid AmrWp = new Guid("00007363-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Flac.</summary>
        /// <unmanaged>MFAudioFormat_FLAC</unmanaged>
        public static readonly System.Guid Flac = new Guid("0000f1ac-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Alac.</summary>
        /// <unmanaged>MFAudioFormat_ALAC</unmanaged>
        public static readonly System.Guid Alac = new Guid("00006c61-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Opus.</summary>
        /// <unmanaged>MFAudioFormat_Opus</unmanaged>
        public static readonly System.Guid Opus = new Guid("0000704f-0000-0010-8000-00aa00389b71");

        /// <summary>Constant DolbyAc3.</summary>
        /// <unmanaged>MFAudioFormat_Dolby_AC3</unmanaged>
        public static readonly System.Guid DolbyAc3 = new Guid("e06d802c-db46-11cf-b4d1-00805f6cbbea");

        /// <summary>Constant DolbyDDPlus.</summary>
        /// <unmanaged>MFAudioFormat_Dolby_DDPlus</unmanaged>
        public static readonly System.Guid DolbyDDPlus = new Guid("a7fb87af-2d02-42fb-a4d4-05cd93843bdd");

        /// <summary>Constant Vorbis.</summary>
        /// <unmanaged>MFAudioFormat_Vorbis</unmanaged>
        public static readonly System.Guid Vorbis = new Guid("8d2fd10b-5841-4a6b-8905-588fec1aded9");

        /// <summary>Constant FloatSpatialObjects.</summary>
        /// <unmanaged>MFAudioFormat_Float_SpatialObjects</unmanaged>
        public static readonly System.Guid FloatSpatialObjects = new Guid("fa39cd94-bc64-4ab1-9b71-dcd09d5a7e7a");

        /// <summary>Constant Lpcm.</summary>
        /// <unmanaged>MFAudioFormat_LPCM</unmanaged>
        public static readonly System.Guid Lpcm = new Guid("e06d8032-db46-11cf-b4d1-00805f6cbbea");

        /// <summary>Constant PcmHdcp.</summary>
        /// <unmanaged>MFAudioFormat_PCM_HDCP</unmanaged>
        public static readonly System.Guid PcmHdcp = new Guid("a5e7ff01-8411-4acc-a865-5f4941288d80");

        /// <summary>Constant DolbyAc3Hdcp.</summary>
        /// <unmanaged>MFAudioFormat_Dolby_AC3_HDCP</unmanaged>
        public static readonly System.Guid DolbyAc3Hdcp = new Guid("97663a80-8ffb-4445-a6ba-792d908f497f");

        /// <summary>Constant AacHdcp.</summary>
        /// <unmanaged>MFAudioFormat_AAC_HDCP</unmanaged>
        public static readonly System.Guid AacHdcp = new Guid("419bce76-8b72-400f-adeb-84b57d63484d");

        /// <summary>Constant AdtsHdcp.</summary>
        /// <unmanaged>MFAudioFormat_ADTS_HDCP</unmanaged>
        public static readonly System.Guid AdtsHdcp = new Guid("da4963a3-14d8-4dcf-92b7-193eb84363db");

        /// <summary>Constant BaseHdcp.</summary>
        /// <unmanaged>MFAudioFormat_Base_HDCP</unmanaged>
        public static readonly System.Guid BaseHdcp = new Guid("3884b5bc-e277-43fd-983d-038aa8d9b605");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.AudioRendererAttributeKeys']/*"/>	
    public static partial class AudioRendererAttributeKeys
    {

        /// <summary>Constant EndpointId.</summary>
        /// <unmanaged>MF_AUDIO_RENDERER_ATTRIBUTE_ENDPOINT_ID</unmanaged>
        public static readonly MediaAttributeKey<string> EndpointId = new MediaAttributeKey<string>("b10aaec3-ef71-4cc3-b873-05a9a08b9f8e", "EndpointId");

        /// <summary>Constant EndpointRole.</summary>
        /// <unmanaged>MF_AUDIO_RENDERER_ATTRIBUTE_ENDPOINT_ROLE</unmanaged>
        public static readonly MediaAttributeKey<int> EndpointRole = new MediaAttributeKey<int>("6ba644ff-27c5-4d02-9887-c28619fdb91b", "EndpointRole");

        /// <summary>Constant Flags.</summary>
        /// <unmanaged>MF_AUDIO_RENDERER_ATTRIBUTE_FLAGS</unmanaged>
        public static readonly MediaAttributeKey<int> Flags = new MediaAttributeKey<int>("ede4b5e0-f805-4d6c-99b3-db01bf95dfab", "Flags");

        /// <summary>Constant SessionId.</summary>
        /// <unmanaged>MF_AUDIO_RENDERER_ATTRIBUTE_SESSION_ID</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> SessionId = new MediaAttributeKey<System.Guid>("ede4b5e3-f805-4d6c-99b3-db01bf95dfab", "SessionId");

        /// <summary>Constant StreamCategory.</summary>
        /// <unmanaged>MF_AUDIO_RENDERER_ATTRIBUTE_STREAM_CATEGORY</unmanaged>
        public static readonly MediaAttributeKey<int> StreamCategory = new MediaAttributeKey<int>("a9770471-92ec-4df4-94fe-81c36f0c3a7a", "StreamCategory");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.ByteStreamAttributeKeys']/*"/>	
    public static partial class ByteStreamAttributeKeys
    {

        /// <summary>Constant ContentType.</summary>
        /// <unmanaged>MF_BYTESTREAM_CONTENT_TYPE</unmanaged>
        public static readonly MediaAttributeKey<string> ContentType = new MediaAttributeKey<string>("fc358289-3cb6-460c-a424-b6681260375a", "ContentType");

        /// <summary>Constant Duration.</summary>
        /// <unmanaged>MF_BYTESTREAM_DURATION</unmanaged>
        public static readonly MediaAttributeKey<long> Duration = new MediaAttributeKey<long>("fc35828a-3cb6-460c-a424-b6681260375a", "Duration");

        /// <summary>Constant EffectiveUrl.</summary>
        /// <unmanaged>MF_BYTESTREAM_EFFECTIVE_URL</unmanaged>
        public static readonly MediaAttributeKey<string> EffectiveUrl = new MediaAttributeKey<string>("9afa0209-89d1-42af-8456-1de6b562d691", "EffectiveUrl");

        /// <summary>Constant IfoFileUri.</summary>
        /// <unmanaged>MF_BYTESTREAM_IFO_FILE_URI</unmanaged>
        public static readonly MediaAttributeKey<string> IfoFileUri = new MediaAttributeKey<string>("fc35828c-3cb6-460c-a424-b6681260375a", "IfoFileUri");

        /// <summary>Constant LastModifiedTime.</summary>
        /// <unmanaged>MF_BYTESTREAM_LAST_MODIFIED_TIME</unmanaged>
        public static readonly MediaAttributeKey<byte[]> LastModifiedTime = new MediaAttributeKey<byte[]>("fc35828b-3cb6-460c-a424-b6681260375a", "LastModifiedTime");

        /// <summary>Constant OriginName.</summary>
        /// <unmanaged>MF_BYTESTREAM_ORIGIN_NAME</unmanaged>
        public static readonly MediaAttributeKey<string> OriginName = new MediaAttributeKey<string>("fc358288-3cb6-460c-a424-b6681260375a", "OriginName");

        /// <summary>Constant HandlerAcceptsShareWrite.</summary>
        /// <unmanaged>MF_BYTESTREAMHANDLER_ACCEPTS_SHARE_WRITE</unmanaged>
        public static readonly MediaAttributeKey<int> HandlerAcceptsShareWrite = new MediaAttributeKey<int>("a6e1f733-3001-4915-8150-1558a2180ec8", "HandlerAcceptsShareWrite");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.CaptureDeviceAttributeKeys']/*"/>	
    public static partial class CaptureDeviceAttributeKeys
    {

        /// <summary>Constant SourceTypeVideoCapture.</summary>
        /// <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_GUID</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> SourceTypeVideoCapture = new MediaAttributeKey<System.Guid>("8ac3587a-4ae7-42d8-99e0-0a6013eef90f", "SourceTypeVideoCapture");

        /// <summary>Constant SourceTypeAudioCapture.</summary>
        /// <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_GUID</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> SourceTypeAudioCapture = new MediaAttributeKey<System.Guid>("14dd9a1c-7cff-41be-b1b9-ba1ac6ecb571", "SourceTypeAudioCapture");

        /// <summary>Constant FriendlyName.</summary>
        /// <unmanaged>MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME</unmanaged>
        public static readonly MediaAttributeKey<string> FriendlyName = new MediaAttributeKey<string>("60d0e559-52f8-4fa2-bbce-acdb34a8ec01", "FriendlyName");

        /// <summary>Constant MediaType.</summary>
        /// <unmanaged>MF_DEVSOURCE_ATTRIBUTE_MEDIA_TYPE</unmanaged>
        public static readonly MediaAttributeKey<byte[]> MediaType = new MediaAttributeKey<byte[]>("56a819ca-0c78-4de4-a0a7-3ddaba0f24d4", "MediaType");

        /// <summary>Constant SourceType.</summary>
        /// <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> SourceType = new MediaAttributeKey<System.Guid>("c60ac5fe-252a-478f-a0ef-bc8fa5f7cad3", "SourceType");

        /// <summary>Constant SourceTypeAudcapEndpointId.</summary>
        /// <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_ENDPOINT_ID</unmanaged>
        public static readonly MediaAttributeKey<string> SourceTypeAudcapEndpointId = new MediaAttributeKey<string>("30da9258-feb9-47a7-a453-763a7a8e1c5f", "SourceTypeAudcapEndpointId");

        /// <summary>Constant SourceTypeAudcapRole.</summary>
        /// <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_ROLE</unmanaged>
        public static readonly MediaAttributeKey<int> SourceTypeAudcapRole = new MediaAttributeKey<int>("bc9d118e-8c67-4a18-85d4-12d300400552", "SourceTypeAudcapRole");

        /// <summary>Constant SourceTypeVidcapCategory.</summary>
        /// <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_CATEGORY</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> SourceTypeVidcapCategory = new MediaAttributeKey<System.Guid>("77f0ae69-c3bd-4509-941d-467e4d24899e", "SourceTypeVidcapCategory");

        /// <summary>Constant SourceTypeVidcapHwSource.</summary>
        /// <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_HW_SOURCE</unmanaged>
        public static readonly MediaAttributeKey<int> SourceTypeVidcapHwSource = new MediaAttributeKey<int>("de7046ba-54d6-4487-a2a4-ec7c0d1bd163", "SourceTypeVidcapHwSource");

        /// <summary>Constant SourceTypeVidcapMaxBuffers.</summary>
        /// <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_MAX_BUFFERS</unmanaged>
        public static readonly MediaAttributeKey<int> SourceTypeVidcapMaxBuffers = new MediaAttributeKey<int>("7dd9b730-4f2d-41d5-8f95-0cc9a912ba26", "SourceTypeVidcapMaxBuffers");

        /// <summary>Constant SourceTypeVidcapSymbolicLink.</summary>
        /// <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_SYMBOLIC_LINK</unmanaged>
        public static readonly MediaAttributeKey<string> SourceTypeVidcapSymbolicLink = new MediaAttributeKey<string>("58f0aad8-22bf-4f8a-bb3d-d2c4978c6e2f", "SourceTypeVidcapSymbolicLink");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.CaptureEngineAttributeKeys']/*"/>	
    public static partial class CaptureEngineAttributeKeys
    {

        /// <summary>Constant D3DManager.</summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_D3D_MANAGER</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.MediaFoundation.DXGIDeviceManager> D3DManager = new MediaAttributeKey<SharpDX.MediaFoundation.DXGIDeviceManager>("76e25e7b-d595-4283-962c-c594afd78ddf", "D3DManager");

        /// <summary>Constant DecoderTransformFieldOfUseUnlockAttribute.</summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_DECODER_MFT_FIELDOFUSE_UNLOCK_Attribute</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> DecoderTransformFieldOfUseUnlockAttribute = new MediaAttributeKey<SharpDX.ComObject>("2b8ad2e8-7acb-4321-a606-325c4249f4fc", "DecoderTransformFieldOfUseUnlockAttribute");

        /// <summary>Constant DisableDXVA.</summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_DISABLE_DXVA</unmanaged>
        public static readonly MediaAttributeKey<bool> DisableDXVA = new MediaAttributeKey<bool>("f9818862-179d-433f-a32f-74cbcf74466d", "DisableDXVA");

        /// <summary>Constant DisableHardwareTransforms.</summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_DISABLE_HARDWARE_TRANSFORMS</unmanaged>
        public static readonly MediaAttributeKey<bool> DisableHardwareTransforms = new MediaAttributeKey<bool>("b7c42a6b-3207-4495-b4e7-81f9c35d5991", "DisableHardwareTransforms");

        /// <summary>Constant EncoderTransformFieldOfUseUnlockAttribute.</summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_ENCODER_MFT_FIELDOFUSE_UNLOCK_Attribute</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> EncoderTransformFieldOfUseUnlockAttribute = new MediaAttributeKey<SharpDX.ComObject>("54c63a00-78d5-422f-aa3e-5e99ac649269", "EncoderTransformFieldOfUseUnlockAttribute");

        /// <summary>Constant EventGeneratorGuid.</summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_EVENT_GENERATOR_GUID</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> EventGeneratorGuid = new MediaAttributeKey<System.Guid>("abfa8ad5-fc6d-4911-87e0-961945f8f7ce", "EventGeneratorGuid");

        /// <summary>Constant EventStreamIndex.</summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_EVENT_STREAM_INDEX</unmanaged>
        public static readonly MediaAttributeKey<int> EventStreamIndex = new MediaAttributeKey<int>("82697f44-b1cf-42eb-9753-f86d649c8865", "EventStreamIndex");

        /// <summary>Constant MediaSourceConfig.</summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_MEDIASOURCE_CONFIG</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> MediaSourceConfig = new MediaAttributeKey<SharpDX.ComObject>("bc6989d2-0fc1-46e1-a74f-efd36bc788de", "MediaSourceConfig");

        /// <summary>Constant RecordSinkAudioMaxProcessedSamples.</summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_RECORD_SINK_AUDIO_MAX_PROCESSED_SAMPLES</unmanaged>
        public static readonly MediaAttributeKey<int> RecordSinkAudioMaxProcessedSamples = new MediaAttributeKey<int>("9896e12a-f707-4500-b6bd-db8eb810b50f", "RecordSinkAudioMaxProcessedSamples");

        /// <summary>Constant RecordSinkAudioMaxUnprocessedSamples.</summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_RECORD_SINK_AUDIO_MAX_UNPROCESSED_SAMPLES</unmanaged>
        public static readonly MediaAttributeKey<long> RecordSinkAudioMaxUnprocessedSamples = new MediaAttributeKey<long>("1cddb141-a7f4-4d58-9896-4d15a53c4efe", "RecordSinkAudioMaxUnprocessedSamples");

        /// <summary>Constant RecordSinkVideoMaxProcessedSamples.</summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_RECORD_SINK_VIDEO_MAX_PROCESSED_SAMPLES</unmanaged>
        public static readonly MediaAttributeKey<int> RecordSinkVideoMaxProcessedSamples = new MediaAttributeKey<int>("e7b4a49e-382c-4aef-a946-aed5490b7111", "RecordSinkVideoMaxProcessedSamples");

        /// <summary>Constant RecordSinkVideoMaxUnprocessedSamples.</summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_RECORD_SINK_VIDEO_MAX_UNPROCESSED_SAMPLES</unmanaged>
        public static readonly MediaAttributeKey<long> RecordSinkVideoMaxUnprocessedSamples = new MediaAttributeKey<long>("b467f705-7913-4894-9d42-a215fea23da9", "RecordSinkVideoMaxUnprocessedSamples");

        /// <summary>Constant UseAudioDeviceOnly.</summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_USE_AUDIO_DEVICE_ONLY</unmanaged>
        public static readonly MediaAttributeKey<bool> UseAudioDeviceOnly = new MediaAttributeKey<bool>("1c8077da-8466-4dc4-8b8e-276b3f85923b", "UseAudioDeviceOnly");

        /// <summary>Constant UseVideoDeviceOnly.</summary>
        /// <unmanaged>MF_CAPTURE_ENGINE_USE_VIDEO_DEVICE_ONLY</unmanaged>
        public static readonly MediaAttributeKey<bool> UseVideoDeviceOnly = new MediaAttributeKey<bool>("7e025171-cf32-4f2e-8f19-410577b73a66", "UseVideoDeviceOnly");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.DeviceStreamAttributeKeys']/*"/>	
    public static partial class DeviceStreamAttributeKeys
    {

        /// <summary>Constant ExtensionPluginClsid.</summary>
        /// <unmanaged>MF_DEVICESTREAM_EXTENSION_PLUGIN_CLSID</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> ExtensionPluginClsid = new MediaAttributeKey<System.Guid>("048e6558-60c4-4173-bd5b-6a3ca2896aee", "ExtensionPluginClsid");

        /// <summary>Constant ExtensionPluginConnectionPoint.</summary>
        /// <unmanaged>MF_DEVICESTREAM_EXTENSION_PLUGIN_CONNECTION_POINT</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> ExtensionPluginConnectionPoint = new MediaAttributeKey<SharpDX.ComObject>("37f9375c-e664-4ea4-aae4-cb6d1daca1f4", "ExtensionPluginConnectionPoint");

        /// <summary>Constant ImageStream.</summary>
        /// <unmanaged>MF_DEVICESTREAM_IMAGE_STREAM</unmanaged>
        public static readonly MediaAttributeKey<bool> ImageStream = new MediaAttributeKey<bool>("a7ffb865-e7b2-43b0-9f6f-9af2a0e50fc0", "ImageStream");

        /// <summary>Constant IndependentImageStream.</summary>
        /// <unmanaged>MF_DEVICESTREAM_INDEPENDENT_IMAGE_STREAM</unmanaged>
        public static readonly MediaAttributeKey<bool> IndependentImageStream = new MediaAttributeKey<bool>("03eeec7e-d605-4576-8b29-6580b490d7d3", "IndependentImageStream");

        /// <summary>Constant MaxFrameBuffers.</summary>
        /// <unmanaged>MF_DEVICESTREAM_MAX_FRAME_BUFFERS</unmanaged>
        public static readonly MediaAttributeKey<int> MaxFrameBuffers = new MediaAttributeKey<int>("1684cebe-3175-4985-882c-0efd3e8ac11e", "MaxFrameBuffers");

        /// <summary>Constant StreamCategory.</summary>
        /// <unmanaged>MF_DEVICESTREAM_STREAM_CATEGORY</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> StreamCategory = new MediaAttributeKey<System.Guid>("2939e7b8-a62e-4579-b674-d4073dfabbba", "StreamCategory");

        /// <summary>Constant StreamId.</summary>
        /// <unmanaged>MF_DEVICESTREAM_STREAM_ID</unmanaged>
        public static readonly MediaAttributeKey<int> StreamId = new MediaAttributeKey<int>("11bd5120-d124-446b-88e6-17060257fff9", "StreamId");

        /// <summary>Constant TakephotoTrigger.</summary>
        /// <unmanaged>MF_DEVICESTREAM_TAKEPHOTO_TRIGGER</unmanaged>
        public static readonly MediaAttributeKey<int> TakephotoTrigger = new MediaAttributeKey<int>("1d180e34-538c-4fbb-a75a-859af7d261a6", "TakephotoTrigger");

        /// <summary>Constant TransformStreamId.</summary>
        /// <unmanaged>MF_DEVICESTREAM_TRANSFORM_STREAM_ID</unmanaged>
        public static readonly MediaAttributeKey<int> TransformStreamId = new MediaAttributeKey<int>("e63937b7-daaf-4d49-815f-d826f8ad31e7", "TransformStreamId");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.DLNAMediaSinkAttributeKeys']/*"/>	
    public static partial class DLNAMediaSinkAttributeKeys
    {

        /// <summary>Constant AudioBitRate.</summary>
        /// <unmanaged>MF_MP2DLNA_AUDIO_BIT_RATE</unmanaged>
        public static readonly MediaAttributeKey<int> AudioBitRate = new MediaAttributeKey<int>("2d1c070e-2b5f-4ab3-a7e6-8d943ba8d00a", "AudioBitRate");

        /// <summary>Constant EncodeQuality.</summary>
        /// <unmanaged>MF_MP2DLNA_ENCODE_QUALITY</unmanaged>
        public static readonly MediaAttributeKey<int> EncodeQuality = new MediaAttributeKey<int>("b52379d7-1d46-4fb6-a317-a4a5f60959f8", "EncodeQuality");

        /// <summary>Constant Statistics.</summary>
        /// <unmanaged>MF_MP2DLNA_STATISTICS</unmanaged>
        public static readonly MediaAttributeKey<byte[]> Statistics = new MediaAttributeKey<byte[]>("75e488a3-d5ad-4898-85e0-bcce24a722d7", "Statistics");

        /// <summary>Constant UseMmcss.</summary>
        /// <unmanaged>MF_MP2DLNA_USE_MMCSS</unmanaged>
        public static readonly MediaAttributeKey<bool> UseMmcss = new MediaAttributeKey<bool>("54f3e2ee-a2a2-497d-9834-973afde521eb", "UseMmcss");

        /// <summary>Constant VideoBitRate.</summary>
        /// <unmanaged>MF_MP2DLNA_VIDEO_BIT_RATE</unmanaged>
        public static readonly MediaAttributeKey<int> VideoBitRate = new MediaAttributeKey<int>("e88548de-73b4-42d7-9c75-adfa0a2a6e4c", "VideoBitRate");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.EventAttributeKeys']/*"/>	
    public static partial class EventAttributeKeys
    {

        /// <summary>Constant DoThinning.</summary>
        /// <unmanaged>MF_EVENT_DO_THINNING</unmanaged>
        public static readonly MediaAttributeKey<bool> DoThinning = new MediaAttributeKey<bool>("321ea6fb-dad9-46e4-b31d-d2eae7090e30", "DoThinning");

        /// <summary>Constant TransformContext.</summary>
        /// <unmanaged>MF_EVENT_MFT_CONTEXT</unmanaged>
        public static readonly MediaAttributeKey<long> TransformContext = new MediaAttributeKey<long>("b7cd31f1-899e-4b41-80c9-26a896d32977", "TransformContext");

        /// <summary>Constant TransformInputStreamId.</summary>
        /// <unmanaged>MF_EVENT_MFT_INPUT_STREAM_ID</unmanaged>
        public static readonly MediaAttributeKey<int> TransformInputStreamId = new MediaAttributeKey<int>("f29c2cca-7ae6-42d2-b284-bf837cc874e2", "TransformInputStreamId");

        /// <summary>Constant OutputNode.</summary>
        /// <unmanaged>MF_EVENT_OUTPUT_NODE</unmanaged>
        public static readonly MediaAttributeKey<long> OutputNode = new MediaAttributeKey<long>("830f1a8b-c060-46dd-a801-1c95dec9b107", "OutputNode");

        /// <summary>Constant PresentationTimeOffset.</summary>
        /// <unmanaged>MF_EVENT_PRESENTATION_TIME_OFFSET</unmanaged>
        public static readonly MediaAttributeKey<long> PresentationTimeOffset = new MediaAttributeKey<long>("5ad914d1-9b45-4a8d-a2c0-81d1e50bfb07", "PresentationTimeOffset");

        /// <summary>Constant ScrubsampleTime.</summary>
        /// <unmanaged>MF_EVENT_SCRUBSAMPLE_TIME</unmanaged>
        public static readonly MediaAttributeKey<long> ScrubsampleTime = new MediaAttributeKey<long>("9ac712b3-dcb8-44d5-8d0c-37455a2782e3", "ScrubsampleTime");

        /// <summary>Constant Sessioncaps.</summary>
        /// <unmanaged>MF_EVENT_SESSIONCAPS</unmanaged>
        public static readonly MediaAttributeKey<int> Sessioncaps = new MediaAttributeKey<int>("7e5ebcd0-11b8-4abe-afad-10f6599a7f42", "Sessioncaps");

        /// <summary>Constant SessioncapsDelta.</summary>
        /// <unmanaged>MF_EVENT_SESSIONCAPS_DELTA</unmanaged>
        public static readonly MediaAttributeKey<int> SessioncapsDelta = new MediaAttributeKey<int>("7e5ebcd1-11b8-4abe-afad-10f6599a7f42", "SessioncapsDelta");

        /// <summary>Constant SourceActualStart.</summary>
        /// <unmanaged>MF_EVENT_SOURCE_ACTUAL_START</unmanaged>
        public static readonly MediaAttributeKey<long> SourceActualStart = new MediaAttributeKey<long>("a8cc55a9-6b31-419f-845d-ffb351a2434b", "SourceActualStart");

        /// <summary>Constant SourceCharacteristics.</summary>
        /// <unmanaged>MF_EVENT_SOURCE_CHARACTERISTICS</unmanaged>
        public static readonly MediaAttributeKey<int> SourceCharacteristics = new MediaAttributeKey<int>("47db8490-8b22-4f52-afda-9ce1b2d3cfa8", "SourceCharacteristics");

        /// <summary>Constant SourceCharacteristicsOld.</summary>
        /// <unmanaged>MF_EVENT_SOURCE_CHARACTERISTICS_OLD</unmanaged>
        public static readonly MediaAttributeKey<int> SourceCharacteristicsOld = new MediaAttributeKey<int>("47db8491-8b22-4f52-afda-9ce1b2d3cfa8", "SourceCharacteristicsOld");

        /// <summary>Constant SourceFakeStart.</summary>
        /// <unmanaged>MF_EVENT_SOURCE_FAKE_START</unmanaged>
        public static readonly MediaAttributeKey<int> SourceFakeStart = new MediaAttributeKey<int>("a8cc55a7-6b31-419f-845d-ffb351a2434b", "SourceFakeStart");

        /// <summary>Constant SourceProjectstart.</summary>
        /// <unmanaged>MF_EVENT_SOURCE_PROJECTSTART</unmanaged>
        public static readonly MediaAttributeKey<long> SourceProjectstart = new MediaAttributeKey<long>("a8cc55a8-6b31-419f-845d-ffb351a2434b", "SourceProjectstart");

        /// <summary>Constant SourceTopologyCanceled.</summary>
        /// <unmanaged>MF_EVENT_SOURCE_TOPOLOGY_CANCELED</unmanaged>
        public static readonly MediaAttributeKey<int> SourceTopologyCanceled = new MediaAttributeKey<int>("db62f650-9a5e-4704-acf3-563bc6a73364", "SourceTopologyCanceled");

        /// <summary>Constant StartPresentationTime.</summary>
        /// <unmanaged>MF_EVENT_START_PRESENTATION_TIME</unmanaged>
        public static readonly MediaAttributeKey<long> StartPresentationTime = new MediaAttributeKey<long>("5ad914d0-9b45-4a8d-a2c0-81d1e50bfb07", "StartPresentationTime");

        /// <summary>Constant StartPresentationTimeAtOutput.</summary>
        /// <unmanaged>MF_EVENT_START_PRESENTATION_TIME_AT_OUTPUT</unmanaged>
        public static readonly MediaAttributeKey<long> StartPresentationTimeAtOutput = new MediaAttributeKey<long>("5ad914d2-9b45-4a8d-a2c0-81d1e50bfb07", "StartPresentationTimeAtOutput");

        /// <summary>Constant TopologyStatus.</summary>
        /// <unmanaged>MF_EVENT_TOPOLOGY_STATUS</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.MediaFoundation.TopologyStatus> TopologyStatus = new MediaAttributeKey<SharpDX.MediaFoundation.TopologyStatus>("30c5018d-9a53-454b-ad9e-6d5f8fa7c43b", "TopologyStatus");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.EVRAttributeKeys']/*"/>	
    public static partial class EVRAttributeKeys
    {

        /// <summary>Constant SaRequiredSampleCount.</summary>
        /// <unmanaged>MF_SA_REQUIRED_SAMPLE_COUNT</unmanaged>
        public static readonly MediaAttributeKey<int> SaRequiredSampleCount = new MediaAttributeKey<int>("18802c61-324b-4952-abd0-176ff5c696ff", "SaRequiredSampleCount");

        /// <summary>Constant VideoZoomRect.</summary>
        /// <unmanaged>VIDEO_ZOOM_RECT</unmanaged>
        public static readonly MediaAttributeKey<byte[]> VideoZoomRect = new MediaAttributeKey<byte[]>("7aaa1638-1b7f-4c93-bd89-5b9c9fb6fcf0", "VideoZoomRect");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.EVRConfigAttributeKeys']/*"/>	
    public static partial class EVRConfigAttributeKeys
    {

        /// <summary>Constant AllowBatching.</summary>
        /// <unmanaged>EVRConfig_AllowBatching</unmanaged>
        public static readonly MediaAttributeKey<int> AllowBatching = new MediaAttributeKey<int>("e447df0a-10ca-4d17-b17e-6a840f8a3a4c", "AllowBatching");

        /// <summary>Constant AllowDropToBob.</summary>
        /// <unmanaged>EVRConfig_AllowDropToBob</unmanaged>
        public static readonly MediaAttributeKey<int> AllowDropToBob = new MediaAttributeKey<int>("e447df02-10ca-4d17-b17e-6a840f8a3a4c", "AllowDropToBob");

        /// <summary>Constant AllowDropToHalfInterlace.</summary>
        /// <unmanaged>EVRConfig_AllowDropToHalfInterlace</unmanaged>
        public static readonly MediaAttributeKey<int> AllowDropToHalfInterlace = new MediaAttributeKey<int>("e447df06-10ca-4d17-b17e-6a840f8a3a4c", "AllowDropToHalfInterlace");

        /// <summary>Constant AllowDropToThrottle.</summary>
        /// <unmanaged>EVRConfig_AllowDropToThrottle</unmanaged>
        public static readonly MediaAttributeKey<int> AllowDropToThrottle = new MediaAttributeKey<int>("e447df04-10ca-4d17-b17e-6a840f8a3a4c", "AllowDropToThrottle");

        /// <summary>Constant AllowScaling.</summary>
        /// <unmanaged>EVRConfig_AllowScaling</unmanaged>
        public static readonly MediaAttributeKey<int> AllowScaling = new MediaAttributeKey<int>("e447df08-10ca-4d17-b17e-6a840f8a3a4c", "AllowScaling");

        /// <summary>Constant ForceBatching.</summary>
        /// <unmanaged>EVRConfig_ForceBatching</unmanaged>
        public static readonly MediaAttributeKey<int> ForceBatching = new MediaAttributeKey<int>("e447df09-10ca-4d17-b17e-6a840f8a3a4c", "ForceBatching");

        /// <summary>Constant ForceBob.</summary>
        /// <unmanaged>EVRConfig_ForceBob</unmanaged>
        public static readonly MediaAttributeKey<int> ForceBob = new MediaAttributeKey<int>("e447df01-10ca-4d17-b17e-6a840f8a3a4c", "ForceBob");

        /// <summary>Constant ForceHalfInterlace.</summary>
        /// <unmanaged>EVRConfig_ForceHalfInterlace</unmanaged>
        public static readonly MediaAttributeKey<int> ForceHalfInterlace = new MediaAttributeKey<int>("e447df05-10ca-4d17-b17e-6a840f8a3a4c", "ForceHalfInterlace");

        /// <summary>Constant ForceScaling.</summary>
        /// <unmanaged>EVRConfig_ForceScaling</unmanaged>
        public static readonly MediaAttributeKey<int> ForceScaling = new MediaAttributeKey<int>("e447df07-10ca-4d17-b17e-6a840f8a3a4c", "ForceScaling");

        /// <summary>Constant ForceThrottle.</summary>
        /// <unmanaged>EVRConfig_ForceThrottle</unmanaged>
        public static readonly MediaAttributeKey<int> ForceThrottle = new MediaAttributeKey<int>("e447df03-10ca-4d17-b17e-6a840f8a3a4c", "ForceThrottle");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.EVRCustomVideoAttributeKeys']/*"/>	
    public static partial class EVRCustomVideoAttributeKeys
    {

        /// <summary>Constant MixerActivate.</summary>
        /// <unmanaged>MF_ACTIVATE_CUSTOM_VIDEO_MIXER_ACTIVATE</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> MixerActivate = new MediaAttributeKey<SharpDX.ComObject>("ba491361-be50-451e-95ab-6d4accc7dad8", "MixerActivate");

        /// <summary>Constant MixerClsid.</summary>
        /// <unmanaged>MF_ACTIVATE_CUSTOM_VIDEO_MIXER_CLSID</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> MixerClsid = new MediaAttributeKey<System.Guid>("ba491360-be50-451e-95ab-6d4accc7dad8", "MixerClsid");

        /// <summary>Constant MixerFlags.</summary>
        /// <unmanaged>MF_ACTIVATE_CUSTOM_VIDEO_MIXER_FLAGS</unmanaged>
        public static readonly MediaAttributeKey<int> MixerFlags = new MediaAttributeKey<int>("ba491362-be50-451e-95ab-6d4accc7dad8", "MixerFlags");

        /// <summary>Constant PresenterActivate.</summary>
        /// <unmanaged>MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_ACTIVATE</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> PresenterActivate = new MediaAttributeKey<SharpDX.ComObject>("ba491365-be50-451e-95ab-6d4accc7dad8", "PresenterActivate");

        /// <summary>Constant PresenterClsid.</summary>
        /// <unmanaged>MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_CLSID</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> PresenterClsid = new MediaAttributeKey<System.Guid>("ba491364-be50-451e-95ab-6d4accc7dad8", "PresenterClsid");

        /// <summary>Constant PresenterFlags.</summary>
        /// <unmanaged>MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_FLAGS</unmanaged>
        public static readonly MediaAttributeKey<int> PresenterFlags = new MediaAttributeKey<int>("ba491366-be50-451e-95ab-6d4accc7dad8", "PresenterFlags");

        /// <summary>Constant ActivateVideoWindow.</summary>
        /// <unmanaged>MF_ACTIVATE_VIDEO_WINDOW</unmanaged>
        public static readonly MediaAttributeKey<long> ActivateVideoWindow = new MediaAttributeKey<long>("9a2dbbdd-f57e-4162-82b9-6831377682d3", "ActivateVideoWindow");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.MediaAttributeKeys']/*"/>	
    public static partial class MediaAttributeKeys
    {

        /// <summary>Constant UserDataPayload.</summary>
        /// <unmanaged>MF_USER_DATA_PAYLOAD</unmanaged>
        public static readonly MediaAttributeKey<byte[]> UserDataPayload = new MediaAttributeKey<byte[]>("d1d4985d-dc92-457a-b3a0-651a33a31047", "UserDataPayload");

        /// <summary>Constant XvpDisableFrc.</summary>
        /// <unmanaged>MF_XVP_DISABLE_FRC</unmanaged>
        public static readonly MediaAttributeKey<bool> XvpDisableFrc = new MediaAttributeKey<bool>("2c0afa19-7a97-4d5a-9ee8-16d4fc518d8c", "XvpDisableFrc");

        /// <summary>Constant LocalPluginControlPolicy.</summary>
        /// <unmanaged>MF_LOCAL_PLUGIN_CONTROL_POLICY</unmanaged>
        public static readonly MediaAttributeKey<int> LocalPluginControlPolicy = new MediaAttributeKey<int>("d91b0085-c86d-4f81-8822-8c68e1d7fa04", "LocalPluginControlPolicy");

        /// <summary>Constant SourceStreamSupportsHardwareConnection.</summary>
        /// <unmanaged>MF_SOURCE_STREAM_SUPPORTS_HW_CONNECTION</unmanaged>
        public static readonly MediaAttributeKey<bool> SourceStreamSupportsHardwareConnection = new MediaAttributeKey<bool>("a38253aa-6314-42fd-a3ce-bb27b6859946", "SourceStreamSupportsHardwareConnection");

        /// <summary>Constant SupportsHardwareConnection.</summary>
        /// <unmanaged>MF_STREAM_SINK_SUPPORTS_HW_CONNECTION</unmanaged>
        public static readonly MediaAttributeKey<bool> SupportsHardwareConnection = new MediaAttributeKey<bool>("9b465cbf-0597-4f9e-9f3c-b97eeef90359", "SupportsHardwareConnection");

        /// <summary>Constant SupportsRotation.</summary>
        /// <unmanaged>MF_STREAM_SINK_SUPPORTS_ROTATION</unmanaged>
        public static readonly MediaAttributeKey<bool> SupportsRotation = new MediaAttributeKey<bool>("b3e96280-bd05-41a5-97ad-8a7fee24b912", "SupportsRotation");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.MediaEngineAttributeKeys']/*"/>	
    public static partial class MediaEngineAttributeKeys
    {

        /// <summary>Constant AudioCategory.</summary>
        /// <unmanaged>MF_MEDIA_ENGINE_AUDIO_CATEGORY</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.Multimedia.AudioStreamCategory> AudioCategory = new MediaAttributeKey<SharpDX.Multimedia.AudioStreamCategory>("c8d4c51d-350e-41f2-ba46-faebbb0857f6", "AudioCategory");

        /// <summary>Constant AudioEndpointRole.</summary>
        /// <unmanaged>MF_MEDIA_ENGINE_AUDIO_ENDPOINT_ROLE</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.Multimedia.AudioEndpointRole> AudioEndpointRole = new MediaAttributeKey<SharpDX.Multimedia.AudioEndpointRole>("d2cb93d1-116a-44f2-9385-f7d0fda2fb46", "AudioEndpointRole");

        /// <summary>Constant Callback.</summary>
        /// <unmanaged>MF_MEDIA_ENGINE_CALLBACK</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> Callback = new MediaAttributeKey<SharpDX.ComObject>("c60381b8-83a4-41f8-a3d0-de05076849a9", "Callback");

        /// <summary>Constant ContentProtectionFlags.</summary>
        /// <unmanaged>MF_MEDIA_ENGINE_CONTENT_PROTECTION_FLAGS</unmanaged>
        public static readonly MediaAttributeKey<MediaEngineProtectionFlags> ContentProtectionFlags = new MediaAttributeKey<MediaEngineProtectionFlags>("e0350223-5aaf-4d76-a7c3-06de70894db4", "ContentProtectionFlags");

        /// <summary>Constant ContentProtectionManager.</summary>
        /// <unmanaged>MF_MEDIA_ENGINE_CONTENT_PROTECTION_MANAGER</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> ContentProtectionManager = new MediaAttributeKey<SharpDX.ComObject>("fdd6dfaa-bd85-4af3-9e0f-a01d539d876a", "ContentProtectionManager");

        /// <summary>Constant DxgiManager.</summary>
        /// <unmanaged>MF_MEDIA_ENGINE_DXGI_MANAGER</unmanaged>
        public static readonly MediaAttributeKey<DXGIDeviceManager> DxgiManager = new MediaAttributeKey<DXGIDeviceManager>("065702da-1094-486d-8617-ee7cc4ee4648", "DxgiManager");

        /// <summary>Constant Extension.</summary>
        /// <unmanaged>MF_MEDIA_ENGINE_EXTENSION</unmanaged>
        public static readonly MediaAttributeKey<MediaEngineExtension> Extension = new MediaAttributeKey<MediaEngineExtension>("3109fd46-060d-4b62-8dcf-faff811318d2", "Extension");

        /// <summary>Constant OpmHwnd.</summary>
        /// <unmanaged>MF_MEDIA_ENGINE_OPM_HWND</unmanaged>
        public static readonly MediaAttributeKey<System.IntPtr> OpmHwnd = new MediaAttributeKey<System.IntPtr>("a0be8ee7-0572-4f2c-a801-2a151bd3e726", "OpmHwnd");

        /// <summary>Constant PlaybackHwnd.</summary>
        /// <unmanaged>MF_MEDIA_ENGINE_PLAYBACK_HWND</unmanaged>
        public static readonly MediaAttributeKey<System.IntPtr> PlaybackHwnd = new MediaAttributeKey<System.IntPtr>("d988879b-67c9-4d92-baa7-6eadd446039d", "PlaybackHwnd");

        /// <summary>Constant PlaybackVisual.</summary>
        /// <unmanaged>MF_MEDIA_ENGINE_PLAYBACK_VISUAL</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> PlaybackVisual = new MediaAttributeKey<SharpDX.ComObject>("6debd26f-6ab9-4d7e-b0ee-c61a73ffad15", "PlaybackVisual");

        /// <summary>Constant VideoOutputFormat.</summary>
        /// <unmanaged>MF_MEDIA_ENGINE_VIDEO_OUTPUT_FORMAT</unmanaged>
        public static readonly MediaAttributeKey<int> VideoOutputFormat = new MediaAttributeKey<int>("5066893c-8cf9-42bc-8b8a-472212e52726", "VideoOutputFormat");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.MediaFactory']/*"/>	
    public static partial class MediaFactory
    {

        /// <summary>Constant Version.</summary>
        /// <unmanaged>MF_VERSION</unmanaged>
        public const int Version = unchecked((int)2 << 16 | 112);

        /// <summary>	
        /// <p> </p><p>Creates the default video presenter for the enhanced video renderer (EVR).</p>	
        /// </summary>	
        /// <param name="ownerRef"><dd> <p>Pointer to the owner of the object. If the object is aggregated, pass a reference to the aggregating object's <strong><see cref="SharpDX.ComObject"/></strong> interface. Otherwise, set this parameter to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="riidDevice"><dd> <p>Interface identifier (IID) of the video device interface that will be used for processing the video. Currently the only supported value is IID_IDirect3DDevice9.</p> </dd></param>	
        /// <param name="riid"><dd> <p>IID of the requested interface on the video presenter. The video presenter exposes the <strong><see cref="SharpDX.MediaFoundation.VideoPresenter"/></strong> interface.</p> </dd></param>	
        /// <param name="videoPresenterOut"><dd> <p>Receives a reference to the requested interface on the video presenter. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateVideoPresenter']/*"/>	
        /// <msdn-id>ms693842</msdn-id>	
        /// <unmanaged>HRESULT MFCreateVideoPresenter([In, Optional] IUnknown* pOwner,[In] const GUID&amp; riidDevice,[In] const GUID&amp; riid,[Out, Optional] void** ppVideoPresenter)</unmanaged>	
        /// <unmanaged-short>MFCreateVideoPresenter</unmanaged-short>	
        public static void CreateVideoPresenter(SharpDX.ComObject ownerRef, System.Guid riidDevice, System.Guid riid, out System.IntPtr videoPresenterOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* videoPresenterOut_ = &videoPresenterOut)
                    __result__ =
                    MFCreateVideoPresenter_((void*)((ownerRef == null) ? IntPtr.Zero : ownerRef.NativePointer), &riidDevice, &riid, videoPresenterOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateVideoPresenter", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateVideoPresenter_(void* arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p> </p><p>Creates the default video mixer for the enhanced video renderer (EVR).</p>	
        /// </summary>	
        /// <param name="ownerRef"><dd> <p>Pointer to the owner of this object. If the object is aggregated, pass a reference to the aggregating object's <strong><see cref="SharpDX.ComObject"/></strong> interface. Otherwise, set this parameter to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="riidDevice"><dd> <p>Interface identifier (IID) of the video device interface that will be used for processing the video. Currently the only supported value is IID_IDirect3DDevice9.</p> </dd></param>	
        /// <param name="riid"><dd> <p>IID of the requested interface on the video mixer.  The video mixer exposes the <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> interface.</p> </dd></param>	
        /// <param name="vOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateVideoMixer']/*"/>	
        /// <msdn-id>ms705653</msdn-id>	
        /// <unmanaged>HRESULT MFCreateVideoMixer([In, Optional] IUnknown* pOwner,[In] const GUID&amp; riidDevice,[In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>	
        /// <unmanaged-short>MFCreateVideoMixer</unmanaged-short>	
        public static void CreateVideoMixer(SharpDX.ComObject ownerRef, System.Guid riidDevice, System.Guid riid, out System.IntPtr vOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vOut_ = &vOut)
                    __result__ =
                    MFCreateVideoMixer_((void*)((ownerRef == null) ? IntPtr.Zero : ownerRef.NativePointer), &riidDevice, &riid, vOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateVideoMixer", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateVideoMixer_(void* arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p> </p><p>Creates the default video mixer and video presenter for the enhanced video renderer (EVR).</p>	
        /// </summary>	
        /// <param name="mixerOwnerRef"><dd> <p>Pointer to the owner of the video mixer. If the mixer is aggregated, pass a reference to the aggregating object's <strong><see cref="SharpDX.ComObject"/></strong> interface. Otherwise, set this parameter to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="presenterOwnerRef"><dd> <p>Pointer to the owner of the video presenter. If the presenter is aggregated, pass a reference to the aggregating object's <strong><see cref="SharpDX.ComObject"/></strong> interface. Otherwise, set this parameter to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="riidMixer"><dd> <p>Interface identifier (IID) of the requested interface on the video mixer. The video mixer exposes the <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> interface.</p> </dd></param>	
        /// <param name="vVideoMixerOut"><dd> <p>Receives a reference to the requested interface on the video mixer. The caller must release the interface.</p> </dd></param>	
        /// <param name="riidPresenter"><dd> <p>IID of the requested interface on the video presenter. The video presenter exposes the <strong><see cref="SharpDX.MediaFoundation.VideoPresenter"/></strong> interface.</p> </dd></param>	
        /// <param name="vVideoPresenterOut"><dd> <p>Receives a reference to the requested interface on the video presenter. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateVideoMixerAndPresenter']/*"/>	
        /// <msdn-id>ms694842</msdn-id>	
        /// <unmanaged>HRESULT MFCreateVideoMixerAndPresenter([In, Optional] IUnknown* pMixerOwner,[In, Optional] IUnknown* pPresenterOwner,[In] const GUID&amp; riidMixer,[Out] void** ppvVideoMixer,[In] const GUID&amp; riidPresenter,[Out] void** ppvVideoPresenter)</unmanaged>	
        /// <unmanaged-short>MFCreateVideoMixerAndPresenter</unmanaged-short>	
        public static void CreateVideoMixerAndPresenter(SharpDX.ComObject mixerOwnerRef, SharpDX.ComObject presenterOwnerRef, System.Guid riidMixer, out System.IntPtr vVideoMixerOut, System.Guid riidPresenter, out System.IntPtr vVideoPresenterOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vVideoMixerOut_ = &vVideoMixerOut)
                fixed (void* vVideoPresenterOut_ = &vVideoPresenterOut)
                    __result__ =
                    MFCreateVideoMixerAndPresenter_((void*)((mixerOwnerRef == null) ? IntPtr.Zero : mixerOwnerRef.NativePointer), (void*)((presenterOwnerRef == null) ? IntPtr.Zero : presenterOwnerRef.NativePointer), &riidMixer, vVideoMixerOut_, &riidPresenter, vVideoPresenterOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateVideoMixerAndPresenter", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateVideoMixerAndPresenter_(void* arg0, void* arg1, void* arg2, void* arg3, void* arg4, void* arg5);

        /// <summary>	
        /// <p> </p><p>Creates an instance of the enhanced video renderer (EVR) media sink.</p>	
        /// </summary>	
        /// <param name="riidRenderer"><dd> <p>Interface identifier (IID) of the requested interface on the EVR.</p> </dd></param>	
        /// <param name="videoRendererOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This function creates the Media Foundation version of the EVR. To create the DirectShow EVR filter, call <strong>CoCreateInstance</strong> with the class identifier CLSID_EnhancedVideoRenderer.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateVideoRenderer']/*"/>	
        /// <msdn-id>ms703814</msdn-id>	
        /// <unmanaged>HRESULT MFCreateVideoRenderer([In] const GUID&amp; riidRenderer,[Out, Optional] void** ppVideoRenderer)</unmanaged>	
        /// <unmanaged-short>MFCreateVideoRenderer</unmanaged-short>	
        public static void CreateVideoRenderer(System.Guid riidRenderer, out System.IntPtr videoRendererOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* videoRendererOut_ = &videoRendererOut)
                    __result__ =
                    MFCreateVideoRenderer_(&riidRenderer, videoRendererOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateVideoRenderer", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateVideoRenderer_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> Creates a media sample that manages a Direct3D surface. </p>	
        /// </summary>	
        /// <param name="unkSurfaceRef"><dd> <p> A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of the Direct3D surface. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="sampleOut"><dd> <p> Receives a reference to the sample's <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The media sample created by this function exposes the following interfaces in addition to <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong>:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.DesiredSample"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.TrackedSample"/></strong> </li> </ul><p>If <em>pUnkSurface</em> is non-<strong><c>null</c></strong>, the sample contains a single media buffer, which holds a reference to the Direct3D surface. To get the Direct3D surface from the media buffer, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> on the buffer, using the service identifier <see cref="SharpDX.MediaFoundation.MediaServiceKeys.Buffer"/>. The media buffer does not implement <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong>, nor does it implement the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.Lock"/></strong> and <strong>Unlock</strong> methods.</p><p>Alternatively, you can set <em>pUnkSurface</em> to <strong><c>null</c></strong>, and later add a DirectX surface buffer to the sample by calling <strong><see cref="SharpDX.MediaFoundation.Sample.AddBuffer"/></strong>. To create a DirectX surface buffer, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDXSurfaceBuffer"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateVideoSampleFromSurface']/*"/>	
        /// <msdn-id>ms703859</msdn-id>	
        /// <unmanaged>HRESULT MFCreateVideoSampleFromSurface([In] IUnknown* pUnkSurface,[Out] IMFSample** ppSample)</unmanaged>	
        /// <unmanaged-short>MFCreateVideoSampleFromSurface</unmanaged-short>	
        public static void CreateVideoSampleFromSurface(SharpDX.ComObject unkSurfaceRef, out SharpDX.MediaFoundation.Sample sampleOut)
        {
            unsafe
            {
                IntPtr sampleOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateVideoSampleFromSurface_((void*)((unkSurfaceRef == null) ? IntPtr.Zero : unkSurfaceRef.NativePointer), &sampleOut_);
                sampleOut = (sampleOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Sample(sampleOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateVideoSampleFromSurface", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateVideoSampleFromSurface_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Creates an object that allocates video samples.</p>	
        /// </summary>	
        /// <param name="riid"><dd> <p>The identifier of the interface to retrieve. Specify one of the following values:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>IID_IUnknown</strong></strong></dt> </dl> </td><td> <p>Retrieve an <strong><see cref="SharpDX.ComObject"/></strong> reference.</p> </td></tr> <tr><td><dl> <dt><strong><strong>IID_IMFVideoSampleAllocator</strong></strong></dt> </dl> </td><td> <p>Retrieve an <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocator"/></strong> reference.</p> </td></tr> <tr><td><dl> <dt><strong><strong>IID_IMFVideoSampleAllocatorCallback</strong></strong></dt> </dl> </td><td> <p>Retrieve an <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocatorCallback"/></strong> reference.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="sampleAllocatorOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateVideoSampleAllocator']/*"/>	
        /// <msdn-id>ff384864</msdn-id>	
        /// <unmanaged>HRESULT MFCreateVideoSampleAllocator([In] const GUID&amp; riid,[Out] void** ppSampleAllocator)</unmanaged>	
        /// <unmanaged-short>MFCreateVideoSampleAllocator</unmanaged-short>	
        public static void CreateVideoSampleAllocator(System.Guid riid, out System.IntPtr sampleAllocatorOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* sampleAllocatorOut_ = &sampleAllocatorOut)
                    __result__ =
                    MFCreateVideoSampleAllocator_(&riid, sampleAllocatorOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateVideoSampleAllocator", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateVideoSampleAllocator_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Creates a new instance of the MFPlay player object.</p>	
        /// </summary>	
        /// <param name="wszURLRef">No documentation.</param>	
        /// <param name="fStartPlayback">No documentation.</param>	
        /// <param name="creationOptions">No documentation.</param>	
        /// <param name="callbackRef">No documentation.</param>	
        /// <param name="hWnd">No documentation.</param>	
        /// <param name="mediaPlayerOut">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Before calling this function, call <strong>CoIntialize(Ex)</strong> from the same thread to initialize the COM library.</p><p>Internally, <strong><see cref="SharpDX.MediaFoundation.MediaFactory.PCreateMediaPlayer"/></strong> calls <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong> to initialize the Microsoft Media Foundation platform. When the player object is destroyed, it calls  <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> to shut down the platform. It is not necessary for an application to call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> when using MFPlay.</p><strong>Note</strong>??If you use other Media Foundation APIs outside the life time of the player object, then your application should call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong> and <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong>.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFPCreateMediaPlayer']/*"/>	
        /// <msdn-id>dd375520</msdn-id>	
        /// <unmanaged>HRESULT MFPCreateMediaPlayer([In, Optional] const wchar_t* pwszURL,[In] BOOL fStartPlayback,[In, Optional] unsigned int creationOptions,[In, Optional] IMFPMediaPlayerCallback* pCallback,[In, Optional] HWND hWnd,[Out, Optional] IMFPMediaPlayer** ppMediaPlayer)</unmanaged>	
        /// <unmanaged-short>MFPCreateMediaPlayer</unmanaged-short>	
        public static void PCreateMediaPlayer(string wszURLRef, SharpDX.Mathematics.Interop.RawBool fStartPlayback, int creationOptions, SharpDX.MediaFoundation.PMediaPlayerCallback callbackRef, System.IntPtr hWnd, out SharpDX.MediaFoundation.PMediaPlayer mediaPlayerOut)
        {
            unsafe
            {
                IntPtr mediaPlayerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* wszURLRef_ = wszURLRef)
                    __result__ =
                    MFPCreateMediaPlayer_((void*)wszURLRef_, fStartPlayback, creationOptions, (void*)((callbackRef == null) ? IntPtr.Zero : callbackRef.NativePointer), (void*)hWnd, &mediaPlayerOut_);
                mediaPlayerOut = (mediaPlayerOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PMediaPlayer(mediaPlayerOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mfplay.dll", EntryPoint = "MFPCreateMediaPlayer", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFPCreateMediaPlayer_(void* arg0, SharpDX.Mathematics.Interop.RawBool arg1, int arg2, void* arg3, void* arg4, void* arg5);

        /// <summary>	
        /// <p> </p><p>Creates the ASF Header Object object.</p>	
        /// </summary>	
        /// <param name="iContentInfoOut">No documentation.</param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateASFContentInfo']/*"/>	
        /// <msdn-id>bb970315</msdn-id>	
        /// <unmanaged>HRESULT MFCreateASFContentInfo([In] IMFASFContentInfo** ppIContentInfo)</unmanaged>	
        /// <unmanaged-short>MFCreateASFContentInfo</unmanaged-short>	
        public static void CreateASFContentInfo(out SharpDX.MediaFoundation.ASFContentInfo iContentInfoOut)
        {
            unsafe
            {
                IntPtr iContentInfoOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateASFContentInfo_(&iContentInfoOut_);
                iContentInfoOut = (iContentInfoOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFContentInfo(iContentInfoOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateASFContentInfo", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateASFContentInfo_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Creates the ASF profile object.</p>	
        /// </summary>	
        /// <param name="iProfileOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.ASFProfile"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateASFProfile']/*"/>	
        /// <msdn-id>ms705632</msdn-id>	
        /// <unmanaged>HRESULT MFCreateASFProfile([In] IMFASFProfile** ppIProfile)</unmanaged>	
        /// <unmanaged-short>MFCreateASFProfile</unmanaged-short>	
        public static void CreateASFProfile(out SharpDX.MediaFoundation.ASFProfile iProfileOut)
        {
            unsafe
            {
                IntPtr iProfileOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateASFProfile_(&iProfileOut_);
                iProfileOut = (iProfileOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFProfile(iProfileOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateASFProfile", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateASFProfile_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Creates an ASF profile object from a presentation descriptor.</p>	
        /// </summary>	
        /// <param name="iPDRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the presentation descriptor that contains the profile information.</p> </dd></param>	
        /// <param name="iProfileOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.ASFProfile"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateASFProfileFromPresentationDescriptor']/*"/>	
        /// <msdn-id>ms694279</msdn-id>	
        /// <unmanaged>HRESULT MFCreateASFProfileFromPresentationDescriptor([In] IMFPresentationDescriptor* pIPD,[In] IMFASFProfile** ppIProfile)</unmanaged>	
        /// <unmanaged-short>MFCreateASFProfileFromPresentationDescriptor</unmanaged-short>	
        public static void CreateASFProfileFromPresentationDescriptor(SharpDX.MediaFoundation.PresentationDescriptor iPDRef, out SharpDX.MediaFoundation.ASFProfile iProfileOut)
        {
            unsafe
            {
                IntPtr iProfileOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateASFProfileFromPresentationDescriptor_((void*)((iPDRef == null) ? IntPtr.Zero : iPDRef.NativePointer), &iProfileOut_);
                iProfileOut = (iProfileOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFProfile(iProfileOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateASFProfileFromPresentationDescriptor", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateASFProfileFromPresentationDescriptor_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> </p><p>Creates a presentation descriptor from an ASF profile object.</p>	
        /// </summary>	
        /// <param name="iProfileRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.ASFProfile"/></strong> interface of the ASF profile object.</p> </dd></param>	
        /// <param name="iPDOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreatePresentationDescriptorFromASFProfile']/*"/>	
        /// <msdn-id>ms704656</msdn-id>	
        /// <unmanaged>HRESULT MFCreatePresentationDescriptorFromASFProfile([In] IMFASFProfile* pIProfile,[In] IMFPresentationDescriptor** ppIPD)</unmanaged>	
        /// <unmanaged-short>MFCreatePresentationDescriptorFromASFProfile</unmanaged-short>	
        public static void CreatePresentationDescriptorFromASFProfile(SharpDX.MediaFoundation.ASFProfile iProfileRef, out SharpDX.MediaFoundation.PresentationDescriptor iPDOut)
        {
            unsafe
            {
                IntPtr iPDOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreatePresentationDescriptorFromASFProfile_((void*)((iProfileRef == null) ? IntPtr.Zero : iProfileRef.NativePointer), &iPDOut_);
                iPDOut = (iPDOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PresentationDescriptor(iPDOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreatePresentationDescriptorFromASFProfile", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreatePresentationDescriptorFromASFProfile_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> </p><p>Creates the ASF Splitter.</p>	
        /// </summary>	
        /// <param name="iSplitterOut">No documentation.</param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateASFSplitter']/*"/>	
        /// <msdn-id>bb970321</msdn-id>	
        /// <unmanaged>HRESULT MFCreateASFSplitter([In] IMFASFSplitter** ppISplitter)</unmanaged>	
        /// <unmanaged-short>MFCreateASFSplitter</unmanaged-short>	
        public static void CreateASFSplitter(out SharpDX.MediaFoundation.ASFSplitter iSplitterOut)
        {
            unsafe
            {
                IntPtr iSplitterOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateASFSplitter_(&iSplitterOut_);
                iSplitterOut = (iSplitterOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFSplitter(iSplitterOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateASFSplitter", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateASFSplitter_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Creates the ASF Multiplexer.</p>	
        /// </summary>	
        /// <param name="iMultiplexerOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.ASFMultiplexer"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateASFMultiplexer']/*"/>	
        /// <msdn-id>bb970397</msdn-id>	
        /// <unmanaged>HRESULT MFCreateASFMultiplexer([In] IMFASFMultiplexer** ppIMultiplexer)</unmanaged>	
        /// <unmanaged-short>MFCreateASFMultiplexer</unmanaged-short>	
        public static void CreateASFMultiplexer(out SharpDX.MediaFoundation.ASFMultiplexer iMultiplexerOut)
        {
            unsafe
            {
                IntPtr iMultiplexerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateASFMultiplexer_(&iMultiplexerOut_);
                iMultiplexerOut = (iMultiplexerOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFMultiplexer(iMultiplexerOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateASFMultiplexer", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateASFMultiplexer_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Creates the ASF Indexer object.</p>	
        /// </summary>	
        /// <param name="iIndexerOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.ASFIndexer"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateASFIndexer']/*"/>	
        /// <msdn-id>ms704561</msdn-id>	
        /// <unmanaged>HRESULT MFCreateASFIndexer([In] IMFASFIndexer** ppIIndexer)</unmanaged>	
        /// <unmanaged-short>MFCreateASFIndexer</unmanaged-short>	
        public static void CreateASFIndexer(out SharpDX.MediaFoundation.ASFIndexer iIndexerOut)
        {
            unsafe
            {
                IntPtr iIndexerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateASFIndexer_(&iIndexerOut_);
                iIndexerOut = (iIndexerOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFIndexer(iIndexerOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateASFIndexer", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateASFIndexer_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Creates a byte stream to access the index in an ASF stream.</p>	
        /// </summary>	
        /// <param name="iContentByteStreamRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream that contains the ASF stream.</p> </dd></param>	
        /// <param name="cbIndexStartOffset"><dd> <p>Byte offset of the index within the ASF stream. To get this value, call <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.GetIndexPosition"/></strong>.</p> </dd></param>	
        /// <param name="iIndexByteStreamRef"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface. Use this interface to read from the index or write to the index. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table:</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The call succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Unexpected"/></strong></dt> </dl> </td><td> <p>The offset specified in <em>cbIndexStartOffset</em> is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateASFIndexerByteStream']/*"/>	
        /// <msdn-id>bb970563</msdn-id>	
        /// <unmanaged>HRESULT MFCreateASFIndexerByteStream([In] IMFByteStream* pIContentByteStream,[In] unsigned longlong cbIndexStartOffset,[In] IMFByteStream** pIIndexByteStream)</unmanaged>	
        /// <unmanaged-short>MFCreateASFIndexerByteStream</unmanaged-short>	
        public static void CreateASFIndexerByteStream(System.IntPtr iContentByteStreamRef, long cbIndexStartOffset, out SharpDX.MediaFoundation.IByteStream iIndexByteStreamRef)
        {
            unsafe
            {
                IntPtr iIndexByteStreamRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateASFIndexerByteStream_((void*)iContentByteStreamRef, cbIndexStartOffset, &iIndexByteStreamRef_);
                iIndexByteStreamRef = (iIndexByteStreamRef_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ByteStream(iIndexByteStreamRef_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateASFIndexerByteStream", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateASFIndexerByteStream_(void* arg0, long arg1, void* arg2);

        /// <summary>	
        /// <p> </p><p>Creates the ASF stream selector.</p>	
        /// </summary>	
        /// <param name="iASFProfileRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.ASFProfile"/></strong> interface.</p> </dd></param>	
        /// <param name="selectorOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.ASFStreamSelector"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateASFStreamSelector']/*"/>	
        /// <msdn-id>ms698963</msdn-id>	
        /// <unmanaged>HRESULT MFCreateASFStreamSelector([In] IMFASFProfile* pIASFProfile,[In] IMFASFStreamSelector** ppSelector)</unmanaged>	
        /// <unmanaged-short>MFCreateASFStreamSelector</unmanaged-short>	
        public static void CreateASFStreamSelector(SharpDX.MediaFoundation.ASFProfile iASFProfileRef, out SharpDX.MediaFoundation.ASFStreamSelector selectorOut)
        {
            unsafe
            {
                IntPtr selectorOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateASFStreamSelector_((void*)((iASFProfileRef == null) ? IntPtr.Zero : iASFProfileRef.NativePointer), &selectorOut_);
                selectorOut = (selectorOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFStreamSelector(selectorOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateASFStreamSelector", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateASFStreamSelector_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> </p><p>Creates the ASF media sink.</p>	
        /// </summary>	
        /// <param name="iByteStreamRef"><dd> <p>Pointer to a byte stream that will be used to write the ASF stream.</p> </dd></param>	
        /// <param name="iMediaSinkOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaSink"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateASFMediaSink']/*"/>	
        /// <msdn-id>ms703955</msdn-id>	
        /// <unmanaged>HRESULT MFCreateASFMediaSink([In] IMFByteStream* pIByteStream,[In] IMFMediaSink** ppIMediaSink)</unmanaged>	
        /// <unmanaged-short>MFCreateASFMediaSink</unmanaged-short>	
        public static void CreateASFMediaSink(System.IntPtr iByteStreamRef, out SharpDX.MediaFoundation.MediaSink iMediaSinkOut)
        {
            unsafe
            {
                IntPtr iMediaSinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateASFMediaSink_((void*)iByteStreamRef, &iMediaSinkOut_);
                iMediaSinkOut = (iMediaSinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSink(iMediaSinkOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateASFMediaSink", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateASFMediaSink_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> </p><p>Creates an activation object that can be used to create the ASF media sink.</p>	
        /// </summary>	
        /// <param name="wszFileNameRef"><dd> <p>Null-terminated wide-character string that contains the output file name.</p> </dd></param>	
        /// <param name="contentInfoRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo"/></strong> interface of an initialized ASF Header Object object. Use this interface to configure the ASF media sink.</p> </dd></param>	
        /// <param name="iActivateOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateASFMediaSinkActivate']/*"/>	
        /// <msdn-id>bb970403</msdn-id>	
        /// <unmanaged>HRESULT MFCreateASFMediaSinkActivate([In] const wchar_t* pwszFileName,[In] IMFASFContentInfo* pContentInfo,[In] IMFActivate** ppIActivate)</unmanaged>	
        /// <unmanaged-short>MFCreateASFMediaSinkActivate</unmanaged-short>	
        public static void CreateASFMediaSinkActivate(string wszFileNameRef, SharpDX.MediaFoundation.ASFContentInfo contentInfoRef, out SharpDX.MediaFoundation.Activate iActivateOut)
        {
            unsafe
            {
                IntPtr iActivateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* wszFileNameRef_ = wszFileNameRef)
                    __result__ =
                    MFCreateASFMediaSinkActivate_((void*)wszFileNameRef_, (void*)((contentInfoRef == null) ? IntPtr.Zero : contentInfoRef.NativePointer), &iActivateOut_);
                iActivateOut = (iActivateOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Activate(iActivateOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateASFMediaSinkActivate", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateASFMediaSinkActivate_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p> Creates an activation object that can be used to create a Windows Media Video (WMV) encoder. </p>	
        /// </summary>	
        /// <param name="mediaTypeRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. This parameter specifies the encoded output format.</p> </dd></param>	
        /// <param name="encodingConfigurationPropertiesRef"><dd> <p> A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a property store that contains encoding parameters. Encoding parameters for the WMV encoder are defined in the header file wmcodecdsp.h. If you have an ASF ContentInfo object that contains an ASF profile object with all the streams for the output file, you can get the property store by calling <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo.GetEncodingConfigurationPropertyStore"/></strong>. </p> </dd></param>	
        /// <param name="activateOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface. Use this interface to create the encoder. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateWMVEncoderActivate']/*"/>	
        /// <msdn-id>ms705622</msdn-id>	
        /// <unmanaged>HRESULT MFCreateWMVEncoderActivate([In] IMFMediaType* pMediaType,[In] IPropertyStore* pEncodingConfigurationProperties,[In] IMFActivate** ppActivate)</unmanaged>	
        /// <unmanaged-short>MFCreateWMVEncoderActivate</unmanaged-short>	
        public static void CreateWMVEncoderActivate(SharpDX.MediaFoundation.MediaType mediaTypeRef, SharpDX.ComObject encodingConfigurationPropertiesRef, out SharpDX.MediaFoundation.Activate activateOut)
        {
            unsafe
            {
                IntPtr activateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateWMVEncoderActivate_((void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), (void*)((encodingConfigurationPropertiesRef == null) ? IntPtr.Zero : encodingConfigurationPropertiesRef.NativePointer), &activateOut_);
                activateOut = (activateOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Activate(activateOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateWMVEncoderActivate", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateWMVEncoderActivate_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p> Creates an activation object that can be used to create a Windows Media Audio (WMA) encoder. </p>	
        /// </summary>	
        /// <param name="mediaTypeRef"><dd> <p> A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. This parameter specifies the encoded output format.</p> </dd></param>	
        /// <param name="encodingConfigurationPropertiesRef"><dd> <p> A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a property store that contains encoding parameters. Encoding parameters for the WMV encoder are defined in the header file wmcodecdsp.h. If you have an ASF ContentInfo object that contains an ASF profile object with all the streams for the output file, you can get the property store by calling <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo.GetEncodingConfigurationPropertyStore"/></strong>. </p> </dd></param>	
        /// <param name="activateOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface. Use this interface to create the encoder. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateWMAEncoderActivate']/*"/>	
        /// <msdn-id>ms702208</msdn-id>	
        /// <unmanaged>HRESULT MFCreateWMAEncoderActivate([In] IMFMediaType* pMediaType,[In] IPropertyStore* pEncodingConfigurationProperties,[In] IMFActivate** ppActivate)</unmanaged>	
        /// <unmanaged-short>MFCreateWMAEncoderActivate</unmanaged-short>	
        public static void CreateWMAEncoderActivate(SharpDX.MediaFoundation.MediaType mediaTypeRef, SharpDX.ComObject encodingConfigurationPropertiesRef, out SharpDX.MediaFoundation.Activate activateOut)
        {
            unsafe
            {
                IntPtr activateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateWMAEncoderActivate_((void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), (void*)((encodingConfigurationPropertiesRef == null) ? IntPtr.Zero : encodingConfigurationPropertiesRef.NativePointer), &activateOut_);
                activateOut = (activateOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Activate(activateOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateWMAEncoderActivate", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateWMAEncoderActivate_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p>Creates an activation object for the ASF streaming sink.</p><p>The  ASF streaming sink enables  an application to write streaming Advanced Systems Format (ASF)  packets to an HTTP byte stream. </p>	
        /// </summary>	
        /// <param name="iByteStreamRef"><dd> <p> A reference to a byte stream object in which the ASF media sink writes the streamed content.</p> </dd></param>	
        /// <param name="iMediaSinkOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaSink"/></strong> interface of the ASF streaming-media sink object. To create the media sink, the application must call <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> on the received reference. The caller must release the interface reference.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To create the ASF streaming sink in another process, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateASFStreamingMediaSinkActivate"/></strong>. </p><p>An application can get a reference to the ASF ContentInfo Object by calling <strong>IUnknown::QueryInterface</strong> on the media sink object received in the <em>ppIMediaSink</em> parameter. The ContentInfo object is used to set the encoder configuration settings, provide stream properties supplied by an ASF profile, and add metadata information. These configuration settings populate the various ASF header objects of the encoded ASF file. For more information, see  	
        /// Setting Properties in the ContentInfo Object.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateASFStreamingMediaSink']/*"/>	
        /// <msdn-id>dd388087</msdn-id>	
        /// <unmanaged>HRESULT MFCreateASFStreamingMediaSink([In] IMFByteStream* pIByteStream,[In] IMFMediaSink** ppIMediaSink)</unmanaged>	
        /// <unmanaged-short>MFCreateASFStreamingMediaSink</unmanaged-short>	
        public static void CreateASFStreamingMediaSink(System.IntPtr iByteStreamRef, out SharpDX.MediaFoundation.MediaSink iMediaSinkOut)
        {
            unsafe
            {
                IntPtr iMediaSinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateASFStreamingMediaSink_((void*)iByteStreamRef, &iMediaSinkOut_);
                iMediaSinkOut = (iMediaSinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSink(iMediaSinkOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateASFStreamingMediaSink", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateASFStreamingMediaSink_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Creates an activation object for the ASF streaming sink.</p><p>The  ASF streaming sink enables  an application to write streaming Advanced Systems Format (ASF)  packets to an HTTP byte stream. The activation object can be used to create the ASF streaming sink in another process.</p>	
        /// </summary>	
        /// <param name="byteStreamActivateRef"><dd> <p>A reference to the  <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface of an activation object. The caller  implements this interface.  The <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> method of the activation object must create a byte-stream object. The byte stream exposes the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface. The ASF streaming sink will write data to this byte stream.</p> </dd></param>	
        /// <param name="contentInfoRef"><dd> <p>A reference to an ASF ContentInfo Object that contains the properties that describe the ASF content. These  settings can contain  stream settings, encoding properties, and metadata. For more information about these properties, see Setting Properties in the ContentInfo Object.</p> </dd></param>	
        /// <param name="iActivateOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface of the activation object that is used to create the ASF streaming-media sink. To create the media sink, the application must call <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> by using the received reference. The <strong>ActivateObject</strong> method also calls   <strong>IMFActivate::Activate</strong> on the byte stream activate object specified by  <em>pByteStreamActivate</em>, to create it so that the media sink can write streamed content in the byte stream. The caller must release the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface reference of the media sink activation object received in <em>ppIActivate</em>.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Starting in Windows?7, Media Foundation provides an ASF streaming  sink that writes the content in  a live streaming scenario. This function should be used in secure transcode scenarios where this  media sink needs to be created and configured in the remote	
        /// process. Like the ASF file sink, the new media sink performs ASF related tasks such as writing the ASF header, generating data packets (muxing). The content is written to a caller-implemented byte stream such as an HTTP byte stream.	
        /// The caller must also provide an activation object that media sink can use to create the byte stream remotely.  </p><p>In addition, it performs transcryption for streaming protected content. It hosts the Windows Media Digital Rights Management (DRM) for Network Devices Output Trust Authority (OTA) that handles the license request and response. For more information, see <strong><see cref="SharpDX.MediaFoundation.DRMNetHelper"/></strong> interface.</p><p>The new media sink does not perform any time adjustments.  If the clock seeks, the timestamps are not changed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateASFStreamingMediaSinkActivate']/*"/>	
        /// <msdn-id>dd388090</msdn-id>	
        /// <unmanaged>HRESULT MFCreateASFStreamingMediaSinkActivate([In] IMFActivate* pByteStreamActivate,[In] IMFASFContentInfo* pContentInfo,[In] IMFActivate** ppIActivate)</unmanaged>	
        /// <unmanaged-short>MFCreateASFStreamingMediaSinkActivate</unmanaged-short>	
        public static void CreateASFStreamingMediaSinkActivate(SharpDX.MediaFoundation.Activate byteStreamActivateRef, SharpDX.MediaFoundation.ASFContentInfo contentInfoRef, out SharpDX.MediaFoundation.Activate iActivateOut)
        {
            unsafe
            {
                IntPtr iActivateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateASFStreamingMediaSinkActivate_((void*)((byteStreamActivateRef == null) ? IntPtr.Zero : byteStreamActivateRef.NativePointer), (void*)((contentInfoRef == null) ? IntPtr.Zero : contentInfoRef.NativePointer), &iActivateOut_);
                iActivateOut = (iActivateOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Activate(iActivateOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateASFStreamingMediaSinkActivate", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateASFStreamingMediaSinkActivate_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p>Initializes Microsoft Media Foundation.</p>	
        /// </summary>	
        /// <param name="version"><dd> <p>Version number. Use the value <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Version"/></strong>, defined in mfapi.h.</p> </dd></param>	
        /// <param name="dwFlags"><dd> <p>This parameter is optional when using C++ but required in C. The value must be one of the following flags: </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>MFSTARTUP_NOSOCKET</dt> </dl> </td><td> <p> Do not initialize the sockets library. </p> </td></tr> <tr><td> <dl> <dt>MFSTARTUP_LITE</dt> </dl> </td><td> <p> Equivalent to MFSTARTUP_NOSOCKET. </p> </td></tr> <tr><td> <dl> <dt>MFSTARTUP_FULL</dt> </dl> </td><td> <p> Initialize the entire Media Foundation platform. This is the default value when <em>dwFlags</em> is not specified. </p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.BadStartupVersion"/></strong></dt> </dl> </td><td> <p> The <em>Version</em> parameter requires a newer version of Media Foundation than the version that is running.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.DisabledInSafemode"/></strong></dt> </dl> </td><td> <p> The Media Foundation platform is disabled because the system was started in "Safe Mode" (fail-safe boot). </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>Media Foundation is not implemented on the system.  This error can occur if the media components are not present (See KB2703761 for more info). </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> An application must call this function before using Media Foundation. Before your application quits, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> once for every previous call to <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong>. </p><p> Do not call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> from work queue threads. For more information about work queues, see Work Queues. </p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFStartup']/*"/>	
        /// <msdn-id>ms702238</msdn-id>	
        /// <unmanaged>HRESULT MFStartup([In] unsigned int Version,[In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>MFStartup</unmanaged-short>	
        public static void Startup(int version, int dwFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFStartup_(version, dwFlags);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFStartup", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFStartup_(int arg0, int arg1);

        /// <summary>	
        /// <p>Shuts down the Microsoft Media Foundation platform. Call this function once for every call to <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong>. Do not call this function from work queue threads.</p>	
        /// </summary>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFShutdown']/*"/>	
        /// <msdn-id>ms694273</msdn-id>	
        /// <unmanaged>HRESULT MFShutdown()</unmanaged>	
        /// <unmanaged-short>MFShutdown</unmanaged-short>	
        public static void Shutdown()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFShutdown_();
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFShutdown", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFShutdown_();

        /// <summary>	
        /// <p> </p><p>Blocks the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> function.</p>	
        /// </summary>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This function prevents work queue threads from being shut down when <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> is called. Use this function to ensure that asynchronous operations complete gracefully before the platform shuts down.</p><p>This function holds a lock on the Media Foundation platform. To unlock the platform, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.UnlockPlatform"/></strong>. The application must call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.UnlockPlatform"/></strong> once for every call to <strong><see cref="SharpDX.MediaFoundation.MediaFactory.LockPlatform"/></strong>.</p><p>The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> function blocks until the platform is unlocked, or until a fixed wait period has elapsed. (The wait period is a few seconds.) To avoid memory leaks, the application should unlock the platform before the wait period ends. For example, cancel any asynchronous operations that are waiting to complete and are holding a lock on the platform.</p><p>The default implementation of the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface automatically locks the Media Foundation platform when the result object is created. Releasing the interface unlocks the platform. Therefore, in most cases your application does not need to lock the platform directly. For more information, see Work Queues.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFLockPlatform']/*"/>	
        /// <msdn-id>ms693588</msdn-id>	
        /// <unmanaged>HRESULT MFLockPlatform()</unmanaged>	
        /// <unmanaged-short>MFLockPlatform</unmanaged-short>	
        public static void LockPlatform()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFLockPlatform_();
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFLockPlatform", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFLockPlatform_();

        /// <summary>	
        /// <p> </p><p>Unlocks the Media Foundation platform after it was locked by a call to the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.LockPlatform"/></strong> function.</p>	
        /// </summary>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The application must call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.UnlockPlatform"/></strong> once for every call to <strong><see cref="SharpDX.MediaFoundation.MediaFactory.LockPlatform"/></strong>.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFUnlockPlatform']/*"/>	
        /// <msdn-id>ms703879</msdn-id>	
        /// <unmanaged>HRESULT MFUnlockPlatform()</unmanaged>	
        /// <unmanaged-short>MFUnlockPlatform</unmanaged-short>	
        public static void UnlockPlatform()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFUnlockPlatform_();
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFUnlockPlatform", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFUnlockPlatform_();

        /// <summary>	
        /// <p> Puts an asynchronous operation on a work queue.</p>	
        /// </summary>	
        /// <param name="dwQueue"><dd> <p> The identifier for the work queue. This value can specify one of the standard Media Foundation work queues, or a work queue created by the application. For list of standard Media Foundation work queues, see <strong>Work Queue Identifiers</strong>. To create a new work queue, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueueEx"/></strong>. </p> </dd></param>	
        /// <param name="callbackRef"><dd> <p> A reference to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface. The caller must implement this interface. </p> </dd></param>	
        /// <param name="stateRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Possible values include the following.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidWorkqueue"/></strong></strong></dt> </dl> </td><td> <p>Invalid work queue. For more information, see <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.GetParameters"/></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong> function was not called, or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> This function creates an asynchronous result object and puts the result object on the work queue. The work queue calls the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method specified by <em>pCallback</em>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFPutWorkItem']/*"/>	
        /// <msdn-id>ms702164</msdn-id>	
        /// <unmanaged>HRESULT MFPutWorkItem([In] unsigned int dwQueue,[In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>	
        /// <unmanaged-short>MFPutWorkItem</unmanaged-short>	
        public static void PutWorkItem(int dwQueue, System.IntPtr callbackRef, SharpDX.ComObject stateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFPutWorkItem_(dwQueue, (void*)callbackRef, (void*)((stateRef == null) ? IntPtr.Zero : stateRef.NativePointer));
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFPutWorkItem", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFPutWorkItem_(int arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p> Puts an asynchronous operation on a work queue, with a specified priority.</p>	
        /// </summary>	
        /// <param name="dwQueue"><dd> <p> The identifier for the work queue. This value can specify one of the standard Media Foundation work queues, or a work queue created by the application. For list of standard Media Foundation work queues, see <strong>Work Queue Identifiers</strong>. To create a new work queue, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong> or  <see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueueEx"/>. </p> </dd></param>	
        /// <param name="priority"><dd> <p>The priority of the work item. Work items are performed in order of priority.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p> A reference to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface. The caller must implement this interface. </p> </dd></param>	
        /// <param name="stateRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Possible values include the following.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidWorkqueue"/></strong></strong></dt> </dl> </td><td> <p>Invalid work queue identifier.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong> function was not called, or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFPutWorkItem2']/*"/>	
        /// <msdn-id>hh162784</msdn-id>	
        /// <unmanaged>HRESULT MFPutWorkItem2([In] unsigned int dwQueue,[In] int Priority,[In] IMFAsyncCallback* pCallback,[In, Optional] IUnknown* pState)</unmanaged>	
        /// <unmanaged-short>MFPutWorkItem2</unmanaged-short>	
        public static void PutWorkItem2(int dwQueue, int priority, System.IntPtr callbackRef, SharpDX.ComObject stateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFPutWorkItem2_(dwQueue, priority, (void*)callbackRef, (void*)((stateRef == null) ? IntPtr.Zero : stateRef.NativePointer));
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFPutWorkItem2", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFPutWorkItem2_(int arg0, int arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p> Puts an asynchronous operation on a work queue. </p>	
        /// </summary>	
        /// <param name="dwQueue"><dd> <p>The identifier for the work queue. This value can specify one of the standard Media Foundation work queues, or a work queue created by the application. For list of standard Media Foundation work queues, see <strong>Work Queue Identifiers</strong>. To create a new work queue, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueueEx"/></strong>. </p> </dd></param>	
        /// <param name="resultRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface of an asynchronous result object. To create the result object, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAsyncResult"/></strong>. </p> </dd></param>	
        /// <returns><p> Returns an <strong><see cref="SharpDX.Result"/></strong> value. Possible values include the following.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p> Success.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidWorkqueue"/></strong></strong></dt> </dl> </td><td> <p>Invalid work queue identifier. For more information, see <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.GetParameters"/></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong> function was not called, or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> To invoke the work-item, this function passes <em>pResult</em> to the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.InvokeCallback"/></strong> function. The callback is specified when you create the result object specified by <em>pResult</em>. </p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFPutWorkItemEx']/*"/>	
        /// <msdn-id>ms697572</msdn-id>	
        /// <unmanaged>HRESULT MFPutWorkItemEx([In] unsigned int dwQueue,[In] IMFAsyncResult* pResult)</unmanaged>	
        /// <unmanaged-short>MFPutWorkItemEx</unmanaged-short>	
        public static void PutWorkItemEx(int dwQueue, SharpDX.MediaFoundation.AsyncResult resultRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFPutWorkItemEx_(dwQueue, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer));
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFPutWorkItemEx", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFPutWorkItemEx_(int arg0, void* arg1);

        /// <summary>	
        /// <p>Puts an asynchronous operation on a work queue, with a specified priority.</p>	
        /// </summary>	
        /// <param name="dwQueue"><dd> <p> The identifier for the work queue. This value can specify one of the standard Media Foundation work queues, or a work queue created by the application. For list of standard Media Foundation work queues, see <strong>Work Queue Identifiers</strong>. To create a new work queue, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong> or  <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueueEx"/></strong>.</p> </dd></param>	
        /// <param name="priority"><dd> <p>The priority of the work item. Work items are performed in order of priority.</p> </dd></param>	
        /// <param name="resultRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface of an asynchronous result object. To create the result object, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAsyncResult"/></strong>.</p> </dd></param>	
        /// <returns><p> Returns an <strong><see cref="SharpDX.Result"/></strong> value. Possible values include the following.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p> Success.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidWorkqueue"/></strong></strong></dt> </dl> </td><td> <p>Invalid work queue identifier.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong> function was not called, or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> To invoke the work item, this function passes <em>pResult</em> to the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.InvokeCallback"/></strong> function. The callback is specified when you create the result object specified by <em>pResult</em>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFPutWorkItemEx2']/*"/>	
        /// <msdn-id>hh162785</msdn-id>	
        /// <unmanaged>HRESULT MFPutWorkItemEx2([In] unsigned int dwQueue,[In] int Priority,[In] IMFAsyncResult* pResult)</unmanaged>	
        /// <unmanaged-short>MFPutWorkItemEx2</unmanaged-short>	
        public static void PutWorkItemEx2(int dwQueue, int priority, SharpDX.MediaFoundation.AsyncResult resultRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFPutWorkItemEx2_(dwQueue, priority, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer));
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFPutWorkItemEx2", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFPutWorkItemEx2_(int arg0, int arg1, void* arg2);

        /// <summary>	
        /// <p>Queues a work item that waits for an event to be signaled.</p>	
        /// </summary>	
        /// <param name="hEvent"><dd> <p>A handle to an event object. To create an event object, call <strong>CreateEvent</strong> or <strong>CreateEventEx</strong>.</p> </dd></param>	
        /// <param name="priority"><dd> <p>The priority of the work item. Work items are performed in order of priority.</p> </dd></param>	
        /// <param name="resultRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface of an asynchronous result object. To create the result object, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAsyncResult"/></strong>.</p> </dd></param>	
        /// <param name="keyRef"><dd> <p>Receives a key that can be used to cancel the wait. To cancel the wait, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CancelWorkItem"/></strong> and pass this key in the <em>Key</em> parameter. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function enables a component to wait for an event without blocking the current thread. </p><p>The function puts a work item on the specified work queue. This work item waits for the event given in <em>hEvent</em> to be signaled. When the event is signaled, the work item invokes a callback. (The callback is contained in the result object given in <em>pResult</em>. For more information, see <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAsyncResult"/></strong>).</p><p>The work item is dispatched on a work queue by the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.GetParameters"/></strong> method of the callback. The work queue can be any of the following:</p><ul> <li>The default work queue (<strong><see cref="SharpDX.MediaFoundation.WorkQueueType.Standard"/></strong>).</li> <li>The platform multithreaded queue (<strong><see cref="SharpDX.MediaFoundation.WorkQueueType.Multithreaded"/></strong>).</li> <li>A multithreaded queue returned by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.LockSharedWorkQueue"/></strong> function.</li> <li>A serial queue created by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateSerialWorkQueue"/></strong> function.</li> </ul><p>Do not use any of the following work queues: <strong><see cref="SharpDX.MediaFoundation.WorkQueueType.Io"/></strong>, <strong><see cref="SharpDX.MediaFoundation.WorkQueueType.LongFunction"/></strong>, <strong><see cref="SharpDX.MediaFoundation.WorkQueueType.Rt"/></strong>, or <strong><see cref="SharpDX.MediaFoundation.WorkQueueType.Timer"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFPutWaitingWorkItem']/*"/>	
        /// <msdn-id>hh162783</msdn-id>	
        /// <unmanaged>HRESULT MFPutWaitingWorkItem([In] void* hEvent,[In] int Priority,[In] IMFAsyncResult* pResult,[Out, Optional] unsigned longlong* pKey)</unmanaged>	
        /// <unmanaged-short>MFPutWaitingWorkItem</unmanaged-short>	
        public static void PutWaitingWorkItem(System.IntPtr hEvent, int priority, SharpDX.MediaFoundation.AsyncResult resultRef, out long keyRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* keyRef_ = &keyRef)
                    __result__ =
                    MFPutWaitingWorkItem_((void*)hEvent, priority, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), keyRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFPutWaitingWorkItem", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFPutWaitingWorkItem_(void* arg0, int arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p>Creates a work queue that is guaranteed to serialize work items. The serial work queue wraps an existing multithreaded work queue. The serial work queue enforces a first-in, first-out (FIFO) execution order.</p>	
        /// </summary>	
        /// <param name="dwWorkQueue"><dd> <p> The identifier of an existing work queue. This must be either a multithreaded queue or another serial work queue. Any of the following can be used:</p> <ul> <li>The default work queue (<strong><see cref="SharpDX.MediaFoundation.WorkQueueType.Standard"/></strong>)</li> <li>The platform multithreaded queue (<strong><see cref="SharpDX.MediaFoundation.WorkQueueType.Multithreaded"/></strong>)</li> <li>A multithreaded queue returned by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.LockSharedWorkQueue"/></strong> function.</li> <li>A serial queue created by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateSerialWorkQueue"/></strong> function.</li> </ul> </dd></param>	
        /// <param name="dwWorkQueueRef"><dd> <p>Receives an identifier for the new serial work queue. Use this identifier when queuing work items.</p> </dd></param>	
        /// <returns><p>This function can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p> The application exceeded the maximum number of work queues. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p> The application did not call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong>, or the application has already called <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong>. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When you are done using the work queue, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.UnlockWorkQueue"/></strong>.</p><p>Multithreaded queues use a thread pool, which  can reduce the total number of threads in the pipeline. However, they do not serialize work items. A serial work queue enables the application to get the benefits of the thread pool, without needing to perform manual serialization of its own work items.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFAllocateSerialWorkQueue']/*"/>	
        /// <msdn-id>hh162744</msdn-id>	
        /// <unmanaged>HRESULT MFAllocateSerialWorkQueue([In] unsigned int dwWorkQueue,[Out] unsigned int* pdwWorkQueue)</unmanaged>	
        /// <unmanaged-short>MFAllocateSerialWorkQueue</unmanaged-short>	
        public static void AllocateSerialWorkQueue(int dwWorkQueue, out int dwWorkQueueRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwWorkQueueRef_ = &dwWorkQueueRef)
                    __result__ =
                    MFAllocateSerialWorkQueue_(dwWorkQueue, dwWorkQueueRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFAllocateSerialWorkQueue", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFAllocateSerialWorkQueue_(int arg0, void* arg1);

        /// <summary>	
        /// <p> </p><p>Schedules an asynchronous operation to be completed after a specified interval.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface of an asynchronous result object. To create the result object, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAsyncResult"/></strong>.</p> </dd></param>	
        /// <param name="timeout"><dd> <p>Time-out interval, in milliseconds. Set this parameter to a negative value. The callback is invoked after ?<em>Timeout</em> milliseconds. For example, if <em>Timeout</em> is ?5000, the callback is invoked after 5000 milliseconds.</p> </dd></param>	
        /// <param name="keyRef"><dd> <p>Receives a key that can be used to cancel the timer. To cancel the timer, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CancelWorkItem"/></strong> and pass this key in the <em>Key</em> parameter.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When the timer interval elapses, the timer calls <strong><see cref="SharpDX.MediaFoundation.MediaFactory.InvokeCallback"/></strong> with the <em>pResult</em> reference to invoke the asynchronous callback. The callback is specified when you create the result object.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFScheduleWorkItemEx']/*"/>	
        /// <msdn-id>ms702259</msdn-id>	
        /// <unmanaged>HRESULT MFScheduleWorkItemEx([In] IMFAsyncResult* pResult,[In] longlong Timeout,[Out, Optional] unsigned longlong* pKey)</unmanaged>	
        /// <unmanaged-short>MFScheduleWorkItemEx</unmanaged-short>	
        public static void ScheduleWorkItemEx(SharpDX.MediaFoundation.AsyncResult resultRef, long timeout, out long keyRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* keyRef_ = &keyRef)
                    __result__ =
                    MFScheduleWorkItemEx_((void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), timeout, keyRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFScheduleWorkItemEx", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFScheduleWorkItemEx_(void* arg0, long arg1, void* arg2);

        /// <summary>	
        /// <p> </p><p>Schedules an asynchronous operation to be completed after a specified interval.</p>	
        /// </summary>	
        /// <param name="callbackRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface. The caller must implement this interface.</p> </dd></param>	
        /// <param name="stateRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <param name="timeout"><dd> <p>Time-out interval, in milliseconds. Set this parameter to a negative value. The callback is invoked after ?<em>Timeout</em> milliseconds. For example, if <em>Timeout</em> is ?5000, the callback is invoked after 5000 milliseconds.</p> </dd></param>	
        /// <param name="keyRef"><dd> <p>Receives a key that can be used to cancel the timer. To cancel the timer, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CancelWorkItem"/></strong> and pass this key in the <em>Key</em> parameter.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This function creates an asynchronous result object. When the timer interval elapses, the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method specified by <em>pCallback</em> is called.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFScheduleWorkItem']/*"/>	
        /// <msdn-id>ms703045</msdn-id>	
        /// <unmanaged>HRESULT MFScheduleWorkItem([In] IMFAsyncCallback* pCallback,[In] IUnknown* pState,[In] longlong Timeout,[Out, Optional] unsigned longlong* pKey)</unmanaged>	
        /// <unmanaged-short>MFScheduleWorkItem</unmanaged-short>	
        public static void ScheduleWorkItem(System.IntPtr callbackRef, SharpDX.ComObject stateRef, long timeout, out long keyRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* keyRef_ = &keyRef)
                    __result__ =
                    MFScheduleWorkItem_((void*)callbackRef, (void*)((stateRef == null) ? IntPtr.Zero : stateRef.NativePointer), timeout, keyRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFScheduleWorkItem", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFScheduleWorkItem_(void* arg0, void* arg1, long arg2, void* arg3);

        /// <summary>	
        /// <p> Attempts to cancel an asynchronous operation that was scheduled with <strong><see cref="SharpDX.MediaFoundation.MediaFactory.ScheduleWorkItem"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.ScheduleWorkItemEx"/></strong>.</p>	
        /// </summary>	
        /// <param name="key">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Because work items are asynchronous, the  work-item callback might still be invoked after <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CancelWorkItem"/></strong> is called.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCancelWorkItem']/*"/>	
        /// <msdn-id>ms701633</msdn-id>	
        /// <unmanaged>HRESULT MFCancelWorkItem([In] unsigned longlong Key)</unmanaged>	
        /// <unmanaged-short>MFCancelWorkItem</unmanaged-short>	
        public static void CancelWorkItem(long key)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFCancelWorkItem_(key);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCancelWorkItem", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCancelWorkItem_(long arg0);

        /// <summary>	
        /// <p> </p><p>Retrieves the timer interval for the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AddPeriodicCallback"/></strong> function.</p>	
        /// </summary>	
        /// <param name="periodicity">No documentation.</param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetTimerPeriodicity']/*"/>	
        /// <msdn-id>ms694873</msdn-id>	
        /// <unmanaged>HRESULT MFGetTimerPeriodicity([Out] unsigned int* Periodicity)</unmanaged>	
        /// <unmanaged-short>MFGetTimerPeriodicity</unmanaged-short>	
        public static void GetTimerPeriodicity(out int periodicity)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* periodicity_ = &periodicity)
                    __result__ =
                    MFGetTimerPeriodicity_(periodicity_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFGetTimerPeriodicity", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetTimerPeriodicity_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Sets a callback function to be called at a fixed interval.</p>	
        /// </summary>	
        /// <param name="callback"><dd> <p>Pointer to the callback function, of type <strong>MFPERIODICCALLBACK</strong>.</p> </dd></param>	
        /// <param name="contextRef"><dd> <p>Pointer to a caller-provided object that implements <strong><see cref="SharpDX.ComObject"/></strong>, or <strong><c>null</c></strong>. This parameter is passed to the callback function.</p> </dd></param>	
        /// <param name="dwKeyRef"><dd> <p>Receives a key that can be used to cancel the callback. To cancel the callback, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.RemovePeriodicCallback"/></strong> and pass this key as the <em>dwKey</em> parameter.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To get the timer interval for the periodic callback, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.GetTimerPeriodicity"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFAddPeriodicCallback']/*"/>	
        /// <msdn-id>ms704699</msdn-id>	
        /// <unmanaged>HRESULT MFAddPeriodicCallback([In] __function__stdcall* Callback,[In] IUnknown* pContext,[Out, Optional] unsigned int* pdwKey)</unmanaged>	
        /// <unmanaged-short>MFAddPeriodicCallback</unmanaged-short>	
        internal static void AddPeriodicCallback(SharpDX.FunctionCallback callback, SharpDX.ComObject contextRef, out int dwKeyRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwKeyRef_ = &dwKeyRef)
                    __result__ =
                    MFAddPeriodicCallback_(callback, (void*)((contextRef == null) ? IntPtr.Zero : contextRef.NativePointer), dwKeyRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFAddPeriodicCallback", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFAddPeriodicCallback_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p> </p><p>Cancels a callback function that was set by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AddPeriodicCallback"/></strong> function.</p>	
        /// </summary>	
        /// <param name="dwKey">No documentation.</param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The callback is dispatched on another thread, and this function does not attempt to synchronize with the callback thread. Therefore, it is possible for the callback to be invoked after this function returns.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFRemovePeriodicCallback']/*"/>	
        /// <msdn-id>ms704741</msdn-id>	
        /// <unmanaged>HRESULT MFRemovePeriodicCallback([In] unsigned int dwKey)</unmanaged>	
        /// <unmanaged-short>MFRemovePeriodicCallback</unmanaged-short>	
        public static void RemovePeriodicCallback(int dwKey)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFRemovePeriodicCallback_(dwKey);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFRemovePeriodicCallback", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFRemovePeriodicCallback_(int arg0);

        /// <summary>	
        /// <p>Creates a new work queue. This function extends the capabilities of the  <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong> function by making it possible to create a  work queue that has a message loop.</p>	
        /// </summary>	
        /// <param name="workQueueType">No documentation.</param>	
        /// <param name="dwWorkQueueRef">No documentation.</param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p>The application exceeded the maximum number of work queues.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The application did not call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong>, or the application has already called <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong>.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When you are done using the work queue, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.UnlockWorkQueue"/></strong>.</p><p>The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong> function is equivalent to calling <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueueEx"/></strong> with the value <see cref="SharpDX.MediaFoundation.AsyncWorkqueueType.MfStandardWorkqueue"/> for the <em>WorkQueueType</em> parameter.</p><p>This function is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFAllocateWorkQueueEx']/*"/>	
        /// <msdn-id>dd375150</msdn-id>	
        /// <unmanaged>HRESULT MFAllocateWorkQueueEx([In] MFASYNC_WORKQUEUE_TYPE WorkQueueType,[Out] unsigned int* pdwWorkQueue)</unmanaged>	
        /// <unmanaged-short>MFAllocateWorkQueueEx</unmanaged-short>	
        public static void AllocateWorkQueueEx(SharpDX.MediaFoundation.AsyncWorkqueueType workQueueType, out int dwWorkQueueRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwWorkQueueRef_ = &dwWorkQueueRef)
                    __result__ =
                    MFAllocateWorkQueueEx_(unchecked((int)workQueueType), dwWorkQueueRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFAllocateWorkQueueEx", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFAllocateWorkQueueEx_(int arg0, void* arg1);

        /// <summary>	
        /// <p> Creates a new work queue.</p>	
        /// </summary>	
        /// <param name="dwWorkQueueRef"><dd> <p>Receives an identifier for the work queue.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p> The application exceeded the maximum number of work queues. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p> The application did not call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong>, or the application has already called <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong>. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When you are done using the work queue, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.UnlockWorkQueue"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFAllocateWorkQueue']/*"/>	
        /// <msdn-id>ms700204</msdn-id>	
        /// <unmanaged>HRESULT MFAllocateWorkQueue([Out] unsigned int* pdwWorkQueue)</unmanaged>	
        /// <unmanaged-short>MFAllocateWorkQueue</unmanaged-short>	
        public static void AllocateWorkQueue(out int dwWorkQueueRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwWorkQueueRef_ = &dwWorkQueueRef)
                    __result__ =
                    MFAllocateWorkQueue_(dwWorkQueueRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFAllocateWorkQueue", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFAllocateWorkQueue_(void* arg0);

        /// <summary>	
        /// <p> Locks a work queue.</p>	
        /// </summary>	
        /// <param name="dwWorkQueue"><dd> <p>The identifier for the work queue. The identifier is returned by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong> function. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function prevents the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> function from shutting down the work queue. Use this function to ensure that asynchronous operations on the work queue complete gracefully before the platform shuts down. The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> function blocks until the work queue is unlocked, or until a fixed wait period has elapsed. (The wait period is a few seconds.)</p><p>Call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.UnlockWorkQueue"/></strong> to unlock the work queue. Each call to <strong><see cref="SharpDX.MediaFoundation.MediaFactory.LockWorkQueue"/></strong> must be matched by a corresponding call to <strong><see cref="SharpDX.MediaFoundation.MediaFactory.UnlockWorkQueue"/></strong>.</p><p> </p><strong>Note</strong>??The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong> function implicitly locks the work queue that it creates.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFLockWorkQueue']/*"/>	
        /// <msdn-id>aa367740</msdn-id>	
        /// <unmanaged>HRESULT MFLockWorkQueue([In] unsigned int dwWorkQueue)</unmanaged>	
        /// <unmanaged-short>MFLockWorkQueue</unmanaged-short>	
        public static void LockWorkQueue(int dwWorkQueue)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFLockWorkQueue_(dwWorkQueue);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFLockWorkQueue", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFLockWorkQueue_(int arg0);

        /// <summary>	
        /// <p> </p><p>Unlocks a work queue.</p>	
        /// </summary>	
        /// <param name="dwWorkQueue"><dd> <p>Identifier for the work queue to be unlocked. The identifier is returned by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong> function.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The application must call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.UnlockWorkQueue"/></strong> once for every call to <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong> and then once for every call to <strong><see cref="SharpDX.MediaFoundation.MediaFactory.LockWorkQueue"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFUnlockWorkQueue']/*"/>	
        /// <msdn-id>aa372543</msdn-id>	
        /// <unmanaged>HRESULT MFUnlockWorkQueue([In] unsigned int dwWorkQueue)</unmanaged>	
        /// <unmanaged-short>MFUnlockWorkQueue</unmanaged-short>	
        public static void UnlockWorkQueue(int dwWorkQueue)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFUnlockWorkQueue_(dwWorkQueue);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFUnlockWorkQueue", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFUnlockWorkQueue_(int arg0);

        /// <summary>	
        /// <p> Associates a work queue with a Multimedia Class Scheduler Service (MMCSS) task.</p>	
        /// </summary>	
        /// <param name="dwWorkQueueId"><dd> <p>The identifier of the work queue.  For private work queues, the identifier is returned by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong> function. For platform work queues, see <strong>Work Queue Identifiers</strong>.</p> </dd></param>	
        /// <param name="wszClass"><dd> <p> The name of the MMCSS task.For more information, see Multimedia Class Scheduler Service. </p> </dd></param>	
        /// <param name="dwTaskId"><dd> <p>The unique task identifier. To obtain a new task identifier, set this value to zero. </p> </dd></param>	
        /// <param name="doneCallbackRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>	
        /// <param name="doneStateRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This function is asynchronous. When the operation completes, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, the application should call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.EndRegisterWorkQueueWithMMCSS"/></strong> to complete the asynchronous request.</p><p>To unregister the work queue from the MMCSS task, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.BeginUnregisterWorkQueueWithMMCSS"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFBeginRegisterWorkQueueWithMMCSS']/*"/>	
        /// <msdn-id>ms701600</msdn-id>	
        /// <unmanaged>HRESULT MFBeginRegisterWorkQueueWithMMCSS([In] unsigned int dwWorkQueueId,[In] const wchar_t* wszClass,[In] unsigned int dwTaskId,[In] IMFAsyncCallback* pDoneCallback,[In] IUnknown* pDoneState)</unmanaged>	
        /// <unmanaged-short>MFBeginRegisterWorkQueueWithMMCSS</unmanaged-short>	
        public static void BeginRegisterWorkQueueWithMMCSS(int dwWorkQueueId, string wszClass, int dwTaskId, System.IntPtr doneCallbackRef, SharpDX.ComObject doneStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* wszClass_ = wszClass)
                    __result__ =
                    MFBeginRegisterWorkQueueWithMMCSS_(dwWorkQueueId, (void*)wszClass_, dwTaskId, (void*)doneCallbackRef, (void*)((doneStateRef == null) ? IntPtr.Zero : doneStateRef.NativePointer));
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFBeginRegisterWorkQueueWithMMCSS", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFBeginRegisterWorkQueueWithMMCSS_(int arg0, void* arg1, int arg2, void* arg3, void* arg4);

        /// <summary>	
        /// <p> Associates a work queue with a Multimedia Class Scheduler Service (MMCSS) task.</p>	
        /// </summary>	
        /// <param name="dwWorkQueueId"><dd> <p>The identifier of the work queue.  For private work queues, the identifier is returned by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong> function. For platform work queues, see <strong>Work Queue Identifiers</strong>.</p> </dd></param>	
        /// <param name="wszClass"><dd> <p> The name of the MMCSS task. For more information, see Multimedia Class Scheduler Service. </p> </dd></param>	
        /// <param name="dwTaskId"><dd> <p>The unique task identifier. To obtain a new task identifier, set this value to zero. </p> </dd></param>	
        /// <param name="lPriority"><dd> <p>The base relative priority for the work-queue threads. For more information, see <strong>AvSetMmThreadPriority</strong>.</p> </dd></param>	
        /// <param name="doneCallbackRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>	
        /// <param name="doneStateRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function extends the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.BeginRegisterWorkQueueWithMMCSS"/></strong> function by adding the <em>lPriority</em> parameter.</p><p>This function is asynchronous. When the operation completes, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.EndRegisterWorkQueueWithMMCSS"/></strong> to complete the asynchronous request. </p><p>To unregister the work queue from the MMCSS task, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.BeginUnregisterWorkQueueWithMMCSS"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFBeginRegisterWorkQueueWithMMCSSEx']/*"/>	
        /// <msdn-id>hh162745</msdn-id>	
        /// <unmanaged>HRESULT MFBeginRegisterWorkQueueWithMMCSSEx([In] unsigned int dwWorkQueueId,[In] const wchar_t* wszClass,[In] unsigned int dwTaskId,[In] int lPriority,[In] IMFAsyncCallback* pDoneCallback,[In] IUnknown* pDoneState)</unmanaged>	
        /// <unmanaged-short>MFBeginRegisterWorkQueueWithMMCSSEx</unmanaged-short>	
        public static void BeginRegisterWorkQueueWithMMCSSEx(int dwWorkQueueId, string wszClass, int dwTaskId, int lPriority, System.IntPtr doneCallbackRef, SharpDX.ComObject doneStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* wszClass_ = wszClass)
                    __result__ =
                    MFBeginRegisterWorkQueueWithMMCSSEx_(dwWorkQueueId, (void*)wszClass_, dwTaskId, lPriority, (void*)doneCallbackRef, (void*)((doneStateRef == null) ? IntPtr.Zero : doneStateRef.NativePointer));
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFBeginRegisterWorkQueueWithMMCSSEx", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFBeginRegisterWorkQueueWithMMCSSEx_(int arg0, void* arg1, int arg2, int arg3, void* arg4, void* arg5);

        /// <summary>	
        /// <p> </p><p>Completes an asynchronous request to associate a work queue with a Multimedia Class Scheduler Service (MMCSS) task.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.</p> </dd></param>	
        /// <param name="dwTaskIdRef"><dd> <p>The unique task identifier.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this function when the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.BeginRegisterWorkQueueWithMMCSS"/></strong> function completes asynchronously.</p><p>To unregister the work queue from the MMCSS class, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.BeginUnregisterWorkQueueWithMMCSS"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFEndRegisterWorkQueueWithMMCSS']/*"/>	
        /// <msdn-id>ms696982</msdn-id>	
        /// <unmanaged>HRESULT MFEndRegisterWorkQueueWithMMCSS([In] IMFAsyncResult* pResult,[Out] unsigned int* pdwTaskId)</unmanaged>	
        /// <unmanaged-short>MFEndRegisterWorkQueueWithMMCSS</unmanaged-short>	
        public static void EndRegisterWorkQueueWithMMCSS(SharpDX.MediaFoundation.AsyncResult resultRef, out int dwTaskIdRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwTaskIdRef_ = &dwTaskIdRef)
                    __result__ =
                    MFEndRegisterWorkQueueWithMMCSS_((void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), dwTaskIdRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFEndRegisterWorkQueueWithMMCSS", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFEndRegisterWorkQueueWithMMCSS_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> </p><p>Unregisters a work queue from a Multimedia Class Scheduler Service (MMCSS) task.</p>	
        /// </summary>	
        /// <param name="dwWorkQueueId"><dd> <p>The identifier of the work queue.  For private work queues, the identifier is returned by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong> function. For platform work queues, see <strong>Work Queue Identifiers</strong>.</p> </dd></param>	
        /// <param name="doneCallbackRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>	
        /// <param name="doneStateRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This function unregisters a work queue that was associated with an MMCSS class through the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.BeginRegisterWorkQueueWithMMCSS"/></strong> function.</p><p>This function is asynchronous. When the operation completes, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, the application should call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.EndUnregisterWorkQueueWithMMCSS"/></strong> to complete the asynchronous request.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFBeginUnregisterWorkQueueWithMMCSS']/*"/>	
        /// <msdn-id>ms704613</msdn-id>	
        /// <unmanaged>HRESULT MFBeginUnregisterWorkQueueWithMMCSS([In] unsigned int dwWorkQueueId,[In] IMFAsyncCallback* pDoneCallback,[In] IUnknown* pDoneState)</unmanaged>	
        /// <unmanaged-short>MFBeginUnregisterWorkQueueWithMMCSS</unmanaged-short>	
        public static void BeginUnregisterWorkQueueWithMMCSS(int dwWorkQueueId, System.IntPtr doneCallbackRef, SharpDX.ComObject doneStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFBeginUnregisterWorkQueueWithMMCSS_(dwWorkQueueId, (void*)doneCallbackRef, (void*)((doneStateRef == null) ? IntPtr.Zero : doneStateRef.NativePointer));
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFBeginUnregisterWorkQueueWithMMCSS", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFBeginUnregisterWorkQueueWithMMCSS_(int arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p> </p><p>Completes an asynchronous request to unregister a work queue from a Multimedia Class Scheduler Service (MMCSS) task.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this function when the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.BeginUnregisterWorkQueueWithMMCSS"/></strong> function completes asynchronously.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFEndUnregisterWorkQueueWithMMCSS']/*"/>	
        /// <msdn-id>ms704803</msdn-id>	
        /// <unmanaged>HRESULT MFEndUnregisterWorkQueueWithMMCSS([In] IMFAsyncResult* pResult)</unmanaged>	
        /// <unmanaged-short>MFEndUnregisterWorkQueueWithMMCSS</unmanaged-short>	
        public static void EndUnregisterWorkQueueWithMMCSS(SharpDX.MediaFoundation.AsyncResult resultRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFEndUnregisterWorkQueueWithMMCSS_((void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer));
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFEndUnregisterWorkQueueWithMMCSS", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFEndUnregisterWorkQueueWithMMCSS_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Retrieves the Multimedia Class Scheduler Service (MMCSS) class currently associated with this work queue.</p>	
        /// </summary>	
        /// <param name="dwWorkQueueId"><dd> <p>Identifier for the work queue. The identifier is retrieved by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong> function.</p> </dd></param>	
        /// <param name="wszClassRef"><dd> <p>Pointer to a buffer that receives the name of the MMCSS class. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="cchClassRef"><dd> <p>On input, specifies the size of the <em>pwszClass</em> buffer, in characters. On output, receives the required size of the buffer, in characters. The size includes the terminating null character.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.BufferTooSmall"/></strong></dt> </dl> </td><td> <p>The <em>pwszClass</em> buffer is too small to receive the task name.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the work queue is not associated with an MMCSS task, the function retrieves an empty string.</p><p>To associate a work queue with an MMCSS task, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.BeginRegisterWorkQueueWithMMCSS"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetWorkQueueMMCSSClass']/*"/>	
        /// <msdn-id>ms701582</msdn-id>	
        /// <unmanaged>HRESULT MFGetWorkQueueMMCSSClass([In] unsigned int dwWorkQueueId,[Out, Buffer, Optional] wchar_t* pwszClass,[InOut] unsigned int* pcchClass)</unmanaged>	
        /// <unmanaged-short>MFGetWorkQueueMMCSSClass</unmanaged-short>	
        public static void GetWorkQueueMMCSSClass(int dwWorkQueueId, System.IntPtr wszClassRef, ref int cchClassRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cchClassRef_ = &cchClassRef)
                    __result__ =
                    MFGetWorkQueueMMCSSClass_(dwWorkQueueId, (void*)wszClassRef, cchClassRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFGetWorkQueueMMCSSClass", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetWorkQueueMMCSSClass_(int arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p> </p><p>Retrieves the Multimedia Class Scheduler Service (MMCSS) task identifier currently associated with this work queue.</p>	
        /// </summary>	
        /// <param name="dwWorkQueueId"><dd> <p>Identifier for the work queue. The identifier is retrieved by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong> function.</p> </dd></param>	
        /// <param name="dwTaskIdRef"><dd> <p>Receives the task identifier.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To associate a work queue with an MMCSS task, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.BeginRegisterWorkQueueWithMMCSS"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetWorkQueueMMCSSTaskId']/*"/>	
        /// <msdn-id>ms704780</msdn-id>	
        /// <unmanaged>HRESULT MFGetWorkQueueMMCSSTaskId([In] unsigned int dwWorkQueueId,[Out] unsigned int* pdwTaskId)</unmanaged>	
        /// <unmanaged-short>MFGetWorkQueueMMCSSTaskId</unmanaged-short>	
        public static void GetWorkQueueMMCSSTaskId(int dwWorkQueueId, out int dwTaskIdRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwTaskIdRef_ = &dwTaskIdRef)
                    __result__ =
                    MFGetWorkQueueMMCSSTaskId_(dwWorkQueueId, dwTaskIdRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFGetWorkQueueMMCSSTaskId", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetWorkQueueMMCSSTaskId_(int arg0, void* arg1);

        /// <summary>	
        /// <p>Registers the standard Microsoft Media Foundation platform work queues with the Multimedia Class Scheduler Service (MMCSS).	
        /// </p>	
        /// </summary>	
        /// <param name="wszClass"><dd> <p>The name of the MMCSS task. </p> </dd></param>	
        /// <param name="dwTaskIdRef"><dd> <p>The MMCSS task identifier. On input, specify an existing  MCCSS task group ID, or use the value zero to create a new task group. On output, receives the actual task group ID.</p> </dd></param>	
        /// <param name="lPriority"><dd> <p>The base priority of the work-queue threads. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To unregister the platform work queues from the MMCSS class, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.UnregisterPlatformFromMMCSS"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFRegisterPlatformWithMMCSS']/*"/>	
        /// <msdn-id>hh162788</msdn-id>	
        /// <unmanaged>HRESULT MFRegisterPlatformWithMMCSS([In] const wchar_t* wszClass,[InOut] unsigned int* pdwTaskId,[In] int lPriority)</unmanaged>	
        /// <unmanaged-short>MFRegisterPlatformWithMMCSS</unmanaged-short>	
        public static void RegisterPlatformWithMMCSS(string wszClass, ref int dwTaskIdRef, int lPriority)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* wszClass_ = wszClass)
                fixed (void* dwTaskIdRef_ = &dwTaskIdRef)
                    __result__ =
                    MFRegisterPlatformWithMMCSS_((void*)wszClass_, dwTaskIdRef_, lPriority);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFRegisterPlatformWithMMCSS", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFRegisterPlatformWithMMCSS_(void* arg0, void* arg1, int arg2);

        /// <summary>	
        /// <p>Unregisters the Microsoft Media Foundation platform work queues from a Multimedia Class Scheduler Service (MMCSS) task.</p>	
        /// </summary>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFUnregisterPlatformFromMMCSS']/*"/>	
        /// <msdn-id>hh162801</msdn-id>	
        /// <unmanaged>HRESULT MFUnregisterPlatformFromMMCSS()</unmanaged>	
        /// <unmanaged-short>MFUnregisterPlatformFromMMCSS</unmanaged-short>	
        public static void UnregisterPlatformFromMMCSS()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFUnregisterPlatformFromMMCSS_();
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFUnregisterPlatformFromMMCSS", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFUnregisterPlatformFromMMCSS_();

        /// <summary>	
        /// <p>Obtains and locks a shared work queue.</p>	
        /// </summary>	
        /// <param name="wszClass"><dd> <p>The name of the MMCSS task.  </p> </dd></param>	
        /// <param name="basePriority"><dd> <p>The base priority of the work-queue threads.  If the regular-priority queue is being used (<em>wszClass</em>=""), then the value 0 must be passed in.</p> </dd></param>	
        /// <param name="dwTaskIdRef"><dd> <p>The MMCSS task identifier. On input, specify an existing MCCSS task group ID , or use the value zero to create a new task group. If the regular priority queue is being used (<em>wszClass</em>=""), then <strong><c>null</c></strong> must be passed in. On output, receives the actual task group ID. </p> </dd></param>	
        /// <param name="iDRef"><dd> <p>Receives an identifier for the new work queue. Use this identifier when queuing work items.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>A <em>multithreaded work queue</em> uses a thread pool to dispatch work items. Whenever a thread becomes available, it dequeues the next work item from the queue. Work items are dequeued in first-in-first-out order, but work items are not serialized. In other words, the work queue does not wait for a work item to complete before it starts the next work item. </p><p>Within a single process, the Microsoft Media Foundation platform creates up to one multithreaded queue for each Multimedia Class Scheduler Service (MMCSS) task. The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.LockSharedWorkQueue"/></strong> function checks whether a matching work queue already exists. If not, the function creates a new work queue and registers the work queue with MMCSS. The function returns the MMCSS task identifier (<em>pdwTaskId</em>) and the work queue identifier (<em>pID</em>). To queue a work item, pass the work queue identifier to any of the following functions: </p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.PutWorkItem"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.PutWorkItem2"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.PutWorkItemEx"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.PutWorkItemEx2"/></strong> </li> </ul><p>The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.LockSharedWorkQueue"/></strong> function also locks the queue. Before the process exits, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.UnlockWorkQueue"/></strong> to unlock the work queue.</p><p>If the regular priority queue is being used (<em>wszClass</em>=""), then <c>null</c> must be passed in to <em>pdwTaskId</em> and the value 0 must be passed into <em>BasePriority</em>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFLockSharedWorkQueue']/*"/>	
        /// <msdn-id>hh162771</msdn-id>	
        /// <unmanaged>HRESULT MFLockSharedWorkQueue([In] const wchar_t* wszClass,[In] int BasePriority,[InOut] unsigned int* pdwTaskId,[Out] unsigned int* pID)</unmanaged>	
        /// <unmanaged-short>MFLockSharedWorkQueue</unmanaged-short>	
        public static void LockSharedWorkQueue(string wszClass, int basePriority, ref int dwTaskIdRef, out int iDRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* wszClass_ = wszClass)
                fixed (void* dwTaskIdRef_ = &dwTaskIdRef)
                fixed (void* iDRef_ = &iDRef)
                    __result__ =
                    MFLockSharedWorkQueue_((void*)wszClass_, basePriority, dwTaskIdRef_, iDRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFLockSharedWorkQueue", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFLockSharedWorkQueue_(void* arg0, int arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p>Gets the relative thread priority of a work queue.</p>	
        /// </summary>	
        /// <param name="dwWorkQueueId"><dd> <p>The identifier of the work queue. For private work queues, the identifier is returned by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong> function. For platform work queues, see <strong>Work Queue Identifiers</strong>.</p> </dd></param>	
        /// <param name="lPriority"><dd> <p>Receives the relative thread priority.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function returns the relative thread priority set by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.BeginRegisterWorkQueueWithMMCSSEx"/></strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetWorkQueueMMCSSPriority']/*"/>	
        /// <msdn-id>hh162768</msdn-id>	
        /// <unmanaged>HRESULT MFGetWorkQueueMMCSSPriority([In] unsigned int dwWorkQueueId,[Out] int* lPriority)</unmanaged>	
        /// <unmanaged-short>MFGetWorkQueueMMCSSPriority</unmanaged-short>	
        public static void GetWorkQueueMMCSSPriority(int dwWorkQueueId, out int lPriority)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* lPriority_ = &lPriority)
                    __result__ =
                    MFGetWorkQueueMMCSSPriority_(dwWorkQueueId, lPriority_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFGetWorkQueueMMCSSPriority", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetWorkQueueMMCSSPriority_(int arg0, void* arg1);

        /// <summary>	
        /// <p> </p><p>Creates an asynchronous result object. Use this function if you are implementing an asynchronous method.</p>	
        /// </summary>	
        /// <param name="unkObjectRef"><dd> <p>Pointer to the object stored in the asynchronous result. This reference is returned by the <strong><see cref="SharpDX.MediaFoundation.AsyncResult.GetObject"/></strong> method. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface. This interface is implemented by the caller of the asynchronous method.</p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object. This value is provided by the caller of the asynchronous method. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="asyncResultOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To invoke the callback specified in <em>pCallback</em>, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.InvokeCallback"/></strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateAsyncResult']/*"/>	
        /// <msdn-id>ms698952</msdn-id>	
        /// <unmanaged>HRESULT MFCreateAsyncResult([In] IUnknown* punkObject,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState,[Out] IMFAsyncResult** ppAsyncResult)</unmanaged>	
        /// <unmanaged-short>MFCreateAsyncResult</unmanaged-short>	
        public static void CreateAsyncResult(SharpDX.ComObject unkObjectRef, System.IntPtr callbackRef, SharpDX.ComObject unkStateRef, out SharpDX.MediaFoundation.AsyncResult asyncResultOut)
        {
            unsafe
            {
                IntPtr asyncResultOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateAsyncResult_((void*)((unkObjectRef == null) ? IntPtr.Zero : unkObjectRef.NativePointer), (void*)callbackRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), &asyncResultOut_);
                asyncResultOut = (asyncResultOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.AsyncResult(asyncResultOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateAsyncResult", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateAsyncResult_(void* arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p> Invokes a callback method to complete an asynchronous operation. </p>	
        /// </summary>	
        /// <param name="asyncResultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. To create this object, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAsyncResult"/></strong>.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidWorkqueue"/></strong></strong></dt> </dl> </td><td> <p>Invalid work queue. For more information, see <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.GetParameters"/></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> function was called to shut down the Media Foundation platform.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If you are implementing an asynchronous method, use this function to invoke the caller's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.</p><p>The callback is invoked from a Media Foundation work queue. For more information, see Writing an Asynchronous Method.</p><p>The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> function shuts down the work queue threads, so the callback is not guaranteed to be invoked after <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> is called.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFInvokeCallback']/*"/>	
        /// <msdn-id>ms695400</msdn-id>	
        /// <unmanaged>HRESULT MFInvokeCallback([In] IMFAsyncResult* pAsyncResult)</unmanaged>	
        /// <unmanaged-short>MFInvokeCallback</unmanaged-short>	
        public static void InvokeCallback(SharpDX.MediaFoundation.AsyncResult asyncResultRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFInvokeCallback_((void*)((asyncResultRef == null) ? IntPtr.Zero : asyncResultRef.NativePointer));
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFInvokeCallback", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFInvokeCallback_(void* arg0);

        /// <summary>	
        /// <p> Creates a byte stream from a file. </p>	
        /// </summary>	
        /// <param name="accessMode"><dd> <p> The requested access mode, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.FileAccessMode"/></strong> enumeration. </p> </dd></param>	
        /// <param name="openMode"><dd> <p> The behavior of the function if the file already exists or does not exist, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.FileOpenMode"/></strong> enumeration. </p> </dd></param>	
        /// <param name="fFlags"><dd> <p> Bitwise <strong>OR</strong> of values from the <strong><see cref="SharpDX.MediaFoundation.FileFlags"/></strong> enumeration. </p> </dd></param>	
        /// <param name="wszFileURLRef"><dd> <p> Pointer to a null-terminated string that contains the file name. </p> </dd></param>	
        /// <param name="iByteStreamOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of the byte stream. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateFile']/*"/>	
        /// <msdn-id>ms696166</msdn-id>	
        /// <unmanaged>HRESULT MFCreateFile([In] MF_FILE_ACCESSMODE AccessMode,[In] MF_FILE_OPENMODE OpenMode,[In] MF_FILE_FLAGS fFlags,[In] const wchar_t* pwszFileURL,[Out] IMFByteStream** ppIByteStream)</unmanaged>	
        /// <unmanaged-short>MFCreateFile</unmanaged-short>	
        public static void CreateFile(SharpDX.MediaFoundation.FileAccessMode accessMode, SharpDX.MediaFoundation.FileOpenMode openMode, SharpDX.MediaFoundation.FileFlags fFlags, string wszFileURLRef, out SharpDX.MediaFoundation.IByteStream iByteStreamOut)
        {
            unsafe
            {
                IntPtr iByteStreamOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* wszFileURLRef_ = wszFileURLRef)
                    __result__ =
                    MFCreateFile_(unchecked((int)accessMode), unchecked((int)openMode), unchecked((int)fFlags), (void*)wszFileURLRef_, &iByteStreamOut_);
                iByteStreamOut = (iByteStreamOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ByteStream(iByteStreamOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateFile", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateFile_(int arg0, int arg1, int arg2, void* arg3, void* arg4);

        /// <summary>	
        /// <p> Creates a byte stream that is backed by a temporary local file. </p>	
        /// </summary>	
        /// <param name="accessMode"><dd> <p> The requested access mode, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.FileAccessMode"/></strong> enumeration. </p> </dd></param>	
        /// <param name="openMode"><dd> <p> The behavior of the function if the file already exists or does not exist, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.FileOpenMode"/></strong> enumeration. </p> </dd></param>	
        /// <param name="fFlags"><dd> <p> Bitwise <strong>OR</strong> of values from the <strong><see cref="SharpDX.MediaFoundation.FileFlags"/></strong> enumeration. </p> </dd></param>	
        /// <param name="iByteStreamOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of the byte stream. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This function creates a file in the system temporary folder, and then returns a byte stream object for that file. The full path name of the file is storted in the <strong><see cref="SharpDX.MediaFoundation.ByteStreamAttributeKeys.OriginName"/></strong> attribute. The file is created with the <strong>FILE_FLAG_DELETE_ON_CLOSE</strong> flag, and is deleted after the byte stream is released.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateTempFile']/*"/>	
        /// <msdn-id>ms695209</msdn-id>	
        /// <unmanaged>HRESULT MFCreateTempFile([In] MF_FILE_ACCESSMODE AccessMode,[In] MF_FILE_OPENMODE OpenMode,[In] MF_FILE_FLAGS fFlags,[Out] IMFByteStream** ppIByteStream)</unmanaged>	
        /// <unmanaged-short>MFCreateTempFile</unmanaged-short>	
        public static void CreateTempFile(SharpDX.MediaFoundation.FileAccessMode accessMode, SharpDX.MediaFoundation.FileOpenMode openMode, SharpDX.MediaFoundation.FileFlags fFlags, out SharpDX.MediaFoundation.IByteStream iByteStreamOut)
        {
            unsafe
            {
                IntPtr iByteStreamOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateTempFile_(unchecked((int)accessMode), unchecked((int)openMode), unchecked((int)fFlags), &iByteStreamOut_);
                iByteStreamOut = (iByteStreamOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ByteStream(iByteStreamOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateTempFile", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateTempFile_(int arg0, int arg1, int arg2, void* arg3);

        /// <summary>	
        /// <p> </p><p>Begins an asynchronous request to create a byte stream from a file.</p>	
        /// </summary>	
        /// <param name="accessMode"><dd> <p>The requested access mode, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.FileAccessMode"/></strong> enumeration.</p> </dd></param>	
        /// <param name="openMode"><dd> <p>The behavior of the function if the file already exists or does not exist, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.FileOpenMode"/></strong> enumeration.</p> </dd></param>	
        /// <param name="fFlags"><dd> <p>Bitwise <strong>OR</strong> of values from the <strong><see cref="SharpDX.MediaFoundation.FileFlags"/></strong> enumeration.</p> </dd></param>	
        /// <param name="wszFilePathRef"><dd> <p>Pointer to a null-terminated string containing the file name.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface</p> </dd></param>	
        /// <param name="stateRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <param name="cancelCookieOut"><dd> <p>Receives an <strong><see cref="SharpDX.ComObject"/></strong> reference or the value <strong><c>null</c></strong>. If the value is not <strong><c>null</c></strong>, you can cancel the asynchronous operation by passing this reference to the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CancelCreateFile"/></strong> function. The caller must release the interface. This parameter is optional and can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When the request is completed, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. The callback object should then call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.EndCreateFile"/></strong> function to get a reference to the byte stream.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFBeginCreateFile']/*"/>	
        /// <msdn-id>ms702074</msdn-id>	
        /// <unmanaged>HRESULT MFBeginCreateFile([In] MF_FILE_ACCESSMODE AccessMode,[In] MF_FILE_OPENMODE OpenMode,[In] MF_FILE_FLAGS fFlags,[In] const wchar_t* pwszFilePath,[In] IMFAsyncCallback* pCallback,[In] IUnknown* pState,[Out] IUnknown** ppCancelCookie)</unmanaged>	
        /// <unmanaged-short>MFBeginCreateFile</unmanaged-short>	
        public static void BeginCreateFile(SharpDX.MediaFoundation.FileAccessMode accessMode, SharpDX.MediaFoundation.FileOpenMode openMode, SharpDX.MediaFoundation.FileFlags fFlags, string wszFilePathRef, System.IntPtr callbackRef, SharpDX.ComObject stateRef, out SharpDX.ComObject cancelCookieOut)
        {
            unsafe
            {
                IntPtr cancelCookieOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* wszFilePathRef_ = wszFilePathRef)
                    __result__ =
                    MFBeginCreateFile_(unchecked((int)accessMode), unchecked((int)openMode), unchecked((int)fFlags), (void*)wszFilePathRef_, (void*)callbackRef, (void*)((stateRef == null) ? IntPtr.Zero : stateRef.NativePointer), &cancelCookieOut_);
                cancelCookieOut = (cancelCookieOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(cancelCookieOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFBeginCreateFile", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFBeginCreateFile_(int arg0, int arg1, int arg2, void* arg3, void* arg4, void* arg5, void* arg6);

        /// <summary>	
        /// <p> </p><p>Completes an asynchronous request to create a byte stream from a file.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>Invoke</strong> method.</p> </dd></param>	
        /// <param name="fileOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of the byte stream. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this function when the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.BeginCreateFile"/></strong> function completes asynchronously.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFEndCreateFile']/*"/>	
        /// <msdn-id>ms703984</msdn-id>	
        /// <unmanaged>HRESULT MFEndCreateFile([In] IMFAsyncResult* pResult,[Out] IMFByteStream** ppFile)</unmanaged>	
        /// <unmanaged-short>MFEndCreateFile</unmanaged-short>	
        public static void EndCreateFile(SharpDX.MediaFoundation.AsyncResult resultRef, out SharpDX.MediaFoundation.IByteStream fileOut)
        {
            unsafe
            {
                IntPtr fileOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFEndCreateFile_((void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), &fileOut_);
                fileOut = (fileOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ByteStream(fileOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFEndCreateFile", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFEndCreateFile_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> </p><p>Cancels an asynchronous request to create a byte stream from a file.</p>	
        /// </summary>	
        /// <param name="cancelCookieRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of the cancellation object. This reference is received in the <em>ppCancelCookie</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.BeginCreateFile"/></strong> function.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You can use this function to cancel a previous call to <strong><see cref="SharpDX.MediaFoundation.MediaFactory.BeginCreateFile"/></strong>. Because that function is asynchronous, however, it might complete before the operation can be canceled. Therefore, your callback might still be invoked after you call this function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCancelCreateFile']/*"/>	
        /// <msdn-id>ms702218</msdn-id>	
        /// <unmanaged>HRESULT MFCancelCreateFile([In] IUnknown* pCancelCookie)</unmanaged>	
        /// <unmanaged-short>MFCancelCreateFile</unmanaged-short>	
        public static void CancelCreateFile(SharpDX.ComObject cancelCookieRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFCancelCreateFile_((void*)((cancelCookieRef == null) ? IntPtr.Zero : cancelCookieRef.NativePointer));
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCancelCreateFile", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCancelCreateFile_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Allocates system memory and creates a media buffer to manage it.</p>	
        /// </summary>	
        /// <param name="cbMaxLength"><dd> <p>Size of the buffer, in bytes.</p> </dd></param>	
        /// <returns><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of the media buffer. The caller must release the interface.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The function allocates a buffer with a 1-byte memory alignment. To allocate a buffer that is aligned to a larger memory boundary, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAlignedMemoryBuffer"/></strong>.</p><p>When the media buffer object is destroyed, it releases the allocated memory.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMemoryBuffer']/*"/>	
        /// <msdn-id>ms695212</msdn-id>	
        /// <unmanaged>HRESULT MFCreateMemoryBuffer([In] unsigned int cbMaxLength,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>	
        /// <unmanaged-short>MFCreateMemoryBuffer</unmanaged-short>	
        public static SharpDX.MediaFoundation.MediaBuffer CreateMemoryBuffer(int cbMaxLength)
        {
            unsafe
            {
                SharpDX.MediaFoundation.MediaBuffer bufferOut;
                IntPtr bufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMemoryBuffer_(cbMaxLength, &bufferOut_);
                bufferOut = (bufferOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaBuffer(bufferOut_);
                __result__.CheckError();
                return bufferOut;
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateMemoryBuffer", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMemoryBuffer_(int arg0, void* arg1);

        /// <summary>	
        /// <p>Creates a media buffer that wraps an existing media buffer. The new media buffer points to the same memory as the original media buffer, or to an offset from the start of the memory.</p>	
        /// </summary>	
        /// <param name="bufferRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of the original media buffer. </p> </dd></param>	
        /// <param name="cbOffset"><dd> <p>The start of the new buffer, as an offset in bytes from the start of the original buffer. </p> </dd></param>	
        /// <param name="dwLength"><dd> <p>The size of the new buffer. The value of <em>cbOffset</em> + <em>dwLength</em> must be less than or equal to the size of valid data the original buffer. (The size of the valid data is returned by the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.GetCurrentLength"/></strong> method.) </p> </dd></param>	
        /// <param name="bufferOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> The requested offset or the requested length is not valid. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The maximum size of the wrapper buffer is limited to the size of the valid data in the original buffer. This might be less than the allocated size of the original buffer. To set the size of the valid data, call <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.SetCurrentLength"/></strong>.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMediaBufferWrapper']/*"/>	
        /// <msdn-id>aa370450</msdn-id>	
        /// <unmanaged>HRESULT MFCreateMediaBufferWrapper([In] IMFMediaBuffer* pBuffer,[In] unsigned int cbOffset,[In] unsigned int dwLength,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>	
        /// <unmanaged-short>MFCreateMediaBufferWrapper</unmanaged-short>	
        public static void CreateMediaBufferWrapper(SharpDX.MediaFoundation.MediaBuffer bufferRef, int cbOffset, int dwLength, out SharpDX.MediaFoundation.MediaBuffer bufferOut)
        {
            unsafe
            {
                IntPtr bufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMediaBufferWrapper_((void*)((bufferRef == null) ? IntPtr.Zero : bufferRef.NativePointer), cbOffset, dwLength, &bufferOut_);
                bufferOut = (bufferOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaBuffer(bufferOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateMediaBufferWrapper", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMediaBufferWrapper_(void* arg0, int arg1, int arg2, void* arg3);

        /// <summary>	
        /// <p> </p><p>Converts a Media Foundation media buffer into a buffer that is compatible with DirectX Media Objects (DMOs).</p>	
        /// </summary>	
        /// <param name="sampleRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface of the sample that contains the Media Foundation buffer. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="mFMediaBufferRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of the Media Foundation buffer.</p> </dd></param>	
        /// <param name="cbOffset"><dd> <p>Offset in bytes from the start of the Media Foundation buffer. This offset defines where the DMO buffer starts. If this parameter is zero, the DMO buffer starts at the beginning of the Media Foundation buffer.</p> </dd></param>	
        /// <param name="mediaBufferOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.IMediaBuffer"/></strong> interface. This interface is documented in the DirectShow SDK documentation. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument. The <em>pIMFMediaBuffer</em> parameter must not be <strong><c>null</c></strong>.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The DMO buffer created by this function also exposes the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface. If <em>pIMFSample</em> is <strong><c>null</c></strong>, all of the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> methods return <see cref="SharpDX.MediaFoundation.ResultCode.NotInitializeD"/>. Otherwise, they call through to the <em>pIMFSample</em> reference.</p><p>If the Media Foundation buffer specified by <em>pIMFMediaBuffer</em> exposes the <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong> interface, the DMO buffer also exposes <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateLegacyMediaBufferOnMFMediaBuffer']/*"/>	
        /// <msdn-id>ms696233</msdn-id>	
        /// <unmanaged>HRESULT MFCreateLegacyMediaBufferOnMFMediaBuffer([In, Optional] IMFSample* pSample,[In] IMFMediaBuffer* pMFMediaBuffer,[In] unsigned int cbOffset,[Out] IMediaBuffer** ppMediaBuffer)</unmanaged>	
        /// <unmanaged-short>MFCreateLegacyMediaBufferOnMFMediaBuffer</unmanaged-short>	
        public static void CreateLegacyMediaBufferOnMFMediaBuffer(SharpDX.MediaFoundation.Sample sampleRef, SharpDX.MediaFoundation.MediaBuffer mFMediaBufferRef, int cbOffset, out SharpDX.MediaFoundation.IMediaBuffer mediaBufferOut)
        {
            unsafe
            {
                IntPtr mediaBufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateLegacyMediaBufferOnMFMediaBuffer_((void*)((sampleRef == null) ? IntPtr.Zero : sampleRef.NativePointer), (void*)((mFMediaBufferRef == null) ? IntPtr.Zero : mFMediaBufferRef.NativePointer), cbOffset, &mediaBufferOut_);
                mediaBufferOut = (mediaBufferOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.IMediaBuffer(mediaBufferOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateLegacyMediaBufferOnMFMediaBuffer", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateLegacyMediaBufferOnMFMediaBuffer_(void* arg0, void* arg1, int arg2, void* arg3);

        /// <summary>	
        /// <p>Converts a Microsoft Direct3D?9 format identifier to a Microsoft DirectX Graphics Infrastructure (DXGI) format identifier.</p>	
        /// </summary>	
        /// <param name="dx9"><dd> <p>The <strong>D3DFORMAT</strong> value or FOURCC code to convert.</p> </dd></param>	
        /// <returns><p>Returns a <strong><see cref="SharpDX.DXGI.Format"/></strong> value.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFMapDX9FormatToDXGIFormat']/*"/>	
        /// <msdn-id>hh162772</msdn-id>	
        /// <unmanaged>DXGI_FORMAT MFMapDX9FormatToDXGIFormat([In] unsigned int dx9)</unmanaged>	
        /// <unmanaged-short>MFMapDX9FormatToDXGIFormat</unmanaged-short>	
        public static SharpDX.DXGI.Format MapDX9FormatToDXGIFormat(int dx9)
        {
            unsafe
            {
                SharpDX.DXGI.Format __result__;
                __result__ =
                MFMapDX9FormatToDXGIFormat_(dx9);
                return __result__;
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFMapDX9FormatToDXGIFormat", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern SharpDX.DXGI.Format MFMapDX9FormatToDXGIFormat_(int arg0);

        /// <summary>	
        /// <p>Converts a Microsoft DirectX Graphics Infrastructure (DXGI) format identifier to a Microsoft Direct3D?9 format identifier.</p>	
        /// </summary>	
        /// <param name="dx11"><dd> <p>The <strong><see cref="SharpDX.DXGI.Format"/></strong> value to convert.</p> </dd></param>	
        /// <returns><p>Returns a <strong>D3DFORMAT</strong> value or FOURCC code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFMapDXGIFormatToDX9Format']/*"/>	
        /// <msdn-id>hh162773</msdn-id>	
        /// <unmanaged>unsigned int MFMapDXGIFormatToDX9Format([In] DXGI_FORMAT dx11)</unmanaged>	
        /// <unmanaged-short>MFMapDXGIFormatToDX9Format</unmanaged-short>	
        public static int MapDXGIFormatToDX9Format(SharpDX.DXGI.Format dx11)
        {
            unsafe
            {
                int __result__;
                __result__ =
                MFMapDXGIFormatToDX9Format_(unchecked((int)dx11));
                return __result__;
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFMapDXGIFormatToDX9Format", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFMapDXGIFormatToDX9Format_(int arg0);

        /// <summary>	
        /// <p>Locks the shared Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager.</p>	
        /// </summary>	
        /// <param name="resetTokenRef"><dd> <p>Receives a token that identifies this instance of the DXGI Device Manager. Use this token when calling <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.ResetDevice"/></strong>. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="managerOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function obtains a reference to a  DXGI Device Manager instance that can be shared between components. The Microsoft Media Foundation platform creates this instance of the  DXGI Device Manager as a singleton object. Alternatively, you can create a new DXGI Device Manager by calling <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDXGIDeviceManager"/></strong>.</p><p>The first time this function is called, the Media Foundation platform creates the shared DXGI Device Manager. </p><p>When you are done use the <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> reference, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.UnlockDXGIDeviceManager"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFLockDXGIDeviceManager']/*"/>	
        /// <msdn-id>hh162770</msdn-id>	
        /// <unmanaged>HRESULT MFLockDXGIDeviceManager([Out, Optional] unsigned int* pResetToken,[Out] IMFDXGIDeviceManager** ppManager)</unmanaged>	
        /// <unmanaged-short>MFLockDXGIDeviceManager</unmanaged-short>	
        public static void LockDXGIDeviceManager(out int resetTokenRef, out SharpDX.MediaFoundation.DXGIDeviceManager managerOut)
        {
            unsafe
            {
                IntPtr managerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* resetTokenRef_ = &resetTokenRef)
                    __result__ =
                    MFLockDXGIDeviceManager_(resetTokenRef_, &managerOut_);
                managerOut = (managerOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.DXGIDeviceManager(managerOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFLockDXGIDeviceManager", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFLockDXGIDeviceManager_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Unlocks the shared Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager.</p>	
        /// </summary>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Call this function after a successful call to the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.LockDXGIDeviceManager"/></strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFUnlockDXGIDeviceManager']/*"/>	
        /// <msdn-id>hh162800</msdn-id>	
        /// <unmanaged>HRESULT MFUnlockDXGIDeviceManager()</unmanaged>	
        /// <unmanaged-short>MFUnlockDXGIDeviceManager</unmanaged-short>	
        public static void UnlockDXGIDeviceManager()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFUnlockDXGIDeviceManager_();
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFUnlockDXGIDeviceManager", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFUnlockDXGIDeviceManager_();

        /// <summary>	
        /// <p> Creates a media buffer object that manages a Direct3D 9 surface. </p>	
        /// </summary>	
        /// <param name="riid"><dd> <p> Identifies the type of Direct3D 9 surface. Currently this value must be <strong>IID_IDirect3DSurface9</strong>. </p> </dd></param>	
        /// <param name="unkSurfaceRef"><dd> <p> A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of the DirectX surface. </p> </dd></param>	
        /// <param name="fBottomUpWhenLinear"><dd> <p> If <strong>TRUE</strong>, the buffer's <strong><see cref="SharpDX.MediaFoundation.Buffer2D.ContiguousCopyTo"/></strong> method copies the buffer into a bottom-up format. The bottom-up format is compatible with GDI for uncompressed RGB images. If this parameter is <strong><see cref="SharpDX.Result.False"/></strong>, the <strong>ContiguousCopyTo</strong> method copies the buffer into a top-down format, which is compatible with DirectX. </p> <p>For more information about top-down versus bottom-up images, see Image Stride.</p> </dd></param>	
        /// <param name="bufferOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface. The caller must release the buffer. </p> </dd></param>	
        /// <returns><p> The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This function creates a media buffer object that holds a reference to the Direct3D surface specified in <em>punkSurface</em>. Locking the buffer gives the caller access to the surface memory. When the buffer object is destroyed, it releases the surface. For more information about media buffers, see Media Buffers.</p><strong>Note</strong>??This function does not allocate the Direct3D surface itself.?<p> The buffer object created by this function also exposes the <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong> interface. For more information, see DirectX Surface Buffer. </p><p>This function does not support DXGI surfaces.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateDXSurfaceBuffer']/*"/>	
        /// <msdn-id>ms703840</msdn-id>	
        /// <unmanaged>HRESULT MFCreateDXSurfaceBuffer([In] const GUID&amp; riid,[In] IUnknown* punkSurface,[In] BOOL fBottomUpWhenLinear,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>	
        /// <unmanaged-short>MFCreateDXSurfaceBuffer</unmanaged-short>	
        public static void CreateDXSurfaceBuffer(System.Guid riid, SharpDX.ComObject unkSurfaceRef, SharpDX.Mathematics.Interop.RawBool fBottomUpWhenLinear, out SharpDX.MediaFoundation.MediaBuffer bufferOut)
        {
            unsafe
            {
                IntPtr bufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateDXSurfaceBuffer_(&riid, (void*)((unkSurfaceRef == null) ? IntPtr.Zero : unkSurfaceRef.NativePointer), fBottomUpWhenLinear, &bufferOut_);
                bufferOut = (bufferOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaBuffer(bufferOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateDXSurfaceBuffer", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateDXSurfaceBuffer_(void* arg0, void* arg1, SharpDX.Mathematics.Interop.RawBool arg2, void* arg3);

        /// <summary>	
        /// <p>Creates a media buffer object that manages a Windows Imaging Component (WIC) bitmap.</p>	
        /// </summary>	
        /// <param name="riid"><dd> <p>Set this parameter to <code>__uuidof(<see cref="SharpDX.WIC.Bitmap"/>)</code>.</p> </dd></param>	
        /// <param name="unkSurfaceRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of the bitmap surface. The bitmap surface must be a WIC bitmap that exposes the <strong><see cref="SharpDX.WIC.Bitmap"/></strong> interface.</p> </dd></param>	
        /// <param name="bufferOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateWICBitmapBuffer']/*"/>	
        /// <msdn-id>hh162764</msdn-id>	
        /// <unmanaged>HRESULT MFCreateWICBitmapBuffer([In] const GUID&amp; riid,[In] IUnknown* punkSurface,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>	
        /// <unmanaged-short>MFCreateWICBitmapBuffer</unmanaged-short>	
        public static void CreateWICBitmapBuffer(System.Guid riid, SharpDX.ComObject unkSurfaceRef, out SharpDX.MediaFoundation.MediaBuffer bufferOut)
        {
            unsafe
            {
                IntPtr bufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateWICBitmapBuffer_(&riid, (void*)((unkSurfaceRef == null) ? IntPtr.Zero : unkSurfaceRef.NativePointer), &bufferOut_);
                bufferOut = (bufferOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaBuffer(bufferOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateWICBitmapBuffer", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateWICBitmapBuffer_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p>Creates a media buffer to manage a Microsoft DirectX Graphics Infrastructure (DXGI) surface.</p>	
        /// </summary>	
        /// <param name="riid"><dd> <p> Identifies the type of DXGI surface. This value must be <strong>IID_ID3D11Texture2D</strong>. </p> </dd></param>	
        /// <param name="unkSurfaceRef"><dd> <p> A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of the DXGI surface. </p> </dd></param>	
        /// <param name="uSubresourceIndex"><dd> <p>The zero-based index of a subresource of the surface. The media buffer object is associated with this subresource.</p> </dd></param>	
        /// <param name="fBottomUpWhenLinear"><dd> <p> If <strong>TRUE</strong>, the buffer's <strong><see cref="SharpDX.MediaFoundation.Buffer2D.ContiguousCopyTo"/></strong> method copies the buffer into a bottom-up format. The bottom-up format is compatible with GDI for uncompressed RGB images. If this parameter is <strong><see cref="SharpDX.Result.False"/></strong>, the <strong>ContiguousCopyTo</strong> method copies the buffer into a top-down format, which is compatible with Direct3D. </p> <p>For more information about top-down versus bottom-up images, see Image Stride.</p> </dd></param>	
        /// <param name="bufferOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface. The caller must release the buffer. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The returned buffer object supports the following interfaces:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.Buffer2D2"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.DXGIBuffer"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateDXGISurfaceBuffer']/*"/>	
        /// <msdn-id>hh162751</msdn-id>	
        /// <unmanaged>HRESULT MFCreateDXGISurfaceBuffer([In] const GUID&amp; riid,[In] IUnknown* punkSurface,[In] unsigned int uSubresourceIndex,[In] BOOL fBottomUpWhenLinear,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>	
        /// <unmanaged-short>MFCreateDXGISurfaceBuffer</unmanaged-short>	
        public static void CreateDXGISurfaceBuffer(System.Guid riid, SharpDX.ComObject unkSurfaceRef, int uSubresourceIndex, SharpDX.Mathematics.Interop.RawBool fBottomUpWhenLinear, out SharpDX.MediaFoundation.MediaBuffer bufferOut)
        {
            unsafe
            {
                IntPtr bufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateDXGISurfaceBuffer_(&riid, (void*)((unkSurfaceRef == null) ? IntPtr.Zero : unkSurfaceRef.NativePointer), uSubresourceIndex, fBottomUpWhenLinear, &bufferOut_);
                bufferOut = (bufferOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaBuffer(bufferOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateDXGISurfaceBuffer", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateDXGISurfaceBuffer_(void* arg0, void* arg1, int arg2, SharpDX.Mathematics.Interop.RawBool arg3, void* arg4);

        /// <summary>	
        /// <p>Creates an object that allocates video samples that are compatible with Microsoft DirectX Graphics Infrastructure (DXGI).</p>	
        /// </summary>	
        /// <param name="riid"><dd> <p>The identifier of the interface to retrieve. Specify one of the following values.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>IID_IUnknown</strong></strong></dt> </dl> </td><td> <p>Retrieve an <strong><see cref="SharpDX.ComObject"/></strong> reference.</p> </td></tr> <tr><td><dl> <dt><strong><strong>IID_IMFVideoSampleAllocator</strong></strong></dt> </dl> </td><td> <p>Retrieve an <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocator"/></strong> reference.</p> </td></tr> <tr><td><dl> <dt><strong><strong>IID_IMFVideoSampleAllocatorEx</strong></strong></dt> </dl> </td><td> <p>Retrieve an <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocatorEx"/></strong> reference.</p> </td></tr> <tr><td><dl> <dt><strong><strong>IID_IMFVideoSampleAllocatorCallback</strong></strong></dt> </dl> </td><td> <p>Retrieve an <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocatorCallback"/></strong> reference.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="sampleAllocatorOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function creates an allocator for DXGI video surfaces. The buffers created by this allocator expose the <strong><see cref="SharpDX.MediaFoundation.DXGIBuffer"/></strong> interface. To create an allocator for Microsoft Direct3D?9 video surfaces, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateVideoSampleAllocator"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateVideoSampleAllocatorEx']/*"/>	
        /// <msdn-id>hh162763</msdn-id>	
        /// <unmanaged>HRESULT MFCreateVideoSampleAllocatorEx([In] const GUID&amp; riid,[Out] void** ppSampleAllocator)</unmanaged>	
        /// <unmanaged-short>MFCreateVideoSampleAllocatorEx</unmanaged-short>	
        public static void CreateVideoSampleAllocatorEx(System.Guid riid, out System.IntPtr sampleAllocatorOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* sampleAllocatorOut_ = &sampleAllocatorOut)
                    __result__ =
                    MFCreateVideoSampleAllocatorEx_(&riid, sampleAllocatorOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateVideoSampleAllocatorEx", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateVideoSampleAllocatorEx_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Creates an instance of the Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager.</p>	
        /// </summary>	
        /// <param name="resetToken"><dd> <p> Receives a token that identifies this instance of the DXGI Device Manager. Use this token when calling <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.ResetDevice"/></strong>. </p> </dd></param>	
        /// <param name="deviceManagerOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>When you create an <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> with <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDXGIDeviceManager"/></strong>, a Microsoft Direct3D?11 device is not associated with the device manager. To associate a Direct3D?11 device with the device manager, call <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.ResetDevice"/></strong>, passing in the reference to the Direct3D?11 device. To create a Direct3D?11 device, call <strong><see cref="SharpDX.Direct3D11.D3D11.CreateDevice"/></strong>. The device should be created with the <strong><see cref="SharpDX.Direct3D11.DeviceCreationFlags.VideoSupport"/></strong> device creation flag which is defined in the <strong><see cref="SharpDX.Direct3D11.DeviceCreationFlags"/></strong> enumeration.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateDXGIDeviceManager']/*"/>	
        /// <msdn-id>hh162750</msdn-id>	
        /// <unmanaged>HRESULT MFCreateDXGIDeviceManager([Out] unsigned int* resetToken,[Out, Fast] IMFDXGIDeviceManager** ppDeviceManager)</unmanaged>	
        /// <unmanaged-short>MFCreateDXGIDeviceManager</unmanaged-short>	
        public static void CreateDXGIDeviceManager(out int resetToken, SharpDX.MediaFoundation.DXGIDeviceManager deviceManagerOut)
        {
            unsafe
            {
                IntPtr deviceManagerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* resetToken_ = &resetToken)
                    __result__ =
                    MFCreateDXGIDeviceManager_(resetToken_, &deviceManagerOut_);
                ((SharpDX.MediaFoundation.DXGIDeviceManager)deviceManagerOut).NativePointer = deviceManagerOut_;
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateDXGIDeviceManager", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateDXGIDeviceManager_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> Allocates system memory with a specified byte alignment and creates a media buffer to manage the memory. </p>	
        /// </summary>	
        /// <param name="cbMaxLength"><dd> <p>Size of the buffer, in bytes.</p> </dd></param>	
        /// <param name="cbAligment"><dd> <p> Specifies the memory alignment for the buffer. Use one of the following constants. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MF_1_BYTE_ALIGNMENT</strong></dt> <dt>0x00000000</dt> </dl> </td><td> <p> Align to 1 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_2_BYTE_ALIGNMENT</strong></dt> <dt>0x00000001</dt> </dl> </td><td> <p> Align to 2 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_4_BYTE_ALIGNMENT</strong></dt> <dt>0x00000003</dt> </dl> </td><td> <p> Align to 4 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_8_BYTE_ALIGNMENT</strong></dt> <dt>0x00000007</dt> </dl> </td><td> <p> Align to 8 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_16_BYTE_ALIGNMENT</strong></dt> <dt>0x0000000F</dt> </dl> </td><td> <p> Align to 16 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_32_BYTE_ALIGNMENT</strong></dt> <dt>0x0000001F</dt> </dl> </td><td> <p> Align to 32 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_64_BYTE_ALIGNMENT</strong></dt> <dt>0x0000003F</dt> </dl> </td><td> <p> Align to 64 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_128_BYTE_ALIGNMENT</strong></dt> <dt>0x0000007F</dt> </dl> </td><td> <p> Align to 128 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_256_BYTE_ALIGNMENT</strong></dt> <dt>0x000000FF</dt> </dl> </td><td> <p> Align to 256 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_512_BYTE_ALIGNMENT</strong></dt> <dt>0x000001FF</dt> </dl> </td><td> <p> Align to 512 bytes. </p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="bufferOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of the media buffer. The caller must release the interface. </p> </dd></param>	
        /// <returns><p> The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> When the media buffer object is destroyed, it releases the allocated memory. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateAlignedMemoryBuffer']/*"/>	
        /// <msdn-id>bb970523</msdn-id>	
        /// <unmanaged>HRESULT MFCreateAlignedMemoryBuffer([In] unsigned int cbMaxLength,[In] unsigned int cbAligment,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>	
        /// <unmanaged-short>MFCreateAlignedMemoryBuffer</unmanaged-short>	
        public static void CreateAlignedMemoryBuffer(int cbMaxLength, int cbAligment, out SharpDX.MediaFoundation.MediaBuffer bufferOut)
        {
            unsafe
            {
                IntPtr bufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateAlignedMemoryBuffer_(cbMaxLength, cbAligment, &bufferOut_);
                bufferOut = (bufferOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaBuffer(bufferOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateAlignedMemoryBuffer", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateAlignedMemoryBuffer_(int arg0, int arg1, void* arg2);

        /// <summary>	
        /// <p> </p><p>Creates a media event object.</p>	
        /// </summary>	
        /// <param name="met"><dd> <p>The event type. See <strong><see cref="SharpDX.MediaFoundation.MediaEvent.GetTypeInfo"/></strong>. For a list of event types, see Media Foundation Events.</p> </dd></param>	
        /// <param name="guidExtendedType"><dd> <p>The extended type. See <strong><see cref="SharpDX.MediaFoundation.MediaEvent.GetExtendedType"/></strong>. If the event type does not have an extended type, use the value GUID_NULL.</p> </dd></param>	
        /// <param name="hrStatus"><dd> <p>The event status. See <strong><see cref="SharpDX.MediaFoundation.MediaEvent.GetStatus"/></strong> </p> </dd></param>	
        /// <param name="vValueRef"><dd> <p>The value associated with the event, if any. See <strong><see cref="SharpDX.MediaFoundation.MediaEvent.GetValue"/></strong>. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="eventOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaEvent"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMediaEvent']/*"/>	
        /// <msdn-id>ms697521</msdn-id>	
        /// <unmanaged>HRESULT MFCreateMediaEvent([In] unsigned int met,[In] const GUID&amp; guidExtendedType,[In] HRESULT hrStatus,[In, Optional] const PROPVARIANT* pvValue,[Out] IMFMediaEvent** ppEvent)</unmanaged>	
        /// <unmanaged-short>MFCreateMediaEvent</unmanaged-short>	
        public static void CreateMediaEvent(int met, System.Guid guidExtendedType, SharpDX.Result hrStatus, SharpDX.Win32.Variant? vValueRef, out SharpDX.MediaFoundation.MediaEvent eventOut)
        {
            unsafe
            {
                SharpDX.Win32.Variant vValueRef_;
                if (vValueRef.HasValue)
                    vValueRef_ = vValueRef.Value;
                IntPtr eventOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMediaEvent_(met, &guidExtendedType, hrStatus, (vValueRef.HasValue) ? &vValueRef_ : (void*)IntPtr.Zero, &eventOut_);
                eventOut = (eventOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaEvent(eventOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateMediaEvent", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMediaEvent_(int arg0, void* arg1, SharpDX.Result arg2, void* arg3, void* arg4);

        /// <summary>	
        /// <p> </p><p>Creates an event queue.</p>	
        /// </summary>	
        /// <param name="mediaEventQueueOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaEventQueue"/></strong> interface of the event queue. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This function creates a helper object that you can use to implement the <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator"/></strong> interface.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateEventQueue']/*"/>	
        /// <msdn-id>ms695252</msdn-id>	
        /// <unmanaged>HRESULT MFCreateEventQueue([Out] IMFMediaEventQueue** ppMediaEventQueue)</unmanaged>	
        /// <unmanaged-short>MFCreateEventQueue</unmanaged-short>	
        public static void CreateEventQueue(out SharpDX.MediaFoundation.MediaEventQueue mediaEventQueueOut)
        {
            unsafe
            {
                IntPtr mediaEventQueueOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateEventQueue_(&mediaEventQueueOut_);
                mediaEventQueueOut = (mediaEventQueueOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaEventQueue(mediaEventQueueOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateEventQueue", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateEventQueue_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Creates an empty media sample.</p>	
        /// </summary>	
        /// <returns><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface of the media sample. The caller must release the interface.</p> </dd></returns>	
        /// <remarks>	
        /// <p>Initially the sample does not contain any media buffers.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateSample']/*"/>	
        /// <msdn-id>ms702276</msdn-id>	
        /// <unmanaged>HRESULT MFCreateSample([Out] IMFSample** ppIMFSample)</unmanaged>	
        /// <unmanaged-short>MFCreateSample</unmanaged-short>	
        public static SharpDX.MediaFoundation.Sample CreateSample()
        {
            unsafe
            {
                SharpDX.MediaFoundation.Sample iMFSampleOut;
                IntPtr iMFSampleOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateSample_(&iMFSampleOut_);
                iMFSampleOut = (iMFSampleOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Sample(iMFSampleOut_);
                __result__.CheckError();
                return iMFSampleOut;
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateSample", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateSample_(void* arg0);

        /// <summary>	
        /// <p> Creates an empty attribute store. </p>	
        /// </summary>	
        /// <param name="mFAttributesOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <param name="cInitialSize"><dd> <p>The initial number of elements allocated for the attribute store. The attribute store grows as needed. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Attributes are used throughout Microsoft Media Foundation to configure objects, describe media formats, query object properties, and other purposes. For more information, see Attributes in Media Foundation.</p><p>For a complete list of all the defined attribute GUIDs in Media Foundation, see Media Foundation Attributes.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateAttributes']/*"/>	
        /// <msdn-id>ms701878</msdn-id>	
        /// <unmanaged>HRESULT MFCreateAttributes([Out, Fast] IMFAttributes** ppMFAttributes,[In] unsigned int cInitialSize)</unmanaged>	
        /// <unmanaged-short>MFCreateAttributes</unmanaged-short>	
        public static void CreateAttributes(SharpDX.MediaFoundation.MediaAttributes mFAttributesOut, int cInitialSize)
        {
            unsafe
            {
                IntPtr mFAttributesOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateAttributes_(&mFAttributesOut_, cInitialSize);
                ((SharpDX.MediaFoundation.MediaAttributes)mFAttributesOut).NativePointer = mFAttributesOut_;
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateAttributes", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateAttributes_(void* arg0, int arg1);

        /// <summary>	
        /// <p> </p><p>Initializes the contents of an attribute store from a byte array.</p>	
        /// </summary>	
        /// <param name="attributesRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the attribute store.</p> </dd></param>	
        /// <param name="bufRef"><dd> <p>Pointer to the array that contains the initialization data.</p> </dd></param>	
        /// <param name="cbBufSize"><dd> <p>Size of the <em>pBuf</em> array, in bytes.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The buffer is not valid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Use this function to deserialize an attribute store that was serialized with the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.GetAttributesAsBlob"/></strong> function.</p><p>This function deletes any attributes that were previously stored in <em>pAttributes</em>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFInitAttributesFromBlob']/*"/>	
        /// <msdn-id>ms703978</msdn-id>	
        /// <unmanaged>HRESULT MFInitAttributesFromBlob([In] IMFAttributes* pAttributes,[In, Buffer] const unsigned char* pBuf,[In] unsigned int cbBufSize)</unmanaged>	
        /// <unmanaged-short>MFInitAttributesFromBlob</unmanaged-short>	
        public static void InitAttributesFromBlob(SharpDX.MediaFoundation.MediaAttributes attributesRef, byte[] bufRef, int cbBufSize)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* bufRef_ = bufRef)
                    __result__ =
                    MFInitAttributesFromBlob_((void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), bufRef_, cbBufSize);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFInitAttributesFromBlob", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFInitAttributesFromBlob_(void* arg0, void* arg1, int arg2);

        /// <summary>	
        /// <p> </p><p>Retrieves the size of the buffer needed for the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.GetAttributesAsBlob"/></strong> function.</p>	
        /// </summary>	
        /// <param name="attributesRef">No documentation.</param>	
        /// <param name="cbBufSizeRef">No documentation.</param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Use this function to find the size of the array that is needed for the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.GetAttributesAsBlob"/></strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetAttributesAsBlobSize']/*"/>	
        /// <msdn-id>ms697064</msdn-id>	
        /// <unmanaged>HRESULT MFGetAttributesAsBlobSize([In] IMFAttributes* pAttributes,[Out] unsigned int* pcbBufSize)</unmanaged>	
        /// <unmanaged-short>MFGetAttributesAsBlobSize</unmanaged-short>	
        public static void GetAttributesAsBlobSize(SharpDX.MediaFoundation.MediaAttributes attributesRef, out int cbBufSizeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cbBufSizeRef_ = &cbBufSizeRef)
                    __result__ =
                    MFGetAttributesAsBlobSize_((void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), cbBufSizeRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFGetAttributesAsBlobSize", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetAttributesAsBlobSize_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> </p><p>Converts the contents of an attribute store to a byte array.</p>	
        /// </summary>	
        /// <param name="attributesRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the attribute store.</p> </dd></param>	
        /// <param name="bufRef"><dd> <p>Pointer to an array that receives the attribute data.</p> </dd></param>	
        /// <param name="cbBufSize"><dd> <p>Size of the <em>pBuf</em> array, in bytes. To get the required size of the buffer, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.GetAttributesAsBlobSize"/></strong>.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.BufferTooSmall"/></strong></dt> </dl> </td><td> <p>The buffer given in <em>pBuf</em> is too small.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The function skips any attributes with <strong><see cref="SharpDX.ComObject"/></strong> reference values (<see cref="SharpDX.MediaFoundation.AttributeType.IUnknown"/>); they are not stored in the array.</p><p>To convert the byte array back into an attribute store, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.InitAttributesFromBlob"/></strong>.</p><p>To write an attribute store to a stream, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.SerializeAttributesToStream"/></strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetAttributesAsBlob']/*"/>	
        /// <msdn-id>ms694877</msdn-id>	
        /// <unmanaged>HRESULT MFGetAttributesAsBlob([In] IMFAttributes* pAttributes,[Out, Buffer] unsigned char* pBuf,[In] unsigned int cbBufSize)</unmanaged>	
        /// <unmanaged-short>MFGetAttributesAsBlob</unmanaged-short>	
        public static void GetAttributesAsBlob(SharpDX.MediaFoundation.MediaAttributes attributesRef, byte[] bufRef, int cbBufSize)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* bufRef_ = bufRef)
                    __result__ =
                    MFGetAttributesAsBlob_((void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), bufRef_, cbBufSize);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFGetAttributesAsBlob", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetAttributesAsBlob_(void* arg0, void* arg1, int arg2);

        /// <summary>	
        /// <p> Adds information about a Media Foundation transform (MFT) to the registry. </p><p>Applications can enumerate the MFT by calling the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnum"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnumEx"/></strong> function.</p>	
        /// </summary>	
        /// <param name="clsidMFT">No documentation.</param>	
        /// <param name="guidCategory">No documentation.</param>	
        /// <param name="szNameRef">No documentation.</param>	
        /// <param name="flags">No documentation.</param>	
        /// <param name="cInputTypes">No documentation.</param>	
        /// <param name="inputTypesRef">No documentation.</param>	
        /// <param name="cOutputTypes">No documentation.</param>	
        /// <param name="outputTypesRef">No documentation.</param>	
        /// <param name="attributesRef">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The registry entries created by this function are read by the following functions: </p><table> <tr><th>Function</th><th>Description</th></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnum"/></strong> </td><td>Enumerates MFTs by media type and category.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnumEx"/></strong> </td><td>Extended version of <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnum"/></strong>.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TGetInfo"/></strong> </td><td>Looks up an MFT by CLSID and retrieves the registry information.</td></tr> </table><p>?</p><p>This function does not register the CLSID of the MFT for the <strong>CoCreateInstance</strong> or <strong>CoGetClassObject</strong> functions. </p><p> To remove the entries from the registry, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TUnregister"/></strong>. If you remove an MFT from the system, you should always call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TUnregister"/></strong>.</p><p> The formats given in the <em>pInputTypes</em> and <em>pOutputTypes</em> parameters are intended to help applications search for MFTs by format. Applications can use the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnum"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnumEx"/></strong> functions to enumerate MFTs that match a particular set of formats.</p><p>It is recommended  to specify at least one input type in <em>pInputTypes</em> and one output type in the <em>pOutputTypes</em> parameter. Otherwise, the MFT might be skipped in the enumeration.</p><p>On 64-bit Windows, the 32-bit version of this function registers the MFT in the 32-bit node of the registry. For more information, see 32-bit and 64-bit Application Data in the Registry.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFTRegister']/*"/>	
        /// <msdn-id>ms705640</msdn-id>	
        /// <unmanaged>HRESULT MFTRegister([In] GUID clsidMFT,[In] GUID guidCategory,[In] wchar_t* pszName,[In] unsigned int Flags,[In] unsigned int cInputTypes,[In, Buffer, Optional] MFT_REGISTER_TYPE_INFO* pInputTypes,[In] unsigned int cOutputTypes,[In, Buffer, Optional] MFT_REGISTER_TYPE_INFO* pOutputTypes,[In, Optional] IMFAttributes* pAttributes)</unmanaged>	
        /// <unmanaged-short>MFTRegister</unmanaged-short>	
        public static void TRegister(System.Guid clsidMFT, System.Guid guidCategory, string szNameRef, int flags, int cInputTypes, SharpDX.MediaFoundation.TRegisterTypeInformation[] inputTypesRef, int cOutputTypes, SharpDX.MediaFoundation.TRegisterTypeInformation[] outputTypesRef, SharpDX.MediaFoundation.MediaAttributes attributesRef)
        {
            unsafe
            {
                SharpDX.MediaFoundation.TRegisterTypeInformation[] inputTypesRef__ = inputTypesRef;
                SharpDX.MediaFoundation.TRegisterTypeInformation[] outputTypesRef__ = outputTypesRef;
                SharpDX.Result __result__;
                fixed (char* szNameRef_ = szNameRef)
                fixed (void* inputTypesRef_ = inputTypesRef__)
                fixed (void* outputTypesRef_ = outputTypesRef__)
                    __result__ =
                    MFTRegister_(clsidMFT, guidCategory, (void*)szNameRef_, flags, cInputTypes, inputTypesRef_, cOutputTypes, outputTypesRef_, (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer));
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFTRegister", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFTRegister_(System.Guid arg0, System.Guid arg1, void* arg2, int arg3, int arg4, void* arg5, int arg6, void* arg7, void* arg8);

        /// <summary>	
        /// <p> Unregisters a Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="clsidMFT"><dd> <p> The CLSID of the MFT. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This function removes the registry entries created by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegister"/></strong> function.</p><p>It is safe to call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TUnregister"/></strong> twice with the same CLSID. If the CLSID is not found in the registry, the function succeeds and does nothing.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFTUnregister']/*"/>	
        /// <msdn-id>ms696199</msdn-id>	
        /// <unmanaged>HRESULT MFTUnregister([In] GUID clsidMFT)</unmanaged>	
        /// <unmanaged-short>MFTUnregister</unmanaged-short>	
        public static void TUnregister(System.Guid clsidMFT)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFTUnregister_(clsidMFT);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFTUnregister", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFTUnregister_(System.Guid arg0);

        /// <summary>	
        /// <p>Registers a Media Foundation transform (MFT) in the caller's process.</p>	
        /// </summary>	
        /// <param name="classFactoryRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a class factory object. The class factory creates the MFT.</p> </dd></param>	
        /// <param name="guidCategory"><dd> <p>A <see cref="System.Guid"/> that specifies the category of the MFT. For a list of MFT categories, see <strong>MFT_CATEGORY</strong>.</p> </dd></param>	
        /// <param name="szNameRef"><dd> <p>A wide-character null-terminated string that contains the friendly name of the MFT.</p> </dd></param>	
        /// <param name="flags"><dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the <strong>_MFT_ENUM_FLAG</strong> enumeration.</p> </dd></param>	
        /// <param name="cInputTypes"><dd> <p>The number of elements in the <em>pInputTypes</em> array.</p> </dd></param>	
        /// <param name="inputTypesRef"><dd> <p>A reference to an array of <strong><see cref="SharpDX.MediaFoundation.TRegisterTypeInformation"/></strong> structures. Each member of the array specifies an input format that the MFT supports. This parameter can be <strong><c>null</c></strong> if <em>cInputTypes</em> is zero.</p> </dd></param>	
        /// <param name="cOutputTypes"><dd> <p>The number of elements in the <em>pOutputTypes</em> array.</p> </dd></param>	
        /// <param name="outputTypesRef"><dd> <p>A reference to an array of <strong><see cref="SharpDX.MediaFoundation.TRegisterTypeInformation"/></strong> structures. Each member of the array defines an output format that the MFT supports. This parameter can be <strong><c>null</c></strong> if <em>cOutputTypes</em> is zero.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The primary purpose of this function is to make an MFT available for automatic topology resolution without making the MFT available to other processes or applications.</p><p>After you call this function, the MFT can be enumerated by calling the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnumEx"/></strong> function with the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Localmft"/></strong> flag. The MFT can be enumerated from within the same process, but is not visible to other processes.</p><p>The <em>pClassFactory</em> parameter specifies a class factory object that creates the MFT. The class factory's <strong>IClassFactory::CreateInstance</strong> method must return an object that supports the <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> interface.</p><strong>Note</strong>??The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnumEx"/></strong> function retrieves a list of <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> references. However, the class factory does not need to support the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface. Instead, the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnumEx"/></strong> function provides an implementation of <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> that wraps the class factory.?<p>To unregister the MFT from the current process, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TUnregisterLocal"/></strong>.</p><p>If you need to register an MFT in the Protected Media Path (PMP) process, use the <strong><see cref="SharpDX.MediaFoundation.LocalMFTRegistration"/></strong> interface.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFTRegisterLocal']/*"/>	
        /// <msdn-id>dd388656</msdn-id>	
        /// <unmanaged>HRESULT MFTRegisterLocal([In] IClassFactory* pClassFactory,[In] const GUID&amp; guidCategory,[In] const wchar_t* pszName,[In] unsigned int Flags,[In] unsigned int cInputTypes,[In, Buffer, Optional] const MFT_REGISTER_TYPE_INFO* pInputTypes,[In] unsigned int cOutputTypes,[In, Buffer, Optional] const MFT_REGISTER_TYPE_INFO* pOutputTypes)</unmanaged>	
        /// <unmanaged-short>MFTRegisterLocal</unmanaged-short>	
        public static void TRegisterLocal(SharpDX.ComObject classFactoryRef, System.Guid guidCategory, string szNameRef, int flags, int cInputTypes, SharpDX.MediaFoundation.TRegisterTypeInformation[] inputTypesRef, int cOutputTypes, SharpDX.MediaFoundation.TRegisterTypeInformation[] outputTypesRef)
        {
            unsafe
            {
                SharpDX.MediaFoundation.TRegisterTypeInformation[] inputTypesRef__ = inputTypesRef;
                SharpDX.MediaFoundation.TRegisterTypeInformation[] outputTypesRef__ = outputTypesRef;
                SharpDX.Result __result__;
                fixed (char* szNameRef_ = szNameRef)
                fixed (void* inputTypesRef_ = inputTypesRef__)
                fixed (void* outputTypesRef_ = outputTypesRef__)
                    __result__ =
                    MFTRegisterLocal_((void*)((classFactoryRef == null) ? IntPtr.Zero : classFactoryRef.NativePointer), &guidCategory, (void*)szNameRef_, flags, cInputTypes, inputTypesRef_, cOutputTypes, outputTypesRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFTRegisterLocal", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFTRegisterLocal_(void* arg0, void* arg1, void* arg2, int arg3, int arg4, void* arg5, int arg6, void* arg7);

        /// <summary>	
        /// <p>Unregisters one or more Media Foundation transforms (MFTs) from the caller's process.</p>	
        /// </summary>	
        /// <param name="classFactoryRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a class factory object. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>HRESULT_FROM_WIN32(<strong><see cref="SharpDX.Win32.ErrorCode.NotFound"/></strong>)</strong></dt> </dl> </td><td> <p>The MFT specified by the <em>pClassFactory</em> parameter was not registered in this process.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Use this function to unregister a local MFT that was previously registered through the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegisterLocal"/></strong> function.</p><p>If the <em>pClassFactory</em> parameter is <strong><c>null</c></strong>, all local MFTs in the process are unregistered. Otherwise, the function unregisters the MFT associated with the class factory specified by the <em>pClassFactory</em> parameter. In that case, the <em>pClassFactory</em> parameter should equal a reference value that was previously passed to  the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegisterLocal"/></strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFTUnregisterLocal']/*"/>	
        /// <msdn-id>dd388658</msdn-id>	
        /// <unmanaged>HRESULT MFTUnregisterLocal([In, Optional] IClassFactory* pClassFactory)</unmanaged>	
        /// <unmanaged-short>MFTUnregisterLocal</unmanaged-short>	
        public static void TUnregisterLocal(SharpDX.ComObject classFactoryRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFTUnregisterLocal_((void*)((classFactoryRef == null) ? IntPtr.Zero : classFactoryRef.NativePointer));
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFTUnregisterLocal", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFTUnregisterLocal_(void* arg0);

        /// <summary>	
        /// <p>Registers a Media Foundation transform (MFT) in the caller's process.</p>	
        /// </summary>	
        /// <param name="clisdMFT"><dd> <p>The class identifier (CLSID) of the MFT.</p> </dd></param>	
        /// <param name="guidCategory"><dd> <p>A <see cref="System.Guid"/> that specifies the category of the MFT. For a list of MFT categories, see <strong>MFT_CATEGORY</strong>.</p> </dd></param>	
        /// <param name="szNameRef"><dd> <p>A wide-character null-terminated string that contains the friendly name of the MFT.</p> </dd></param>	
        /// <param name="flags"><dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the <strong>_MFT_ENUM_FLAG</strong> enumeration.</p> </dd></param>	
        /// <param name="cInputTypes"><dd> <p>The number of elements in the <em>pInputTypes</em> array.</p> </dd></param>	
        /// <param name="inputTypesRef"><dd> <p>A reference to an array of <strong><see cref="SharpDX.MediaFoundation.TRegisterTypeInformation"/></strong> structures. Each member of the array specifies an input format that the MFT supports. This parameter can be <strong><c>null</c></strong> if <em>cInputTypes</em> is zero.</p> </dd></param>	
        /// <param name="cOutputTypes"><dd> <p>The number of elements in the <em>pOutputTypes</em> array.</p> </dd></param>	
        /// <param name="outputTypesRef"><dd> <p>A reference to an array of <strong><see cref="SharpDX.MediaFoundation.TRegisterTypeInformation"/></strong> structures. Each member of the array defines an output format that the MFT supports. This parameter can be <strong><c>null</c></strong> if <em>cOutputTypes</em> is zero.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The primary purpose of this function is to make an MFT available for automatic topology resolution without making the MFT available to other processes or applications.</p><p>After you call this function, the MFT can be enumerated by calling the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnumEx"/></strong> function with the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Localmft"/></strong> flag. The MFT can be enumerated from within the same process, but is not visible to other processes.</p><p>To unregister the MFT from the current process, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TUnregisterLocalByCLSID"/></strong>.</p><p>If you need to register an MFT in the Protected Media Path (PMP) process, use the <strong><see cref="SharpDX.MediaFoundation.LocalMFTRegistration"/></strong> interface.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFTRegisterLocalByCLSID']/*"/>	
        /// <msdn-id>dd388657</msdn-id>	
        /// <unmanaged>HRESULT MFTRegisterLocalByCLSID([In] const GUID&amp; clisdMFT,[In] const GUID&amp; guidCategory,[In] const wchar_t* pszName,[In] unsigned int Flags,[In] unsigned int cInputTypes,[In, Buffer, Optional] const MFT_REGISTER_TYPE_INFO* pInputTypes,[In] unsigned int cOutputTypes,[In, Buffer, Optional] const MFT_REGISTER_TYPE_INFO* pOutputTypes)</unmanaged>	
        /// <unmanaged-short>MFTRegisterLocalByCLSID</unmanaged-short>	
        public static void TRegisterLocalByCLSID(System.Guid clisdMFT, System.Guid guidCategory, string szNameRef, int flags, int cInputTypes, SharpDX.MediaFoundation.TRegisterTypeInformation[] inputTypesRef, int cOutputTypes, SharpDX.MediaFoundation.TRegisterTypeInformation[] outputTypesRef)
        {
            unsafe
            {
                SharpDX.MediaFoundation.TRegisterTypeInformation[] inputTypesRef__ = inputTypesRef;
                SharpDX.MediaFoundation.TRegisterTypeInformation[] outputTypesRef__ = outputTypesRef;
                SharpDX.Result __result__;
                fixed (char* szNameRef_ = szNameRef)
                fixed (void* inputTypesRef_ = inputTypesRef__)
                fixed (void* outputTypesRef_ = outputTypesRef__)
                    __result__ =
                    MFTRegisterLocalByCLSID_(&clisdMFT, &guidCategory, (void*)szNameRef_, flags, cInputTypes, inputTypesRef_, cOutputTypes, outputTypesRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFTRegisterLocalByCLSID", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFTRegisterLocalByCLSID_(void* arg0, void* arg1, void* arg2, int arg3, int arg4, void* arg5, int arg6, void* arg7);

        /// <summary>	
        /// <p>Unregisters a Media Foundation transform (MFT) from the caller's process.</p>	
        /// </summary>	
        /// <param name="clsidMFT"><dd> <p>The class identifier (CLSID) of the MFT.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>HRESULT_FROM_WIN32(<strong><see cref="SharpDX.Win32.ErrorCode.NotFound"/></strong>)</strong></dt> </dl> </td><td> <p>The MFT specified by the <em>clsidMFT</em> parameter was not registered in this process.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Use this function to unregister a local MFT that was previously registered through the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegisterLocalByCLSID"/></strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFTUnregisterLocalByCLSID']/*"/>	
        /// <msdn-id>dd388659</msdn-id>	
        /// <unmanaged>HRESULT MFTUnregisterLocalByCLSID([In] GUID clsidMFT)</unmanaged>	
        /// <unmanaged-short>MFTUnregisterLocalByCLSID</unmanaged-short>	
        public static void TUnregisterLocalByCLSID(System.Guid clsidMFT)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFTUnregisterLocalByCLSID_(clsidMFT);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFTUnregisterLocalByCLSID", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFTUnregisterLocalByCLSID_(System.Guid arg0);

        /// <summary>	
        /// <p> Enumerates Media Foundation transforms (MFTs) in the registry. </p><p>Starting in Windows?7, applications should use the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnumEx"/></strong> function instead.</p>	
        /// </summary>	
        /// <param name="guidCategory">No documentation.</param>	
        /// <param name="flags">No documentation.</param>	
        /// <param name="inputTypeRef">No documentation.</param>	
        /// <param name="outputTypeRef">No documentation.</param>	
        /// <param name="attributesRef">No documentation.</param>	
        /// <param name="clsidMFTOut">No documentation.</param>	
        /// <param name="cMFTsRef">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This function returns a list of all the MFTs in the specified category that match the search criteria given by the <em>pInputType</em>, <em>pOutputType</em>, and <em>pAttributes</em> parameters. Any of those parameters can be <strong><c>null</c></strong>. </p><p> If no MFTs match the criteria, the method succeeds but returns the value zero in <em>pcMFTs</em>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFTEnum']/*"/>	
        /// <msdn-id>ms701774</msdn-id>	
        /// <unmanaged>HRESULT MFTEnum([In] GUID guidCategory,[In] unsigned int Flags,[In, Optional] MFT_REGISTER_TYPE_INFO* pInputType,[In, Optional] MFT_REGISTER_TYPE_INFO* pOutputType,[In, Optional] IMFAttributes* pAttributes,[Out, Buffer] GUID** ppclsidMFT,[Out] unsigned int* pcMFTs)</unmanaged>	
        /// <unmanaged-short>MFTEnum</unmanaged-short>	
        public static void TEnum(System.Guid guidCategory, int flags, SharpDX.MediaFoundation.TRegisterTypeInformation? inputTypeRef, SharpDX.MediaFoundation.TRegisterTypeInformation? outputTypeRef, SharpDX.MediaFoundation.MediaAttributes attributesRef, System.Guid[] clsidMFTOut, out int cMFTsRef)
        {
            unsafe
            {
                SharpDX.MediaFoundation.TRegisterTypeInformation inputTypeRef_;
                if (inputTypeRef.HasValue)
                    inputTypeRef_ = inputTypeRef.Value;
                SharpDX.MediaFoundation.TRegisterTypeInformation outputTypeRef_;
                if (outputTypeRef.HasValue)
                    outputTypeRef_ = outputTypeRef.Value;
                SharpDX.Result __result__;
                fixed (void* clsidMFTOut_ = clsidMFTOut)
                fixed (void* cMFTsRef_ = &cMFTsRef)
                    __result__ =
                    MFTEnum_(guidCategory, flags, (inputTypeRef.HasValue) ? &inputTypeRef_ : (void*)IntPtr.Zero, (outputTypeRef.HasValue) ? &outputTypeRef_ : (void*)IntPtr.Zero, (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), clsidMFTOut_, cMFTsRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFTEnum", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFTEnum_(System.Guid arg0, int arg1, void* arg2, void* arg3, void* arg4, void* arg5, void* arg6);

        /// <summary>	
        /// <p>Gets a list of Microsoft Media Foundation transforms (MFTs) that match specified search criteria. This function extends the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnum"/></strong> function.</p>	
        /// </summary>	
        /// <param name="guidCategory">No documentation.</param>	
        /// <param name="flags">No documentation.</param>	
        /// <param name="inputTypeRef">No documentation.</param>	
        /// <param name="outputTypeRef">No documentation.</param>	
        /// <param name="pMFTActivateOut">No documentation.</param>	
        /// <param name="numMFTActivateRef">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The <em>Flags</em> parameter controls which MFTs are enumerated, and the order in which they are returned. The flags for this parameter fall into several groups.</p><p> </p><p>The first set of flags specifies how an MFT processes data.</p><table> <tr><th>Flag</th><th>Description</th></tr> <tr><td> <p><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Syncmft"/></p> </td><td> <p>The MFT performs synchronous data processing in software. This is the original MFT processing model, and is  compatible with Windows?Vista.</p> </td></tr> <tr><td> <p><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Asyncmft"/></p> </td><td> <p>The MFT performs asynchronous data processing in software. This processing model requires Windows?7. For more information, see Asynchronous MFTs.</p> </td></tr> <tr><td> <p><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Hardware"/></p> </td><td> <p>The MFT performs hardware-based data processing, using either the AVStream driver or a GPU-based proxy MFT. MFTs in this category always process data asynchronously. For more information, see Hardware MFTs.</p> </td></tr> </table><p>?</p><p>Every MFT falls into exactly one of these categories.  To enumerate a category, set the corresponding flag in the <em>Flags</em> parameter. You can combine these flags to enumerate more than one category. If none of these flags is specified, the default category is synchronous MFTs (<strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Syncmft"/></strong>).</p><p> </p><p> </p><p>Next, the following flags include MFTs that are otherwise  excluded from the results. By default, flags that match these criteria are excluded from the results. Use any these flags to include them.</p><table> <tr><th>Flag</th><th>Description</th></tr> <tr><td> <p><strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Fieldofuse"/></strong></p> </td><td> <p>Include MFTs that must be unlocked by the application.</p> </td></tr> <tr><td> <p><strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Localmft"/></strong></p> </td><td> <p>Include MFTs that are registered in the caller's process through either the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegisterLocal"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegisterLocalByCLSID"/></strong> function.</p> </td></tr> <tr><td> <p><strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.TranscodeOnly"/></strong></p> </td><td> <p>Include MFTs that are optimized for transcoding rather than playback.</p> </td></tr> </table><p>?</p><p> </p><p> </p><p>The last flag is used to sort and filter the results:</p><table> <tr><th>Flag</th><th>Description</th></tr> <tr><td> <p><strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.SortAndFilter"/></strong></p> </td><td> <p>Sort and filter the results.</p> </td></tr> </table><p>?</p><p>If the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.SortAndFilter"/></strong> flag is set, the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnumEx"/></strong> function sorts the results as follows:</p><ul> <li>Local: If the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Localmft"/></strong> flag is set, local MFTs appear first in the list. To register a local MFT, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegisterLocal"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegisterLocalByCLSID"/></strong> function.</li> <li>Merit: MFTs with a merit value appear next on the list, in order of merit value (highest to lowest). For more information about merit, see <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.MftCodecMeritAttribute"/>. </li> <li>Preferred: If an MFT is listed in the plug-in control's preferred list, it appears next in the list. For more information about the plug-in control, see <strong><see cref="SharpDX.MediaFoundation.PluginControl"/></strong>.</li> <li>If an MFT appears on the blocked list, it is excluded from the results. For more information about the blocked list, see <strong><see cref="SharpDX.MediaFoundation.PluginControl.IsDisabled"/></strong>.</li> <li>Any other MFTs that match the search criteria appear at the end of the list, unsorted.</li> </ul><p>If you do not set the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.SortAndFilter"/></strong> flag, the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnumEx"/></strong> function returns an unsorted list.</p><p>Setting the <em>Flags</em> parameter to zero is equivalent to using the value <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Syncmft"/></strong> | <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Localmft"/></strong> | <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.SortAndFilter"/></strong>.</p><p>Setting <em>Flags</em> to <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Syncmft"/></strong> is equivalent to calling the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnum"/></strong> function.</p><p>If no MFTs match the search criteria, the function returns <strong><see cref="SharpDX.Result.Ok"/></strong>, unless some other error occurs. Therefore, always check the count received in the <em>pcMFTActivate</em> parameter before you dereference the <em>pppMFTActivate</em> reference.</p><strong>Note</strong>??There is no way to enumerate just local MFTs and nothing else. Setting <em>Flags</em> equal to <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Localmft"/></strong> is equivalent to  including the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Syncmft"/></strong> flag. However, if you also sort the results by specifying the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.SortAndFilter"/></strong> flag, local MFTs appear first in the list.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFTEnumEx']/*"/>	
        /// <msdn-id>dd388652</msdn-id>	
        /// <unmanaged>HRESULT MFTEnumEx([In] GUID guidCategory,[In] unsigned int Flags,[In, Optional] const MFT_REGISTER_TYPE_INFO* pInputType,[In, Optional] const MFT_REGISTER_TYPE_INFO* pOutputType,[Out] void*** pppMFTActivate,[Out] unsigned int* pnumMFTActivate)</unmanaged>	
        /// <unmanaged-short>MFTEnumEx</unmanaged-short>	
        internal static void TEnumEx(System.Guid guidCategory, int flags, SharpDX.MediaFoundation.TRegisterTypeInformation? inputTypeRef, SharpDX.MediaFoundation.TRegisterTypeInformation? outputTypeRef, out System.IntPtr pMFTActivateOut, out int numMFTActivateRef)
        {
            unsafe
            {
                SharpDX.MediaFoundation.TRegisterTypeInformation inputTypeRef_;
                if (inputTypeRef.HasValue)
                    inputTypeRef_ = inputTypeRef.Value;
                SharpDX.MediaFoundation.TRegisterTypeInformation outputTypeRef_;
                if (outputTypeRef.HasValue)
                    outputTypeRef_ = outputTypeRef.Value;
                SharpDX.Result __result__;
                fixed (void* pMFTActivateOut_ = &pMFTActivateOut)
                fixed (void* numMFTActivateRef_ = &numMFTActivateRef)
                    __result__ =
                    MFTEnumEx_(guidCategory, flags, (inputTypeRef.HasValue) ? &inputTypeRef_ : (void*)IntPtr.Zero, (outputTypeRef.HasValue) ? &outputTypeRef_ : (void*)IntPtr.Zero, pMFTActivateOut_, numMFTActivateRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFTEnumEx", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFTEnumEx_(System.Guid arg0, int arg1, void* arg2, void* arg3, void* arg4, void* arg5);

        /// <summary>	
        /// <p> Gets a list of Microsoft Media Foundation transforms (MFTs) that match specified search criteria. This function extends the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnumEx"/></strong> function to allow external applications and internal components to discover the hardware MFTs that correspond to a specific video adapter.  </p>	
        /// </summary>	
        /// <param name="guidCategory">No documentation.</param>	
        /// <param name="flags">No documentation.</param>	
        /// <param name="inputTypeRef">No documentation.</param>	
        /// <param name="outputTypeRef">No documentation.</param>	
        /// <param name="attributesRef">No documentation.</param>	
        /// <param name="pMFTActivateOut">No documentation.</param>	
        /// <param name="numMFTActivateRef">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The <em>Flags</em> parameter controls which MFTs are enumerated, and the order in which they are returned. The flags for this parameter fall into several groups.</p><p> </p><p>The first set of flags specifies how an MFT processes data.</p><table> <tr><th>Flag</th><th>Description</th></tr> <tr><td> <p><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Syncmft"/></p> </td><td> <p>The MFT performs synchronous data processing in software. This is the original MFT processing model, and is  compatible with Windows?Vista.</p> </td></tr> <tr><td> <p><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Asyncmft"/></p> </td><td> <p>The MFT performs asynchronous data processing in software. This processing model requires Windows?7. For more information, see Asynchronous MFTs.</p> </td></tr> <tr><td> <p><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Hardware"/></p> </td><td> <p>The MFT performs hardware-based data processing, using either the AVStream driver or a GPU-based proxy MFT. MFTs in this category always process data asynchronously. For more information, see Hardware MFTs.</p> </td></tr> </table><p>?</p><p>Every MFT falls into exactly one of these categories.  To enumerate a category, set the corresponding flag in the <em>Flags</em> parameter. You can combine these flags to enumerate more than one category. If none of these flags is specified, the default category is synchronous MFTs (<strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Syncmft"/></strong>).</p><p> </p><p> </p><p>Next, the following flags include MFTs that are otherwise  excluded from the results. By default, flags that match these criteria are excluded from the results. Use any these flags to include them.</p><table> <tr><th>Flag</th><th>Description</th></tr> <tr><td> <p><strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Fieldofuse"/></strong></p> </td><td> <p>Include MFTs that must be unlocked by the application.</p> </td></tr> <tr><td> <p><strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Localmft"/></strong></p> </td><td> <p>Include MFTs that are registered in the caller's process through either the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegisterLocal"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegisterLocalByCLSID"/></strong> function.</p> </td></tr> <tr><td> <p><strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.TranscodeOnly"/></strong></p> </td><td> <p>Include MFTs that are optimized for transcoding rather than playback.</p> </td></tr> </table><p>?</p><p> </p><p> </p><p>The last flag is used to sort and filter the results:</p><table> <tr><th>Flag</th><th>Description</th></tr> <tr><td> <p><strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.SortAndFilter"/></strong></p> </td><td> <p>Sort and filter the results.</p> </td></tr> </table><p>?</p><p>If the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.SortAndFilter"/></strong> flag is set, the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnum2"/></strong> function sorts the results as follows:</p><ul> <li>Local: If the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Localmft"/></strong> flag is set, local MFTs appear first in the list. To register a local MFT, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegisterLocal"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegisterLocalByCLSID"/></strong> function.</li> <li>Merit: MFTs with a merit value appear next on the list, in order of merit value (highest to lowest). For more information about merit, see <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.MftCodecMeritAttribute"/>. </li> <li>Preferred: If an MFT is listed in the plug-in control's preferred list, it appears next in the list. For more information about the plug-in control, see <strong><see cref="SharpDX.MediaFoundation.PluginControl"/></strong>.</li> <li>If an MFT appears on the blocked list, it is excluded from the results. For more information about the blocked list, see <strong><see cref="SharpDX.MediaFoundation.PluginControl.IsDisabled"/></strong>.</li> <li>Any other MFTs that match the search criteria appear at the end of the list, unsorted.</li> </ul><p>If you do not set the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.SortAndFilter"/></strong> flag, the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnum2"/></strong> function returns an unsorted list.</p><p>Setting the <em>Flags</em> parameter to zero is equivalent to using the value <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Syncmft"/></strong> | <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Localmft"/></strong> | <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.SortAndFilter"/></strong>.</p><p>Setting <em>Flags</em> to <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Syncmft"/></strong> is equivalent to calling the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnum"/></strong> function.</p><p>If no MFTs match the search criteria, the function returns <strong><see cref="SharpDX.Result.Ok"/></strong>, unless some other error occurs. Therefore, always check the count received in the <em>pcMFTActivate</em> parameter before you dereference the <em>pppMFTActivate</em> reference.</p><strong>Note</strong>??There is no way to enumerate just local MFTs and nothing else. Setting <em>Flags</em> equal to <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Localmft"/></strong> is equivalent to  including the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Syncmft"/></strong> flag. However, if you also sort the results by specifying the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.SortAndFilter"/></strong> flag, local MFTs appear first in the list.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFTEnum2']/*"/>	
        /// <msdn-id>mt739436</msdn-id>	
        /// <unmanaged>HRESULT MFTEnum2([In] GUID guidCategory,[In] unsigned int Flags,[In, Optional] const MFT_REGISTER_TYPE_INFO* pInputType,[In, Optional] const MFT_REGISTER_TYPE_INFO* pOutputType,[In, Optional] IMFAttributes* pAttributes,[Out, Buffer] IMFActivate*** pppMFTActivate,[Out] unsigned int* pnumMFTActivate)</unmanaged>	
        /// <unmanaged-short>MFTEnum2</unmanaged-short>	
        public static void TEnum2(System.Guid guidCategory, int flags, SharpDX.MediaFoundation.TRegisterTypeInformation? inputTypeRef, SharpDX.MediaFoundation.TRegisterTypeInformation? outputTypeRef, SharpDX.MediaFoundation.MediaAttributes attributesRef, SharpDX.MediaFoundation.Activate[] pMFTActivateOut, out int numMFTActivateRef)
        {
            unsafe
            {
                SharpDX.MediaFoundation.TRegisterTypeInformation inputTypeRef_;
                if (inputTypeRef.HasValue)
                    inputTypeRef_ = inputTypeRef.Value;
                SharpDX.MediaFoundation.TRegisterTypeInformation outputTypeRef_;
                if (outputTypeRef.HasValue)
                    outputTypeRef_ = outputTypeRef.Value;
                IntPtr* pMFTActivateOut_ = stackalloc IntPtr[pMFTActivateOut.Length];
                SharpDX.Result __result__;
                fixed (void* numMFTActivateRef_ = &numMFTActivateRef)
                    __result__ =
                    MFTEnum2_(guidCategory, flags, (inputTypeRef.HasValue) ? &inputTypeRef_ : (void*)IntPtr.Zero, (outputTypeRef.HasValue) ? &outputTypeRef_ : (void*)IntPtr.Zero, (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), pMFTActivateOut_, numMFTActivateRef_);
                for (int i = 0; i < pMFTActivateOut.Length; i++)
                    pMFTActivateOut[i] = (pMFTActivateOut_[i] == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Activate(pMFTActivateOut_[i]);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFTEnum2", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFTEnum2_(System.Guid arg0, int arg1, void* arg2, void* arg3, void* arg4, void* arg5, void* arg6);

        /// <summary>	
        /// <p> Gets information from the registry about a Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="clsidMFT"><dd> <p> The CLSID of the MFT. </p> </dd></param>	
        /// <param name="szNameRef"><dd> <p> Receives a reference to a wide-character string containing the friendly name of the MFT. The caller must free the string by calling <strong>CoTaskMemFree</strong>. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="inputTypesOut"><dd> <p> Receives a reference to an array of <strong><see cref="SharpDX.MediaFoundation.TRegisterTypeInformation"/></strong> structures. Each member of the array describes an input format that the MFT supports. The caller must free the array by calling <strong>CoTaskMemFree</strong>. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="cInputTypesRef"><dd> <p> Receives the number of elements in the <em>ppInputTypes</em> array. If <em>ppInputTypes</em> is <strong><c>null</c></strong>, this parameter is ignored and can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="outputTypesOut"><dd> <p> Receives a reference to an array of <strong><see cref="SharpDX.MediaFoundation.TRegisterTypeInformation"/></strong> structures. Each member of the array describes an output format that the MFT supports. The caller must free the array by calling <strong>CoTaskMemFree</strong>. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="cOutputTypesRef"><dd> <p> Receives the number of elements in the <em>ppOutputType</em> array. If <em>ppOutputTypes</em> is <strong><c>null</c></strong>, this parameter is ignored and can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="attributesOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of an attribute store. The caller must release the interface. The attribute store might contain attributes that are stored in the registry for the specified MFT. (For more information, see <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegister"/></strong>.)  If no attributes are stored in the registry for this MFT, the attribute store is empty. </p> <p>This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFTGetInfo']/*"/>	
        /// <msdn-id>ms703830</msdn-id>	
        /// <unmanaged>HRESULT MFTGetInfo([In] GUID clsidMFT,[Out, Optional] wchar_t** pszName,[Out, Buffer, Optional] MFT_REGISTER_TYPE_INFO** ppInputTypes,[Out, Optional] unsigned int* pcInputTypes,[Out, Buffer, Optional] MFT_REGISTER_TYPE_INFO** ppOutputTypes,[Out, Optional] unsigned int* pcOutputTypes,[Out, Optional] IMFAttributes** ppAttributes)</unmanaged>	
        /// <unmanaged-short>MFTGetInfo</unmanaged-short>	
        public static void TGetInfo(System.Guid clsidMFT, System.IntPtr szNameRef, SharpDX.MediaFoundation.TRegisterTypeInformation[] inputTypesOut, out int cInputTypesRef, SharpDX.MediaFoundation.TRegisterTypeInformation[] outputTypesOut, out int cOutputTypesRef, out SharpDX.MediaFoundation.MediaAttributes attributesOut)
        {
            unsafe
            {
                SharpDX.MediaFoundation.TRegisterTypeInformation[] inputTypesOut__ = inputTypesOut;
                SharpDX.MediaFoundation.TRegisterTypeInformation[] outputTypesOut__ = outputTypesOut;
                IntPtr attributesOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* inputTypesOut_ = inputTypesOut__)
                fixed (void* cInputTypesRef_ = &cInputTypesRef)
                fixed (void* outputTypesOut_ = outputTypesOut__)
                fixed (void* cOutputTypesRef_ = &cOutputTypesRef)
                    __result__ =
                    MFTGetInfo_(clsidMFT, (void*)szNameRef, inputTypesOut_, cInputTypesRef_, outputTypesOut_, cOutputTypesRef_, &attributesOut_);
                attributesOut = (attributesOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(attributesOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFTGetInfo", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFTGetInfo_(System.Guid arg0, void* arg1, void* arg2, void* arg3, void* arg4, void* arg5, void* arg6);

        /// <summary>	
        /// <p>Gets a reference to the Microsoft Media Foundation plug-in manager.</p>	
        /// </summary>	
        /// <param name="pluginControlOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.PluginControl"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetPluginControl']/*"/>	
        /// <msdn-id>dd388507</msdn-id>	
        /// <unmanaged>HRESULT MFGetPluginControl([Out] IMFPluginControl** ppPluginControl)</unmanaged>	
        /// <unmanaged-short>MFGetPluginControl</unmanaged-short>	
        public static void GetPluginControl(out SharpDX.MediaFoundation.PluginControl pluginControlOut)
        {
            unsafe
            {
                IntPtr pluginControlOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFGetPluginControl_(&pluginControlOut_);
                pluginControlOut = (pluginControlOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PluginControl(pluginControlOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFGetPluginControl", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetPluginControl_(void* arg0);

        /// <summary>	
        /// <p>Gets the merit value of a hardware codec.</p>	
        /// </summary>	
        /// <param name="mFTRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of the Media Foundation transform (MFT) that represents the codec.</p> </dd></param>	
        /// <param name="cbVerifier"><dd> <p>The size, in bytes, of the <em>verifier</em> array.</p> </dd></param>	
        /// <param name="verifier"><dd> <p>The address of a buffer that contains one of the following:</p> <ul> <li>The class identifier (CLSID) of the MFT.</li> <li>A null-terminated wide-character string that contains the symbol link for the underlying hardware device. Include the size of the terminating null in the value of <em>cbVerifier</em>.</li> </ul> </dd></param>	
        /// <param name="merit"><dd> <p>Receives the merit value.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The function fails if the MFT does not represent a hardware device with a valid Output Protection Manager (OPM) certificate. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetMFTMerit']/*"/>	
        /// <msdn-id>dd388506</msdn-id>	
        /// <unmanaged>HRESULT MFGetMFTMerit([InOut] IUnknown* pMFT,[In] unsigned int cbVerifier,[In, Buffer] const unsigned char* verifier,[Out] unsigned int* merit)</unmanaged>	
        /// <unmanaged-short>MFGetMFTMerit</unmanaged-short>	
        public static void GetMFTMerit(SharpDX.ComObject mFTRef, int cbVerifier, byte[] verifier, out int merit)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* verifier_ = verifier)
                fixed (void* merit_ = &merit)
                    __result__ =
                    MFGetMFTMerit_((void*)((mFTRef == null) ? IntPtr.Zero : mFTRef.NativePointer), cbVerifier, verifier_, merit_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFGetMFTMerit", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetMFTMerit_(void* arg0, int arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p>Registers a scheme handler in the caller's process.</p>	
        /// </summary>	
        /// <param name="szScheme"><dd> <p>A string that contains the scheme. The scheme includes the trailing ':' character; for example,  "http:".</p> </dd></param>	
        /// <param name="activateRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface of an activation  object. The caller implements this interface. The  <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> method of the activation object must create a scheme handler object. The scheme handler exposes the  <strong><see cref="SharpDX.MediaFoundation.SchemeHandler"/></strong> interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Scheme handlers are used in Microsoft Media Foundation during the source resolution process, which creates a media  source from a URL. For more information, see  Scheme Handlers and Byte-Stream Handlers.</p><p>Within a process, local scheme handlers take precedence over scheme handlers that are registered in the  registry. Local scheme handlers are not visible to other processes.</p><p>Use this function if you want to register a custom scheme handler for your application, but do not want the  handler available to other applications.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFRegisterLocalSchemeHandler']/*"/>	
        /// <msdn-id>hh162787</msdn-id>	
        /// <unmanaged>HRESULT MFRegisterLocalSchemeHandler([In] const wchar_t* szScheme,[In] IMFActivate* pActivate)</unmanaged>	
        /// <unmanaged-short>MFRegisterLocalSchemeHandler</unmanaged-short>	
        public static void RegisterLocalSchemeHandler(string szScheme, SharpDX.MediaFoundation.Activate activateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* szScheme_ = szScheme)
                    __result__ =
                    MFRegisterLocalSchemeHandler_((void*)szScheme_, (void*)((activateRef == null) ? IntPtr.Zero : activateRef.NativePointer));
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFRegisterLocalSchemeHandler", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFRegisterLocalSchemeHandler_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Registers a byte-stream handler in the caller's process.</p>	
        /// </summary>	
        /// <param name="szFileExtension"><dd> <p>A string that contains the file name extension for this handler.</p> </dd></param>	
        /// <param name="szMimeType"><dd> <p>A string that contains the MIME type for this handler.</p> </dd></param>	
        /// <param name="activateRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface of an activation object. The caller implements this interface. The <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> method of the activation object must create a byte-stream handler. The byte-stream handler exposes the <strong><see cref="SharpDX.MediaFoundation.ByteStreamHandler"/></strong> interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Byte-stream handlers are used in Microsoft Media Foundation during the source resolution process, which creates a media source from a URL. For more information, see Scheme Handlers and Byte-Stream Handlers.</p><p>Within a process, local byte-stream handlers take precedence over byte-stream handlers that are registered in the registry. Local byte-stream handlers are not visible to other processes.</p><p>Use this function if you want to register a custom byte-stream handler for your application, but do not want the handler available to other applications.</p><p>Either <em>szFileExtension</em> or <em>szMimeType</em> can be <strong><c>null</c></strong>; at least one must be non-<strong><c>null</c></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFRegisterLocalByteStreamHandler']/*"/>	
        /// <msdn-id>hh162786</msdn-id>	
        /// <unmanaged>HRESULT MFRegisterLocalByteStreamHandler([In] const wchar_t* szFileExtension,[In] const wchar_t* szMimeType,[In] IMFActivate* pActivate)</unmanaged>	
        /// <unmanaged-short>MFRegisterLocalByteStreamHandler</unmanaged-short>	
        public static void RegisterLocalByteStreamHandler(string szFileExtension, string szMimeType, SharpDX.MediaFoundation.Activate activateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* szFileExtension_ = szFileExtension)
                fixed (char* szMimeType_ = szMimeType)
                    __result__ =
                    MFRegisterLocalByteStreamHandler_((void*)szFileExtension_, (void*)szMimeType_, (void*)((activateRef == null) ? IntPtr.Zero : activateRef.NativePointer));
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFRegisterLocalByteStreamHandler", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFRegisterLocalByteStreamHandler_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p>Creates a wrapper for a byte stream.</p>	
        /// </summary>	
        /// <param name="streamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of the original byte stream.</p> </dd></param>	
        /// <param name="streamWrapperOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of the wrapper. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> methods on the wrapper call directly through to the original byte stream, except for the <strong><see cref="SharpDX.MediaFoundation.IByteStream.Close"/></strong> method. Calling <strong>Close</strong> on the wrapper closes the wrapper object, but leaves the original byte stream open.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMFByteStreamWrapper']/*"/>	
        /// <msdn-id>hh162755</msdn-id>	
        /// <unmanaged>HRESULT MFCreateMFByteStreamWrapper([In] IMFByteStream* pStream,[Out] IMFByteStream** ppStreamWrapper)</unmanaged>	
        /// <unmanaged-short>MFCreateMFByteStreamWrapper</unmanaged-short>	
        public static void CreateMFByteStreamWrapper(System.IntPtr streamRef, out SharpDX.MediaFoundation.IByteStream streamWrapperOut)
        {
            unsafe
            {
                IntPtr streamWrapperOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMFByteStreamWrapper_((void*)streamRef, &streamWrapperOut_);
                streamWrapperOut = (streamWrapperOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ByteStream(streamWrapperOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateMFByteStreamWrapper", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMFByteStreamWrapper_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Creates an activation object for a Windows Runtime class.</p>	
        /// </summary>	
        /// <param name="szActivatableClassId"><dd> <p>The class identifier that is associated with the activatable runtime class.</p> </dd></param>	
        /// <param name="configurationRef"><dd> <p>A reference to an optional <strong>IPropertySet</strong> object, which is used to configure the Windows Runtime class. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="riid"><dd> <p>The interface identifier (IID) of the interface being requested. The activation object created  by this function supports the following interfaces:</p> <ul> <li> <strong><see cref="SharpDX.ComObject"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> </li> <li> <strong>IPersistStream</strong> </li> </ul> </dd></param>	
        /// <param name="vObjectOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To create the Windows Runtime object, call <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> or <strong>IClassFactory::CreateInstance</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMediaExtensionActivate']/*"/>	
        /// <msdn-id>hh162753</msdn-id>	
        /// <unmanaged>HRESULT MFCreateMediaExtensionActivate([In] const wchar_t* szActivatableClassId,[In, Optional] IUnknown* pConfiguration,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>	
        /// <unmanaged-short>MFCreateMediaExtensionActivate</unmanaged-short>	
        public static void CreateMediaExtensionActivate(string szActivatableClassId, SharpDX.ComObject configurationRef, System.Guid riid, out System.IntPtr vObjectOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* szActivatableClassId_ = szActivatableClassId)
                fixed (void* vObjectOut_ = &vObjectOut)
                    __result__ =
                    MFCreateMediaExtensionActivate_((void*)szActivatableClassId_, (void*)((configurationRef == null) ? IntPtr.Zero : configurationRef.NativePointer), &riid, vObjectOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateMediaExtensionActivate", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMediaExtensionActivate_(void* arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="attributesToMuxRef">No documentation.</param>	
        /// <param name="muxAttribsOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMuxStreamAttributes']/*"/>	
        /// <unmanaged>HRESULT MFCreateMuxStreamAttributes([In] IMFCollection* pAttributesToMux,[Out] IMFAttributes** ppMuxAttribs)</unmanaged>	
        /// <unmanaged-short>MFCreateMuxStreamAttributes</unmanaged-short>	
        public static void CreateMuxStreamAttributes(SharpDX.MediaFoundation.Collection attributesToMuxRef, out SharpDX.MediaFoundation.MediaAttributes muxAttribsOut)
        {
            unsafe
            {
                IntPtr muxAttribsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMuxStreamAttributes_((void*)((attributesToMuxRef == null) ? IntPtr.Zero : attributesToMuxRef.NativePointer), &muxAttribsOut_);
                muxAttribsOut = (muxAttribsOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(muxAttribsOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateMuxStreamAttributes", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMuxStreamAttributes_(void* arg0, void* arg1);

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="mediaTypesToMuxRef">No documentation.</param>	
        /// <param name="muxMediaTypeOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMuxStreamMediaType']/*"/>	
        /// <unmanaged>HRESULT MFCreateMuxStreamMediaType([In] IMFCollection* pMediaTypesToMux,[Out] IMFMediaType** ppMuxMediaType)</unmanaged>	
        /// <unmanaged-short>MFCreateMuxStreamMediaType</unmanaged-short>	
        public static void CreateMuxStreamMediaType(SharpDX.MediaFoundation.Collection mediaTypesToMuxRef, out SharpDX.MediaFoundation.MediaType muxMediaTypeOut)
        {
            unsafe
            {
                IntPtr muxMediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMuxStreamMediaType_((void*)((mediaTypesToMuxRef == null) ? IntPtr.Zero : mediaTypesToMuxRef.NativePointer), &muxMediaTypeOut_);
                muxMediaTypeOut = (muxMediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(muxMediaTypeOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateMuxStreamMediaType", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMuxStreamMediaType_(void* arg0, void* arg1);

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="samplesToMuxRef">No documentation.</param>	
        /// <param name="muxSampleOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMuxStreamSample']/*"/>	
        /// <unmanaged>HRESULT MFCreateMuxStreamSample([In] IMFCollection* pSamplesToMux,[Out] IMFSample** ppMuxSample)</unmanaged>	
        /// <unmanaged-short>MFCreateMuxStreamSample</unmanaged-short>	
        public static void CreateMuxStreamSample(SharpDX.MediaFoundation.Collection samplesToMuxRef, out SharpDX.MediaFoundation.Sample muxSampleOut)
        {
            unsafe
            {
                IntPtr muxSampleOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMuxStreamSample_((void*)((samplesToMuxRef == null) ? IntPtr.Zero : samplesToMuxRef.NativePointer), &muxSampleOut_);
                muxSampleOut = (muxSampleOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Sample(muxSampleOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateMuxStreamSample", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMuxStreamSample_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> Validates the size of a buffer for a video format block. </p>	
        /// </summary>	
        /// <param name="formatType"><dd> <p><see cref="System.Guid"/> that specifies the type of format block. It must be one of the following values:</p> <dl><dt><strong>FORMAT_DvInfo</strong></dt><dt><strong>FORMAT_MFVideoFormat</strong></dt><dt><strong>FORMAT_MPEG2Video</strong></dt><dt><strong>FORMAT_MPEGStreams</strong></dt><dt><strong>FORMAT_MPEGVideo</strong></dt><dt><strong>FORMAT_VideoInfo</strong></dt><dt><strong>FORMAT_VideoInfo2</strong></dt><dt><strong>FORMAT_WaveFormatEx</strong></dt> </dl> </dd></param>	
        /// <param name="blockRef"><dd> <p> Pointer to a buffer that contains the format block. </p> </dd></param>	
        /// <param name="cbSize"><dd> <p> Size of the <em>pBlock</em> buffer, in bytes. </p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The buffer that contains the format block is large enough. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidMediaType"/></strong></dt> </dl> </td><td> <p> The buffer that contains the format block is too small, or the format block is not valid. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedFormat"/></strong></dt> </dl> </td><td> <p> This function does not support the specified format type. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFValidateMediaTypeSize']/*"/>	
        /// <msdn-id>ms698993</msdn-id>	
        /// <unmanaged>HRESULT MFValidateMediaTypeSize([In] GUID FormatType,[In, Buffer, Optional] unsigned char* pBlock,[In] unsigned int cbSize)</unmanaged>	
        /// <unmanaged-short>MFValidateMediaTypeSize</unmanaged-short>	
        public static void ValidateMediaTypeSize(System.Guid formatType, byte[] blockRef, int cbSize)
        {
            unsafe
            {
                byte[] blockRef__ = blockRef;
                SharpDX.Result __result__;
                fixed (void* blockRef_ = blockRef__)
                    __result__ =
                    MFValidateMediaTypeSize_(formatType, blockRef_, cbSize);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFValidateMediaTypeSize", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFValidateMediaTypeSize_(System.Guid arg0, void* arg1, int arg2);

        /// <summary>	
        /// <p> </p><p>Creates an empty media type.</p>	
        /// </summary>	
        /// <param name="mFTypeOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The media type is created without any attributes. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMediaType']/*"/>	
        /// <msdn-id>ms693861</msdn-id>	
        /// <unmanaged>HRESULT MFCreateMediaType([Out, Fast] IMFMediaType** ppMFType)</unmanaged>	
        /// <unmanaged-short>MFCreateMediaType</unmanaged-short>	
        public static void CreateMediaType(SharpDX.MediaFoundation.MediaType mFTypeOut)
        {
            unsafe
            {
                IntPtr mFTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMediaType_(&mFTypeOut_);
                ((SharpDX.MediaFoundation.MediaType)mFTypeOut).NativePointer = mFTypeOut_;
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateMediaType", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMediaType_(void* arg0);

        /// <summary>	
        /// <p>[This API is not supported and may be altered or unavailable in the future. Applications should avoid using the <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure, and use media type attributes instead. For more information, see Video Media Types.]</p><p> Creates an <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure from a video media type.</p>	
        /// </summary>	
        /// <param name="mFTypeRef">No documentation.</param>	
        /// <param name="mFVFOut">No documentation.</param>	
        /// <param name="cbSizeRef">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMFVideoFormatFromMFMediaType']/*"/>	
        /// <msdn-id>aa473827</msdn-id>	
        /// <unmanaged>HRESULT MFCreateMFVideoFormatFromMFMediaType([In] IMFMediaType* pMFType,[Out] MFVIDEOFORMAT** ppMFVF,[Out, Optional] unsigned int* pcbSize)</unmanaged>	
        /// <unmanaged-short>MFCreateMFVideoFormatFromMFMediaType</unmanaged-short>	
        public static void CreateMFVideoFormatFromMFMediaType(SharpDX.MediaFoundation.MediaType mFTypeRef, out SharpDX.MediaFoundation.VideoFormat mFVFOut, out int cbSizeRef)
        {
            unsafe
            {
                var mFVFOut_ = new SharpDX.MediaFoundation.VideoFormat.__Native();
                SharpDX.Result __result__;
                fixed (void* cbSizeRef_ = &cbSizeRef)
                    __result__ =
                    MFCreateMFVideoFormatFromMFMediaType_((void*)((mFTypeRef == null) ? IntPtr.Zero : mFTypeRef.NativePointer), &mFVFOut_, cbSizeRef_);
                mFVFOut = new SharpDX.MediaFoundation.VideoFormat();
                mFVFOut.__MarshalFrom(ref mFVFOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateMFVideoFormatFromMFMediaType", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMFVideoFormatFromMFMediaType_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p> </p><p>Converts a Media Foundation audio media type to a <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure.</p>	
        /// </summary>	
        /// <param name="mFTypeRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type.</p> </dd></param>	
        /// <param name="wFOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure. The caller must release the memory allocated for the structure by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <param name="cbSizeRef"><dd> <p>Receives the size of the <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure.</p> </dd></param>	
        /// <param name="flags"><dd> <p>Contains a flag from the <strong><see cref="SharpDX.MediaFoundation.WaveFormatExConvertFlags"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the <strong>wFormatTag</strong> member of the returned structure is <strong><see cref="SharpDX.Multimedia.WaveFormatEncoding.Extensible"/></strong>, you can cast the reference to a <strong><see cref="SharpDX.Multimedia.WaveFormatExtensible"/></strong> structure.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateWaveFormatExFromMFMediaType']/*"/>	
        /// <msdn-id>ms702177</msdn-id>	
        /// <unmanaged>HRESULT MFCreateWaveFormatExFromMFMediaType([In] IMFMediaType* pMFType,[Out] void** ppWF,[Out, Optional] unsigned int* pcbSize,[In] unsigned int Flags)</unmanaged>	
        /// <unmanaged-short>MFCreateWaveFormatExFromMFMediaType</unmanaged-short>	
        internal static void CreateWaveFormatExFromMFMediaType(SharpDX.MediaFoundation.MediaType mFTypeRef, out System.IntPtr wFOut, out int cbSizeRef, int flags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* wFOut_ = &wFOut)
                fixed (void* cbSizeRef_ = &cbSizeRef)
                    __result__ =
                    MFCreateWaveFormatExFromMFMediaType_((void*)((mFTypeRef == null) ? IntPtr.Zero : mFTypeRef.NativePointer), wFOut_, cbSizeRef_, flags);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateWaveFormatExFromMFMediaType", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateWaveFormatExFromMFMediaType_(void* arg0, void* arg1, void* arg2, int arg3);

        /// <summary>	
        /// <p>Retrieves the image size for a video format. Given a <strong><see cref="SharpDX.Win32.BitmapInfoHeader"/></strong> structure, this function calculates the correct value of the <strong>biSizeImage</strong> member. </p>	
        /// </summary>	
        /// <param name="bMIHRef">No documentation.</param>	
        /// <param name="cbBufSize">No documentation.</param>	
        /// <param name="cbImageSizeRef">No documentation.</param>	
        /// <param name="bKnownRef">No documentation.</param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> The <strong><see cref="SharpDX.Win32.BitmapInfoHeader"/></strong> structure is not valid, or the value of <em>cbBufSize</em> is too small. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> Before calling this function, you must set at least the following members of the <strong><see cref="SharpDX.Win32.BitmapInfoHeader"/></strong> structure:</p><ul> <li><strong>biCompression</strong></li> <li><strong>biBitCount</strong></li> <li><strong>biWidth</strong></li> <li><strong>biHeight</strong></li> </ul><p>Also, if <strong>biCompression</strong> is <strong>BI_BITFIELDS</strong>, the <strong><see cref="SharpDX.Win32.BitmapInfoHeader"/></strong> structure must be followed by an array of color masks. </p><p> This function fails if the <strong><see cref="SharpDX.Win32.BitmapInfoHeader"/></strong> structure describes a format that is not a video format. For example, it fails if <strong>biCompresson</strong> is <strong>BI_JPEG</strong> or <strong>BI_PNG</strong> .</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCalculateBitmapImageSize']/*"/>	
        /// <msdn-id>ms697582</msdn-id>	
        /// <unmanaged>HRESULT MFCalculateBitmapImageSize([In, Buffer] const BITMAPINFOHEADER* pBMIH,[In] unsigned int cbBufSize,[Out] unsigned int* pcbImageSize,[Out, Optional] BOOL* pbKnown)</unmanaged>	
        /// <unmanaged-short>MFCalculateBitmapImageSize</unmanaged-short>	
        public static void CalculateBitmapImageSize(SharpDX.Win32.BitmapInfoHeader[] bMIHRef, int cbBufSize, out int cbImageSizeRef, out SharpDX.Mathematics.Interop.RawBool bKnownRef)
        {
            unsafe
            {
                bKnownRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* bMIHRef_ = bMIHRef)
                fixed (void* cbImageSizeRef_ = &cbImageSizeRef)
                fixed (void* bKnownRef_ = &bKnownRef)
                    __result__ =
                    MFCalculateBitmapImageSize_(bMIHRef_, cbBufSize, cbImageSizeRef_, bKnownRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCalculateBitmapImageSize", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCalculateBitmapImageSize_(void* arg0, int arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p> </p><p>Retrieves the image size, in bytes, for an uncompressed video format.</p>	
        /// </summary>	
        /// <param name="guidSubtype"><dd> <p>Media subtype for the video format. For a list of subtypes, see Media Type GUIDs.</p> </dd></param>	
        /// <param name="unWidth"><dd> <p>Width of the image, in pixels.</p> </dd></param>	
        /// <param name="unHeight"><dd> <p>Height of the image, in pixels.</p> </dd></param>	
        /// <param name="cbImageSizeRef"><dd> <p>Receives the size of each frame, in bytes. If the format is compressed or is not recognized, the value is zero.</p> </dd></param>	
        /// <returns><p>The function returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCalculateImageSize']/*"/>	
        /// <msdn-id>bb970318</msdn-id>	
        /// <unmanaged>HRESULT MFCalculateImageSize([In] const GUID&amp; guidSubtype,[In] unsigned int unWidth,[In] unsigned int unHeight,[Out] unsigned int* pcbImageSize)</unmanaged>	
        /// <unmanaged-short>MFCalculateImageSize</unmanaged-short>	
        public static void CalculateImageSize(System.Guid guidSubtype, int unWidth, int unHeight, out int cbImageSizeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cbImageSizeRef_ = &cbImageSizeRef)
                    __result__ =
                    MFCalculateImageSize_(&guidSubtype, unWidth, unHeight, cbImageSizeRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCalculateImageSize", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCalculateImageSize_(void* arg0, int arg1, int arg2, void* arg3);

        /// <summary>	
        /// <p> Converts a video frame rate into a frame duration.</p>	
        /// </summary>	
        /// <param name="unNumerator"><dd> <p>The numerator of the frame rate. </p> </dd></param>	
        /// <param name="unDenominator"><dd> <p> The denominator of the frame rate. </p> </dd></param>	
        /// <param name="unAverageTimePerFrameRef"><dd> <p> Receives the average duration of a video frame, in 100-nanosecond units. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function is useful for calculating time stamps on a sample, given the frame rate.</p><p>Also, average time per frame is used in the older <strong><see cref="SharpDX.Win32.Unsupported.VideoInfoHeader"/></strong> and <strong><see cref="SharpDX.MediaFoundation.VideoInformationHeader2"/></strong> format structures. This function provides a standard conversion so that all components in the pipeline can use consistent values, if they need to translate between the older format structures and the media type attributes used in Media Foundation.</p><p> For certain common frame rates, the function gets the frame duration from a look-up table:</p><table> <tr><th>Frames per second (floating point)</th><th>Frames per second (fractional)</th><th>Average time per frame</th></tr> <tr><td>59.94</td><td>60000/1001</td><td>166833</td></tr> <tr><td>29.97</td><td>30000/1001</td><td>333667</td></tr> <tr><td>23.976</td><td>24000/1001</td><td>417188</td></tr> <tr><td>60</td><td>60/1</td><td>166667</td></tr> <tr><td>30</td><td>30/1</td><td>333333</td></tr> <tr><td>50</td><td>50/1</td><td>200000</td></tr> <tr><td>25</td><td>25/1</td><td>400000</td></tr> <tr><td>24</td><td>24/1</td><td>416667</td></tr> </table><p>?</p><p> Most video content uses one of the frame rates listed here. For other frame rates, the function calculates the duration.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFFrameRateToAverageTimePerFrame']/*"/>	
        /// <msdn-id>aa370467</msdn-id>	
        /// <unmanaged>HRESULT MFFrameRateToAverageTimePerFrame([In] unsigned int unNumerator,[In] unsigned int unDenominator,[Out] unsigned longlong* punAverageTimePerFrame)</unmanaged>	
        /// <unmanaged-short>MFFrameRateToAverageTimePerFrame</unmanaged-short>	
        public static void FrameRateToAverageTimePerFrame(int unNumerator, int unDenominator, out long unAverageTimePerFrameRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* unAverageTimePerFrameRef_ = &unAverageTimePerFrameRef)
                    __result__ =
                    MFFrameRateToAverageTimePerFrame_(unNumerator, unDenominator, unAverageTimePerFrameRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFFrameRateToAverageTimePerFrame", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFFrameRateToAverageTimePerFrame_(int arg0, int arg1, void* arg2);

        /// <summary>	
        /// <p> </p><p>Calculates the frame rate, in frames per second, from the average duration of a video frame.</p>	
        /// </summary>	
        /// <param name="unAverageTimePerFrame"><dd> <p>The average duration of a video frame, in 100-nanosecond units.</p> </dd></param>	
        /// <param name="unNumeratorRef"><dd> <p>Receives the numerator of the frame rate.</p> </dd></param>	
        /// <param name="unDenominatorRef"><dd> <p>Receives the denominator of the frame rate.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Average time per frame is used in the older <strong><see cref="SharpDX.Win32.Unsupported.VideoInfoHeader"/></strong> and <strong><see cref="SharpDX.MediaFoundation.VideoInformationHeader2"/></strong> format structures. This function provides a standard conversion so that all components in the pipeline can use consistent values, if they need to translate between the older format structures and the media type attributes used in Media Foundation.</p><p>This function uses a look-up table for certain common durations. The table is listed in the Remarks section for the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.FrameRateToAverageTimePerFrame"/></strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFAverageTimePerFrameToFrameRate']/*"/>	
        /// <msdn-id>bb970468</msdn-id>	
        /// <unmanaged>HRESULT MFAverageTimePerFrameToFrameRate([In] unsigned longlong unAverageTimePerFrame,[Out] unsigned int* punNumerator,[Out] unsigned int* punDenominator)</unmanaged>	
        /// <unmanaged-short>MFAverageTimePerFrameToFrameRate</unmanaged-short>	
        public static void AverageTimePerFrameToFrameRate(long unAverageTimePerFrame, out int unNumeratorRef, out int unDenominatorRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* unNumeratorRef_ = &unNumeratorRef)
                fixed (void* unDenominatorRef_ = &unDenominatorRef)
                    __result__ =
                    MFAverageTimePerFrameToFrameRate_(unAverageTimePerFrame, unNumeratorRef_, unDenominatorRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFAverageTimePerFrameToFrameRate", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFAverageTimePerFrameToFrameRate_(long arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p>[This API is not supported and may be altered or unavailable in the future. Applications should avoid using the <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure, and use media type attributes instead. For more information, see Video Media Types.]</p><p>Initializes a media type from an <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure.</p>	
        /// </summary>	
        /// <param name="mFTypeRef">No documentation.</param>	
        /// <param name="mFVFRef">No documentation.</param>	
        /// <param name="cbBufSize">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFInitMediaTypeFromMFVideoFormat']/*"/>	
        /// <msdn-id>aa473795</msdn-id>	
        /// <unmanaged>HRESULT MFInitMediaTypeFromMFVideoFormat([In] IMFMediaType* pMFType,[In, Buffer] const MFVIDEOFORMAT* pMFVF,[In] unsigned int cbBufSize)</unmanaged>	
        /// <unmanaged-short>MFInitMediaTypeFromMFVideoFormat</unmanaged-short>	
        public static void InitMediaTypeFromMFVideoFormat(SharpDX.MediaFoundation.MediaType mFTypeRef, SharpDX.MediaFoundation.VideoFormat[] mFVFRef, int cbBufSize)
        {
            unsafe
            {
                SharpDX.MediaFoundation.VideoFormat.__Native[] mFVFRef__ = new SharpDX.MediaFoundation.VideoFormat.__Native[mFVFRef.Length];
                for (int i = 0; i < mFVFRef.Length; i++)
                    mFVFRef[i].__MarshalTo(ref mFVFRef__[i]);
                SharpDX.Result __result__;
                fixed (void* mFVFRef_ = mFVFRef__)
                    __result__ =
                    MFInitMediaTypeFromMFVideoFormat_((void*)((mFTypeRef == null) ? IntPtr.Zero : mFTypeRef.NativePointer), mFVFRef_, cbBufSize);
                for (int i = 0; i < mFVFRef.Length; i++)
                    mFVFRef[i].__MarshalFree(ref mFVFRef__[i]);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFInitMediaTypeFromMFVideoFormat", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFInitMediaTypeFromMFVideoFormat_(void* arg0, void* arg1, int arg2);

        /// <summary>	
        /// <p> Initializes a media type from a <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure. </p>	
        /// </summary>	
        /// <param name="mFTypeRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type to initialize. To create the uninitialized media type object, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateMediaType"/></strong>.</p> </dd></param>	
        /// <param name="waveFormatRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure that describes the media type. The caller must fill in the structure members before calling this function.</p> </dd></param>	
        /// <param name="cbBufSize"><dd> <p>Size of the <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure, in bytes.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFInitMediaTypeFromWaveFormatEx']/*"/>	
        /// <msdn-id>ms700801</msdn-id>	
        /// <unmanaged>HRESULT MFInitMediaTypeFromWaveFormatEx([In] IMFMediaType* pMFType,[In, Buffer] const WAVEFORMATEX* pWaveFormat,[In] unsigned int cbBufSize)</unmanaged>	
        /// <unmanaged-short>MFInitMediaTypeFromWaveFormatEx</unmanaged-short>	
        public static void InitMediaTypeFromWaveFormatEx(SharpDX.MediaFoundation.MediaType mFTypeRef, SharpDX.Multimedia.WaveFormat[] waveFormatRef, int cbBufSize)
        {
            unsafe
            {
                SharpDX.Multimedia.WaveFormat.__Native[] waveFormatRef__ = new SharpDX.Multimedia.WaveFormat.__Native[waveFormatRef.Length];
                for (int i = 0; i < waveFormatRef.Length; i++)
                    waveFormatRef[i].__MarshalTo(ref waveFormatRef__[i]);
                SharpDX.Result __result__;
                fixed (void* waveFormatRef_ = waveFormatRef__)
                    __result__ =
                    MFInitMediaTypeFromWaveFormatEx_((void*)((mFTypeRef == null) ? IntPtr.Zero : mFTypeRef.NativePointer), waveFormatRef_, cbBufSize);
                for (int i = 0; i < waveFormatRef.Length; i++)
                    waveFormatRef[i].__MarshalFree(ref waveFormatRef__[i]);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFInitMediaTypeFromWaveFormatEx", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFInitMediaTypeFromWaveFormatEx_(void* arg0, void* arg1, int arg2);

        /// <summary>	
        /// <p> </p><p>Compares a full media type to a partial media type.</p>	
        /// </summary>	
        /// <param name="mFTypeFullRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the full media type.</p> </dd></param>	
        /// <param name="mFTypePartialRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the partial media type.</p> </dd></param>	
        /// <returns><p>If the full media type is compatible with the partial media type, the function returns <strong>TRUE</strong>. Otherwise, the function returns <strong><see cref="SharpDX.Result.False"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>A pipeline component can return a partial media type to describe a range of possible formats the component might accept. A partial media type has at least a major type <see cref="System.Guid"/>, but might be missing some of the other attributes that are needed to fully describe the type. The missing attributes represent "don't care" values for the partial type. For example, a partial video type might be missing the attributes for the width and height of the video.</p><p>This function returns <strong>TRUE</strong> if the following conditions are both true:</p><ul> <li> The partial media type contains a major type <see cref="System.Guid"/>. </li> <li> All of the attributes in the partial type exist in the full type and are set to the same value. </li> </ul><p> Otherwise, the function returns <strong><see cref="SharpDX.Result.False"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCompareFullToPartialMediaType']/*"/>	
        /// <msdn-id>ms697237</msdn-id>	
        /// <unmanaged>BOOL MFCompareFullToPartialMediaType([In] IMFMediaType* pMFTypeFull,[In] IMFMediaType* pMFTypePartial)</unmanaged>	
        /// <unmanaged-short>MFCompareFullToPartialMediaType</unmanaged-short>	
        public static SharpDX.Mathematics.Interop.RawBool CompareFullToPartialMediaType(SharpDX.MediaFoundation.MediaType mFTypeFullRef, SharpDX.MediaFoundation.MediaType mFTypePartialRef)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                MFCompareFullToPartialMediaType_((void*)((mFTypeFullRef == null) ? IntPtr.Zero : mFTypeFullRef.NativePointer), (void*)((mFTypePartialRef == null) ? IntPtr.Zero : mFTypePartialRef.NativePointer));
                return __result__;
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCompareFullToPartialMediaType", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern SharpDX.Mathematics.Interop.RawBool MFCompareFullToPartialMediaType_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> Creates a media type that wraps another media type. </p>	
        /// </summary>	
        /// <param name="origRef"><dd> <p> A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type to wrap in a new media type. </p> </dd></param>	
        /// <param name="majorType"><dd> <p>A  <see cref="System.Guid"/> that specifies the major type for the new media type. For a list of possible values, see Major Media Types. </p> </dd></param>	
        /// <param name="subType"><dd> <p>A  <see cref="System.Guid"/> that specifies the subtype for the new media type. For possible values, see:</p> <ul> <li> <strong>Audio Subtypes</strong> </li> <li> Video Subtypes </li> </ul> <p>Applications can define custom subtype GUIDs.</p> </dd></param>	
        /// <param name="wrapOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the new media type that wraps the original media type. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The original media type (<em>pOrig</em>) is stored in the new media type under the <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.WrappedType"/></strong> attribute. To extract the original media type, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.UnwrapMediaType"/></strong>. </p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFWrapMediaType']/*"/>	
        /// <msdn-id>ms701782</msdn-id>	
        /// <unmanaged>HRESULT MFWrapMediaType([In] IMFMediaType* pOrig,[In] const GUID&amp; MajorType,[In] const GUID&amp; SubType,[Out] IMFMediaType** ppWrap)</unmanaged>	
        /// <unmanaged-short>MFWrapMediaType</unmanaged-short>	
        public static void WrapMediaType(SharpDX.MediaFoundation.MediaType origRef, System.Guid majorType, System.Guid subType, out SharpDX.MediaFoundation.MediaType wrapOut)
        {
            unsafe
            {
                IntPtr wrapOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFWrapMediaType_((void*)((origRef == null) ? IntPtr.Zero : origRef.NativePointer), &majorType, &subType, &wrapOut_);
                wrapOut = (wrapOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(wrapOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFWrapMediaType", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFWrapMediaType_(void* arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p> Retrieves a media type that was wrapped in another media type by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.WrapMediaType"/></strong> function. </p>	
        /// </summary>	
        /// <param name="wrapRef">No documentation.</param>	
        /// <param name="origOut">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFUnwrapMediaType']/*"/>	
        /// <msdn-id>ms696190</msdn-id>	
        /// <unmanaged>HRESULT MFUnwrapMediaType([In] IMFMediaType* pWrap,[Out] IMFMediaType** ppOrig)</unmanaged>	
        /// <unmanaged-short>MFUnwrapMediaType</unmanaged-short>	
        public static void UnwrapMediaType(SharpDX.MediaFoundation.MediaType wrapRef, out SharpDX.MediaFoundation.MediaType origOut)
        {
            unsafe
            {
                IntPtr origOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFUnwrapMediaType_((void*)((wrapRef == null) ? IntPtr.Zero : wrapRef.NativePointer), &origOut_);
                origOut = (origOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(origOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFUnwrapMediaType", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFUnwrapMediaType_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>[This API is not supported and may be altered or unavailable in the future. Applications should avoid using the <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure, and use media type attributes instead. For more information, see Video Media Types.]</p><p> Creates a video media type from an <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure. </p>	
        /// </summary>	
        /// <param name="videoFormatRef">No documentation.</param>	
        /// <param name="iVideoMediaTypeOut">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Instead of using the <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure to initialize a video media type, you can call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateMediaType"/></strong> and set the media type attributes directly. </p><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateVideoMediaType']/*"/>	
        /// <msdn-id>aa473781</msdn-id>	
        /// <unmanaged>HRESULT MFCreateVideoMediaType([In] const MFVIDEOFORMAT* pVideoFormat,[Out] IMFVideoMediaType** ppIVideoMediaType)</unmanaged>	
        /// <unmanaged-short>MFCreateVideoMediaType</unmanaged-short>	
        public static void CreateVideoMediaType(ref SharpDX.MediaFoundation.VideoFormat videoFormatRef, out SharpDX.MediaFoundation.VideoMediaType iVideoMediaTypeOut)
        {
            unsafe
            {
                var videoFormatRef_ = new SharpDX.MediaFoundation.VideoFormat.__Native();
                videoFormatRef.__MarshalTo(ref videoFormatRef_);
                IntPtr iVideoMediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateVideoMediaType_(&videoFormatRef_, &iVideoMediaTypeOut_);
                videoFormatRef.__MarshalFree(ref videoFormatRef_);
                iVideoMediaTypeOut = (iVideoMediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.VideoMediaType(iVideoMediaTypeOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateVideoMediaType", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateVideoMediaType_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> Creates a partial video media type with a specified subtype. </p>	
        /// </summary>	
        /// <param name="aMSubtypeRef"><dd> <p> Pointer to a <see cref="System.Guid"/> that specifies the subtype. See Video Subtype GUIDs. </p> </dd></param>	
        /// <param name="iVideoMediaTypeOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.VideoMediaType"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This function creates a media type and sets the major type equal to <strong><see cref="SharpDX.MediaFoundation.MediaTypeGuids.Video"/></strong> and the subtype equal to the value specified in <em>pAMSubtype</em>. </p><p>You can get the same result with the following steps:</p><ol> <li> Call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateMediaType"/></strong>. This function returns a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. </li> <li> Set the <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.MajorType"/></strong> attribute to <strong><see cref="SharpDX.MediaFoundation.MediaTypeGuids.Video"/></strong>. </li> <li> Set the <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.Subtype"/></strong> attribute to the subtype. </li> </ol><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateVideoMediaTypeFromSubtype']/*"/>	
        /// <msdn-id>aa473791</msdn-id>	
        /// <unmanaged>HRESULT MFCreateVideoMediaTypeFromSubtype([In] const GUID* pAMSubtype,[Out] IMFVideoMediaType** ppIVideoMediaType)</unmanaged>	
        /// <unmanaged-short>MFCreateVideoMediaTypeFromSubtype</unmanaged-short>	
        public static void CreateVideoMediaTypeFromSubtype(System.Guid aMSubtypeRef, out SharpDX.MediaFoundation.VideoMediaType iVideoMediaTypeOut)
        {
            unsafe
            {
                IntPtr iVideoMediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateVideoMediaTypeFromSubtype_(&aMSubtypeRef, &iVideoMediaTypeOut_);
                iVideoMediaTypeOut = (iVideoMediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.VideoMediaType(iVideoMediaTypeOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateVideoMediaTypeFromSubtype", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateVideoMediaTypeFromSubtype_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> </p><p>Queries whether a FOURCC code or <strong>D3DFORMAT</strong> value is a YUV format.</p>	
        /// </summary>	
        /// <param name="format"><dd> <p>FOURCC code or <strong>D3DFORMAT</strong> value.</p> </dd></param>	
        /// <returns><p>The function returns one of the following values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>TRUE</strong></dt> </dl> </td><td> <p>The value specifies a YUV format.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.False"/></strong></dt> </dl> </td><td> <p>The value does not specify a recognized YUV format.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This function checks whether <em>Format</em> specifies a YUV format. Not every YUV format is recognized by this function. However, if a YUV format is not recognized by this function, it is probably not supported for video rendering or DirectX video acceleration (DXVA).</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFIsFormatYUV']/*"/>	
        /// <msdn-id>ms704010</msdn-id>	
        /// <unmanaged>BOOL MFIsFormatYUV([In] unsigned int Format)</unmanaged>	
        /// <unmanaged-short>MFIsFormatYUV</unmanaged-short>	
        public static SharpDX.Mathematics.Interop.RawBool IsFormatYUV(int format)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                MFIsFormatYUV_(format);
                return __result__;
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFIsFormatYUV", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern SharpDX.Mathematics.Interop.RawBool MFIsFormatYUV_(int arg0);

        /// <summary>	
        /// <p> This function is not implemented.</p>	
        /// </summary>	
        /// <param name="bmihBitMapInfoHeaderRef"><dd> <p>Reserved.</p> </dd></param>	
        /// <param name="dwPixelAspectRatioX"><dd> <p>Reserved.</p> </dd></param>	
        /// <param name="dwPixelAspectRatioY"><dd> <p>Reserved.</p> </dd></param>	
        /// <param name="interlaceMode"><dd> <p>Reserved.</p> </dd></param>	
        /// <param name="videoFlags"><dd> <p>Reserved.</p> </dd></param>	
        /// <param name="qwFramesPerSecondNumerator"><dd> <p>Reserved.</p> </dd></param>	
        /// <param name="qwFramesPerSecondDenominator"><dd> <p>Reserved.</p> </dd></param>	
        /// <param name="dwMaxBitRate"><dd> <p>Reserved.</p> </dd></param>	
        /// <param name="iVideoMediaTypeOut"><dd> <p>Reserved.</p> </dd></param>	
        /// <returns><p>Returns <strong>E_FAIL</strong>.</p></returns>	
        /// <remarks>	
        /// <strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateVideoMediaTypeFromBitMapInfoHeader']/*"/>	
        /// <msdn-id>aa473801</msdn-id>	
        /// <unmanaged>HRESULT MFCreateVideoMediaTypeFromBitMapInfoHeader([In] const BITMAPINFOHEADER* pbmihBitMapInfoHeader,[In] unsigned int dwPixelAspectRatioX,[In] unsigned int dwPixelAspectRatioY,[In] MFVideoInterlaceMode InterlaceMode,[In] unsigned longlong VideoFlags,[In] unsigned longlong qwFramesPerSecondNumerator,[In] unsigned longlong qwFramesPerSecondDenominator,[In] unsigned int dwMaxBitRate,[Out] IMFVideoMediaType** ppIVideoMediaType)</unmanaged>	
        /// <unmanaged-short>MFCreateVideoMediaTypeFromBitMapInfoHeader</unmanaged-short>	
        public static void CreateVideoMediaTypeFromBitMapInfoHeader(ref SharpDX.Win32.BitmapInfoHeader bmihBitMapInfoHeaderRef, int dwPixelAspectRatioX, int dwPixelAspectRatioY, SharpDX.MediaFoundation.VideoInterlaceMode interlaceMode, long videoFlags, long qwFramesPerSecondNumerator, long qwFramesPerSecondDenominator, int dwMaxBitRate, out SharpDX.MediaFoundation.VideoMediaType iVideoMediaTypeOut)
        {
            unsafe
            {
                IntPtr iVideoMediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* bmihBitMapInfoHeaderRef_ = &bmihBitMapInfoHeaderRef)
                    __result__ =
                    MFCreateVideoMediaTypeFromBitMapInfoHeader_(bmihBitMapInfoHeaderRef_, dwPixelAspectRatioX, dwPixelAspectRatioY, unchecked((int)interlaceMode), videoFlags, qwFramesPerSecondNumerator, qwFramesPerSecondDenominator, dwMaxBitRate, &iVideoMediaTypeOut_);
                iVideoMediaTypeOut = (iVideoMediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.VideoMediaType(iVideoMediaTypeOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateVideoMediaTypeFromBitMapInfoHeader", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateVideoMediaTypeFromBitMapInfoHeader_(void* arg0, int arg1, int arg2, int arg3, long arg4, long arg5, long arg6, int arg7, void* arg8);

        /// <summary>	
        /// <p> Calculates the minimum surface stride for a video format. </p>	
        /// </summary>	
        /// <param name="format"><dd> <p>FOURCC code or <strong>D3DFORMAT</strong> value that specifies the video format. If you have a video subtype <see cref="System.Guid"/>, you can use the first <strong>DWORD</strong> of the subtype.</p> </dd></param>	
        /// <param name="dwWidth"><dd> <p>Width of the image, in pixels.</p> </dd></param>	
        /// <param name="strideRef"><dd> <p>Receives the minimum surface stride, in pixels.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This function calculates the minimum stride needed to hold the image in memory. Use this function if you are allocating buffers in system memory. Surfaces allocated in video memory might require a larger stride, depending on the graphics card. </p><p> If you are working with a DirectX surface buffer, use the <strong><see cref="SharpDX.MediaFoundation.Buffer2D.Lock2D"/></strong> method to find the surface stride. </p><p> For planar YUV formats, this function returns the stride for the Y plane. Depending on the format, the chroma planes might have a different stride. </p><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetStrideForBitmapInfoHeader']/*"/>	
        /// <msdn-id>aa473720</msdn-id>	
        /// <unmanaged>HRESULT MFGetStrideForBitmapInfoHeader([In] unsigned int format,[In] unsigned int dwWidth,[Out] int* pStride)</unmanaged>	
        /// <unmanaged-short>MFGetStrideForBitmapInfoHeader</unmanaged-short>	
        public static void GetStrideForBitmapInfoHeader(int format, int dwWidth, out int strideRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* strideRef_ = &strideRef)
                    __result__ =
                    MFGetStrideForBitmapInfoHeader_(format, dwWidth, strideRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFGetStrideForBitmapInfoHeader", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetStrideForBitmapInfoHeader_(int arg0, int arg1, void* arg2);

        /// <summary>	
        /// <p> </p><p>Retrieves the image size, in bytes, for an uncompressed video format.</p>	
        /// </summary>	
        /// <param name="format"><dd> <p>FOURCC code or <strong>D3DFORMAT</strong> value that specifies the video format.</p> </dd></param>	
        /// <param name="dwWidth"><dd> <p>Width of the image, in pixels.</p> </dd></param>	
        /// <param name="dwHeight"><dd> <p>Height of the image, in pixels.</p> </dd></param>	
        /// <param name="dwPlaneSizeRef"><dd> <p>Receives the size of one frame, in bytes. If the format is compressed or is not recognized, this value is zero.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> This function is equivalent to the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CalculateImageSize"/></strong> function. </p><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetPlaneSize']/*"/>	
        /// <msdn-id>aa473798</msdn-id>	
        /// <unmanaged>HRESULT MFGetPlaneSize([In] unsigned int format,[In] unsigned int dwWidth,[In] unsigned int dwHeight,[Out] unsigned int* pdwPlaneSize)</unmanaged>	
        /// <unmanaged-short>MFGetPlaneSize</unmanaged-short>	
        public static void GetPlaneSize(int format, int dwWidth, int dwHeight, out int dwPlaneSizeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwPlaneSizeRef_ = &dwPlaneSizeRef)
                    __result__ =
                    MFGetPlaneSize_(format, dwWidth, dwHeight, dwPlaneSizeRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFGetPlaneSize", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetPlaneSize_(int arg0, int arg1, int arg2, void* arg3);

        /// <summary>	
        /// <p>Creates a video media type from a <strong><see cref="SharpDX.Win32.BitmapInfoHeader"/></strong> structure.</p>	
        /// </summary>	
        /// <param name="bmihBitMapInfoHeaderRef">No documentation.</param>	
        /// <param name="cbBitMapInfoHeader">No documentation.</param>	
        /// <param name="dwPixelAspectRatioX">No documentation.</param>	
        /// <param name="dwPixelAspectRatioY">No documentation.</param>	
        /// <param name="interlaceMode">No documentation.</param>	
        /// <param name="videoFlags">No documentation.</param>	
        /// <param name="dwFramesPerSecondNumerator">No documentation.</param>	
        /// <param name="dwFramesPerSecondDenominator">No documentation.</param>	
        /// <param name="dwMaxBitRate">No documentation.</param>	
        /// <param name="iVideoMediaTypeOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateVideoMediaTypeFromBitMapInfoHeaderEx']/*"/>	
        /// <msdn-id>dd388121</msdn-id>	
        /// <unmanaged>HRESULT MFCreateVideoMediaTypeFromBitMapInfoHeaderEx([In, Buffer] const BITMAPINFOHEADER* pbmihBitMapInfoHeader,[In] unsigned int cbBitMapInfoHeader,[In] unsigned int dwPixelAspectRatioX,[In] unsigned int dwPixelAspectRatioY,[In] MFVideoInterlaceMode InterlaceMode,[In] unsigned longlong VideoFlags,[In] unsigned int dwFramesPerSecondNumerator,[In] unsigned int dwFramesPerSecondDenominator,[In] unsigned int dwMaxBitRate,[Out] IMFVideoMediaType** ppIVideoMediaType)</unmanaged>	
        /// <unmanaged-short>MFCreateVideoMediaTypeFromBitMapInfoHeaderEx</unmanaged-short>	
        public static void CreateVideoMediaTypeFromBitMapInfoHeaderEx(SharpDX.Win32.BitmapInfoHeader[] bmihBitMapInfoHeaderRef, int cbBitMapInfoHeader, int dwPixelAspectRatioX, int dwPixelAspectRatioY, SharpDX.MediaFoundation.VideoInterlaceMode interlaceMode, long videoFlags, int dwFramesPerSecondNumerator, int dwFramesPerSecondDenominator, int dwMaxBitRate, out SharpDX.MediaFoundation.VideoMediaType iVideoMediaTypeOut)
        {
            unsafe
            {
                IntPtr iVideoMediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* bmihBitMapInfoHeaderRef_ = bmihBitMapInfoHeaderRef)
                    __result__ =
                    MFCreateVideoMediaTypeFromBitMapInfoHeaderEx_(bmihBitMapInfoHeaderRef_, cbBitMapInfoHeader, dwPixelAspectRatioX, dwPixelAspectRatioY, unchecked((int)interlaceMode), videoFlags, dwFramesPerSecondNumerator, dwFramesPerSecondDenominator, dwMaxBitRate, &iVideoMediaTypeOut_);
                iVideoMediaTypeOut = (iVideoMediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.VideoMediaType(iVideoMediaTypeOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateVideoMediaTypeFromBitMapInfoHeaderEx", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateVideoMediaTypeFromBitMapInfoHeaderEx_(void* arg0, int arg1, int arg2, int arg3, int arg4, long arg5, int arg6, int arg7, int arg8, void* arg9);

        /// <summary>	
        /// <p> </p><p>Creates a Media Foundation media type from another format representation.</p>	
        /// </summary>	
        /// <param name="guidRepresentation"><dd> <p><see cref="System.Guid"/> that specifies which format representation to convert. The following value is defined.</p> <table> <tr><th><see cref="System.Guid"/></th><th>Description</th></tr> <tr><td>AM_MEDIA_TYPE_REPRESENTATION</td><td>Convert a DirectShow <strong><see cref="SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure.</td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="vRepresentationRef"><dd> <p>Pointer to a buffer that contains the format representation to convert. The layout of the buffer depends on the value of <em>guidRepresentation</em>.</p> </dd></param>	
        /// <param name="iMediaTypeOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedRepresentation"/></strong></dt> </dl> </td><td> <p>The <see cref="System.Guid"/> specified in <em>guidRepresentation</em> is not supported.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the original format is a DirectShow audio media type, and the format type is not recognized, the function sets the following attributes on the converted media type.</p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.AmFormatType"/></strong> </td><td>Contains the format type <see cref="System.Guid"/>.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.UserData"/></strong> </td><td>Contains the format block.</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMediaTypeFromRepresentation']/*"/>	
        /// <msdn-id>aa369931</msdn-id>	
        /// <unmanaged>HRESULT MFCreateMediaTypeFromRepresentation([In] GUID guidRepresentation,[In] void* pvRepresentation,[Out] IMFMediaType** ppIMediaType)</unmanaged>	
        /// <unmanaged-short>MFCreateMediaTypeFromRepresentation</unmanaged-short>	
        public static void CreateMediaTypeFromRepresentation(System.Guid guidRepresentation, System.IntPtr vRepresentationRef, out SharpDX.MediaFoundation.MediaType iMediaTypeOut)
        {
            unsafe
            {
                IntPtr iMediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMediaTypeFromRepresentation_(guidRepresentation, (void*)vRepresentationRef, &iMediaTypeOut_);
                iMediaTypeOut = (iMediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(iMediaTypeOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateMediaTypeFromRepresentation", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMediaTypeFromRepresentation_(System.Guid arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p>[This API is not supported and may be altered or unavailable in the future.]</p><p>Creates an audio media type from a <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure.</p>	
        /// </summary>	
        /// <param name="audioFormatRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure that describes the audio format.</p> </dd></param>	
        /// <param name="iAudioMediaTypeOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.AudioMediaType"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The <strong><see cref="SharpDX.MediaFoundation.AudioMediaType"/></strong> interface is deprecrated, so applications should avoid using this function. To create a media type from a <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure, do the following: </p><ol> <li> Call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateMediaType"/></strong>. This function returns a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. The returned media type object is initially empty. </li> <li> Call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.InitMediaTypeFromWaveFormatEx"/></strong> to populate the media type from the <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure. </li> </ol><p> Alternatively, you can call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateMediaType"/></strong> and then set the media type attributes directly. </p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateAudioMediaType']/*"/>	
        /// <msdn-id>aa473812</msdn-id>	
        /// <unmanaged>HRESULT MFCreateAudioMediaType([In] const WAVEFORMATEX* pAudioFormat,[Out] IMFAudioMediaType** ppIAudioMediaType)</unmanaged>	
        /// <unmanaged-short>MFCreateAudioMediaType</unmanaged-short>	
        public static void CreateAudioMediaType(ref SharpDX.Multimedia.WaveFormat audioFormatRef, out SharpDX.MediaFoundation.AudioMediaType iAudioMediaTypeOut)
        {
            unsafe
            {
                var audioFormatRef_ = new SharpDX.Multimedia.WaveFormat.__Native();
                audioFormatRef.__MarshalTo(ref audioFormatRef_);
                IntPtr iAudioMediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateAudioMediaType_(&audioFormatRef_, &iAudioMediaTypeOut_);
                audioFormatRef.__MarshalFree(ref audioFormatRef_);
                iAudioMediaTypeOut = (iAudioMediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.AudioMediaType(iAudioMediaTypeOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateAudioMediaType", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateAudioMediaType_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>[This API is not supported and may be altered or unavailable in the future. Applications should avoid using the <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure, and use media type attributes instead. For more information, see Video Media Types.]</p><p>Returns the FOURCC or <strong>D3DFORMAT</strong> value for an uncompressed video format.</p>	
        /// </summary>	
        /// <param name="videoFormatRef">No documentation.</param>	
        /// <returns><p>Returns a FOURCC or <strong>D3DFORMAT</strong> value that identifies the video format. If the video format is compressed or not recognized, the return value is D3DFMT_UNKNOWN.</p></returns>	
        /// <remarks>	
        /// <strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetUncompressedVideoFormat']/*"/>	
        /// <msdn-id>aa473806</msdn-id>	
        /// <unmanaged>unsigned int MFGetUncompressedVideoFormat([In] const MFVIDEOFORMAT* pVideoFormat)</unmanaged>	
        /// <unmanaged-short>MFGetUncompressedVideoFormat</unmanaged-short>	
        public static int GetUncompressedVideoFormat(ref SharpDX.MediaFoundation.VideoFormat videoFormatRef)
        {
            unsafe
            {
                var videoFormatRef_ = new SharpDX.MediaFoundation.VideoFormat.__Native();
                videoFormatRef.__MarshalTo(ref videoFormatRef_);
                int __result__;
                __result__ =
                MFGetUncompressedVideoFormat_(&videoFormatRef_);
                videoFormatRef.__MarshalFree(ref videoFormatRef_);
                return __result__;
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFGetUncompressedVideoFormat", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetUncompressedVideoFormat_(void* arg0);

        /// <summary>	
        /// <p>[This API is not supported and may be altered or unavailable in the future. Applications should avoid using the <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure, and use media type attributes instead. For more information, see Video Media Types.]</p><p> Initializes an <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure for a standard video format such as DVD, analog television, or ATSC digital television.</p>	
        /// </summary>	
        /// <param name="videoFormatRef">No documentation.</param>	
        /// <param name="type">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFInitVideoFormat']/*"/>	
        /// <msdn-id>aa473783</msdn-id>	
        /// <unmanaged>HRESULT MFInitVideoFormat([In] MFVIDEOFORMAT* pVideoFormat,[In] MFStandardVideoFormat type)</unmanaged>	
        /// <unmanaged-short>MFInitVideoFormat</unmanaged-short>	
        public static void InitVideoFormat(ref SharpDX.MediaFoundation.VideoFormat videoFormatRef, SharpDX.MediaFoundation.StandardVideoFormat type)
        {
            unsafe
            {
                var videoFormatRef_ = new SharpDX.MediaFoundation.VideoFormat.__Native();
                videoFormatRef.__MarshalTo(ref videoFormatRef_);
                SharpDX.Result __result__;
                __result__ =
                MFInitVideoFormat_(&videoFormatRef_, unchecked((int)type));
                videoFormatRef.__MarshalFree(ref videoFormatRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFInitVideoFormat", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFInitVideoFormat_(void* arg0, int arg1);

        /// <summary>	
        /// <p>[This API is not supported and may be altered or unavailable in the future. Applications should avoid using the <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure, and use media type attributes instead. For more information, see Video Media Types.]</p><p> Initializes an <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure for an uncompressed RGB video format.</p>	
        /// </summary>	
        /// <param name="videoFormatRef">No documentation.</param>	
        /// <param name="dwWidth">No documentation.</param>	
        /// <param name="dwHeight">No documentation.</param>	
        /// <param name="d3Dfmt">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This function fills in some reasonable default values for the specified RGB format. </p><p> Developers are encouraged to use media type attributes instead of using the <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure. See Media Type Attributes. </p><p> In general, you should avoid calling this function. If you know all of the format details, you can fill in the <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure without this function. If you do not know all of the format details, attributes are preferable to using the <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure. </p><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFInitVideoFormat_RGB']/*"/>	
        /// <msdn-id>aa473797</msdn-id>	
        /// <unmanaged>HRESULT MFInitVideoFormat_RGB([In] MFVIDEOFORMAT* pVideoFormat,[In] unsigned int dwWidth,[In] unsigned int dwHeight,[In] unsigned int D3Dfmt)</unmanaged>	
        /// <unmanaged-short>MFInitVideoFormat_RGB</unmanaged-short>	
        public static void InitVideoFormatRgb(ref SharpDX.MediaFoundation.VideoFormat videoFormatRef, int dwWidth, int dwHeight, int d3Dfmt)
        {
            unsafe
            {
                var videoFormatRef_ = new SharpDX.MediaFoundation.VideoFormat.__Native();
                videoFormatRef.__MarshalTo(ref videoFormatRef_);
                SharpDX.Result __result__;
                __result__ =
                MFInitVideoFormat_RGB_(&videoFormatRef_, dwWidth, dwHeight, d3Dfmt);
                videoFormatRef.__MarshalFree(ref videoFormatRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFInitVideoFormat_RGB", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFInitVideoFormat_RGB_(void* arg0, int arg1, int arg2, int arg3);

        /// <summary>	
        /// <p>[This API is not supported and may be altered or unavailable in the future. Applications should avoid using the <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure, and use media type attributes instead. For more information, see Extended Color Information.]</p><p> Converts the extended color information from an <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> to the equivalent DirectX Video Acceleration (DXVA) color information. </p>	
        /// </summary>	
        /// <param name="dwToDXVARef">No documentation.</param>	
        /// <param name="fromFormatRef">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFConvertColorInfoToDXVA']/*"/>	
        /// <msdn-id>bb970405</msdn-id>	
        /// <unmanaged>HRESULT MFConvertColorInfoToDXVA([Out] unsigned int* pdwToDXVA,[In] const MFVIDEOFORMAT* pFromFormat)</unmanaged>	
        /// <unmanaged-short>MFConvertColorInfoToDXVA</unmanaged-short>	
        public static void ConvertColorInfoToDXVA(out int dwToDXVARef, ref SharpDX.MediaFoundation.VideoFormat fromFormatRef)
        {
            unsafe
            {
                var fromFormatRef_ = new SharpDX.MediaFoundation.VideoFormat.__Native();
                fromFormatRef.__MarshalTo(ref fromFormatRef_);
                SharpDX.Result __result__;
                fixed (void* dwToDXVARef_ = &dwToDXVARef)
                    __result__ =
                    MFConvertColorInfoToDXVA_(dwToDXVARef_, &fromFormatRef_);
                fromFormatRef.__MarshalFree(ref fromFormatRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFConvertColorInfoToDXVA", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFConvertColorInfoToDXVA_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>[This API is not supported and may be altered or unavailable in the future. Applications should avoid using the <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure, and use media type attributes instead. For more information, see Extended Color Information.]</p><p> Sets the extended color information in a <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure.</p>	
        /// </summary>	
        /// <param name="toFormatRef">No documentation.</param>	
        /// <param name="dwFromDXVA">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function sets the following fields in the <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> structure.</p><ul> <li><strong>videoInfo.<see cref="SharpDX.MediaFoundation.NominalRange"/></strong></li> <li><strong>videoInfo.<see cref="SharpDX.MediaFoundation.VideoLighting"/></strong></li> <li><strong>videoInfo.<see cref="SharpDX.MediaFoundation.VideoPrimaries"/></strong></li> <li><strong>videoInfo.<see cref="SharpDX.MediaFoundation.VideoTransferFunction"/></strong></li> <li><strong>videoInfo.<see cref="SharpDX.MediaFoundation.VideoTransferMatrix"/></strong></li> <li><strong>videoInfo.SourceChromaSubsampling</strong></li> </ul><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFConvertColorInfoFromDXVA']/*"/>	
        /// <msdn-id>bb970494</msdn-id>	
        /// <unmanaged>HRESULT MFConvertColorInfoFromDXVA([InOut] MFVIDEOFORMAT* pToFormat,[In] unsigned int dwFromDXVA)</unmanaged>	
        /// <unmanaged-short>MFConvertColorInfoFromDXVA</unmanaged-short>	
        public static void ConvertColorInfoFromDXVA(ref SharpDX.MediaFoundation.VideoFormat toFormatRef, int dwFromDXVA)
        {
            unsafe
            {
                var toFormatRef_ = new SharpDX.MediaFoundation.VideoFormat.__Native();
                toFormatRef.__MarshalTo(ref toFormatRef_);
                SharpDX.Result __result__;
                __result__ =
                MFConvertColorInfoFromDXVA_(&toFormatRef_, dwFromDXVA);
                toFormatRef.__MarshalFrom(ref toFormatRef_);
                toFormatRef.__MarshalFree(ref toFormatRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFConvertColorInfoFromDXVA", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFConvertColorInfoFromDXVA_(void* arg0, int arg1);

        /// <summary>	
        /// <p> Copies an image or image plane from one buffer to another. </p>	
        /// </summary>	
        /// <param name="destRef"><dd> <p> Pointer to the start of the first row of pixels in the destination buffer. </p> </dd></param>	
        /// <param name="lDestStride"><dd> <p> Stride of the destination buffer, in bytes. </p> </dd></param>	
        /// <param name="srcRef"><dd> <p> Pointer to the start of the first row of pixels in the source image. </p> </dd></param>	
        /// <param name="lSrcStride"><dd> <p> Stride of the source image, in bytes. </p> </dd></param>	
        /// <param name="dwWidthInBytes"><dd> <p> Width of the image, in bytes. </p> </dd></param>	
        /// <param name="dwLines"><dd> <p> Number of rows of pixels to copy. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This function copies a single plane of the image. For planar YUV formats, you must call the function once for each plane. In this case, <em>pDest</em> and <em>pSrc</em> must point to the start of each plane. </p><p> This function is optimized if the MMX, SSE, or SSE2 instruction sets are available on the processor. The function performs a non-temporal store (the data is written to memory directly without polluting the cache). </p><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCopyImage']/*"/>	
        /// <msdn-id>bb970554</msdn-id>	
        /// <unmanaged>HRESULT MFCopyImage([Out, Buffer] unsigned char* pDest,[In] int lDestStride,[In, Buffer] const unsigned char* pSrc,[In] int lSrcStride,[In] unsigned int dwWidthInBytes,[In] unsigned int dwLines)</unmanaged>	
        /// <unmanaged-short>MFCopyImage</unmanaged-short>	
        public static void CopyImage(byte[] destRef, int lDestStride, byte[] srcRef, int lSrcStride, int dwWidthInBytes, int dwLines)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* destRef_ = destRef)
                fixed (void* srcRef_ = srcRef)
                    __result__ =
                    MFCopyImage_(destRef_, lDestStride, srcRef_, lSrcStride, dwWidthInBytes, dwLines);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCopyImage", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCopyImage_(void* arg0, int arg1, void* arg2, int arg3, int arg4, int arg5);

        /// <summary>	
        /// <p> Converts an array of 16-bit floating-point numbers into an array of 32-bit floating-point numbers. </p>	
        /// </summary>	
        /// <param name="destRef"><dd> <p> Pointer to an array of <strong>float</strong> values. The array must contain at least <em>dwCount</em> elements. </p> </dd></param>	
        /// <param name="srcRef"><dd> <p> Pointer to an array of 16-bit floating-point values, typed as <strong>WORD</strong> values. The array must contain at least <em>dwCount</em> elements. </p> </dd></param>	
        /// <param name="dwCount"><dd> <p> Number of elements in the <em>pSrc</em> array to convert. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The function converts <em>dwCount</em> values in the <em>pSrc</em> array and writes them into the <em>pDest</em> array. </p><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFConvertFromFP16Array']/*"/>	
        /// <msdn-id>bb970412</msdn-id>	
        /// <unmanaged>HRESULT MFConvertFromFP16Array([Out, Buffer] float* pDest,[In, Buffer] const unsigned short* pSrc,[In] unsigned int dwCount)</unmanaged>	
        /// <unmanaged-short>MFConvertFromFP16Array</unmanaged-short>	
        public static void ConvertFromFP16Array(float[] destRef, short[] srcRef, int dwCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* destRef_ = destRef)
                fixed (void* srcRef_ = srcRef)
                    __result__ =
                    MFConvertFromFP16Array_(destRef_, srcRef_, dwCount);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFConvertFromFP16Array", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFConvertFromFP16Array_(void* arg0, void* arg1, int arg2);

        /// <summary>	
        /// <p> Converts an array of 32-bit floating-point numbers into an array of 16-bit floating-point numbers. </p>	
        /// </summary>	
        /// <param name="destRef"><dd> <p>Pointer to an array of 16-bit floating-point values, typed as <strong>WORD</strong> values. The array must contain at least <em>dwCount</em> elements.</p> </dd></param>	
        /// <param name="srcRef"><dd> <p>Pointer to an array of <strong>float</strong> values. The array must contain at least <em>dwCount</em> elements.</p> </dd></param>	
        /// <param name="dwCount"><dd> <p>Number of elements in the <em>pSrc</em> array to convert.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The function converts the values in the <em>pSrc</em> array and writes them into the <em>pDest</em> array. </p><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFConvertToFP16Array']/*"/>	
        /// <msdn-id>aa473816</msdn-id>	
        /// <unmanaged>HRESULT MFConvertToFP16Array([Out, Buffer] unsigned short* pDest,[In, Buffer] const float* pSrc,[In] unsigned int dwCount)</unmanaged>	
        /// <unmanaged-short>MFConvertToFP16Array</unmanaged-short>	
        public static void ConvertToFP16Array(short[] destRef, float[] srcRef, int dwCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* destRef_ = destRef)
                fixed (void* srcRef_ = srcRef)
                    __result__ =
                    MFConvertToFP16Array_(destRef_, srcRef_, dwCount);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFConvertToFP16Array", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFConvertToFP16Array_(void* arg0, void* arg1, int arg2);

        /// <summary>	
        /// <p>Creates a system-memory buffer object to hold 2D image data.</p>	
        /// </summary>	
        /// <param name="dwWidth"><dd> <p>Width of the image, in pixels. </p> </dd></param>	
        /// <param name="dwHeight"><dd> <p>Height of the image, in pixels.</p> </dd></param>	
        /// <param name="dwFourCC"><dd> <p>A <strong>FOURCC</strong> code or D3DFORMAT value that specifies the video format. If you have a video subtype <see cref="System.Guid"/>, you can use the first <strong>DWORD</strong> of the subtype. </p> </dd></param>	
        /// <param name="fBottomUp"><dd> <p>If <strong>TRUE,</strong> the buffer's <strong><see cref="SharpDX.MediaFoundation.Buffer2D.ContiguousCopyTo"/></strong> method copies the buffer into a bottom-up format. The bottom-up format is compatible with GDI for uncompressed RGB images. If this parameter is <strong><see cref="SharpDX.Result.False"/></strong>, the <strong>ContiguousCopyTo</strong> method copies the buffer into a top-down format, which is compatible with DirectX.  </p> <p>For more information about top-down versus bottom-up images, see Image Stride. </p> </dd></param>	
        /// <param name="bufferOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface.</p> </dd></param>	
        /// <returns><p>This function can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidMediaType"/></strong></dt> </dl> </td><td> <p>Unrecognized video format.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The returned buffer object also exposes the <strong><see cref="SharpDX.MediaFoundation.Buffer2D2"/></strong> interface.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreate2DMediaBuffer']/*"/>	
        /// <msdn-id>hh162746</msdn-id>	
        /// <unmanaged>HRESULT MFCreate2DMediaBuffer([In] unsigned int dwWidth,[In] unsigned int dwHeight,[In] unsigned int dwFourCC,[In] BOOL fBottomUp,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>	
        /// <unmanaged-short>MFCreate2DMediaBuffer</unmanaged-short>	
        public static void Create2DMediaBuffer(int dwWidth, int dwHeight, int dwFourCC, SharpDX.Mathematics.Interop.RawBool fBottomUp, out SharpDX.MediaFoundation.MediaBuffer bufferOut)
        {
            unsafe
            {
                IntPtr bufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreate2DMediaBuffer_(dwWidth, dwHeight, dwFourCC, fBottomUp, &bufferOut_);
                bufferOut = (bufferOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaBuffer(bufferOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreate2DMediaBuffer", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreate2DMediaBuffer_(int arg0, int arg1, int arg2, SharpDX.Mathematics.Interop.RawBool arg3, void* arg4);

        /// <summary>	
        /// <p>Allocates a system-memory buffer that is optimal for a specified media type.</p>	
        /// </summary>	
        /// <param name="mediaTypeRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type.</p> </dd></param>	
        /// <param name="llDuration"><dd> <p>The sample duration. This value is required for audio formats.</p> </dd></param>	
        /// <param name="dwMinLength"><dd> <p>The minimum size of the buffer, in bytes. The actual buffer size might be larger. Specify zero to allocate the default buffer size for the media type.</p> </dd></param>	
        /// <param name="dwMinAlignment"><dd> <p>The minimum memory alignment for the buffer. Specify zero to use the default memory alignment.</p> </dd></param>	
        /// <param name="bufferOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>For video formats, if the format is recognized, the function creates a 2-D buffer that implements the <strong><see cref="SharpDX.MediaFoundation.Buffer2D2"/></strong> interface. Otherwise it creates a linear buffer. To get the  <strong><see cref="SharpDX.MediaFoundation.Buffer2D2"/></strong> interface, call <strong>QueryInterface</strong> on the reference returned in <em>ppBuffer</em>. If the <strong>QueryInterface</strong> method fails, use the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface to access the buffer memory.</p><p>For audio formats, the function allocates a buffer that is large enough to contain <em>llDuration</em> audio samples, or <em>dwMinLength</em>, whichever is larger.</p><p>This function always allocates system memory. For Direct3D surfaces, use the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDXGISurfaceBuffer"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDXSurfaceBuffer"/></strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMediaBufferFromMediaType']/*"/>	
        /// <msdn-id>hh162752</msdn-id>	
        /// <unmanaged>HRESULT MFCreateMediaBufferFromMediaType([In] IMFMediaType* pMediaType,[In] longlong llDuration,[In] unsigned int dwMinLength,[In] unsigned int dwMinAlignment,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>	
        /// <unmanaged-short>MFCreateMediaBufferFromMediaType</unmanaged-short>	
        public static void CreateMediaBufferFromMediaType(SharpDX.MediaFoundation.MediaType mediaTypeRef, long llDuration, int dwMinLength, int dwMinAlignment, out SharpDX.MediaFoundation.MediaBuffer bufferOut)
        {
            unsafe
            {
                IntPtr bufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMediaBufferFromMediaType_((void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), llDuration, dwMinLength, dwMinAlignment, &bufferOut_);
                bufferOut = (bufferOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaBuffer(bufferOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateMediaBufferFromMediaType", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMediaBufferFromMediaType_(void* arg0, long arg1, int arg2, int arg3, void* arg4);

        /// <summary>	
        /// <p> </p><p>Creates an empty collection object.</p>	
        /// </summary>	
        /// <param name="iMFCollectionOut"><dd> <p>Receives a reference to the collection object's <strong><see cref="SharpDX.MediaFoundation.Collection"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateCollection']/*"/>	
        /// <msdn-id>ms698852</msdn-id>	
        /// <unmanaged>HRESULT MFCreateCollection([Out] IMFCollection** ppIMFCollection)</unmanaged>	
        /// <unmanaged-short>MFCreateCollection</unmanaged-short>	
        public static void CreateCollection(out SharpDX.MediaFoundation.Collection iMFCollectionOut)
        {
            unsafe
            {
                IntPtr iMFCollectionOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateCollection_(&iMFCollectionOut_);
                iMFCollectionOut = (iMFCollectionOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Collection(iMFCollectionOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateCollection", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateCollection_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Allocates a block of memory.</p>	
        /// </summary>	
        /// <param name="nSize"><dd> <p>Number of bytes to allocate.</p> </dd></param>	
        /// <param name="dwFlags"><dd> <p>Zero or more flags. For a list of valid flags, see <strong>HeapAlloc</strong> in the Windows SDK documentation.</p> </dd></param>	
        /// <param name="szFileRef"><dd> <p> Reserved. Set to <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="line"><dd> <p> Reserved. Set to zero. </p> </dd></param>	
        /// <param name="eat"><dd> <p> Reserved. Set to <strong>eAllocationTypeIgnore</strong>. </p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns a reference to the allocated memory block. If the function fails, it returns <strong><c>null</c></strong>.</p></returns>	
        /// <remarks>	
        /// <p>In the current version of Media Foundation, this function is equivalent to calling the <strong>HeapAlloc</strong> function and specifying the heap of the calling process.</p><p>To free the allocated memory, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.HeapFree"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFHeapAlloc']/*"/>	
        /// <msdn-id>aa473790</msdn-id>	
        /// <unmanaged>void* MFHeapAlloc([In] unsigned int nSize,[In] unsigned int dwFlags,[In, Optional] char* pszFile,[In] int line,[In] EAllocationType eat)</unmanaged>	
        /// <unmanaged-short>MFHeapAlloc</unmanaged-short>	
        public static System.IntPtr HeapAlloc(int nSize, int dwFlags, string szFileRef, int line, SharpDX.MediaFoundation.EAllocationType eat)
        {
            unsafe
            {
                IntPtr szFileRef_ = Utilities.StringToHGlobalAnsi(szFileRef);
                System.IntPtr __result__;
                __result__ =
                MFHeapAlloc_(nSize, dwFlags, (void*)szFileRef_, line, unchecked((int)eat));
                Marshal.FreeHGlobal(szFileRef_);
                return __result__;
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFHeapAlloc", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern System.IntPtr MFHeapAlloc_(int arg0, int arg1, void* arg2, int arg3, int arg4);

        /// <summary>	
        /// <p> </p><p>Frees a block of memory that was allocated by calling the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.HeapAlloc"/></strong> function.</p>	
        /// </summary>	
        /// <param name="vRef">No documentation.</param>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFHeapFree']/*"/>	
        /// <msdn-id>aa473826</msdn-id>	
        /// <unmanaged>void MFHeapFree([In] void* pv)</unmanaged>	
        /// <unmanaged-short>MFHeapFree</unmanaged-short>	
        public static void HeapFree(System.IntPtr vRef)
        {
            unsafe
            {
                MFHeapFree_((void*)vRef);
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFHeapFree", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern void MFHeapFree_(void* arg0);

        /// <summary>	
        /// <p>Calculates ((a * b) + d) / c, where each term is a 64-bit signed value.</p>	
        /// </summary>	
        /// <param name="a"><dd> <p>A multiplier.</p> </dd></param>	
        /// <param name="b"><dd> <p>Another multiplier.</p> </dd></param>	
        /// <param name="c"><dd> <p>The divisor.</p> </dd></param>	
        /// <param name="d"><dd> <p>The rounding factor.</p> </dd></param>	
        /// <returns><p>Returns the result of the calculation. If numeric overflow occurs, the function returns _I64_MAX (positive overflow) or LLONG_MIN (negative overflow). If Mfplat.dll cannot be loaded, the function returns _I64_MAX.</p></returns>	
        /// <remarks>	
        /// <strong>Note</strong>??A previous version of this topic described the parameters incorrectly. The divisor is <em>c</em> and the rounding factor is <em>d</em>.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFllMulDiv']/*"/>	
        /// <msdn-id>dd388510</msdn-id>	
        /// <unmanaged>longlong MFllMulDiv([In] longlong a,[In] longlong b,[In] longlong c,[In] longlong d)</unmanaged>	
        /// <unmanaged-short>MFllMulDiv</unmanaged-short>	
        public static long LlMulDiv(long a, long b, long c, long d)
        {
            unsafe
            {
                long __result__;
                __result__ =
                MFllMulDiv_(a, b, c, d);
                return __result__;
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFllMulDiv", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern long MFllMulDiv_(long arg0, long arg1, long arg2, long arg3);

        /// <summary>	
        /// <p>Gets the class identifier for a content protection system.</p>	
        /// </summary>	
        /// <param name="guidProtectionSystemID"><dd> <p>The <see cref="System.Guid"/> that identifies the content protection system.</p> </dd></param>	
        /// <param name="clsidRef"><dd> <p>Receives the class identifier to the content protection system.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The class identifier can be used to create the input trust authority (ITA) for the content protection system. Call <strong>CoCreateInstance</strong> or <strong><see cref="SharpDX.MediaFoundation.PMPHost.CreateObjectByCLSID_"/></strong> to get an <strong><see cref="SharpDX.MediaFoundation.TrustedInput"/></strong> reference.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetContentProtectionSystemCLSID']/*"/>	
        /// <msdn-id>hh162766</msdn-id>	
        /// <unmanaged>HRESULT MFGetContentProtectionSystemCLSID([In] const GUID&amp; guidProtectionSystemID,[Out] GUID* pclsid)</unmanaged>	
        /// <unmanaged-short>MFGetContentProtectionSystemCLSID</unmanaged-short>	
        public static void GetContentProtectionSystemCLSID(System.Guid guidProtectionSystemID, out System.Guid clsidRef)
        {
            unsafe
            {
                clsidRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* clsidRef_ = &clsidRef)
                    __result__ =
                    MFGetContentProtectionSystemCLSID_(&guidProtectionSystemID, clsidRef_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFGetContentProtectionSystemCLSID", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetContentProtectionSystemCLSID_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> </p><p>Creates the Media Session in the application's process.</p>	
        /// </summary>	
        /// <param name="configurationRef">No documentation.</param>	
        /// <param name="mediaSessionOut">No documentation.</param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If your application does not play protected content, you can use this function to create the Media Session in the application's process. To use the Media Session for protected content, you must call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreatePMPMediaSession"/></strong>. </p><p> You can use the <em>pConfiguration</em> parameter to specify any of the following attributes: </p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaSessionAttributeKeys.GlobalTime"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaSessionAttributeKeys.QualityManager"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaSessionAttributeKeys.Topoloader"/></strong> </li> <li> <see cref="SharpDX.MediaFoundation.SinkWriterAttributeKeys.LowLatency"/> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMediaSession']/*"/>	
        /// <msdn-id>ms700174</msdn-id>	
        /// <unmanaged>HRESULT MFCreateMediaSession([In] IMFAttributes* pConfiguration,[Out] IMFMediaSession** ppMediaSession)</unmanaged>	
        /// <unmanaged-short>MFCreateMediaSession</unmanaged-short>	
        public static void CreateMediaSession(SharpDX.MediaFoundation.MediaAttributes configurationRef, out SharpDX.MediaFoundation.MediaSession mediaSessionOut)
        {
            unsafe
            {
                IntPtr mediaSessionOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMediaSession_((void*)((configurationRef == null) ? IntPtr.Zero : configurationRef.NativePointer), &mediaSessionOut_);
                mediaSessionOut = (mediaSessionOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSession(mediaSessionOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateMediaSession", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMediaSession_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> Creates an instance of the Media Session inside a Protected Media Path (PMP) process. </p>	
        /// </summary>	
        /// <param name="dwCreationFlags">No documentation.</param>	
        /// <param name="configurationRef">No documentation.</param>	
        /// <param name="mediaSessionOut">No documentation.</param>	
        /// <param name="enablerActivateOut">No documentation.</param>	
        /// <returns><p> The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You can use the <em>pConfiguration</em> parameter to set any of the following attributes:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaSessionAttributeKeys.ContentProtectionManager"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaSessionAttributeKeys.GlobalTime"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaSessionAttributeKeys.QualityManager"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaSessionAttributeKeys.RemoteSourceMode"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaSessionAttributeKeys.ServerContext"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaSessionAttributeKeys.Topoloader"/></strong> </li> </ul><p>If this function cannot create the PMP Media Session because a trusted binary was revoked, the <em>ppEnablerActivate</em> parameter receives an <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface reference. The application can use this reference to create a content enabler object, which can then be used to download an updated binary:</p><ol> <li> Call <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> with the interface identifier IID_IMFContentEnabler to get an <strong><see cref="SharpDX.MediaFoundation.ContentEnabler"/></strong> interface reference. </li> <li> Use that interface to download the updated binary. </li> <li> Call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreatePMPMediaSession"/></strong> again. </li> </ol><p>If the function successfully creates the PMP Media Session, the <em>ppEnablerActivate</em> parameter receives the value <strong><c>null</c></strong>.</p><p>Do not make calls to the PMP Media Session from a thread that is processing a window message sent from another thread. To test whether the current thread falls into this category, call <strong>InSendMessage</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreatePMPMediaSession']/*"/>	
        /// <msdn-id>ms703144</msdn-id>	
        /// <unmanaged>HRESULT MFCreatePMPMediaSession([In] unsigned int dwCreationFlags,[In] IMFAttributes* pConfiguration,[Out] IMFMediaSession** ppMediaSession,[Out, Optional] IMFActivate** ppEnablerActivate)</unmanaged>	
        /// <unmanaged-short>MFCreatePMPMediaSession</unmanaged-short>	
        public static void CreatePMPMediaSession(int dwCreationFlags, SharpDX.MediaFoundation.MediaAttributes configurationRef, out SharpDX.MediaFoundation.MediaSession mediaSessionOut, out SharpDX.MediaFoundation.Activate enablerActivateOut)
        {
            unsafe
            {
                IntPtr mediaSessionOut_ = IntPtr.Zero;
                IntPtr enablerActivateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreatePMPMediaSession_(dwCreationFlags, (void*)((configurationRef == null) ? IntPtr.Zero : configurationRef.NativePointer), &mediaSessionOut_, &enablerActivateOut_);
                mediaSessionOut = (mediaSessionOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSession(mediaSessionOut_);
                enablerActivateOut = (enablerActivateOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Activate(enablerActivateOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreatePMPMediaSession", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreatePMPMediaSession_(int arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p> Creates the source resolver, which is used to create a media source from a URL or byte stream. </p>	
        /// </summary>	
        /// <param name="iSourceResolverOut"><dd> <p>Receives a reference to the source resolver's <strong><see cref="SharpDX.MediaFoundation.SourceResolver"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <strong>Note</strong>??Prior to Windows?7, this function was exported from mf.dll. Starting in Windows?7, this function is exported from mfplat.dll, and mf.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateSourceResolver']/*"/>	
        /// <msdn-id>ms697433</msdn-id>	
        /// <unmanaged>HRESULT MFCreateSourceResolver([Out, Fast] IMFSourceResolver** ppISourceResolver)</unmanaged>	
        /// <unmanaged-short>MFCreateSourceResolver</unmanaged-short>	
        internal static void CreateSourceResolver(SharpDX.MediaFoundation.SourceResolver iSourceResolverOut)
        {
            unsafe
            {
                IntPtr iSourceResolverOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateSourceResolver_(&iSourceResolverOut_);
                ((SharpDX.MediaFoundation.SourceResolver)iSourceResolverOut).NativePointer = iSourceResolverOut_;
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateSourceResolver", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateSourceResolver_(void* arg0);

        /// <summary>	
        /// <p>[This API is not supported and may be altered or unavailable in the future. Instead, applications should use the <strong>PSCreateMemoryPropertyStore</strong> function to create property stores.]</p><p> Creates an empty property store object.</p>	
        /// </summary>	
        /// <param name="storeOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='CreatePropertyStore']/*"/>	
        /// <msdn-id>ms702984</msdn-id>	
        /// <unmanaged>HRESULT CreatePropertyStore([Out] IPropertyStore** ppStore)</unmanaged>	
        /// <unmanaged-short>CreatePropertyStore</unmanaged-short>	
        public static void CreatePropertyStore(out SharpDX.ComObject storeOut)
        {
            unsafe
            {
                IntPtr storeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                CreatePropertyStore_(&storeOut_);
                storeOut = (storeOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(storeOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Temp.dll", EntryPoint = "CreatePropertyStore", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int CreatePropertyStore_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Retrieves the URL schemes that are registered for the source resolver.</p>	
        /// </summary>	
        /// <param name="propVarSchemeArrayRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that receives the URL schemes. Before calling this method, call <strong>PropVariantInit</strong> to initialize the <strong><see cref="SharpDX.Win32.Variant"/></strong>. If the method succeeds, the <strong><see cref="SharpDX.Win32.Variant"/></strong> contains an array of wide-character strings. The <strong><see cref="SharpDX.Win32.Variant"/></strong> data type is VT_VECTOR | VT_LPWSTR. The caller must release the <strong><see cref="SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetSupportedSchemes']/*"/>	
        /// <msdn-id>ms702236</msdn-id>	
        /// <unmanaged>HRESULT MFGetSupportedSchemes([Out] PROPVARIANT* pPropVarSchemeArray)</unmanaged>	
        /// <unmanaged-short>MFGetSupportedSchemes</unmanaged-short>	
        public static void GetSupportedSchemes(out SharpDX.Win32.Variant propVarSchemeArrayRef)
        {
            unsafe
            {
                propVarSchemeArrayRef = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* propVarSchemeArrayRef_ = &propVarSchemeArrayRef)
                    __result__ =
                    MFGetSupportedSchemes_(propVarSchemeArrayRef_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFGetSupportedSchemes", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetSupportedSchemes_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Retrieves the MIME types that are registered for the source resolver.</p>	
        /// </summary>	
        /// <param name="propVarMimeTypeArrayRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that receives the MIME types. Before calling this method, call <strong>PropVariantInit</strong> to initialize the <strong><see cref="SharpDX.Win32.Variant"/></strong>. If the method succeeds, the <strong><see cref="SharpDX.Win32.Variant"/></strong> contains an array of wide-character strings. The <strong><see cref="SharpDX.Win32.Variant"/></strong> data type is VT_VECTOR | VT_LPWSTR. The caller must release the <strong><see cref="SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetSupportedMimeTypes']/*"/>	
        /// <msdn-id>ms699844</msdn-id>	
        /// <unmanaged>HRESULT MFGetSupportedMimeTypes([Out] PROPVARIANT* pPropVarMimeTypeArray)</unmanaged>	
        /// <unmanaged-short>MFGetSupportedMimeTypes</unmanaged-short>	
        public static void GetSupportedMimeTypes(out SharpDX.Win32.Variant propVarMimeTypeArrayRef)
        {
            unsafe
            {
                propVarMimeTypeArrayRef = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* propVarMimeTypeArrayRef_ = &propVarMimeTypeArrayRef)
                    __result__ =
                    MFGetSupportedMimeTypes_(propVarMimeTypeArrayRef_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFGetSupportedMimeTypes", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetSupportedMimeTypes_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Creates a topology object.</p>	
        /// </summary>	
        /// <param name="topoOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Topology"/></strong> interface of the topology object. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateTopology']/*"/>	
        /// <msdn-id>ms701584</msdn-id>	
        /// <unmanaged>HRESULT MFCreateTopology([Out] IMFTopology** ppTopo)</unmanaged>	
        /// <unmanaged-short>MFCreateTopology</unmanaged-short>	
        public static void CreateTopology(out SharpDX.MediaFoundation.Topology topoOut)
        {
            unsafe
            {
                IntPtr topoOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateTopology_(&topoOut_);
                topoOut = (topoOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Topology(topoOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateTopology", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateTopology_(void* arg0);

        /// <summary>	
        /// <p> Creates a topology node.</p>	
        /// </summary>	
        /// <param name="nodeType"><dd> <p> The type of node to create, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.TopologyType"/></strong> enumeration.</p> </dd></param>	
        /// <param name="nodeOut"><dd> <p> Receives a reference to the node's <strong><see cref="SharpDX.MediaFoundation.TopologyNode"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateTopologyNode']/*"/>	
        /// <msdn-id>ms697574</msdn-id>	
        /// <unmanaged>HRESULT MFCreateTopologyNode([In] MF_TOPOLOGY_TYPE NodeType,[Out] IMFTopologyNode** ppNode)</unmanaged>	
        /// <unmanaged-short>MFCreateTopologyNode</unmanaged-short>	
        public static void CreateTopologyNode(SharpDX.MediaFoundation.TopologyType nodeType, out SharpDX.MediaFoundation.TopologyNode nodeOut)
        {
            unsafe
            {
                IntPtr nodeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateTopologyNode_(unchecked((int)nodeType), &nodeOut_);
                nodeOut = (nodeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TopologyNode(nodeOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateTopologyNode", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateTopologyNode_(int arg0, void* arg1);

        /// <summary>	
        /// <p>Gets the media type for a stream associated with a topology node.</p>	
        /// </summary>	
        /// <param name="nodeRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.TopologyNode"/></strong> interface.</p> </dd></param>	
        /// <param name="dwStreamIndex"><dd> <p>The identifier of the stream to query. This parameter is interpreted as follows:</p> <ul> <li>Transform nodes: The value is the zero-based index of the input or output stream.</li> <li>All other node types: The value must be zero.</li> </ul> </dd></param>	
        /// <param name="fOutput"><dd> <p><strong>If TRUE</strong>, the function gets an output type<strong>. If <see cref="SharpDX.Result.False"/></strong>, the function gets an input type. This parameter is interpreted as follows:</p> <ul> <li>Output nodes: The value must be <strong>TRUE</strong>.</li> <li>Source nodes: The value must be <strong><see cref="SharpDX.Result.False"/></strong>.</li> <li>Tee nodes: The value is ignored.</li> <li>Transform nodes: If the value is <strong>TRUE</strong>, the <em>dwStreamIndex</em> parameter is the index for an output stream. Otherwise, <em>dwStreamIndex</em> is the index for an input stream.</li> </ul> </dd></param>	
        /// <param name="typeOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The stream index is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This function gets the actual media type from the object that is associated with the topology node. The <em>pNode</em> parameter should specify a node that belongs to a fully resolved topology.  If the node belongs to a partial topology, the function will probably fail. </p><p>Tee nodes do not have an associated object to query. For tee nodes, the function gets the node's input type, if available. Otherwise, if no input type is available, the function gets the media type of the node's primary output stream. The primary output stream is identified by the <strong><see cref="SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Primaryoutput"/></strong> attribute.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetTopoNodeCurrentType']/*"/>	
        /// <msdn-id>dd388509</msdn-id>	
        /// <unmanaged>HRESULT MFGetTopoNodeCurrentType([In] IMFTopologyNode* pNode,[In] unsigned int dwStreamIndex,[In] BOOL fOutput,[Out] IMFMediaType** ppType)</unmanaged>	
        /// <unmanaged-short>MFGetTopoNodeCurrentType</unmanaged-short>	
        public static void GetTopoNodeCurrentType(SharpDX.MediaFoundation.TopologyNode nodeRef, int dwStreamIndex, SharpDX.Mathematics.Interop.RawBool fOutput, out SharpDX.MediaFoundation.MediaType typeOut)
        {
            unsafe
            {
                IntPtr typeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFGetTopoNodeCurrentType_((void*)((nodeRef == null) ? IntPtr.Zero : nodeRef.NativePointer), dwStreamIndex, fOutput, &typeOut_);
                typeOut = (typeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(typeOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFGetTopoNodeCurrentType", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetTopoNodeCurrentType_(void* arg0, int arg1, SharpDX.Mathematics.Interop.RawBool arg2, void* arg3);

        /// <summary>	
        /// <p>Queries an object for a specified service interface.</p><p>This function is a helper function that wraps the <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> method. The function queries the object for the <strong><see cref="SharpDX.MediaFoundation.ServiceProvider"/></strong> interface and, if successful, calls <strong>GetService</strong> on the object.</p>	
        /// </summary>	
        /// <param name="unkObjectRef">No documentation.</param>	
        /// <param name="guidService">No documentation.</param>	
        /// <param name="riid">No documentation.</param>	
        /// <param name="vObjectOut">No documentation.</param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedService"/></strong></dt> </dl> </td><td> <p> The service requested cannot be found in the object represented by <em>punkObject</em>. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetService']/*"/>	
        /// <msdn-id>ms694284</msdn-id>	
        /// <unmanaged>HRESULT MFGetService([In] IUnknown* punkObject,[In] const GUID&amp; guidService,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>	
        /// <unmanaged-short>MFGetService</unmanaged-short>	
        public static void GetService(SharpDX.ComObject unkObjectRef, System.Guid guidService, System.Guid riid, out System.IntPtr vObjectOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vObjectOut_ = &vObjectOut)
                    __result__ =
                    MFGetService_((void*)((unkObjectRef == null) ? IntPtr.Zero : unkObjectRef.NativePointer), &guidService, &riid, vObjectOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFGetService", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetService_(void* arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p> Returns the system time. </p>	
        /// </summary>	
        /// <returns><p> Returns the system time, in 100-nanosecond units. </p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetSystemTime']/*"/>	
        /// <msdn-id>ms704625</msdn-id>	
        /// <unmanaged>longlong MFGetSystemTime()</unmanaged>	
        /// <unmanaged-short>MFGetSystemTime</unmanaged-short>	
        public static long GetSystemTime()
        {
            unsafe
            {
                long __result__;
                __result__ =
                MFGetSystemTime_();
                return __result__;
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFGetSystemTime", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern long MFGetSystemTime_();

        /// <summary>	
        /// <p>Creates the presentation clock. The presentation clock is used to schedule the time at which samples are rendered and to synchronize multiple streams.	
        /// </p>	
        /// </summary>	
        /// <param name="presentationClockOut"><dd> <p>Receives a reference to the clock's <strong><see cref="SharpDX.MediaFoundation.PresentationClock"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The caller must shut down the presentation clock by calling <strong><see cref="SharpDX.MediaFoundation.Shutdownable.Shutdown"/></strong> on the clock.</p><p>Typically applications do not create the presentation clock. The Media Session automatically creates the presentation clock. To get a reference to the presentation clock from the Media Session, call <strong><see cref="SharpDX.MediaFoundation.MediaSession.GetClock"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreatePresentationClock']/*"/>	
        /// <msdn-id>ms702174</msdn-id>	
        /// <unmanaged>HRESULT MFCreatePresentationClock([Out] IMFPresentationClock** ppPresentationClock)</unmanaged>	
        /// <unmanaged-short>MFCreatePresentationClock</unmanaged-short>	
        public static void CreatePresentationClock(out SharpDX.MediaFoundation.PresentationClock presentationClockOut)
        {
            unsafe
            {
                IntPtr presentationClockOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreatePresentationClock_(&presentationClockOut_);
                presentationClockOut = (presentationClockOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PresentationClock(presentationClockOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreatePresentationClock", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreatePresentationClock_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Creates a presentation time source that is based on the system time.</p>	
        /// </summary>	
        /// <param name="systemTimeSourceOut"><dd> <p>Receives a reference to the object's <strong><see cref="SharpDX.MediaFoundation.PresentationTimeSource"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateSystemTimeSource']/*"/>	
        /// <msdn-id>ms705610</msdn-id>	
        /// <unmanaged>HRESULT MFCreateSystemTimeSource([Out] IMFPresentationTimeSource** ppSystemTimeSource)</unmanaged>	
        /// <unmanaged-short>MFCreateSystemTimeSource</unmanaged-short>	
        public static void CreateSystemTimeSource(out SharpDX.MediaFoundation.PresentationTimeSource systemTimeSourceOut)
        {
            unsafe
            {
                IntPtr systemTimeSourceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateSystemTimeSource_(&systemTimeSourceOut_);
                systemTimeSourceOut = (systemTimeSourceOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PresentationTimeSource(systemTimeSourceOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateSystemTimeSource", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateSystemTimeSource_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Creates a presentation descriptor.</p>	
        /// </summary>	
        /// <param name="cStreamDescriptors"><dd> <p>Number of elements in the <em>apStreamDescriptors</em> array.</p> </dd></param>	
        /// <param name="apStreamDescriptors"><dd> <p>Array of <strong><see cref="SharpDX.MediaFoundation.StreamDescriptor"/></strong> interface references. Each reference represents a stream descriptor for one stream in the presentation.</p> </dd></param>	
        /// <param name="presentationDescriptorOut"><dd> <p>Receives a reference to an <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the presentation descriptor. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> If you are writing a custom media source, you can use this function to create the source presentation descriptor. The presentation descriptor is created with no streams selected. Generally, a media source should select at least one stream by default. To select a stream, call <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor.SelectStream"/></strong>. </p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreatePresentationDescriptor']/*"/>	
        /// <msdn-id>ms695404</msdn-id>	
        /// <unmanaged>HRESULT MFCreatePresentationDescriptor([In] unsigned int cStreamDescriptors,[In, Buffer, Optional] IMFStreamDescriptor** apStreamDescriptors,[Out] IMFPresentationDescriptor** ppPresentationDescriptor)</unmanaged>	
        /// <unmanaged-short>MFCreatePresentationDescriptor</unmanaged-short>	
        public static void CreatePresentationDescriptor(int cStreamDescriptors, SharpDX.MediaFoundation.StreamDescriptor[] apStreamDescriptors, out SharpDX.MediaFoundation.PresentationDescriptor presentationDescriptorOut)
        {
            unsafe
            {
                IntPtr* apStreamDescriptors_ = (IntPtr*)0;
                if (apStreamDescriptors != null)
                {
                    IntPtr* apStreamDescriptors__ = stackalloc IntPtr[apStreamDescriptors.Length];
                    apStreamDescriptors_ = apStreamDescriptors__;
                    for (int i = 0; i < apStreamDescriptors.Length; i++)
                        apStreamDescriptors_[i] = (apStreamDescriptors[i] == null) ? IntPtr.Zero : apStreamDescriptors[i].NativePointer;
                }
                IntPtr presentationDescriptorOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreatePresentationDescriptor_(cStreamDescriptors, apStreamDescriptors_, &presentationDescriptorOut_);
                presentationDescriptorOut = (presentationDescriptorOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PresentationDescriptor(presentationDescriptorOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreatePresentationDescriptor", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreatePresentationDescriptor_(int arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p> </p><p>Queries whether a media presentation requires the Protected Media Path (PMP).</p>	
        /// </summary>	
        /// <param name="presentationDescriptorRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of a presentation descriptor. The presentation descriptor is created by the media source, and describes the presentation.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>This presentation requires a protected environment.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>S_FALSE</strong></strong></dt> </dl> </td><td> <p>This presentation does not require a protected environment.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If this function returns <strong><see cref="SharpDX.Result.Ok"/></strong>, it means the PMP is required for this presentation. Call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreatePMPMediaSession"/></strong> to create the PMP session object.</p><p>If the function returns <strong>S_FALSE</strong>, you can use the unprotected pipeline. Call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateMediaSession"/></strong> to create the regular Media Session object.</p><p>Internally, this function checks whether any of the stream descriptors in the presentation have the <strong><see cref="SharpDX.MediaFoundation.StreamDescriptorAttributeKeys.Protected"/></strong> attribute with the value <strong>TRUE</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFRequireProtectedEnvironment']/*"/>	
        /// <msdn-id>ms697052</msdn-id>	
        /// <unmanaged>HRESULT MFRequireProtectedEnvironment([In] IMFPresentationDescriptor* pPresentationDescriptor)</unmanaged>	
        /// <unmanaged-short>MFRequireProtectedEnvironment</unmanaged-short>	
        public static void RequireProtectedEnvironment(SharpDX.MediaFoundation.PresentationDescriptor presentationDescriptorRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFRequireProtectedEnvironment_((void*)((presentationDescriptorRef == null) ? IntPtr.Zero : presentationDescriptorRef.NativePointer));
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFRequireProtectedEnvironment", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFRequireProtectedEnvironment_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Serializes a presentation descriptor to a byte array.</p>	
        /// </summary>	
        /// <param name="pDRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the presentation descriptor to serialize.</p> </dd></param>	
        /// <param name="cbDataRef"><dd> <p>Receives the size of the <em>ppbData</em> array, in bytes.</p> </dd></param>	
        /// <param name="bDataOut"><dd> <p>Receives a reference to an array of bytes containing the serialized presentation descriptor. The caller must free the memory for the array by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To deserialize the presentation descriptor, pass the byte array to the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.DeserializePresentationDescriptor"/></strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFSerializePresentationDescriptor']/*"/>	
        /// <msdn-id>ms705608</msdn-id>	
        /// <unmanaged>HRESULT MFSerializePresentationDescriptor([In] IMFPresentationDescriptor* pPD,[Out] unsigned int* pcbData,[Out, Buffer] unsigned char** ppbData)</unmanaged>	
        /// <unmanaged-short>MFSerializePresentationDescriptor</unmanaged-short>	
        public static void SerializePresentationDescriptor(SharpDX.MediaFoundation.PresentationDescriptor pDRef, out int cbDataRef, byte[] bDataOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cbDataRef_ = &cbDataRef)
                fixed (void* bDataOut_ = bDataOut)
                    __result__ =
                    MFSerializePresentationDescriptor_((void*)((pDRef == null) ? IntPtr.Zero : pDRef.NativePointer), cbDataRef_, bDataOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFSerializePresentationDescriptor", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFSerializePresentationDescriptor_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p> </p><p>Deserializes a presentation descriptor from a byte array.</p>	
        /// </summary>	
        /// <param name="cbData"><dd> <p>Size of the <em>pbData</em> array, in bytes.</p> </dd></param>	
        /// <param name="bDataRef"><dd> <p>Pointer to an array of bytes that contains the serialized presentation descriptor.</p> </dd></param>	
        /// <param name="pDOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the presentation descriptor. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFDeserializePresentationDescriptor']/*"/>	
        /// <msdn-id>ms697044</msdn-id>	
        /// <unmanaged>HRESULT MFDeserializePresentationDescriptor([In] unsigned int cbData,[In, Buffer] unsigned char* pbData,[Out] IMFPresentationDescriptor** ppPD)</unmanaged>	
        /// <unmanaged-short>MFDeserializePresentationDescriptor</unmanaged-short>	
        public static void DeserializePresentationDescriptor(int cbData, byte[] bDataRef, out SharpDX.MediaFoundation.PresentationDescriptor pDOut)
        {
            unsafe
            {
                IntPtr pDOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* bDataRef_ = bDataRef)
                    __result__ =
                    MFDeserializePresentationDescriptor_(cbData, bDataRef_, &pDOut_);
                pDOut = (pDOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PresentationDescriptor(pDOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFDeserializePresentationDescriptor", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFDeserializePresentationDescriptor_(int arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p> Creates a stream descriptor. </p>	
        /// </summary>	
        /// <param name="dwStreamIdentifier"><dd> <p> Stream identifier. </p> </dd></param>	
        /// <param name="cMediaTypes"><dd> <p> Number of elements in the <em>apMediaTypes</em> array. </p> </dd></param>	
        /// <param name="apMediaTypes"><dd> <p> Pointer to an array of <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface references. These references are used to initialize the media type handler for the stream descriptor. </p> </dd></param>	
        /// <param name="descriptorOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.StreamDescriptor"/></strong> interface of the new stream descriptor. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> If you are writing a custom media source, you can use this function to create stream descriptors for the source. This function automatically creates the stream descriptor media type handler and initializes it with the list of types given in <em>apMediaTypes</em>. The function does not set the current media type on the handler, however. To set the type, call <strong><see cref="SharpDX.MediaFoundation.MediaTypeHandler.SetCurrentMediaType"/></strong>. </p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateStreamDescriptor']/*"/>	
        /// <msdn-id>ms698990</msdn-id>	
        /// <unmanaged>HRESULT MFCreateStreamDescriptor([In] unsigned int dwStreamIdentifier,[In] unsigned int cMediaTypes,[In, Buffer] IMFMediaType** apMediaTypes,[Out] IMFStreamDescriptor** ppDescriptor)</unmanaged>	
        /// <unmanaged-short>MFCreateStreamDescriptor</unmanaged-short>	
        public static void CreateStreamDescriptor(int dwStreamIdentifier, int cMediaTypes, SharpDX.MediaFoundation.MediaType[] apMediaTypes, out SharpDX.MediaFoundation.StreamDescriptor descriptorOut)
        {
            unsafe
            {
                IntPtr* apMediaTypes_ = (IntPtr*)0;
                if (apMediaTypes != null)
                {
                    IntPtr* apMediaTypes__ = stackalloc IntPtr[apMediaTypes.Length];
                    apMediaTypes_ = apMediaTypes__;
                    for (int i = 0; i < apMediaTypes.Length; i++)
                        apMediaTypes_[i] = (apMediaTypes[i] == null) ? IntPtr.Zero : apMediaTypes[i].NativePointer;
                }
                IntPtr descriptorOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateStreamDescriptor_(dwStreamIdentifier, cMediaTypes, apMediaTypes_, &descriptorOut_);
                descriptorOut = (descriptorOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.StreamDescriptor(descriptorOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateStreamDescriptor", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateStreamDescriptor_(int arg0, int arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p> </p><p>Creates a media-type handler that supports a single media type at a time.</p>	
        /// </summary>	
        /// <param name="handlerOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaTypeHandler"/></strong> interface of the media-type handler. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The media-type handler created by this function supports one media type at a time. Set the media type by calling <strong><see cref="SharpDX.MediaFoundation.MediaTypeHandler.SetCurrentMediaType"/></strong>. After the type is set, <strong><see cref="SharpDX.MediaFoundation.MediaTypeHandler.IsMediaTypeSupported"/></strong> always checks against that type.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateSimpleTypeHandler']/*"/>	
        /// <msdn-id>ms696988</msdn-id>	
        /// <unmanaged>HRESULT MFCreateSimpleTypeHandler([Out] IMFMediaTypeHandler** ppHandler)</unmanaged>	
        /// <unmanaged-short>MFCreateSimpleTypeHandler</unmanaged-short>	
        public static void CreateSimpleTypeHandler(out SharpDX.MediaFoundation.MediaTypeHandler handlerOut)
        {
            unsafe
            {
                IntPtr handlerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateSimpleTypeHandler_(&handlerOut_);
                handlerOut = (handlerOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaTypeHandler(handlerOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateSimpleTypeHandler", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateSimpleTypeHandler_(void* arg0);

        /// <summary>	
        /// <p>Shuts down a Media Foundation object and releases all resources associated with the object.</p><p>This function is a helper function that wraps the <strong><see cref="SharpDX.MediaFoundation.Shutdownable.Shutdown"/></strong> method. The function queries the object for the <strong><see cref="SharpDX.MediaFoundation.Shutdownable"/></strong> interface and, if successful, calls <strong>Shutdown</strong> on the object.</p>	
        /// </summary>	
        /// <param name="unkRef">No documentation.</param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This function is not related to the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> function, which shuts down the Media Foundation platform, as described in Initializing Media Foundation. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFShutdownObject']/*"/>	
        /// <msdn-id>ms701968</msdn-id>	
        /// <unmanaged>HRESULT MFShutdownObject([In] IUnknown* pUnk)</unmanaged>	
        /// <unmanaged-short>MFShutdownObject</unmanaged-short>	
        public static void ShutdownObject(SharpDX.ComObject unkRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFShutdownObject_((void*)((unkRef == null) ? IntPtr.Zero : unkRef.NativePointer));
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFShutdownObject", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFShutdownObject_(void* arg0);

        /// <summary>	
        /// <p> Creates the Streaming Audio Renderer. </p>	
        /// </summary>	
        /// <param name="audioAttributesRef">No documentation.</param>	
        /// <param name="sinkOut">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To configure the audio renderer, set any of the following attributes on the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface specified in the <em>pAudioAttributes</em> parameter.</p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.AudioRendererAttributeKeys.EndpointId"/></strong> </td><td>The audio endpoint device identifier.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.AudioRendererAttributeKeys.EndpointRole"/></strong> </td><td>The audio endpoint role.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.AudioRendererAttributeKeys.Flags"/></strong> </td><td>Miscellaneous configuration flags.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.AudioRendererAttributeKeys.SessionId"/></strong> </td><td>The audio policy class.</td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.AudioRendererAttributeKeys.StreamCategory"/> </td><td>The audio stream category.</td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.SinkWriterAttributeKeys.LowLatency"/> </td><td>Enables low-latency audio streaming.</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateAudioRenderer']/*"/>	
        /// <msdn-id>ms701557</msdn-id>	
        /// <unmanaged>HRESULT MFCreateAudioRenderer([In] IMFAttributes* pAudioAttributes,[Out] IMFMediaSink** ppSink)</unmanaged>	
        /// <unmanaged-short>MFCreateAudioRenderer</unmanaged-short>	
        public static void CreateAudioRenderer(SharpDX.MediaFoundation.MediaAttributes audioAttributesRef, out SharpDX.MediaFoundation.MediaSink sinkOut)
        {
            unsafe
            {
                IntPtr sinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateAudioRenderer_((void*)((audioAttributesRef == null) ? IntPtr.Zero : audioAttributesRef.NativePointer), &sinkOut_);
                sinkOut = (sinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSink(sinkOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateAudioRenderer", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateAudioRenderer_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> </p><p>Creates an activation object for the Streaming Audio Renderer.</p>	
        /// </summary>	
        /// <param name="activateOut">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To create the audio renderer, call <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> on the retrieved <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> reference.</p><strong>Note</strong>??To avoid a memory leak, call <strong><see cref="SharpDX.MediaFoundation.Activate.ShutdownObject"/></strong> before releasing the final reference to the audio renderer or the audio renderer activate object.?<p>To configure the audio renderer, set any of the following attributes on the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> object before calling <strong>ActivateObject</strong>. (If you are using the Media Session, the Media Session automatically calls <strong>ActivateObject</strong> when you queue the topology.)</p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.AudioRendererAttributeKeys.EndpointId"/></strong> </td><td>The audio endpoint device identifier.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.AudioRendererAttributeKeys.EndpointRole"/></strong> </td><td>The audio endpoint role.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.AudioRendererAttributeKeys.Flags"/></strong> </td><td>Miscellaneous configuration flags.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.AudioRendererAttributeKeys.SessionId"/></strong> </td><td>The audio policy class.</td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.AudioRendererAttributeKeys.StreamCategory"/> </td><td>The audio stream category.</td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.SinkWriterAttributeKeys.LowLatency"/> </td><td>Enables low-latency audio streaming.</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateAudioRendererActivate']/*"/>	
        /// <msdn-id>ms702998</msdn-id>	
        /// <unmanaged>HRESULT MFCreateAudioRendererActivate([Out] IMFActivate** ppActivate)</unmanaged>	
        /// <unmanaged-short>MFCreateAudioRendererActivate</unmanaged-short>	
        public static void CreateAudioRendererActivate(out SharpDX.MediaFoundation.Activate activateOut)
        {
            unsafe
            {
                IntPtr activateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateAudioRendererActivate_(&activateOut_);
                activateOut = (activateOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Activate(activateOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateAudioRendererActivate", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateAudioRendererActivate_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Creates an activation object for the enhanced video renderer (EVR) media sink.</p>	
        /// </summary>	
        /// <param name="hwndVideo"><dd> <p>Handle to the window where the video will be displayed.</p> </dd></param>	
        /// <param name="activateOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface. Use this interface to create the EVR. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To create the EVR, call <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> on the retrieved <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> reference. (If you are using the Media Session, the Media Session automatically calls <strong>ActivateObject</strong> when you queue the topology.)</p><p>To configure the EVR, set any of the following attributes on the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> object before calling <strong>ActivateObject</strong>.</p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.EVRCustomVideoAttributeKeys.MixerActivate"/></strong> </td><td>Activation object for a custom mixer.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.EVRCustomVideoAttributeKeys.MixerClsid"/></strong> </td><td>CLSID for a custom mixer.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.EVRCustomVideoAttributeKeys.MixerFlags"/></strong> </td><td>Flags for creating a custom mixer.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.EVRCustomVideoAttributeKeys.PresenterActivate"/></strong> </td><td>Activation object for a custom presenter.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.EVRCustomVideoAttributeKeys.PresenterClsid"/></strong> </td><td>CLSID for a custom presenter.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.EVRCustomVideoAttributeKeys.PresenterFlags"/></strong> </td><td>Flags for creating a custom presenter.</td></tr> </table><p>?</p><p>When <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> is called, the activation objects sets the video window on the EVR by calling <strong><see cref="SharpDX.MediaFoundation.VideoDisplayControl.SetVideoPosition"/></strong>. Passing <strong><c>null</c></strong> for the <em>hwndVideo</em> parameter is not an error, but no video will render unless the EVR has a valid video window.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateVideoRendererActivate']/*"/>	
        /// <msdn-id>ms693543</msdn-id>	
        /// <unmanaged>HRESULT MFCreateVideoRendererActivate([In] HWND hwndVideo,[Out] IMFActivate** ppActivate)</unmanaged>	
        /// <unmanaged-short>MFCreateVideoRendererActivate</unmanaged-short>	
        public static void CreateVideoRendererActivate(System.IntPtr hwndVideo, out SharpDX.MediaFoundation.Activate activateOut)
        {
            unsafe
            {
                IntPtr activateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateVideoRendererActivate_((void*)hwndVideo, &activateOut_);
                activateOut = (activateOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Activate(activateOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateVideoRendererActivate", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateVideoRendererActivate_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Creates a media sink for authoring MP4 files.</p>	
        /// </summary>	
        /// <param name="iByteStreamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream.  The media sink writes the MP4 file to this byte stream. The byte stream must be writable and support seeking.</p> </dd></param>	
        /// <param name="videoMediaTypeRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of a video media type. This type specifies the format of the video stream.</p> <p>This parameter can be <strong><c>null</c></strong>, but not if <em>pAudioMediaType</em> is <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="audioMediaTypeRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of an audio media type. This type specifies the format of the audio stream.</p> <p>This parameter can be <strong><c>null</c></strong>, but not if <em>pVideoMediaType</em> is <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="iMediaSinkOut"><dd> <p>Receives a reference to the MP4 media sink's <strong><see cref="SharpDX.MediaFoundation.MediaSink"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The MP4 media sink supports a maximum of one video stream and one audio stream. The initial stream formats are given in the <em>pVideoMediaType</em> and <em>pAudioMediaType</em> parameters. To create an MP4 file with one stream, set the other stream type to <strong><c>null</c></strong>. For example, to create an audio-only file, set <em>pVideoMediaType</em> to <strong><c>null</c></strong>. </p><p>The number of streams is fixed when you create the media sink. The sink does not support the <strong><see cref="SharpDX.MediaFoundation.MediaSink.AddStreamSink"/></strong> method.</p><p>To author 3GP files, use the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Create3GPMediaSink"/></strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMPEG4MediaSink']/*"/>	
        /// <msdn-id>dd388100</msdn-id>	
        /// <unmanaged>HRESULT MFCreateMPEG4MediaSink([In] IMFByteStream* pIByteStream,[In, Optional] IMFMediaType* pVideoMediaType,[In, Optional] IMFMediaType* pAudioMediaType,[Out] IMFMediaSink** ppIMediaSink)</unmanaged>	
        /// <unmanaged-short>MFCreateMPEG4MediaSink</unmanaged-short>	
        public static void CreateMPEG4MediaSink(System.IntPtr iByteStreamRef, SharpDX.MediaFoundation.MediaType videoMediaTypeRef, SharpDX.MediaFoundation.MediaType audioMediaTypeRef, out SharpDX.MediaFoundation.MediaSink iMediaSinkOut)
        {
            unsafe
            {
                IntPtr iMediaSinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMPEG4MediaSink_((void*)iByteStreamRef, (void*)((videoMediaTypeRef == null) ? IntPtr.Zero : videoMediaTypeRef.NativePointer), (void*)((audioMediaTypeRef == null) ? IntPtr.Zero : audioMediaTypeRef.NativePointer), &iMediaSinkOut_);
                iMediaSinkOut = (iMediaSinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSink(iMediaSinkOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateMPEG4MediaSink", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMPEG4MediaSink_(void* arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p>Creates a media sink for authoring 3GP files.</p>	
        /// </summary>	
        /// <param name="iByteStreamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream.  The media sink writes the 3GP file to this byte stream. The byte stream must be writable and support seeking.</p> </dd></param>	
        /// <param name="videoMediaTypeRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of a video media type. This type specifies the format of the video stream.</p> <p>This parameter can be <strong><c>null</c></strong>, but not if <em>pAudioMediaType</em> is <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="audioMediaTypeRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of an audio media type. This type specifies the format of the audio stream.</p> <p>This parameter can be <strong><c>null</c></strong>, but not if <em>pVideoMediaType</em> is <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="iMediaSinkOut"><dd> <p>Receives a reference to the 3GP media sink's <strong><see cref="SharpDX.MediaFoundation.MediaSink"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The 3GP media sink supports a maximum of one video stream and one audio stream. The initial stream formats are given in the <em>pVideoMediaType</em> and <em>pAudioMediaType</em> parameters. To create an MP4 file with one stream, set the other stream type to <strong><c>null</c></strong>. For example, to create an audio-only file, set <em>pVideoMediaType</em> to <strong><c>null</c></strong>. </p><p>The number of streams is fixed when you create the media sink. The sink does not support the <strong><see cref="SharpDX.MediaFoundation.MediaSink.AddStreamSink"/></strong> method.</p><p>To author MP4 files, use the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateMPEG4MediaSink"/></strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreate3GPMediaSink']/*"/>	
        /// <msdn-id>dd388084</msdn-id>	
        /// <unmanaged>HRESULT MFCreate3GPMediaSink([In] IMFByteStream* pIByteStream,[In, Optional] IMFMediaType* pVideoMediaType,[In, Optional] IMFMediaType* pAudioMediaType,[Out] IMFMediaSink** ppIMediaSink)</unmanaged>	
        /// <unmanaged-short>MFCreate3GPMediaSink</unmanaged-short>	
        public static void Create3GPMediaSink(System.IntPtr iByteStreamRef, SharpDX.MediaFoundation.MediaType videoMediaTypeRef, SharpDX.MediaFoundation.MediaType audioMediaTypeRef, out SharpDX.MediaFoundation.MediaSink iMediaSinkOut)
        {
            unsafe
            {
                IntPtr iMediaSinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreate3GPMediaSink_((void*)iByteStreamRef, (void*)((videoMediaTypeRef == null) ? IntPtr.Zero : videoMediaTypeRef.NativePointer), (void*)((audioMediaTypeRef == null) ? IntPtr.Zero : audioMediaTypeRef.NativePointer), &iMediaSinkOut_);
                iMediaSinkOut = (iMediaSinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSink(iMediaSinkOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreate3GPMediaSink", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreate3GPMediaSink_(void* arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p>Creates the MP3 media sink.</p>	
        /// </summary>	
        /// <param name="targetByteStreamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream.  The media sink writes the MP3 file to this byte stream. The byte stream must be writable.</p> </dd></param>	
        /// <param name="mediaSinkOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaSink"/></strong> interface of the MP3 media sink.. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The MP3  media sink takes compressed MP3	
        /// audio samples as input, and writes an MP3 file with ID3 headers as output. The MP3 media sink does not perform MP3 audio encoding. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMP3MediaSink']/*"/>	
        /// <msdn-id>dd388098</msdn-id>	
        /// <unmanaged>HRESULT MFCreateMP3MediaSink([In] IMFByteStream* pTargetByteStream,[Out] IMFMediaSink** ppMediaSink)</unmanaged>	
        /// <unmanaged-short>MFCreateMP3MediaSink</unmanaged-short>	
        public static void CreateMP3MediaSink(System.IntPtr targetByteStreamRef, out SharpDX.MediaFoundation.MediaSink mediaSinkOut)
        {
            unsafe
            {
                IntPtr mediaSinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMP3MediaSink_((void*)targetByteStreamRef, &mediaSinkOut_);
                mediaSinkOut = (mediaSinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSink(mediaSinkOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateMP3MediaSink", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMP3MediaSink_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Creates an instance of the AC-3 media sink.</p>	
        /// </summary>	
        /// <param name="targetByteStreamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. The media sink writes the AC-3 file to this byte stream. The byte stream must be writable. </p> </dd></param>	
        /// <param name="audioMediaTypeRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. This parameter specifies the media type for the AC-3 audio stream. The media type must contain the following attributes.</p> <table> <tr><th>Attribute</th><th>Value</th></tr> <tr><td> <see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.MajorType"/> </td><td><strong><see cref="SharpDX.MediaFoundation.MediaTypeGuids.Audio"/></strong></td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.Subtype"/> </td><td><strong><see cref="SharpDX.MediaFoundation.AudioFormatGuids.DolbyAc3"/></strong> or <strong><see cref="SharpDX.MediaFoundation.AudioFormatGuids.DolbyDDPlus"/></strong></td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="mediaSinkOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaSink"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The AC-3 media sink takes compressed AC-3 audio as input and writes the audio to the  byte stream without modification. The primary use for this media sink is to stream AC-3 audio over a network. The media sink does not perform AC-3 audio encoding.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateAC3MediaSink']/*"/>	
        /// <msdn-id>hh162747</msdn-id>	
        /// <unmanaged>HRESULT MFCreateAC3MediaSink([In] IMFByteStream* pTargetByteStream,[In] IMFMediaType* pAudioMediaType,[Out] IMFMediaSink** ppMediaSink)</unmanaged>	
        /// <unmanaged-short>MFCreateAC3MediaSink</unmanaged-short>	
        public static void CreateAC3MediaSink(System.IntPtr targetByteStreamRef, SharpDX.MediaFoundation.MediaType audioMediaTypeRef, out SharpDX.MediaFoundation.MediaSink mediaSinkOut)
        {
            unsafe
            {
                IntPtr mediaSinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateAC3MediaSink_((void*)targetByteStreamRef, (void*)((audioMediaTypeRef == null) ? IntPtr.Zero : audioMediaTypeRef.NativePointer), &mediaSinkOut_);
                mediaSinkOut = (mediaSinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSink(mediaSinkOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateAC3MediaSink", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateAC3MediaSink_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p>Creates an instance of the audio data transport stream (ADTS) media sink.</p>	
        /// </summary>	
        /// <param name="targetByteStreamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. The media sink writes the ADTS stream to this byte stream. The byte stream must be writable.</p> </dd></param>	
        /// <param name="audioMediaTypeRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. This parameter specifies the media type for the ADTS stream. The media type must contain the following attributes.</p> <table> <tr><th>Attribute</th><th>Value</th></tr> <tr><td> <see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.MajorType"/> </td><td><strong><see cref="SharpDX.MediaFoundation.MediaTypeGuids.Audio"/></strong></td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.Subtype"/> </td><td><strong><see cref="SharpDX.MediaFoundation.AudioFormatGuids.Aac"/></strong></td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.AacPayloadType"/> </td><td>0 (raw AAC) or 1 (ADTS)</td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="mediaSinkOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaSink"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The ADTS media sink converts Advanced Audio Coding (AAC) audio packets into an ADTS stream. The primary use for this media sink is to stream ADTS over a network. The output is not an audio file, but a stream of audio frames with ADTS headers.</p><p>The media sink can accept raw AAC frames (<see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.AacPayloadType"/> = 0) or ADTS packets (<see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.AacPayloadType"/> = 1). If the input is raw AAC, the media sink inserts an ADTS header at the start of each audio frame. If the input is ADTS packets, the media sink passes the packets through to the byte stream, without modification.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateADTSMediaSink']/*"/>	
        /// <msdn-id>hh162748</msdn-id>	
        /// <unmanaged>HRESULT MFCreateADTSMediaSink([In] IMFByteStream* pTargetByteStream,[In] IMFMediaType* pAudioMediaType,[Out] IMFMediaSink** ppMediaSink)</unmanaged>	
        /// <unmanaged-short>MFCreateADTSMediaSink</unmanaged-short>	
        public static void CreateADTSMediaSink(System.IntPtr targetByteStreamRef, SharpDX.MediaFoundation.MediaType audioMediaTypeRef, out SharpDX.MediaFoundation.MediaSink mediaSinkOut)
        {
            unsafe
            {
                IntPtr mediaSinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateADTSMediaSink_((void*)targetByteStreamRef, (void*)((audioMediaTypeRef == null) ? IntPtr.Zero : audioMediaTypeRef.NativePointer), &mediaSinkOut_);
                mediaSinkOut = (mediaSinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSink(mediaSinkOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateADTSMediaSink", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateADTSMediaSink_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p>Creates a generic media sink that wraps a multiplexer Microsoft Media Foundation transform (MFT).</p>	
        /// </summary>	
        /// <param name="guidOutputSubType"><dd> <p>The subtype <see cref="System.Guid"/> of the output type for the MFT.</p> </dd></param>	
        /// <param name="outputAttributesRef"><dd> <p>A list of format attributes for the MFT output type. This parameter is optional and can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="outputByteStreamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. The output from the MFT is written to this byte stream. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="muxSinkOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaSink"/></strong> interface of the media sink. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function attempts to find a multiplexer MFT that supports an output type with the following definition:</p><ul> <li>Major type: <strong><see cref="SharpDX.MediaFoundation.MediaTypeGuids.Stream"/></strong></li> <li>Subtype: <em>guidOutputSubType</em></li> <li>Additional format attributes (optional)</li> </ul><p>To provide a list of additional format attributes:</p><ol> <li>Call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAttributes"/></strong> to get an <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> reference.</li> <li>Use the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface to set the attributes. (See Media Type Attributes.)</li> <li>Pass the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> reference in the <em>pOutputAttributes</em> parameter.</li> </ol><p>The multiplexer MFT must be registered in the <strong><see cref="SharpDX.MediaFoundation.TransformCategoryGuids.Multiplexer"/></strong> category.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMuxSink']/*"/>	
        /// <msdn-id>hh162756</msdn-id>	
        /// <unmanaged>HRESULT MFCreateMuxSink([In] GUID guidOutputSubType,[In, Optional] IMFAttributes* pOutputAttributes,[In, Optional] IMFByteStream* pOutputByteStream,[Out] IMFMediaSink** ppMuxSink)</unmanaged>	
        /// <unmanaged-short>MFCreateMuxSink</unmanaged-short>	
        public static void CreateMuxSink(System.Guid guidOutputSubType, SharpDX.MediaFoundation.MediaAttributes outputAttributesRef, System.IntPtr outputByteStreamRef, out SharpDX.MediaFoundation.MediaSink muxSinkOut)
        {
            unsafe
            {
                IntPtr muxSinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMuxSink_(guidOutputSubType, (void*)((outputAttributesRef == null) ? IntPtr.Zero : outputAttributesRef.NativePointer), (void*)outputByteStreamRef, &muxSinkOut_);
                muxSinkOut = (muxSinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSink(muxSinkOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateMuxSink", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMuxSink_(System.Guid arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p>Creates a media sink for authoring fragmented MP4 files.</p>	
        /// </summary>	
        /// <param name="iByteStreamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream.  The media sink writes the MP4 file to this byte stream. The byte stream must be writable and support seeking.</p> </dd></param>	
        /// <param name="videoMediaTypeRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of a video media type. This type specifies the format of the video stream.</p> <p>This parameter can be <strong><c>null</c></strong>, but not if <em>pAudioMediaType</em> is <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="audioMediaTypeRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of an audio media type. This type specifies the format of the audio stream.</p> <p>This parameter can be <strong><c>null</c></strong>, but not if <em>pVideoMediaType</em> is <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="iMediaSinkOut"><dd> <p>Receives a reference to the MP4 media sink's <strong><see cref="SharpDX.MediaFoundation.MediaSink"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateFMPEG4MediaSink']/*"/>	
        /// <msdn-id>jj247578</msdn-id>	
        /// <unmanaged>HRESULT MFCreateFMPEG4MediaSink([In] IMFByteStream* pIByteStream,[In, Optional] IMFMediaType* pVideoMediaType,[In, Optional] IMFMediaType* pAudioMediaType,[Out] IMFMediaSink** ppIMediaSink)</unmanaged>	
        /// <unmanaged-short>MFCreateFMPEG4MediaSink</unmanaged-short>	
        public static void CreateFMPEG4MediaSink(System.IntPtr iByteStreamRef, SharpDX.MediaFoundation.MediaType videoMediaTypeRef, SharpDX.MediaFoundation.MediaType audioMediaTypeRef, out SharpDX.MediaFoundation.MediaSink iMediaSinkOut)
        {
            unsafe
            {
                IntPtr iMediaSinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateFMPEG4MediaSink_((void*)iByteStreamRef, (void*)((videoMediaTypeRef == null) ? IntPtr.Zero : videoMediaTypeRef.NativePointer), (void*)((audioMediaTypeRef == null) ? IntPtr.Zero : audioMediaTypeRef.NativePointer), &iMediaSinkOut_);
                iMediaSinkOut = (iMediaSinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSink(iMediaSinkOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateFMPEG4MediaSink", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateFMPEG4MediaSink_(void* arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p>Creates an Audio-Video Interleaved (AVI) Sink.</p>	
        /// </summary>	
        /// <param name="iByteStreamRef"><dd> <p>Pointer to the byte stream that will be used to write the AVI file.</p> </dd></param>	
        /// <param name="videoMediaTypeRef"><dd> <p>Pointer to the media type of the video input stream</p> </dd></param>	
        /// <param name="audioMediaTypeRef"><dd> <p>Pointer to the media type of the audio input stream</p> </dd></param>	
        /// <param name="iMediaSinkOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaSink"/></strong> Interface.  The caller must release this interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateAVIMediaSink']/*"/>	
        /// <msdn-id>dn302108</msdn-id>	
        /// <unmanaged>HRESULT MFCreateAVIMediaSink([In] IMFByteStream* pIByteStream,[In] IMFMediaType* pVideoMediaType,[In, Optional] IMFMediaType* pAudioMediaType,[Out] IMFMediaSink** ppIMediaSink)</unmanaged>	
        /// <unmanaged-short>MFCreateAVIMediaSink</unmanaged-short>	
        public static void CreateAVIMediaSink(System.IntPtr iByteStreamRef, SharpDX.MediaFoundation.MediaType videoMediaTypeRef, SharpDX.MediaFoundation.MediaType audioMediaTypeRef, out SharpDX.MediaFoundation.MediaSink iMediaSinkOut)
        {
            unsafe
            {
                IntPtr iMediaSinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateAVIMediaSink_((void*)iByteStreamRef, (void*)((videoMediaTypeRef == null) ? IntPtr.Zero : videoMediaTypeRef.NativePointer), (void*)((audioMediaTypeRef == null) ? IntPtr.Zero : audioMediaTypeRef.NativePointer), &iMediaSinkOut_);
                iMediaSinkOut = (iMediaSinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSink(iMediaSinkOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateAVIMediaSink", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateAVIMediaSink_(void* arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p> Creates an WAVE archive sink.  The WAVE archive sink takes	
        /// audio and writes it to an .wav file.	
        /// </p>	
        /// </summary>	
        /// <param name="targetByteStreamRef"><dd> <p> Pointer to the byte stream that will be used to write the .wav file.</p> </dd></param>	
        /// <param name="audioMediaTypeRef"><dd> <p>Pointer to the audio media type.</p> </dd></param>	
        /// <param name="mediaSinkOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaSink"/></strong> interface.  The caller must release this interface.</p> </dd></param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateWAVEMediaSink']/*"/>	
        /// <msdn-id>dn302112</msdn-id>	
        /// <unmanaged>HRESULT MFCreateWAVEMediaSink([In] IMFByteStream* pTargetByteStream,[In] IMFMediaType* pAudioMediaType,[Out] IMFMediaSink** ppMediaSink)</unmanaged>	
        /// <unmanaged-short>MFCreateWAVEMediaSink</unmanaged-short>	
        public static void CreateWAVEMediaSink(System.IntPtr targetByteStreamRef, SharpDX.MediaFoundation.MediaType audioMediaTypeRef, out SharpDX.MediaFoundation.MediaSink mediaSinkOut)
        {
            unsafe
            {
                IntPtr mediaSinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateWAVEMediaSink_((void*)targetByteStreamRef, (void*)((audioMediaTypeRef == null) ? IntPtr.Zero : audioMediaTypeRef.NativePointer), &mediaSinkOut_);
                mediaSinkOut = (mediaSinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSink(mediaSinkOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateWAVEMediaSink", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateWAVEMediaSink_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p> </p><p>Creates a new instance of the topology loader.</p>	
        /// </summary>	
        /// <param name="objOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.TopoLoader"/></strong> interface of the topology loader. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateTopoLoader']/*"/>	
        /// <msdn-id>ms694159</msdn-id>	
        /// <unmanaged>HRESULT MFCreateTopoLoader([Out] IMFTopoLoader** ppObj)</unmanaged>	
        /// <unmanaged-short>MFCreateTopoLoader</unmanaged-short>	
        public static void CreateTopoLoader(out SharpDX.MediaFoundation.TopoLoader objOut)
        {
            unsafe
            {
                IntPtr objOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateTopoLoader_(&objOut_);
                objOut = (objOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TopoLoader(objOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateTopoLoader", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateTopoLoader_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Creates an activation object for the sample grabber media sink.</p>	
        /// </summary>	
        /// <param name="iMFMediaTypeRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface, defining the media type for the sample grabber's input stream. </p> </dd></param>	
        /// <param name="iMFSampleGrabberSinkCallbackRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.SampleGrabberSinkCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>	
        /// <param name="iActivateOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface. Use this interface to complete the creation of the sample grabber. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To create the sample grabber sink, call <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> on the reference received in the <em>ppIActivate</em> parameter.</p><p>Before calling <strong>ActivateObject</strong>, you can configure the sample grabber by setting any of the following attributes on the <em>ppIActivate</em> reference:</p><ul> <li> <see cref="SharpDX.MediaFoundation.SampleGrabberSinkAttributeKeys.IgnoreClock"/> </li> <li> <strong><see cref="SharpDX.MediaFoundation.SampleGrabberSinkAttributeKeys.SampleTimeOffset"/></strong> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateSampleGrabberSinkActivate']/*"/>	
        /// <msdn-id>ms702068</msdn-id>	
        /// <unmanaged>HRESULT MFCreateSampleGrabberSinkActivate([In] IMFMediaType* pIMFMediaType,[In] IMFSampleGrabberSinkCallback* pIMFSampleGrabberSinkCallback,[Out] IMFActivate** ppIActivate)</unmanaged>	
        /// <unmanaged-short>MFCreateSampleGrabberSinkActivate</unmanaged-short>	
        internal static void CreateSampleGrabberSinkActivate(SharpDX.MediaFoundation.MediaType iMFMediaTypeRef, System.IntPtr iMFSampleGrabberSinkCallbackRef, out SharpDX.MediaFoundation.Activate iActivateOut)
        {
            unsafe
            {
                IntPtr iActivateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateSampleGrabberSinkActivate_((void*)((iMFMediaTypeRef == null) ? IntPtr.Zero : iMFMediaTypeRef.NativePointer), (void*)iMFSampleGrabberSinkCallbackRef, &iActivateOut_);
                iActivateOut = (iActivateOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Activate(iActivateOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateSampleGrabberSinkActivate", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateSampleGrabberSinkActivate_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p> </p><p>Creates the default implementation of the quality manager.</p>	
        /// </summary>	
        /// <param name="qualityManagerOut"><dd> <p>Receives a reference to the quality manager's <strong><see cref="SharpDX.MediaFoundation.QualityManager"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateStandardQualityManager']/*"/>	
        /// <msdn-id>ms701594</msdn-id>	
        /// <unmanaged>HRESULT MFCreateStandardQualityManager([Out] IMFQualityManager** ppQualityManager)</unmanaged>	
        /// <unmanaged-short>MFCreateStandardQualityManager</unmanaged-short>	
        public static void CreateStandardQualityManager(out SharpDX.MediaFoundation.QualityManager qualityManagerOut)
        {
            unsafe
            {
                IntPtr qualityManagerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateStandardQualityManager_(&qualityManagerOut_);
                qualityManagerOut = (qualityManagerOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.QualityManager(qualityManagerOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateStandardQualityManager", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateStandardQualityManager_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Creates the sequencer source.</p>	
        /// </summary>	
        /// <param name="reservedRef"><dd> <p>Reserved. Must be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="sequencerSourceOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.SequencerSource"/></strong> interface of the sequencer source. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateSequencerSource']/*"/>	
        /// <msdn-id>ms704663</msdn-id>	
        /// <unmanaged>HRESULT MFCreateSequencerSource([In] IUnknown* pReserved,[Out] IMFSequencerSource** ppSequencerSource)</unmanaged>	
        /// <unmanaged-short>MFCreateSequencerSource</unmanaged-short>	
        public static void CreateSequencerSource(SharpDX.ComObject reservedRef, out SharpDX.MediaFoundation.SequencerSource sequencerSourceOut)
        {
            unsafe
            {
                IntPtr sequencerSourceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateSequencerSource_((void*)((reservedRef == null) ? IntPtr.Zero : reservedRef.NativePointer), &sequencerSourceOut_);
                sequencerSourceOut = (sequencerSourceOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.SequencerSource(sequencerSourceOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateSequencerSource", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateSequencerSource_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> Creates a <strong><see cref="SharpDX.Win32.Variant"/></strong> that can be used to seek within a sequencer source presentation. </p>	
        /// </summary>	
        /// <param name="dwId"><dd> <p> Sequencer element identifier. This value specifies the segment in which to begin playback. The element identifier is returned in the <strong><see cref="SharpDX.MediaFoundation.SequencerSource.AppendTopology"/></strong> method. </p> </dd></param>	
        /// <param name="hnsOffset"><dd> <p> Starting position within the segment, in 100-nanosecond units. </p> </dd></param>	
        /// <param name="varSegmentOffsetRef"><dd> <p> Pointer to a <strong><see cref="SharpDX.Win32.Variant"/></strong>. The method fills in the <strong><see cref="SharpDX.Win32.Variant"/></strong> with the information needed for performing a seek operation. The caller must free the <strong><see cref="SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>. </p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The <strong><see cref="SharpDX.Win32.Variant"/></strong> returned in <em>pvarSegmentOffset</em> can be used for the <em>pvarStartPosition</em> parameter in the <strong><see cref="SharpDX.MediaFoundation.MediaSession.Start"/></strong> method. Use the time format <strong><see cref="System.Guid"/> MF_TIME_FORMAT_SEGMENT_OFFSET</strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateSequencerSegmentOffset']/*"/>	
        /// <msdn-id>ms697268</msdn-id>	
        /// <unmanaged>HRESULT MFCreateSequencerSegmentOffset([In] unsigned int dwId,[In] longlong hnsOffset,[Out] PROPVARIANT* pvarSegmentOffset)</unmanaged>	
        /// <unmanaged-short>MFCreateSequencerSegmentOffset</unmanaged-short>	
        public static void CreateSequencerSegmentOffset(int dwId, long hnsOffset, out SharpDX.Win32.Variant varSegmentOffsetRef)
        {
            unsafe
            {
                varSegmentOffsetRef = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* varSegmentOffsetRef_ = &varSegmentOffsetRef)
                    __result__ =
                    MFCreateSequencerSegmentOffset_(dwId, hnsOffset, varSegmentOffsetRef_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateSequencerSegmentOffset", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateSequencerSegmentOffset_(int arg0, long arg1, void* arg2);

        /// <summary>	
        /// <p>Creates a media source that aggregates a collection of media sources. </p>	
        /// </summary>	
        /// <param name="sourceCollectionRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.Collection"/></strong> interface of the collection object that contains a list of media sources. </p> </dd></param>	
        /// <param name="aggSourceOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaSource"/></strong> interface of the aggregated media source. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> The <em>pSourceCollection</em> collection does not contain any elements.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The aggregated media source is useful for combining  streams from separate media sources. For example, you can use it to  combine a video capture source and an audio capture source. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateAggregateSource']/*"/>	
        /// <msdn-id>dd388085</msdn-id>	
        /// <unmanaged>HRESULT MFCreateAggregateSource([In] IMFCollection* pSourceCollection,[Out] IMFMediaSource** ppAggSource)</unmanaged>	
        /// <unmanaged-short>MFCreateAggregateSource</unmanaged-short>	
        public static void CreateAggregateSource(SharpDX.MediaFoundation.Collection sourceCollectionRef, out SharpDX.MediaFoundation.MediaSource aggSourceOut)
        {
            unsafe
            {
                IntPtr aggSourceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateAggregateSource_((void*)((sourceCollectionRef == null) ? IntPtr.Zero : sourceCollectionRef.NativePointer), &aggSourceOut_);
                aggSourceOut = (aggSourceOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSource(aggSourceOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateAggregateSource", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateAggregateSource_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> </p><p>Creates a credential cache object. An application can use this object to implement a custom credential manager.</p>	
        /// </summary>	
        /// <param name="cacheOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.NetCredentialCache"/></strong> interface of the new credential cache object. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateCredentialCache']/*"/>	
        /// <msdn-id>ms704802</msdn-id>	
        /// <unmanaged>HRESULT MFCreateCredentialCache([Out] IMFNetCredentialCache** ppCache)</unmanaged>	
        /// <unmanaged-short>MFCreateCredentialCache</unmanaged-short>	
        public static void CreateCredentialCache(out SharpDX.MediaFoundation.NetCredentialCache cacheOut)
        {
            unsafe
            {
                IntPtr cacheOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateCredentialCache_(&cacheOut_);
                cacheOut = (cacheOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.NetCredentialCache(cacheOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateCredentialCache", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateCredentialCache_(void* arg0);

        /// <summary>	
        /// <p> </p><p>Creates a default proxy locator.</p>	
        /// </summary>	
        /// <param name="szProtocolRef"><dd> <p>The name of the protocol.</p> <strong>Note</strong>??In this release of Media Foundation, the default proxy locator does not support RTSP. ? </dd></param>	
        /// <param name="proxyConfigRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a property store that contains the proxy configuration in the <strong>MFNETSOURCE_PROXYSETTINGS</strong> property.</p> </dd></param>	
        /// <param name="proxyLocatorOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.NetProxyLocator"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateProxyLocator']/*"/>	
        /// <msdn-id>ms701595</msdn-id>	
        /// <unmanaged>HRESULT MFCreateProxyLocator([In] const wchar_t* pszProtocol,[In] IPropertyStore* pProxyConfig,[Out] IMFNetProxyLocator** ppProxyLocator)</unmanaged>	
        /// <unmanaged-short>MFCreateProxyLocator</unmanaged-short>	
        public static void CreateProxyLocator(string szProtocolRef, SharpDX.ComObject proxyConfigRef, out SharpDX.MediaFoundation.NetProxyLocator proxyLocatorOut)
        {
            unsafe
            {
                IntPtr proxyLocatorOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* szProtocolRef_ = szProtocolRef)
                    __result__ =
                    MFCreateProxyLocator_((void*)szProtocolRef_, (void*)((proxyConfigRef == null) ? IntPtr.Zero : proxyConfigRef.NativePointer), &proxyLocatorOut_);
                proxyLocatorOut = (proxyLocatorOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.NetProxyLocator(proxyLocatorOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateProxyLocator", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateProxyLocator_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p> </p><p>Creates the scheme handler for the network source.</p>	
        /// </summary>	
        /// <param name="riid"><dd> <p>Interface identifier (IID) of the interface to retrieve.</p> </dd></param>	
        /// <param name="vHandlerOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface. The scheme handler exposes the <strong><see cref="SharpDX.MediaFoundation.SchemeHandler"/></strong> interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateNetSchemePlugin']/*"/>	
        /// <msdn-id>aa378396</msdn-id>	
        /// <unmanaged>HRESULT MFCreateNetSchemePlugin([In] const GUID&amp; riid,[In] void** ppvHandler)</unmanaged>	
        /// <unmanaged-short>MFCreateNetSchemePlugin</unmanaged-short>	
        public static void CreateNetSchemePlugin(System.Guid riid, System.IntPtr vHandlerOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFCreateNetSchemePlugin_(&riid, (void*)vHandlerOut);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateNetSchemePlugin", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateNetSchemePlugin_(void* arg0, void* arg1);

        /// <summary>	
        /// <p> </p><p>Creates the protected media path (PMP) server object.</p>	
        /// </summary>	
        /// <param name="dwCreationFlags"><dd> <p>A member of the <strong><see cref="SharpDX.MediaFoundation.PmpsessionCreationFlags"/></strong> enumeration that specifies how to create the PMP session.</p> </dd></param>	
        /// <param name="pMPServerOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.PMPServer"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreatePMPServer']/*"/>	
        /// <msdn-id>ms696183</msdn-id>	
        /// <unmanaged>HRESULT MFCreatePMPServer([In] unsigned int dwCreationFlags,[Out] IMFPMPServer** ppPMPServer)</unmanaged>	
        /// <unmanaged-short>MFCreatePMPServer</unmanaged-short>	
        public static void CreatePMPServer(int dwCreationFlags, out SharpDX.MediaFoundation.PMPServer pMPServerOut)
        {
            unsafe
            {
                IntPtr pMPServerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreatePMPServer_(dwCreationFlags, &pMPServerOut_);
                pMPServerOut = (pMPServerOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PMPServer(pMPServerOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreatePMPServer", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreatePMPServer_(int arg0, void* arg1);

        /// <summary>	
        /// <p> </p><p>Creates the remote desktop plug-in object. Use this object if the application is running in a Terminal Services client session.</p>	
        /// </summary>	
        /// <param name="pluginOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.RemoteDesktopPlugin"/></strong> interface of the plug-in object. The caller must release the interface.</p> </dd></param>	
        /// <returns><p> The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_ACCESSDENIED</strong></dt> </dl> </td><td> <p>Remote desktop connections are not allowed by the current session policy.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateRemoteDesktopPlugin']/*"/>	
        /// <msdn-id>ms703133</msdn-id>	
        /// <unmanaged>HRESULT MFCreateRemoteDesktopPlugin([Out] IMFRemoteDesktopPlugin** ppPlugin)</unmanaged>	
        /// <unmanaged-short>MFCreateRemoteDesktopPlugin</unmanaged-short>	
        public static void CreateRemoteDesktopPlugin(out SharpDX.MediaFoundation.RemoteDesktopPlugin pluginOut)
        {
            unsafe
            {
                IntPtr pluginOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateRemoteDesktopPlugin_(&pluginOut_);
                pluginOut = (pluginOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.RemoteDesktopPlugin(pluginOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateRemoteDesktopPlugin", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateRemoteDesktopPlugin_(void* arg0);

        /// <summary>	
        /// <p>[This API is not supported and may be altered or unavailable in the future. Instead, applications should use the <strong>PSCreateMemoryPropertyStore</strong> function to create named property stores.]</p><p>Creates an empty property store to hold name/value pairs.</p>	
        /// </summary>	
        /// <param name="storeOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='CreateNamedPropertyStore']/*"/>	
        /// <msdn-id>aa367379</msdn-id>	
        /// <unmanaged>HRESULT CreateNamedPropertyStore([Out] INamedPropertyStore** ppStore)</unmanaged>	
        /// <unmanaged-short>CreateNamedPropertyStore</unmanaged-short>	
        public static void CreateNamedPropertyStore(out SharpDX.ComObject storeOut)
        {
            unsafe
            {
                IntPtr storeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                CreateNamedPropertyStore_(&storeOut_);
                storeOut = (storeOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(storeOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "CreateNamedPropertyStore", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int CreateNamedPropertyStore_(void* arg0);

        /// <summary>	
        /// <p>Creates an instance of the sample copier transform.</p>	
        /// </summary>	
        /// <param name="copierMFTOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The sample copier is a Media Foundation transform (MFT) that copies data from input samples to output samples without modifying the data. The following data is copied from the sample:</p><ul> <li>All Sample Attributes.</li> <li>The time stamp and duration.</li> <li>Sample flags (see <strong><see cref="SharpDX.MediaFoundation.Sample.SetSampleFlags"/></strong>).</li> <li>The data in the media buffers. If the input sample contains multiple buffers, the data is copied into a single buffer on the output sample.</li> </ul><p>This MFT is useful in the following situation:</p><ul> <li>One pipeline object, such as a media source, allocates media samples for output.</li> <li>Another pipeline object, such as a media sink, allocates its own media samples for input. For example, the object might require buffers allocated from a special memory pool, such as video memory.</li> </ul><p>The following diagram shows this situation with a media source and a media sink.</p><p></p><p>In order for the media sink to receive data from the media source, the data must be copied into the media samples owned by the media sink. The sample copier can be used for this purpose.</p><p>A specific example of such a media sink is the  Enhanced Video Renderer (EVR). The EVR allocates samples that contain Direct3D surface buffers, so it cannot receive video samples directly from a media source. Starting in Windows?7, the topology loader automatically handles this case by inserting the sample copier between the media source and the EVR.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateSampleCopierMFT']/*"/>	
        /// <msdn-id>dd388101</msdn-id>	
        /// <unmanaged>HRESULT MFCreateSampleCopierMFT([Out] IMFTransform** ppCopierMFT)</unmanaged>	
        /// <unmanaged-short>MFCreateSampleCopierMFT</unmanaged-short>	
        public static void CreateSampleCopierMFT(out SharpDX.MediaFoundation.Transform copierMFTOut)
        {
            unsafe
            {
                IntPtr copierMFTOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateSampleCopierMFT_(&copierMFTOut_);
                copierMFTOut = (copierMFTOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Transform(copierMFTOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateSampleCopierMFT", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateSampleCopierMFT_(void* arg0);

        /// <summary>	
        /// <p>Creates an empty transcode profile object.</p><p>The transcode profile stores configuration settings for the output file. These configuration settings are specified by the caller, and include audio and video stream properties, encoder settings, and  container settings. To set these properties, the caller must call the appropriate <strong><see cref="SharpDX.MediaFoundation.TranscodeProfile"/></strong> methods.</p><p>The configured transcode profile is passed to the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateTranscodeTopology"/></strong> function.  The underlying topology builder uses these settings to build the transcode topology.</p>	
        /// </summary>	
        /// <param name="transcodeProfileOut">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateTranscodeProfile"/></strong> function creates an empty transcode profile. You must configure the transcode profile setting attributes that define the media types and the container properties. Use the following methods to configure the profile:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.TranscodeProfile.SetAudioAttributes"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.TranscodeProfile.SetVideoAttributes"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.TranscodeProfile.SetContainerAttributes"/></strong> </li> </ul><p>For example code that uses this function, see the following topics:</p><ul> <li> Tutorial: Encoding an MP4 File </li> <li> Tutorial: Encoding a WMA File </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateTranscodeProfile']/*"/>	
        /// <msdn-id>dd388113</msdn-id>	
        /// <unmanaged>HRESULT MFCreateTranscodeProfile([Out] IMFTranscodeProfile** ppTranscodeProfile)</unmanaged>	
        /// <unmanaged-short>MFCreateTranscodeProfile</unmanaged-short>	
        public static void CreateTranscodeProfile(out SharpDX.MediaFoundation.TranscodeProfile transcodeProfileOut)
        {
            unsafe
            {
                IntPtr transcodeProfileOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateTranscodeProfile_(&transcodeProfileOut_);
                transcodeProfileOut = (transcodeProfileOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TranscodeProfile(transcodeProfileOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateTranscodeProfile", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateTranscodeProfile_(void* arg0);

        /// <summary>	
        /// <p>Creates a partial transcode topology.</p><p>The underlying topology builder creates a partial topology by connecting the required pipeline objects:	
        /// source, encoder, and sink. The encoder and the sink are configured according to the settings specified by the caller in the transcode profile. </p><p>To create the transcode profile object, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateTranscodeProfile"/></strong> function and set the required attributes by calling the appropriate the <strong><see cref="SharpDX.MediaFoundation.TranscodeProfile"/></strong> methods. </p><p>The configured transcode profile is passed to the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateTranscodeTopology"/></strong> function, which creates the transcode topology with the appropriate settings. The caller can then set this topology on the Media Session and start the session to begin the encoding process. When the Media Session ends, the transcoded file is generated.</p>	
        /// </summary>	
        /// <param name="srcRef">No documentation.</param>	
        /// <param name="wszOutputFilePathRef">No documentation.</param>	
        /// <param name="profileRef">No documentation.</param>	
        /// <param name="transcodeTopoOut">No documentation.</param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function call succeeded, and <em>ppTranscodeTopo</em> receives a reference to the transcode topology.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pwszOutputFilePath</em> contains invalid characters.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.MediaSourceNoStreamsSelected"/></strong></dt> </dl> </td><td> <p>No streams are selected in the media source.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TranscodeNoContainertype"/></strong></dt> </dl> </td><td> <p>The profile does not contain the <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeContainertype"/> attribute.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TranscodeNoMatchingEncoder"/></strong></dt> </dl> </td><td> <p>For one or more streams, cannot find an encoder that accepts the media type given in the profile.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TranscodeProfileNoMatchingStreams"/></strong></dt> </dl> </td><td> <p>The profile does not specify a media type for any of the selected streams on the media source.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>For example code that uses this function, see the following topics:</p><ul> <li> Tutorial: Encoding an MP4 File </li> <li> Tutorial: Encoding a WMA File </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateTranscodeTopology']/*"/>	
        /// <msdn-id>dd388118</msdn-id>	
        /// <unmanaged>HRESULT MFCreateTranscodeTopology([In] IMFMediaSource* pSrc,[In] const wchar_t* pwszOutputFilePath,[In] IMFTranscodeProfile* pProfile,[Out] IMFTopology** ppTranscodeTopo)</unmanaged>	
        /// <unmanaged-short>MFCreateTranscodeTopology</unmanaged-short>	
        public static void CreateTranscodeTopology(SharpDX.MediaFoundation.MediaSource srcRef, string wszOutputFilePathRef, SharpDX.MediaFoundation.TranscodeProfile profileRef, out SharpDX.MediaFoundation.Topology transcodeTopoOut)
        {
            unsafe
            {
                IntPtr transcodeTopoOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* wszOutputFilePathRef_ = wszOutputFilePathRef)
                    __result__ =
                    MFCreateTranscodeTopology_((void*)((srcRef == null) ? IntPtr.Zero : srcRef.NativePointer), (void*)wszOutputFilePathRef_, (void*)((profileRef == null) ? IntPtr.Zero : profileRef.NativePointer), &transcodeTopoOut_);
                transcodeTopoOut = (transcodeTopoOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Topology(transcodeTopoOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateTranscodeTopology", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateTranscodeTopology_(void* arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p>Creates a topology for transcoding to a byte stream.</p>	
        /// </summary>	
        /// <param name="srcRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaSource"/></strong> interface of a media source. The media source provides that source content for transcoding.</p> </dd></param>	
        /// <param name="outputStreamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. The transcoded output will be written to this byte stream.</p> </dd></param>	
        /// <param name="profileRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.TranscodeProfile"/></strong> interface of a transcoding profile. </p> </dd></param>	
        /// <param name="transcodeTopoOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Topology"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function creates a partial topology that contains the media source, the encoder, and the media sink. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateTranscodeTopologyFromByteStream']/*"/>	
        /// <msdn-id>hh162762</msdn-id>	
        /// <unmanaged>HRESULT MFCreateTranscodeTopologyFromByteStream([In] IMFMediaSource* pSrc,[In] IMFByteStream* pOutputStream,[In] IMFTranscodeProfile* pProfile,[Out] IMFTopology** ppTranscodeTopo)</unmanaged>	
        /// <unmanaged-short>MFCreateTranscodeTopologyFromByteStream</unmanaged-short>	
        public static void CreateTranscodeTopologyFromByteStream(SharpDX.MediaFoundation.MediaSource srcRef, System.IntPtr outputStreamRef, SharpDX.MediaFoundation.TranscodeProfile profileRef, out SharpDX.MediaFoundation.Topology transcodeTopoOut)
        {
            unsafe
            {
                IntPtr transcodeTopoOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateTranscodeTopologyFromByteStream_((void*)((srcRef == null) ? IntPtr.Zero : srcRef.NativePointer), (void*)outputStreamRef, (void*)((profileRef == null) ? IntPtr.Zero : profileRef.NativePointer), &transcodeTopoOut_);
                transcodeTopoOut = (transcodeTopoOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Topology(transcodeTopoOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateTranscodeTopologyFromByteStream", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateTranscodeTopologyFromByteStream_(void* arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p>Gets a list of output formats from an audio encoder.</p>	
        /// </summary>	
        /// <param name="guidSubType"><dd> <p>Specifies the subtype of the output media. The encoder uses this value as a filter when it is enumerating the available output types. For information about the audio subtypes, see  <strong>Audio Subtype GUIDs</strong>. </p> </dd></param>	
        /// <param name="dwMFTFlags"><dd> <p>Bitwise <strong>OR</strong> of zero or more flags from the <strong>_MFT_ENUM_FLAG</strong> enumeration. </p> </dd></param>	
        /// <param name="codecConfigRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of an attribute store. The attribute store specifies the encoder configuration settings. This parameter can be <strong><c>null</c></strong>. The attribute store can hold any of the following attributes.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.TransformAttributeKeys.MftFieldofuseUnlockAttribute"/></strong></dt> </dl> </td><td> <p>Set this attribute to unlock an encoder that has field-of-use descriptions.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeEncodingprofile"/></strong></dt> </dl> </td><td> <p>Specifies a device conformance profile for a Windows Media encoder.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeQualityvsspeed"/></strong></dt> </dl> </td><td> <p>Sets the tradeoff between encoding quality and encoding speed.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Collection"/></strong> interface of a collection object that contains a list of preferred audio media types. The collection contains <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> references. The caller must release the interface reference.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This function assumes the encoder will be used in its default encoding mode, which is typically constant bit-rate (CBR) encoding. Therefore, the types returned by the function might not work with other modes, such as variable bit-rate (VBR) encoding.</p><p>Internally, this function works by calling <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnumEx"/></strong> to find a matching encoder, and then calling <strong><see cref="SharpDX.MediaFoundation.Transform.GetOutputAvailableType"/></strong> to get the encoder's output types.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFTranscodeGetAudioOutputAvailableTypes']/*"/>	
        /// <msdn-id>dd388655</msdn-id>	
        /// <unmanaged>HRESULT MFTranscodeGetAudioOutputAvailableTypes([In] const GUID&amp; guidSubType,[In] _MFT_ENUM_FLAG dwMFTFlags,[In, Optional] IMFAttributes* pCodecConfig,[Out] IMFCollection** ppAvailableTypes)</unmanaged>	
        /// <unmanaged-short>MFTranscodeGetAudioOutputAvailableTypes</unmanaged-short>	
        public static SharpDX.MediaFoundation.Collection TranscodeGetAudioOutputAvailableTypes(System.Guid guidSubType, SharpDX.MediaFoundation.TransformEnumFlag dwMFTFlags, SharpDX.MediaFoundation.MediaAttributes codecConfigRef)
        {
            unsafe
            {
                SharpDX.MediaFoundation.Collection availableTypesOut;
                IntPtr availableTypesOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFTranscodeGetAudioOutputAvailableTypes_(&guidSubType, unchecked((int)dwMFTFlags), (void*)((codecConfigRef == null) ? IntPtr.Zero : codecConfigRef.NativePointer), &availableTypesOut_);
                availableTypesOut = (availableTypesOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Collection(availableTypesOut_);
                __result__.CheckError();
                return availableTypesOut;
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFTranscodeGetAudioOutputAvailableTypes", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFTranscodeGetAudioOutputAvailableTypes_(void* arg0, int arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p>Creates the transcode sink activation object.</p><p>The transcode sink activation object can be used to create any of the following file sinks:</p><ul> <li>3GP file sink</li> <li>MP3 file sink</li> <li>MP4 file sink</li> </ul><p>The transcode sink activation object exposes the <strong><see cref="SharpDX.MediaFoundation.TranscodeSinkInfoProvider"/></strong> interface.</p>	
        /// </summary>	
        /// <param name="activateOut">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateTranscodeSinkActivate']/*"/>	
        /// <msdn-id>dd388115</msdn-id>	
        /// <unmanaged>HRESULT MFCreateTranscodeSinkActivate([Out] IMFActivate** ppActivate)</unmanaged>	
        /// <unmanaged-short>MFCreateTranscodeSinkActivate</unmanaged-short>	
        public static void CreateTranscodeSinkActivate(out SharpDX.MediaFoundation.Activate activateOut)
        {
            unsafe
            {
                IntPtr activateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateTranscodeSinkActivate_(&activateOut_);
                activateOut = (activateOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Activate(activateOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateTranscodeSinkActivate", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateTranscodeSinkActivate_(void* arg0);

        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.MediaFoundation.TrackedSample"/></strong> object that tracks the reference counts on a video media sample.</p>	
        /// </summary>	
        /// <param name="mFSampleOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateTrackedSample']/*"/>	
        /// <msdn-id>hh162761</msdn-id>	
        /// <unmanaged>HRESULT MFCreateTrackedSample([Out] IMFTrackedSample** ppMFSample)</unmanaged>	
        /// <unmanaged-short>MFCreateTrackedSample</unmanaged-short>	
        public static void CreateTrackedSample(out SharpDX.MediaFoundation.TrackedSample mFSampleOut)
        {
            unsafe
            {
                IntPtr mFSampleOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateTrackedSample_(&mFSampleOut_);
                mFSampleOut = (mFSampleOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TrackedSample(mFSampleOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateTrackedSample", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateTrackedSample_(void* arg0);

        /// <summary>	
        /// <p>Creates a Microsoft Media Foundation byte stream that wraps an <strong><see cref="SharpDX.Win32.IStream"/></strong> reference.</p>	
        /// </summary>	
        /// <param name="streamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.Win32.IStream"/></strong> interface.</p> </dd></param>	
        /// <param name="byteStreamOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value.</p></returns>	
        /// <remarks>	
        /// <p>This function enables applications to pass an <strong><see cref="SharpDX.Win32.IStream"/></strong> object to a Media Foundation API that takes an <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> reference.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMFByteStreamOnStream']/*"/>	
        /// <msdn-id>dd388095</msdn-id>	
        /// <unmanaged>HRESULT MFCreateMFByteStreamOnStream([In] IStream* pStream,[Out] IMFByteStream** ppByteStream)</unmanaged>	
        /// <unmanaged-short>MFCreateMFByteStreamOnStream</unmanaged-short>	
        public static void CreateMFByteStreamOnStream(System.IntPtr streamRef, out SharpDX.MediaFoundation.IByteStream byteStreamOut)
        {
            unsafe
            {
                IntPtr byteStreamOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMFByteStreamOnStream_((void*)streamRef, &byteStreamOut_);
                byteStreamOut = (byteStreamOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ByteStream(byteStreamOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateMFByteStreamOnStream", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMFByteStreamOnStream_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Returns an <strong><see cref="SharpDX.Win32.IStream"/></strong> reference that wraps a Microsoft Media Foundation byte stream.</p>	
        /// </summary>	
        /// <param name="byteStreamRef">No documentation.</param>	
        /// <param name="streamOut">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function enables an application to pass a Media Foundation byte stream to an API that takes an <strong><see cref="SharpDX.Win32.IStream"/></strong> reference.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateStreamOnMFByteStream']/*"/>	
        /// <msdn-id>hh162759</msdn-id>	
        /// <unmanaged>HRESULT MFCreateStreamOnMFByteStream([In] IMFByteStream* pByteStream,[Out] IStream** ppStream)</unmanaged>	
        /// <unmanaged-short>MFCreateStreamOnMFByteStream</unmanaged-short>	
        public static void CreateStreamOnMFByteStream(System.IntPtr byteStreamRef, out SharpDX.Win32.IStream streamOut)
        {
            unsafe
            {
                IntPtr streamOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateStreamOnMFByteStream_((void*)byteStreamRef, &streamOut_);
                streamOut = (streamOut_ == IntPtr.Zero) ? null : new SharpDX.Win32.ComStream(streamOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateStreamOnMFByteStream", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateStreamOnMFByteStream_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Creates a Microsoft Media Foundation byte stream that wraps an <strong>IRandomAccessStream</strong> object.</p>	
        /// </summary>	
        /// <param name="unkStreamRef">No documentation.</param>	
        /// <param name="byteStreamOut">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMFByteStreamOnStreamEx']/*"/>	
        /// <msdn-id>hh162754</msdn-id>	
        /// <unmanaged>HRESULT MFCreateMFByteStreamOnStreamEx([In] IUnknown* punkStream,[Out, Fast] IMFByteStream** ppByteStream)</unmanaged>	
        /// <unmanaged-short>MFCreateMFByteStreamOnStreamEx</unmanaged-short>	
        public static void CreateMFByteStreamOnStreamEx(SharpDX.ComObject unkStreamRef, SharpDX.MediaFoundation.IByteStream byteStreamOut)
        {
            unsafe
            {
                IntPtr byteStreamOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMFByteStreamOnStreamEx_((void*)((unkStreamRef == null) ? IntPtr.Zero : unkStreamRef.NativePointer), &byteStreamOut_);
                ((SharpDX.MediaFoundation.ByteStream)byteStreamOut).NativePointer = byteStreamOut_;
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateMFByteStreamOnStreamEx", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMFByteStreamOnStreamEx_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Creates an <strong>IRandomAccessStream</strong> object that wraps a Microsoft Media Foundation byte stream.</p>	
        /// </summary>	
        /// <param name="byteStreamRef">No documentation.</param>	
        /// <param name="riid">No documentation.</param>	
        /// <param name="vOut">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The returned byte stream object exposes the <strong><see cref="SharpDX.MediaFoundation.ServiceProvider"/></strong> interface. To get the original <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> reference, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> using the service identifier <strong><see cref="SharpDX.MediaFoundation.MediaServiceKeys.WrappedObject"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateStreamOnMFByteStreamEx']/*"/>	
        /// <msdn-id>hh162760</msdn-id>	
        /// <unmanaged>HRESULT MFCreateStreamOnMFByteStreamEx([In] IMFByteStream* pByteStream,[In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>	
        /// <unmanaged-short>MFCreateStreamOnMFByteStreamEx</unmanaged-short>	
        public static void CreateStreamOnMFByteStreamEx(System.IntPtr byteStreamRef, System.Guid riid, out System.IntPtr vOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vOut_ = &vOut)
                    __result__ =
                    MFCreateStreamOnMFByteStreamEx_((void*)byteStreamRef, &riid, vOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateStreamOnMFByteStreamEx", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateStreamOnMFByteStreamEx_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p>Create an <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> from properties.</p>	
        /// </summary>	
        /// <param name="unkStreamRef">No documentation.</param>	
        /// <param name="mediaTypeOut">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateMediaTypeFromProperties']/*"/>	
        /// <msdn-id>jj247579</msdn-id>	
        /// <unmanaged>HRESULT MFCreateMediaTypeFromProperties([In] IUnknown* punkStream,[Out] IMFMediaType** ppMediaType)</unmanaged>	
        /// <unmanaged-short>MFCreateMediaTypeFromProperties</unmanaged-short>	
        public static void CreateMediaTypeFromProperties(SharpDX.ComObject unkStreamRef, out SharpDX.MediaFoundation.MediaType mediaTypeOut)
        {
            unsafe
            {
                IntPtr mediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateMediaTypeFromProperties_((void*)((unkStreamRef == null) ? IntPtr.Zero : unkStreamRef.NativePointer), &mediaTypeOut_);
                mediaTypeOut = (mediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(mediaTypeOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateMediaTypeFromProperties", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateMediaTypeFromProperties_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Creates properties from a <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong>.</p>	
        /// </summary>	
        /// <param name="mediaTypeRef">No documentation.</param>	
        /// <param name="riid">No documentation.</param>	
        /// <param name="vOut">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreatePropertiesFromMediaType']/*"/>	
        /// <msdn-id>jj247580</msdn-id>	
        /// <unmanaged>HRESULT MFCreatePropertiesFromMediaType([In] IMFMediaType* pMediaType,[In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>	
        /// <unmanaged-short>MFCreatePropertiesFromMediaType</unmanaged-short>	
        public static void CreatePropertiesFromMediaType(SharpDX.MediaFoundation.MediaType mediaTypeRef, System.Guid riid, out System.IntPtr vOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vOut_ = &vOut)
                    __result__ =
                    MFCreatePropertiesFromMediaType_((void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), &riid, vOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreatePropertiesFromMediaType", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreatePropertiesFromMediaType_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p>Enumerates a list of audio or video capture devices.</p>	
        /// </summary>	
        /// <param name="attributesRef"><dd> <p>Pointer to an attribute store that contains search criteria. To create the attribute store, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAttributes"/></strong>. Set one or more of the following attributes on the attribute store:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceType"/></strong></dt> </dl> </td><td> <p>Specifies whether to enumerate audio or video devices. (Required.)</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeAudcapRole"/></strong></dt> </dl> </td><td> <p>For audio capture devices, specifies the device role. (Optional.)</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeVidcapCategory"/></strong></dt> </dl> </td><td> <p>For video capture devices, specifies the device category. (Optional.)</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="pSourceActivateOut"><dd> <p>Receives an array of <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface references. Each reference represents an activation object for a media source. The function allocates the memory for the array. The caller must release the references in the array and call <strong>CoTaskMemFree</strong> to free the memory for the array.</p> </dd></param>	
        /// <param name="cSourceActivateRef"><dd> <p>Receives the number of elements in the <em>pppSourceActivate</em> array. If no capture devices match the search criteria, this parameter receives the value 0.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Each returned <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> reference represents a capture device, and can be used to create a media source for that device. You can also use the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> reference to query for attributes that describe the device. The following attributes might be set:</p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.FriendlyName"/> </td><td>The display name of the device.</td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.MediaType"/> </td><td>The major type and subtype GUIDs that describe the device's output format.</td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceType"/> </td><td>The type of capture device (audio or video).</td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeAudcapEndpointId"/> </td><td>The audio endpoint ID string. (Audio devices only.)</td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeVidcapCategory"/> </td><td>The device category. (Video devices only.)</td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeVidcapHwSource"/> </td><td> Whether a device is a hardware or software device. (Video devices only.)</td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeVidcapSymbolicLink"/> </td><td>The symbolic link for the device driver. (Video devices only.)</td></tr> </table><p>?</p><p>To create a media source from an <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> reference, call the <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFEnumDeviceSources']/*"/>	
        /// <msdn-id>dd388503</msdn-id>	
        /// <unmanaged>HRESULT MFEnumDeviceSources([In] IMFAttributes* pAttributes,[Out] void*** pppSourceActivate,[Out] unsigned int* pcSourceActivate)</unmanaged>	
        /// <unmanaged-short>MFEnumDeviceSources</unmanaged-short>	
        internal static void EnumDeviceSources(SharpDX.MediaFoundation.MediaAttributes attributesRef, out System.IntPtr pSourceActivateOut, out int cSourceActivateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* pSourceActivateOut_ = &pSourceActivateOut)
                fixed (void* cSourceActivateRef_ = &cSourceActivateRef)
                    __result__ =
                    MFEnumDeviceSources_((void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), pSourceActivateOut_, cSourceActivateRef_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFEnumDeviceSources", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFEnumDeviceSources_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p>Creates a media source for a hardware capture device.</p>	
        /// </summary>	
        /// <param name="attributesRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of an attribute store, which is used to select the device. See Remarks.</p> </dd></param>	
        /// <param name="sourceOut"><dd> <p>Receives a reference to the media source's <strong><see cref="SharpDX.MediaFoundation.MediaSource"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <strong>Important</strong>??When the capture device is no longer needed, you must shut down the device by calling <strong>Shutdown</strong> on the <strong><see cref="SharpDX.MediaFoundation.MediaSource"/></strong> object you obtained by calling <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDeviceSource"/></strong>. Failure to call <strong>Shutdown</strong> can result in memory links because the system may keep a reference to <strong><see cref="SharpDX.MediaFoundation.MediaSource"/></strong> resources until <strong>Shutdown</strong> is called.?<p>The <em>pAttributes</em> parameter specifies an attribute store. To create the attribute store, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAttributes"/></strong> function.  You must set the <see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceType"/> attribute, which specifies the type of device (audio or video).</p><p>For audio capture devices, optionally set one of the following attributes:</p><p></p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <p><see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeAudcapEndpointId"/> </p> </td><td> <p>Specifies the audio endpoint ID of the audio capture device.</p> </td></tr> <tr><td> <p><see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeAudcapRole"/> </p> </td><td> <p>Specifies the device role. If this attribute is set, the function uses the default audio capture device for that device role.</p> <p>Do not combine this attribute with the <see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeAudcapEndpointId"/> attribute.</p> </td></tr> </table><p>?</p><p>If neither attribute is specified, the function selects the default audio capture device for the <strong>eCommunications</strong> role.</p><p>For video capture devices, you must set the following attribute:</p><p></p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <p><see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeVidcapSymbolicLink"/> </p> </td><td> <p>Specifies the symbolic link to the device.</p> </td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateDeviceSource']/*"/>	
        /// <msdn-id>dd388091</msdn-id>	
        /// <unmanaged>HRESULT MFCreateDeviceSource([In] IMFAttributes* pAttributes,[Out] IMFMediaSource** ppSource)</unmanaged>	
        /// <unmanaged-short>MFCreateDeviceSource</unmanaged-short>	
        public static void CreateDeviceSource(SharpDX.MediaFoundation.MediaAttributes attributesRef, out SharpDX.MediaFoundation.MediaSource sourceOut)
        {
            unsafe
            {
                IntPtr sourceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateDeviceSource_((void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), &sourceOut_);
                sourceOut = (sourceOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSource(sourceOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateDeviceSource", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateDeviceSource_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Creates an activation object that represents a hardware capture device.</p>	
        /// </summary>	
        /// <param name="attributesRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of an attribute store, which is used to select the device. See Remarks.</p> </dd></param>	
        /// <param name="activateOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns>No documentation.</returns>	
        /// <remarks>	
        /// <p>This function creates an activation object that can be used to create a media source for a hardware device. To create the media source itself, call <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong>.</p><p>The <em>pAttributes</em> parameter specifies an attribute store. To create the attribute store, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAttributes"/></strong> function.  You must set the <see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceType"/> attribute, which specifies the type of device (audio or video).</p><p>For audio capture devices, optionally set one of the following attributes:</p><p></p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <p><see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeAudcapEndpointId"/> </p> </td><td> <p>Specifies the audio endpoint ID of the audio capture device.</p> </td></tr> <tr><td> <p><see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeAudcapRole"/> </p> </td><td> <p>Specifies the device role. If this attribute is set, the function uses the default audio capture device for that device role.</p> <p>Do not combine this attribute with the <see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeAudcapEndpointId"/> attribute.</p> </td></tr> </table><p>?</p><p>If neither attribute is specified, the function selects the default audio capture device for the <strong>eCommunications</strong> role.</p><p>For video capture devices, you must set the following attribute:</p><p></p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <p><see cref="SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeVidcapSymbolicLink"/> </p> </td><td> <p>Specifies the symbolic link to the device.</p> </td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateDeviceSourceActivate']/*"/>	
        /// <msdn-id>dd388093</msdn-id>	
        /// <unmanaged>HRESULT MFCreateDeviceSourceActivate([In] IMFAttributes* pAttributes,[Out] IMFActivate** ppActivate)</unmanaged>	
        /// <unmanaged-short>MFCreateDeviceSourceActivate</unmanaged-short>	
        public static void CreateDeviceSourceActivate(SharpDX.MediaFoundation.MediaAttributes attributesRef, out SharpDX.MediaFoundation.Activate activateOut)
        {
            unsafe
            {
                IntPtr activateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateDeviceSourceActivate_((void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), &activateOut_);
                activateOut = (activateOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Activate(activateOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateDeviceSourceActivate", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateDeviceSourceActivate_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.MediaFoundation.ProtectedEnvironmentAccess"/></strong> object that allows content protection systems to perform a handshake with the protected environment.</p>	
        /// </summary>	
        /// <param name="accessOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateProtectedEnvironmentAccess']/*"/>	
        /// <msdn-id>hh162758</msdn-id>	
        /// <unmanaged>HRESULT MFCreateProtectedEnvironmentAccess([Out] IMFProtectedEnvironmentAccess** ppAccess)</unmanaged>	
        /// <unmanaged-short>MFCreateProtectedEnvironmentAccess</unmanaged-short>	
        public static void CreateProtectedEnvironmentAccess(out SharpDX.MediaFoundation.ProtectedEnvironmentAccess accessOut)
        {
            unsafe
            {
                IntPtr accessOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateProtectedEnvironmentAccess_(&accessOut_);
                accessOut = (accessOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ProtectedEnvironmentAccess(accessOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFCreateProtectedEnvironmentAccess", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateProtectedEnvironmentAccess_(void* arg0);

        /// <summary>	
        /// <p>Loads a dynamic link library that is signed for the protected environment.</p>	
        /// </summary>	
        /// <param name="szNameRef"><dd> <p>The name of the dynamic link library to load.  This dynamic link library must be signed for the protected environment.</p> </dd></param>	
        /// <param name="libOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.SignedLibrary"/></strong> interface for the library.</p> </dd></param>	
        /// <returns>No documentation.</returns>	
        /// <remarks>	
        /// <p>A singlemodule load count is maintained on the dynamic link library (as it is with <strong>LoadLibrary</strong>).  This load count  is freed when the final release is called on the <strong><see cref="SharpDX.MediaFoundation.SignedLibrary"/></strong> object.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFLoadSignedLibrary']/*"/>	
        /// <msdn-id>hh162769</msdn-id>	
        /// <unmanaged>HRESULT MFLoadSignedLibrary([In] const wchar_t* pszName,[Out] IMFSignedLibrary** ppLib)</unmanaged>	
        /// <unmanaged-short>MFLoadSignedLibrary</unmanaged-short>	
        public static void LoadSignedLibrary(string szNameRef, out SharpDX.MediaFoundation.SignedLibrary libOut)
        {
            unsafe
            {
                IntPtr libOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* szNameRef_ = szNameRef)
                    __result__ =
                    MFLoadSignedLibrary_((void*)szNameRef_, &libOut_);
                libOut = (libOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.SignedLibrary(libOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFLoadSignedLibrary", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFLoadSignedLibrary_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Returns an <strong><see cref="SharpDX.MediaFoundation.SystemId"/></strong> object for retrieving system id data.</p>	
        /// </summary>	
        /// <param name="idOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetSystemId']/*"/>	
        /// <msdn-id>hh162767</msdn-id>	
        /// <unmanaged>HRESULT MFGetSystemId([Out] IMFSystemId** ppId)</unmanaged>	
        /// <unmanaged-short>MFGetSystemId</unmanaged-short>	
        public static void GetSystemId(out SharpDX.MediaFoundation.SystemId idOut)
        {
            unsafe
            {
                IntPtr idOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFGetSystemId_(&idOut_);
                idOut = (idOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.SystemId(idOut_);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFGetSystemId", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetSystemId_(void* arg0);

        /// <summary>	
        /// <p>Gets the local system ID.</p>	
        /// </summary>	
        /// <param name="verifier"><dd> <p>Application-specific verifier value.</p> </dd></param>	
        /// <param name="size"><dd> <p>Length in bytes of verifier.</p> </dd></param>	
        /// <param name="id"><dd> <p>Returned ID string.  This value must be freed by the caller by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFGetLocalId']/*"/>	
        /// <msdn-id>jj128335</msdn-id>	
        /// <unmanaged>HRESULT MFGetLocalId([In, Buffer] const unsigned char* verifier,[In] unsigned int size,[Out] wchar_t** id)</unmanaged>	
        /// <unmanaged-short>MFGetLocalId</unmanaged-short>	
        public static void GetLocalId(byte[] verifier, int size, System.IntPtr id)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* verifier_ = verifier)
                    __result__ =
                    MFGetLocalId_(verifier_, size, (void*)id);
                __result__.CheckError();
            }
        }
        [DllImport("mf.dll", EntryPoint = "MFGetLocalId", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFGetLocalId_(void* arg0, int arg1, void* arg2);

        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.MediaFoundation.ContentProtectionDevice"/></strong> interface for the specified media protection system.</p>	
        /// </summary>	
        /// <param name="protectionSystemId">No documentation.</param>	
        /// <param name="contentProtectionDevice">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateContentProtectionDevice']/*"/>	
        /// <msdn-id>mt219225</msdn-id>	
        /// <unmanaged>HRESULT MFCreateContentProtectionDevice([In] const GUID&amp; ProtectionSystemId,[Out] IMFContentProtectionDevice** ContentProtectionDevice)</unmanaged>	
        /// <unmanaged-short>MFCreateContentProtectionDevice</unmanaged-short>	
        public static void CreateContentProtectionDevice(System.Guid protectionSystemId, out SharpDX.MediaFoundation.ContentProtectionDevice contentProtectionDevice)
        {
            unsafe
            {
                IntPtr contentProtectionDevice_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateContentProtectionDevice_(&protectionSystemId, &contentProtectionDevice_);
                contentProtectionDevice = (contentProtectionDevice_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ContentProtectionDevice(contentProtectionDevice_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateContentProtectionDevice", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateContentProtectionDevice_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Checks whether a hardware security processor is supported for the specified media protection system.</p>	
        /// </summary>	
        /// <param name="protectionSystemId"><dd> <p>The identifier of the protection system that you want to check.</p> </dd></param>	
        /// <param name="isSupported"><dd> <p><strong>TRUE</strong> if the hardware security processor is supported for the specified protection system; otherwise <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFIsContentProtectionDeviceSupported']/*"/>	
        /// <msdn-id>mt219226</msdn-id>	
        /// <unmanaged>HRESULT MFIsContentProtectionDeviceSupported([In] const GUID&amp; ProtectionSystemId,[Out] BOOL* isSupported)</unmanaged>	
        /// <unmanaged-short>MFIsContentProtectionDeviceSupported</unmanaged-short>	
        public static void IsContentProtectionDeviceSupported(System.Guid protectionSystemId, out SharpDX.Mathematics.Interop.RawBool isSupported)
        {
            unsafe
            {
                isSupported = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* isSupported_ = &isSupported)
                    __result__ =
                    MFIsContentProtectionDeviceSupported_(&protectionSystemId, isSupported_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFIsContentProtectionDeviceSupported", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFIsContentProtectionDeviceSupported_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.MediaFoundation.ContentDecryptorContext"/></strong> interface for the specified media protection system.  </p>	
        /// </summary>	
        /// <param name="guidMediaProtectionSystemId">No documentation.</param>	
        /// <param name="d3DManagerRef">No documentation.</param>	
        /// <param name="contentProtectionDeviceRef">No documentation.</param>	
        /// <param name="contentDecryptorContextOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateContentDecryptorContext']/*"/>	
        /// <msdn-id>mt219224</msdn-id>	
        /// <unmanaged>HRESULT MFCreateContentDecryptorContext([In] const GUID&amp; guidMediaProtectionSystemId,[In, Optional] IMFDXGIDeviceManager* pD3DManager,[In] IMFContentProtectionDevice* pContentProtectionDevice,[Out] IMFContentDecryptorContext** ppContentDecryptorContext)</unmanaged>	
        /// <unmanaged-short>MFCreateContentDecryptorContext</unmanaged-short>	
        public static void CreateContentDecryptorContext(System.Guid guidMediaProtectionSystemId, SharpDX.MediaFoundation.DXGIDeviceManager d3DManagerRef, SharpDX.MediaFoundation.ContentProtectionDevice contentProtectionDeviceRef, out SharpDX.MediaFoundation.ContentDecryptorContext contentDecryptorContextOut)
        {
            unsafe
            {
                IntPtr contentDecryptorContextOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateContentDecryptorContext_(&guidMediaProtectionSystemId, (void*)((d3DManagerRef == null) ? IntPtr.Zero : d3DManagerRef.NativePointer), (void*)((contentProtectionDeviceRef == null) ? IntPtr.Zero : contentProtectionDeviceRef.NativePointer), &contentDecryptorContextOut_);
                contentDecryptorContextOut = (contentDecryptorContextOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ContentDecryptorContext(contentDecryptorContextOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateContentDecryptorContext", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateContentDecryptorContext_(void* arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p>Locks the shared Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager.</p>	
        /// </summary>	
        /// <param name="sensorGroupSymbolicLink"><dd> <p>Receives a token that identifies this instance of the DXGI Device Manager. Use this token when calling <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.ResetDevice"/></strong>. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="sensorGroupOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function obtains a reference to a  DXGI Device Manager instance that can be shared between components. The Microsoft Media Foundation platform creates this instance of the  DXGI Device Manager as a singleton object. Alternatively, you can create a new DXGI Device Manager by calling <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDXGIDeviceManager"/></strong>.</p><p>The first time this function is called, the Media Foundation platform creates the shared DXGI Device Manager. </p><p>When you are done use the <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> reference, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.UnlockDXGIDeviceManager"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateSensorGroup']/*"/>	
        /// <msdn-id>hh162770</msdn-id>	
        /// <unmanaged>HRESULT MFCreateSensorGroup([In] const wchar_t* SensorGroupSymbolicLink,[Out] IMFSensorGroup** ppSensorGroup)</unmanaged>	
        /// <unmanaged-short>MFCreateSensorGroup</unmanaged-short>	
        public static void CreateSensorGroup(string sensorGroupSymbolicLink, out SharpDX.MediaFoundation.SensorGroup sensorGroupOut)
        {
            unsafe
            {
                IntPtr sensorGroupOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* sensorGroupSymbolicLink_ = sensorGroupSymbolicLink)
                    __result__ =
                    MFCreateSensorGroup_((void*)sensorGroupSymbolicLink_, &sensorGroupOut_);
                sensorGroupOut = (sensorGroupOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.SensorGroup(sensorGroupOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateSensorGroup", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateSensorGroup_(void* arg0, void* arg1);

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Creates an instance of the <strong><see cref="SharpDX.MediaFoundation.SensorStream"/></strong> interface.</p>	
        /// </summary>	
        /// <param name="streamId">No documentation.</param>	
        /// <param name="attributesRef">No documentation.</param>	
        /// <param name="mediaTypeCollectionRef">No documentation.</param>	
        /// <param name="streamOut">No documentation.</param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>The supplied <strong><see cref="SharpDX.MediaFoundation.SensorGroup"/></strong> is null.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The supplied <strong>LPCWSTR</strong> is null.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateSensorStream']/*"/>	
        /// <msdn-id>mt797980</msdn-id>	
        /// <unmanaged>HRESULT MFCreateSensorStream([In] unsigned int StreamId,[In, Optional] IMFAttributes* pAttributes,[In] IMFCollection* pMediaTypeCollection,[Out] IMFSensorStream** ppStream)</unmanaged>	
        /// <unmanaged-short>MFCreateSensorStream</unmanaged-short>	
        public static void CreateSensorStream(int streamId, SharpDX.MediaFoundation.MediaAttributes attributesRef, SharpDX.MediaFoundation.Collection mediaTypeCollectionRef, out SharpDX.MediaFoundation.SensorStream streamOut)
        {
            unsafe
            {
                IntPtr streamOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateSensorStream_(streamId, (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), (void*)((mediaTypeCollectionRef == null) ? IntPtr.Zero : mediaTypeCollectionRef.NativePointer), &streamOut_);
                streamOut = (streamOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.SensorStream(streamOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateSensorStream", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateSensorStream_(int arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p>Creates the source reader from a URL.</p>	
        /// </summary>	
        /// <param name="wszURLRef"><dd> <p>The URL  of a media file to open.</p> </dd></param>	
        /// <param name="attributesRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the source reader. For more information, see Source Reader Attributes. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="sourceReaderOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.SourceReader"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Call <strong>CoInitialize(Ex)</strong> and <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong> before calling this function.</p><p> Internally, the source reader calls the <strong><see cref="SharpDX.MediaFoundation.SourceResolver.CreateObjectFromURL"/></strong> method to create a media source from the URL. </p><p>This function is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateSourceReaderFromURL']/*"/>	
        /// <msdn-id>dd388110</msdn-id>	
        /// <unmanaged>HRESULT MFCreateSourceReaderFromURL([In] const wchar_t* pwszURL,[In, Optional] IMFAttributes* pAttributes,[Out, Fast] IMFSourceReader** ppSourceReader)</unmanaged>	
        /// <unmanaged-short>MFCreateSourceReaderFromURL</unmanaged-short>	
        public static void CreateSourceReaderFromURL(string wszURLRef, SharpDX.MediaFoundation.MediaAttributes attributesRef, SharpDX.MediaFoundation.SourceReader sourceReaderOut)
        {
            unsafe
            {
                IntPtr sourceReaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* wszURLRef_ = wszURLRef)
                    __result__ =
                    MFCreateSourceReaderFromURL_((void*)wszURLRef_, (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), &sourceReaderOut_);
                ((SharpDX.MediaFoundation.SourceReader)sourceReaderOut).NativePointer = sourceReaderOut_;
                __result__.CheckError();
            }
        }
        [DllImport("Mfreadwrite.dll", EntryPoint = "MFCreateSourceReaderFromURL", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateSourceReaderFromURL_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p>Creates the source reader from a byte stream.</p>	
        /// </summary>	
        /// <param name="byteStreamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. This byte stream will provide the source data for the source reader.</p> </dd></param>	
        /// <param name="attributesRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the source reader. For more information, see Source Reader Attributes. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="sourceReaderOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.SourceReader"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Call <strong>CoInitialize(Ex)</strong> and <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong> before calling this function.</p><p> Internally, the source reader calls the <strong><see cref="SharpDX.MediaFoundation.SourceResolver.CreateObjectFromByteStream_"/></strong> method to create a media source from the byte stream. Therefore, a byte-stream handler must be registered for the byte stream. For more information about byte-stream handlers, see Scheme Handlers and Byte-Stream Handlers. </p><p>This function is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateSourceReaderFromByteStream']/*"/>	
        /// <msdn-id>dd388106</msdn-id>	
        /// <unmanaged>HRESULT MFCreateSourceReaderFromByteStream([In] IMFByteStream* pByteStream,[In, Optional] IMFAttributes* pAttributes,[Out, Fast] IMFSourceReader** ppSourceReader)</unmanaged>	
        /// <unmanaged-short>MFCreateSourceReaderFromByteStream</unmanaged-short>	
        public static void CreateSourceReaderFromByteStream(System.IntPtr byteStreamRef, SharpDX.MediaFoundation.MediaAttributes attributesRef, SharpDX.MediaFoundation.SourceReader sourceReaderOut)
        {
            unsafe
            {
                IntPtr sourceReaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateSourceReaderFromByteStream_((void*)byteStreamRef, (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), &sourceReaderOut_);
                ((SharpDX.MediaFoundation.SourceReader)sourceReaderOut).NativePointer = sourceReaderOut_;
                __result__.CheckError();
            }
        }
        [DllImport("Mfreadwrite.dll", EntryPoint = "MFCreateSourceReaderFromByteStream", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateSourceReaderFromByteStream_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p>Creates the source reader from a media source.</p>	
        /// </summary>	
        /// <param name="mediaSourceRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaSource"/></strong> interface of a media source.</p> </dd></param>	
        /// <param name="attributesRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the source reader. For more information, see Source Reader Attributes. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="sourceReaderOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.SourceReader"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.DrmUnsupported"/></strong></strong></dt> </dl> </td><td> <p>The source contains protected content.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call <strong>CoInitialize(Ex)</strong> and <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong> before calling this function.</p><p>By default, when the application releases the source reader, the source reader shuts down the media source by calling <strong><see cref="SharpDX.MediaFoundation.MediaSource.Shutdown"/></strong> on the media source. At that point, the application can no longer use the media source.</p><p>To change this default behavior, set the <see cref="SharpDX.MediaFoundation.SourceReaderAttributeKeys.DisconnectMediasourceOnShutdown"/> attribute in the <em>pAttributes</em> parameter. If this attribute is <strong>TRUE</strong>, the application is responsible for  shutting down the media source.</p><p>When using the Source Reader, do not call any of the following methods on the media source:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaSource.Pause"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaSource.Start"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaSource.Stop"/></strong> </li> <li>All <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator"/></strong> methods</li> </ul><p>This function is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateSourceReaderFromMediaSource']/*"/>	
        /// <msdn-id>dd388108</msdn-id>	
        /// <unmanaged>HRESULT MFCreateSourceReaderFromMediaSource([In] IMFMediaSource* pMediaSource,[In, Optional] IMFAttributes* pAttributes,[Out, Fast] IMFSourceReader** ppSourceReader)</unmanaged>	
        /// <unmanaged-short>MFCreateSourceReaderFromMediaSource</unmanaged-short>	
        public static void CreateSourceReaderFromMediaSource(SharpDX.MediaFoundation.MediaSource mediaSourceRef, SharpDX.MediaFoundation.MediaAttributes attributesRef, SharpDX.MediaFoundation.SourceReader sourceReaderOut)
        {
            unsafe
            {
                IntPtr sourceReaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateSourceReaderFromMediaSource_((void*)((mediaSourceRef == null) ? IntPtr.Zero : mediaSourceRef.NativePointer), (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), &sourceReaderOut_);
                ((SharpDX.MediaFoundation.SourceReader)sourceReaderOut).NativePointer = sourceReaderOut_;
                __result__.CheckError();
            }
        }
        [DllImport("Mfreadwrite.dll", EntryPoint = "MFCreateSourceReaderFromMediaSource", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateSourceReaderFromMediaSource_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p>Creates the sink writer from a URL or byte stream.</p>	
        /// </summary>	
        /// <param name="wszOutputURLRef"><dd> <p>A null-terminated string that contains the URL of the output file. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="byteStreamRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. This parameter can be <strong><c>null</c></strong>.</p> <p>If this parameter is a valid reference, the sink writer writes to the provided byte stream. (The byte stream must be writable.) Otherwise, if <em>pByteStream</em> is <strong><c>null</c></strong>, the sink writer creates a new file named <em>pwszOutputURL</em>.</p> </dd></param>	
        /// <param name="attributesRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the sink writer. For more information, see Sink Writer Attributes. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.SinkWriter"/></strong> interface. The caller must release the interface.</p> </dd></returns>	
        /// <remarks>	
        /// <p>Call <strong>CoInitialize(Ex)</strong> and <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong> before calling this function.</p><p>The first three parameters to this function can be <strong><c>null</c></strong>; however, only certain combinations are valid:</p><p> </p><table> <tr><th>Description</th><th><em>pwszOutputURL</em></th><th><em>pByteStream</em></th><th><em>pAttributes</em></th></tr> <tr><td>Specify a byte stream, with no URL.</td><td><strong><c>null</c></strong></td><td>non-<strong><c>null</c></strong></td><td>Required (must not be <strong><c>null</c></strong>).</td></tr> <tr><td>Specify a URL, with no byte stream.</td><td>not <strong><c>null</c></strong></td><td><strong><c>null</c></strong></td><td>Optional (may be <strong><c>null</c></strong>).</td></tr> <tr><td>Specify both a URL and a byte stream.</td><td>non-<strong><c>null</c></strong></td><td>non-<strong><c>null</c></strong></td><td>Optional (may be <strong><c>null</c></strong>).</td></tr> </table><p>?</p><p>The <em>pAttributes</em> parameter is required in the first case and optional in the others.</p><ul> <li>Case 1: Specify a byte stream without a URL. The <em>pAttributes</em> parameter must point to an attribute store that contains the <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeContainertype"/> attribute. The sink writer uses the  <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeContainertype"/> attribute to determine the type of file container to write, such as ASF or MP4.</li> <li>Case 2: Specify a URL without a byte stream. The sink writer creates a new file named <em>pwszOutputURL</em>. If <em>pAttributes</em> specifies an attribute store with the <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeContainertype"/> attribute, the sink writer uses that attribute to determine the type of file container. Otherwise, if the <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeContainertype"/> attribute is absent or <em>pAttributes</em> is <strong><c>null</c></strong>, the sink writer uses the file name extension to select the container type; for example, ".asf" for an ASF file.</li> <li>Case 3: Specify both a URL and a byte stream. The sink writer writes to the byte stream. The URL provided in <em>pwszOutputURL</em> is informational only; the sink writer does not create a new file. If <em>pAttributes</em> specifies an attribute store with the <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeContainertype"/> attribute, the sink writer uses that attribute to determine the type of file container. Otherwise, the sink writer uses the file name extension to select the container type. The <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeContainertype"/> attribute overrides the URL file name extension in this case.</li> </ul><p>This function is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateSinkWriterFromURL']/*"/>	
        /// <msdn-id>dd388105</msdn-id>	
        /// <unmanaged>HRESULT MFCreateSinkWriterFromURL([In, Optional] const wchar_t* pwszOutputURL,[In, Optional] IMFByteStream* pByteStream,[In, Optional] IMFAttributes* pAttributes,[Out] IMFSinkWriter** ppSinkWriter)</unmanaged>	
        /// <unmanaged-short>MFCreateSinkWriterFromURL</unmanaged-short>	
        public static SharpDX.MediaFoundation.SinkWriter CreateSinkWriterFromURL(string wszOutputURLRef, System.IntPtr byteStreamRef, SharpDX.MediaFoundation.MediaAttributes attributesRef)
        {
            unsafe
            {
                SharpDX.MediaFoundation.SinkWriter sinkWriterOut;
                IntPtr sinkWriterOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* wszOutputURLRef_ = wszOutputURLRef)
                    __result__ =
                    MFCreateSinkWriterFromURL_((void*)wszOutputURLRef_, (void*)byteStreamRef, (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), &sinkWriterOut_);
                sinkWriterOut = (sinkWriterOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.SinkWriter(sinkWriterOut_);
                __result__.CheckError();
                return sinkWriterOut;
            }
        }
        [DllImport("Mfreadwrite.dll", EntryPoint = "MFCreateSinkWriterFromURL", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateSinkWriterFromURL_(void* arg0, void* arg1, void* arg2, void* arg3);

        /// <summary>	
        /// <p>Creates the sink writer from a media sink.</p>	
        /// </summary>	
        /// <param name="mediaSinkRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaSink"/></strong> interface of a media sink. </p> </dd></param>	
        /// <param name="attributesRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the sink writer. For more information, see Sink Writer Attributes. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="sinkWriterOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.SinkWriter"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Call <strong>CoInitialize(Ex)</strong> and <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong> before calling this function.</p><p>When you are done using the media sink, call the media sink's <strong><see cref="SharpDX.MediaFoundation.MediaSink.Shutdown"/></strong> method. (The sink writer does not shut down the media sink.) Release the sink writer before calling <strong>Shutdown</strong> on the media sink.</p><p>This function is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateSinkWriterFromMediaSink']/*"/>	
        /// <msdn-id>dd388103</msdn-id>	
        /// <unmanaged>HRESULT MFCreateSinkWriterFromMediaSink([In] IMFMediaSink* pMediaSink,[In, Optional] IMFAttributes* pAttributes,[Out] IMFSinkWriter** ppSinkWriter)</unmanaged>	
        /// <unmanaged-short>MFCreateSinkWriterFromMediaSink</unmanaged-short>	
        public static void CreateSinkWriterFromMediaSink(SharpDX.MediaFoundation.MediaSink mediaSinkRef, SharpDX.MediaFoundation.MediaAttributes attributesRef, out SharpDX.MediaFoundation.SinkWriter sinkWriterOut)
        {
            unsafe
            {
                IntPtr sinkWriterOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateSinkWriterFromMediaSink_((void*)((mediaSinkRef == null) ? IntPtr.Zero : mediaSinkRef.NativePointer), (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), &sinkWriterOut_);
                sinkWriterOut = (sinkWriterOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.SinkWriter(sinkWriterOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfreadwrite.dll", EntryPoint = "MFCreateSinkWriterFromMediaSink", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateSinkWriterFromMediaSink_(void* arg0, void* arg1, void* arg2);

        /// <summary>	
        /// <p> </p><p>Writes the contents of an attribute store to a stream.</p>	
        /// </summary>	
        /// <param name="attrRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the attribute store.</p> </dd></param>	
        /// <param name="dwOptions"><dd> <p>Bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.AttributeSerializeOptions"/></strong> enumeration.</p> </dd></param>	
        /// <param name="stmRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.Win32.IStream"/></strong> interface of the stream where the attributes are saved.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If <em>dwOptions</em> contains the <see cref="SharpDX.MediaFoundation.AttributeSerializeOptions.UnknownByref"/> flag, the function serializes <strong><see cref="SharpDX.ComObject"/></strong> references in the attribute store, as follows:</p><ul> <li> <p>If the <strong><see cref="SharpDX.Win32.IStream"/></strong> reference exposes the <strong><see cref="SharpDX.MediaFoundation.ObjectReferenceStream"/></strong> interface (through <strong>QueryInterface</strong>), the function calls <strong><see cref="SharpDX.MediaFoundation.ObjectReferenceStream.SaveReference"/></strong> to serialize each reference.</p> </li> <li> <p>Otherwise, the function calls <strong>CoMarshalInterface</strong> to serialize a proxy for the object.</p> </li> </ul><p>If <em>dwOptions</em> does not include the <see cref="SharpDX.MediaFoundation.AttributeSerializeOptions.UnknownByref"/> flag, the function skips <strong><see cref="SharpDX.ComObject"/></strong> references in the attribute store.</p><p>To load the attributes from the stream, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.DeserializeAttributesFromStream"/></strong>.</p><p>The main purpose of this function is to marshal attributes across process boundaries.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFSerializeAttributesToStream']/*"/>	
        /// <msdn-id>ms702278</msdn-id>	
        /// <unmanaged>HRESULT MFSerializeAttributesToStream([In] IMFAttributes* pAttr,[In] unsigned int dwOptions,[In] IStream* pStm)</unmanaged>	
        /// <unmanaged-short>MFSerializeAttributesToStream</unmanaged-short>	
        public static void SerializeAttributesToStream(SharpDX.MediaFoundation.MediaAttributes attrRef, int dwOptions, System.IntPtr stmRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFSerializeAttributesToStream_((void*)((attrRef == null) ? IntPtr.Zero : attrRef.NativePointer), dwOptions, (void*)stmRef);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFSerializeAttributesToStream", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFSerializeAttributesToStream_(void* arg0, int arg1, void* arg2);

        /// <summary>	
        /// <p> </p><p>Loads attributes from a stream into an attribute store.</p>	
        /// </summary>	
        /// <param name="attrRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the attribute store.</p> </dd></param>	
        /// <param name="dwOptions"><dd> <p>Bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.AttributeSerializeOptions"/></strong> enumeration.</p> </dd></param>	
        /// <param name="stmRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.Win32.IStream"/></strong> interface of the stream from which to read the attributes.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Use this function to deserialize an attribute store that was serialized with the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.SerializeAttributesToStream"/></strong> function.</p><p>If <em>dwOptions</em> contains the <see cref="SharpDX.MediaFoundation.AttributeSerializeOptions.UnknownByref"/> flag, the function deserializes <strong><see cref="SharpDX.ComObject"/></strong> references from the stream, as follows:</p><ul> <li> <p>If the <strong><see cref="SharpDX.Win32.IStream"/></strong> reference exposes the <strong><see cref="SharpDX.MediaFoundation.ObjectReferenceStream"/></strong> interface (through <strong>QueryInterface</strong>), the function calls <strong><see cref="SharpDX.MediaFoundation.ObjectReferenceStream.LoadReference"/></strong> to deserialize each reference.</p> </li> <li> <p>Otherwise, the function calls <strong>CoUnmarshalInterface</strong> to deserialize a proxy for the object.</p> </li> </ul><p>This function deletes any attributes that were previously stored in <em>pAttr</em>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFDeserializeAttributesFromStream']/*"/>	
        /// <msdn-id>ms703162</msdn-id>	
        /// <unmanaged>HRESULT MFDeserializeAttributesFromStream([In] IMFAttributes* pAttr,[In] unsigned int dwOptions,[In] IStream* pStm)</unmanaged>	
        /// <unmanaged-short>MFDeserializeAttributesFromStream</unmanaged-short>	
        public static void DeserializeAttributesFromStream(SharpDX.MediaFoundation.MediaAttributes attrRef, int dwOptions, System.IntPtr stmRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                MFDeserializeAttributesFromStream_((void*)((attrRef == null) ? IntPtr.Zero : attrRef.NativePointer), dwOptions, (void*)stmRef);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFDeserializeAttributesFromStream", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFDeserializeAttributesFromStream_(void* arg0, int arg1, void* arg2);

        /// <summary>	
        /// <p>Creates a generic activation object for Media Foundation transforms (MFTs).</p>	
        /// </summary>	
        /// <param name="activateOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Most applications will not use this function; it is used internally by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnumEx"/></strong> function. </p><p>An <em>activation object</em> is a helper object that creates another object, somewhat similar to a class factory. The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateTransformActivate"/></strong> function creates an activation object for MFTs. Before this activation object can create an MFT, the caller must initialize the activation object by setting one or more attributes on it.</p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.MftTransformClsidAttribute"/> </td><td>Required. Contains the CLSID of the MFT. The activation object creates the MFT by passing this CLSID to the <strong>CoCreateInstance</strong> function.</td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.TransformCategoryAttribute"/> </td><td>Optional. Specifies the category of the MFT.</td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.TransformFlagsAttribute"/> </td><td>Contains various flags that describe the MFT. For hardware-based MFTs, set the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Hardware"/></strong> flag. Otherwise, this attribute is optional.</td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.MftCodecMeritAttribute"/> </td><td> <p>Optional. Contains the merit value of a hardware codec.</p> <p>If this attribute is set and its value is greater than zero, the activation object calls <strong><see cref="SharpDX.MediaFoundation.MediaFactory.GetMFTMerit"/></strong> to get the trusted merit value for the MFT. If the trusted merit is less than the value of this attribute, the activation object's <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> method fails and returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidCodecMerit"/></strong>.</p> </td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.MftEnumHardwareUrlAttribute"/> </td><td>Required for hardware-based MFTs. Specifies the symbolic link for the hardware device. The device proxy uses this value to configure the MFT.</td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.MftFieldofuseUnlockAttribute"/> </td><td> <p>Optional. Contains an <strong><see cref="SharpDX.MediaFoundation.FieldOfUseMFTUnlock"/></strong> reference, which can be used to unlock the MFT. The <strong><see cref="SharpDX.MediaFoundation.FieldOfUseMFTUnlock"/></strong> interface is used with MFTs that have usage restrictions.</p> <p>If this attribute is set and the <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.TransformFlagsAttribute"/> attribute contains the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Fieldofuse"/></strong> flag, the activation object calls <strong><see cref="SharpDX.MediaFoundation.FieldOfUseMFTUnlock.Unlock"/></strong> when it creates the MFT. An application can also set the <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.MftFieldofuseUnlockAttribute"/> attribute without setting the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Fieldofuse"/></strong> flag. In that case, the application must call <strong>Unlock</strong>.</p> </td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.MftPreferredEncoderProfile"/> </td><td> <p>Optional. Contains the encoding profile for an encoder. The value of this attribute is an <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> reference.</p> <p>If this attribute is set and the value of the <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.TransformCategoryAttribute"/> attribute is <strong><see cref="SharpDX.MediaFoundation.TransformCategoryGuids.AudioEncoder"/></strong> or <strong><see cref="SharpDX.MediaFoundation.TransformCategoryGuids.VideoEncoder"/></strong>, the activation object uses the encoding profile to configure the MFT. The MFT must expose either <strong>ICodecAPI</strong> or <strong><see cref="SharpDX.ComObject"/></strong> for this purpose.</p> </td></tr> <tr><td> <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.MftPreferredOutputtypeAttribute"/> </td><td> <p>Optional. Specifies the preferred output format for an encoder.</p> <p>If this attribute set and the value of the <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.TransformCategoryAttribute"/> attribute is <strong><see cref="SharpDX.MediaFoundation.TransformCategoryGuids.AudioEncoder"/></strong> or <strong><see cref="SharpDX.MediaFoundation.TransformCategoryGuids.VideoEncoder"/></strong>, the activation object sets this media type on the MFT.</p> </td></tr> </table><p>?</p><p>For more information about activation objects, see Activation Objects.  </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFCreateTransformActivate']/*"/>	
        /// <msdn-id>dd388120</msdn-id>	
        /// <unmanaged>HRESULT MFCreateTransformActivate([Out] IMFActivate** ppActivate)</unmanaged>	
        /// <unmanaged-short>MFCreateTransformActivate</unmanaged-short>	
        public static void CreateTransformActivate(out SharpDX.MediaFoundation.Activate activateOut)
        {
            unsafe
            {
                IntPtr activateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                MFCreateTransformActivate_(&activateOut_);
                activateOut = (activateOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Activate(activateOut_);
                __result__.CheckError();
            }
        }
        [DllImport("Mfplat.dll", EntryPoint = "MFCreateTransformActivate", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int MFCreateTransformActivate_(void* arg0);
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.MediaServiceKeys']/*"/>	
    public static partial class MediaServiceKeys
    {

        /// <summary>Constant MetadataProvider.</summary>
        /// <unmanaged>MF_METADATA_PROVIDER_SERVICE</unmanaged>
        public static readonly Guid MetadataProvider = new Guid("db214084-58a4-4d2e-b84f-6f755b2f7a0d");

        /// <summary>Constant PMPServer.</summary>
        /// <unmanaged>MF_PMP_SERVER_CONTEXT</unmanaged>
        public static readonly Guid PMPServer = new Guid("2f00c910-d2cf-4278-8b6a-d077fac3a25f");

        /// <summary>Constant Qualiy.</summary>
        /// <unmanaged>MF_QUALITY_SERVICES</unmanaged>
        public static readonly Guid Qualiy = new Guid("b7e2be11-2f96-4640-b52c-282365bdf16c");

        /// <summary>Constant RateControl.</summary>
        /// <unmanaged>MF_RATE_CONTROL_SERVICE</unmanaged>
        public static readonly Guid RateControl = new Guid("866fa297-b802-4bf8-9dc9-5e3b6a9f53c9");

        /// <summary>Constant RemoteProxy.</summary>
        /// <unmanaged>MF_REMOTE_PROXY</unmanaged>
        public static readonly Guid RemoteProxy = new Guid("2f00c90e-d2cf-4278-8b6a-d077fac3a25f");

        /// <summary>Constant Sami.</summary>
        /// <unmanaged>MF_SAMI_SERVICE</unmanaged>
        public static readonly Guid Sami = new Guid("49a89ae7-b4d9-4ef2-aa5c-f65a3e05ae4e");

        /// <summary>Constant SourcePresentationProvider.</summary>
        /// <unmanaged>MF_SOURCE_PRESENTATION_PROVIDER_SERVICE</unmanaged>
        public static readonly Guid SourcePresentationProvider = new Guid("e002aadc-f4af-4ee5-9847-053edf840426");

        /// <summary>Constant TimeCode.</summary>
        /// <unmanaged>MF_TIMECODE_SERVICE</unmanaged>
        public static readonly Guid TimeCode = new Guid("a0d502a7-0eb3-4885-b1b9-9feb0d083454");

        /// <summary>Constant ToplogyNodeAttributeEditor.</summary>
        /// <unmanaged>MF_TOPONODE_ATTRIBUTE_EDITOR_SERVICE</unmanaged>
        public static readonly Guid ToplogyNodeAttributeEditor = new Guid("65656e1a-077f-4472-83ef-316f11d5087a");

        /// <summary>Constant WrappedObject.</summary>
        /// <unmanaged>MF_WRAPPED_OBJECT</unmanaged>
        public static readonly Guid WrappedObject = new Guid("2b182c4c-d6ac-49f4-8915-f71887db70cd");

        /// <summary>Constant WorkQueue.</summary>
        /// <unmanaged>MF_WORKQUEUE_SERVICES</unmanaged>
        public static readonly Guid WorkQueue = new Guid("8e37d489-41e0-413a-9068-287c886d8dda");

        /// <summary>Constant SaveJob.</summary>
        /// <unmanaged>MFNET_SAVEJOB_SERVICE</unmanaged>
        public static readonly Guid SaveJob = new Guid("b85a587f-3d02-4e52-9565-55d3ec1e7ff7");

        /// <summary>Constant NetworkSourceStatistics.</summary>
        /// <unmanaged>MFNETSOURCE_STATISTICS_SERVICE</unmanaged>
        public static readonly Guid NetworkSourceStatistics = new Guid("3cb1f275-0505-4c5d-ae71-0a556344efa1");

        /// <summary>Constant AudioPolicy.</summary>
        /// <unmanaged>MR_AUDIO_POLICY_SERVICE</unmanaged>
        public static readonly Guid AudioPolicy = new Guid("911fd737-6775-4ab0-a614-297862fdac88");

        /// <summary>Constant Buffer.</summary>
        /// <unmanaged>MR_BUFFER_SERVICE</unmanaged>
        public static readonly Guid Buffer = new Guid("a562248c-9ac6-4ffc-9fba-3af8f8ad1a4d");

        /// <summary>Constant CapturePolicyVolume.</summary>
        /// <unmanaged>MR_CAPTURE_POLICY_VOLUME_SERVICE</unmanaged>
        public static readonly Guid CapturePolicyVolume = new Guid("24030acd-107a-4265-975c-414e33e65f2a");

        /// <summary>Constant PolicyVolume.</summary>
        /// <unmanaged>MR_POLICY_VOLUME_SERVICE</unmanaged>
        public static readonly Guid PolicyVolume = new Guid("1abaa2ac-9d3b-47c6-ab48-c59506de784d");

        /// <summary>Constant StreamVolume.</summary>
        /// <unmanaged>MR_STREAM_VOLUME_SERVICE</unmanaged>
        public static readonly Guid StreamVolume = new Guid("f8b5fa2f-32ef-46f5-b172-1321212fb2c4");

        /// <summary>Constant VideoAcceleration.</summary>
        /// <unmanaged>MR_VIDEO_ACCELERATION_SERVICE</unmanaged>
        public static readonly Guid VideoAcceleration = new Guid("efef5175-5c7d-4ce2-bbbd-34ff8bca6554");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.MediaSessionAttributeKeys']/*"/>	
    public static partial class MediaSessionAttributeKeys
    {

        /// <summary>Constant ApproxEventOccurrenceTime.</summary>
        /// <unmanaged>MF_SESSION_APPROX_EVENT_OCCURRENCE_TIME</unmanaged>
        public static readonly MediaAttributeKey<long> ApproxEventOccurrenceTime = new MediaAttributeKey<long>("190e852f-6238-42d1-b5af-69ea338ef850", "ApproxEventOccurrenceTime");

        /// <summary>Constant ContentProtectionManager.</summary>
        /// <unmanaged>MF_SESSION_CONTENT_PROTECTION_MANAGER</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> ContentProtectionManager = new MediaAttributeKey<SharpDX.ComObject>("1e83d482-1f1c-4571-8405-88f4b2181f74", "ContentProtectionManager");

        /// <summary>Constant GlobalTime.</summary>
        /// <unmanaged>MF_SESSION_GLOBAL_TIME</unmanaged>
        public static readonly MediaAttributeKey<bool> GlobalTime = new MediaAttributeKey<bool>("1e83d482-1f1c-4571-8405-88f4b2181f72", "GlobalTime");

        /// <summary>Constant QualityManager.</summary>
        /// <unmanaged>MF_SESSION_QUALITY_MANAGER</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> QualityManager = new MediaAttributeKey<System.Guid>("1e83d482-1f1c-4571-8405-88f4b2181f73", "QualityManager");

        /// <summary>Constant RemoteSourceMode.</summary>
        /// <unmanaged>MF_SESSION_REMOTE_SOURCE_MODE</unmanaged>
        public static readonly MediaAttributeKey<bool> RemoteSourceMode = new MediaAttributeKey<bool>("f4033ef4-9bb3-4378-941f-85a0856bc244", "RemoteSourceMode");

        /// <summary>Constant ServerContext.</summary>
        /// <unmanaged>MF_SESSION_SERVER_CONTEXT</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> ServerContext = new MediaAttributeKey<SharpDX.ComObject>("afe5b291-50fa-46e8-b9be-0c0c3ce4b3a5", "ServerContext");

        /// <summary>Constant Topoloader.</summary>
        /// <unmanaged>MF_SESSION_TOPOLOADER</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> Topoloader = new MediaAttributeKey<System.Guid>("1e83d482-1f1c-4571-8405-88f4b2181f71", "Topoloader");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.MediaTypeAttributeKeys']/*"/>	
    public static partial class MediaTypeAttributeKeys
    {

        /// <summary>Constant AacAudioProfileLevelIndication.</summary>
        /// <unmanaged>MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION</unmanaged>
        public static readonly MediaAttributeKey<int> AacAudioProfileLevelIndication = new MediaAttributeKey<int>("7632f0e6-9538-4d61-acda-ea29c8c14456", "AacAudioProfileLevelIndication");

        /// <summary>Constant AacPayloadType.</summary>
        /// <unmanaged>MF_MT_AAC_PAYLOAD_TYPE</unmanaged>
        public static readonly MediaAttributeKey<int> AacPayloadType = new MediaAttributeKey<int>("bfbabe79-7434-4d1c-94f0-72a3b9e17188", "AacPayloadType");

        /// <summary>Constant AllSamplesIndependent.</summary>
        /// <unmanaged>MF_MT_ALL_SAMPLES_INDEPENDENT</unmanaged>
        public static readonly MediaAttributeKey<int> AllSamplesIndependent = new MediaAttributeKey<int>("c9173739-5e56-461c-b713-46fb995cb95f", "AllSamplesIndependent");

        /// <summary>Constant AmFormatType.</summary>
        /// <unmanaged>MF_MT_AM_FORMAT_TYPE</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> AmFormatType = new MediaAttributeKey<System.Guid>("73d1072d-1870-4174-a063-29ff4ff6c11e", "AmFormatType");

        /// <summary>Constant ArbitraryFormat.</summary>
        /// <unmanaged>MF_MT_ARBITRARY_FORMAT</unmanaged>
        public static readonly MediaAttributeKey<byte[]> ArbitraryFormat = new MediaAttributeKey<byte[]>("5a75b249-0d7d-49a1-a1c3-e0d87f0cade5", "ArbitraryFormat");

        /// <summary>Constant ArbitraryHeader.</summary>
        /// <unmanaged>MF_MT_ARBITRARY_HEADER</unmanaged>
        public static readonly MediaAttributeKey<byte[]> ArbitraryHeader = new MediaAttributeKey<byte[]>("9e6bd6f5-0109-4f95-84ac-9309153a19fc", "ArbitraryHeader");

        /// <summary>Constant AudioAvgBytesPerSecond.</summary>
        /// <unmanaged>MF_MT_AUDIO_AVG_BYTES_PER_SECOND</unmanaged>
        public static readonly MediaAttributeKey<int> AudioAvgBytesPerSecond = new MediaAttributeKey<int>("1aab75c8-cfef-451c-ab95-ac034b8e1731", "AudioAvgBytesPerSecond");

        /// <summary>Constant AudioBitsPerSample.</summary>
        /// <unmanaged>MF_MT_AUDIO_BITS_PER_SAMPLE</unmanaged>
        public static readonly MediaAttributeKey<int> AudioBitsPerSample = new MediaAttributeKey<int>("f2deb57f-40fa-4764-aa33-ed4f2d1ff669", "AudioBitsPerSample");

        /// <summary>Constant AudioBlockAlignment.</summary>
        /// <unmanaged>MF_MT_AUDIO_BLOCK_ALIGNMENT</unmanaged>
        public static readonly MediaAttributeKey<int> AudioBlockAlignment = new MediaAttributeKey<int>("322de230-9eeb-43bd-ab7a-ff412251541d", "AudioBlockAlignment");

        /// <summary>Constant AudioChannelMask.</summary>
        /// <unmanaged>MF_MT_AUDIO_CHANNEL_MASK</unmanaged>
        public static readonly MediaAttributeKey<int> AudioChannelMask = new MediaAttributeKey<int>("55fb5765-644a-4caf-8479-938983bb1588", "AudioChannelMask");

        /// <summary>Constant AudioFloatSamplesPerSecond.</summary>
        /// <unmanaged>MF_MT_AUDIO_FLOAT_SAMPLES_PER_SECOND</unmanaged>
        public static readonly MediaAttributeKey<double> AudioFloatSamplesPerSecond = new MediaAttributeKey<double>("fb3b724a-cfb5-4319-aefe-6e42b2406132", "AudioFloatSamplesPerSecond");

        /// <summary>Constant AudioFolddownMatrix.</summary>
        /// <unmanaged>MF_MT_AUDIO_FOLDDOWN_MATRIX</unmanaged>
        public static readonly MediaAttributeKey<byte[]> AudioFolddownMatrix = new MediaAttributeKey<byte[]>("9d62927c-36be-4cf2-b5c4-a3926e3e8711", "AudioFolddownMatrix");

        /// <summary>Constant AudioNumChannels.</summary>
        /// <unmanaged>MF_MT_AUDIO_NUM_CHANNELS</unmanaged>
        public static readonly MediaAttributeKey<int> AudioNumChannels = new MediaAttributeKey<int>("37e48bf5-645e-4c5b-89de-ada9e29b696a", "AudioNumChannels");

        /// <summary>Constant AudioPreferWaveformatex.</summary>
        /// <unmanaged>MF_MT_AUDIO_PREFER_WAVEFORMATEX</unmanaged>
        public static readonly MediaAttributeKey<bool> AudioPreferWaveformatex = new MediaAttributeKey<bool>("a901aaba-e037-458a-bdf6-545be2074042", "AudioPreferWaveformatex");

        /// <summary>Constant AudioSamplesPerBlock.</summary>
        /// <unmanaged>MF_MT_AUDIO_SAMPLES_PER_BLOCK</unmanaged>
        public static readonly MediaAttributeKey<int> AudioSamplesPerBlock = new MediaAttributeKey<int>("aab15aac-e13a-4995-9222-501ea15c6877", "AudioSamplesPerBlock");

        /// <summary>Constant AudioSamplesPerSecond.</summary>
        /// <unmanaged>MF_MT_AUDIO_SAMPLES_PER_SECOND</unmanaged>
        public static readonly MediaAttributeKey<int> AudioSamplesPerSecond = new MediaAttributeKey<int>("5faeeae7-0290-4c31-9e8a-c534f68d9dba", "AudioSamplesPerSecond");

        /// <summary>Constant AudioValidBitsPerSample.</summary>
        /// <unmanaged>MF_MT_AUDIO_VALID_BITS_PER_SAMPLE</unmanaged>
        public static readonly MediaAttributeKey<int> AudioValidBitsPerSample = new MediaAttributeKey<int>("d9bf8d6a-9530-4b7c-9ddf-ff6fd58bbd06", "AudioValidBitsPerSample");

        /// <summary>Constant AudioWmadrcAvgref.</summary>
        /// <unmanaged>MF_MT_AUDIO_WMADRC_AVGREF</unmanaged>
        public static readonly MediaAttributeKey<int> AudioWmadrcAvgref = new MediaAttributeKey<int>("9d62927f-36be-4cf2-b5c4-a3926e3e8711", "AudioWmadrcAvgref");

        /// <summary>Constant AudioWmadrcAvgtarget.</summary>
        /// <unmanaged>MF_MT_AUDIO_WMADRC_AVGTARGET</unmanaged>
        public static readonly MediaAttributeKey<int> AudioWmadrcAvgtarget = new MediaAttributeKey<int>("9d629280-36be-4cf2-b5c4-a3926e3e8711", "AudioWmadrcAvgtarget");

        /// <summary>Constant AudioWmadrcPeakref.</summary>
        /// <unmanaged>MF_MT_AUDIO_WMADRC_PEAKREF</unmanaged>
        public static readonly MediaAttributeKey<int> AudioWmadrcPeakref = new MediaAttributeKey<int>("9d62927d-36be-4cf2-b5c4-a3926e3e8711", "AudioWmadrcPeakref");

        /// <summary>Constant AudioWmadrcPeaktarget.</summary>
        /// <unmanaged>MF_MT_AUDIO_WMADRC_PEAKTARGET</unmanaged>
        public static readonly MediaAttributeKey<int> AudioWmadrcPeaktarget = new MediaAttributeKey<int>("9d62927e-36be-4cf2-b5c4-a3926e3e8711", "AudioWmadrcPeaktarget");

        /// <summary>Constant AvgBitErrorRate.</summary>
        /// <unmanaged>MF_MT_AVG_BIT_ERROR_RATE</unmanaged>
        public static readonly MediaAttributeKey<int> AvgBitErrorRate = new MediaAttributeKey<int>("799cabd6-3508-4db4-a3c7-569cd533deb1", "AvgBitErrorRate");

        /// <summary>Constant AvgBitrate.</summary>
        /// <unmanaged>MF_MT_AVG_BITRATE</unmanaged>
        public static readonly MediaAttributeKey<int> AvgBitrate = new MediaAttributeKey<int>("20332624-fb0d-4d9e-bd0d-cbf6786c102e", "AvgBitrate");

        /// <summary>Constant Compressed.</summary>
        /// <unmanaged>MF_MT_COMPRESSED</unmanaged>
        public static readonly MediaAttributeKey<bool> Compressed = new MediaAttributeKey<bool>("3afd0cee-18f2-4ba5-a110-8bea502e1f92", "Compressed");

        /// <summary>Constant CustomVideoPrimaries.</summary>
        /// <unmanaged>MF_MT_CUSTOM_VIDEO_PRIMARIES</unmanaged>
        public static readonly MediaAttributeKey<byte[]> CustomVideoPrimaries = new MediaAttributeKey<byte[]>("47537213-8cfb-4722-aa34-fbc9e24d77b8", "CustomVideoPrimaries");

        /// <summary>Constant DefaultStride.</summary>
        /// <unmanaged>MF_MT_DEFAULT_STRIDE</unmanaged>
        public static readonly MediaAttributeKey<int> DefaultStride = new MediaAttributeKey<int>("644b4e48-1e02-4516-b0eb-c01ca9d49ac6", "DefaultStride");

        /// <summary>Constant DrmFlags.</summary>
        /// <unmanaged>MF_MT_DRM_FLAGS</unmanaged>
        public static readonly MediaAttributeKey<int> DrmFlags = new MediaAttributeKey<int>("8772f323-355a-4cc7-bb78-6d61a048ae82", "DrmFlags");

        /// <summary>Constant DvAauxCtrlPack0.</summary>
        /// <unmanaged>MF_MT_DV_AAUX_CTRL_PACK_0</unmanaged>
        public static readonly MediaAttributeKey<int> DvAauxCtrlPack0 = new MediaAttributeKey<int>("f731004e-1dd1-4515-aabe-f0c06aa536ac", "DvAauxCtrlPack0");

        /// <summary>Constant DvAauxCtrlPack1.</summary>
        /// <unmanaged>MF_MT_DV_AAUX_CTRL_PACK_1</unmanaged>
        public static readonly MediaAttributeKey<int> DvAauxCtrlPack1 = new MediaAttributeKey<int>("cd1f470d-1f04-4fe0-bfb9-d07ae0386ad8", "DvAauxCtrlPack1");

        /// <summary>Constant DvAauxSrcPack0.</summary>
        /// <unmanaged>MF_MT_DV_AAUX_SRC_PACK_0</unmanaged>
        public static readonly MediaAttributeKey<int> DvAauxSrcPack0 = new MediaAttributeKey<int>("84bd5d88-0fb8-4ac8-be4b-a8848bef98f3", "DvAauxSrcPack0");

        /// <summary>Constant DvAauxSrcPack1.</summary>
        /// <unmanaged>MF_MT_DV_AAUX_SRC_PACK_1</unmanaged>
        public static readonly MediaAttributeKey<int> DvAauxSrcPack1 = new MediaAttributeKey<int>("720e6544-0225-4003-a651-0196563a958e", "DvAauxSrcPack1");

        /// <summary>Constant DvVauxCtrlPack.</summary>
        /// <unmanaged>MF_MT_DV_VAUX_CTRL_PACK</unmanaged>
        public static readonly MediaAttributeKey<int> DvVauxCtrlPack = new MediaAttributeKey<int>("2f84e1c4-0da1-4788-938e-0dfbfbb34b48", "DvVauxCtrlPack");

        /// <summary>Constant DvVauxSrcPack.</summary>
        /// <unmanaged>MF_MT_DV_VAUX_SRC_PACK</unmanaged>
        public static readonly MediaAttributeKey<int> DvVauxSrcPack = new MediaAttributeKey<int>("41402d9d-7b57-43c6-b129-2cb997f15009", "DvVauxSrcPack");

        /// <summary>Constant FixedSizeSamples.</summary>
        /// <unmanaged>MF_MT_FIXED_SIZE_SAMPLES</unmanaged>
        public static readonly MediaAttributeKey<int> FixedSizeSamples = new MediaAttributeKey<int>("b8ebefaf-b718-4e04-b0a9-116775e3321b", "FixedSizeSamples");

        /// <summary>Constant FrameRate.</summary>
        /// <unmanaged>MF_MT_FRAME_RATE</unmanaged>
        public static readonly MediaAttributeKey<long> FrameRate = new MediaAttributeKey<long>("c459a2e8-3d2c-4e44-b132-fee5156c7bb0", "FrameRate");

        /// <summary>Constant FrameRateRangeMax.</summary>
        /// <unmanaged>MF_MT_FRAME_RATE_RANGE_MAX</unmanaged>
        public static readonly MediaAttributeKey<long> FrameRateRangeMax = new MediaAttributeKey<long>("e3371d41-b4cf-4a05-bd4e-20b88bb2c4d6", "FrameRateRangeMax");

        /// <summary>Constant FrameRateRangeMin.</summary>
        /// <unmanaged>MF_MT_FRAME_RATE_RANGE_MIN</unmanaged>
        public static readonly MediaAttributeKey<long> FrameRateRangeMin = new MediaAttributeKey<long>("d2e7558c-dc1f-403f-9a72-d28bb1eb3b5e", "FrameRateRangeMin");

        /// <summary>Constant FrameSize.</summary>
        /// <unmanaged>MF_MT_FRAME_SIZE</unmanaged>
        public static readonly MediaAttributeKey<long> FrameSize = new MediaAttributeKey<long>("1652c33d-d6b2-4012-b834-72030849a37d", "FrameSize");

        /// <summary>Constant GeometricAperture.</summary>
        /// <unmanaged>MF_MT_GEOMETRIC_APERTURE</unmanaged>
        public static readonly MediaAttributeKey<byte[]> GeometricAperture = new MediaAttributeKey<byte[]>("66758743-7e5f-400d-980a-aa8596c85696", "GeometricAperture");

        /// <summary>Constant H264Capabilities.</summary>
        /// <unmanaged>MF_MT_H264_CAPABILITIES</unmanaged>
        public static readonly MediaAttributeKey<int> H264Capabilities = new MediaAttributeKey<int>("bb3bd508-490a-11e0-99e4-1316dfd72085", "H264Capabilities");

        /// <summary>Constant H264MaxCodecConfigDelay.</summary>
        /// <unmanaged>MF_MT_H264_MAX_CODEC_CONFIG_DELAY</unmanaged>
        public static readonly MediaAttributeKey<int> H264MaxCodecConfigDelay = new MediaAttributeKey<int>("f5929986-4c45-4fbb-bb49-6cc534d05b9b", "H264MaxCodecConfigDelay");

        /// <summary>Constant H264MaxMbPerSec.</summary>
        /// <unmanaged>MF_MT_H264_MAX_MB_PER_SEC</unmanaged>
        public static readonly MediaAttributeKey<byte[]> H264MaxMbPerSec = new MediaAttributeKey<byte[]>("45256d30-7215-4576-9336-b0f1bcd59bb2", "H264MaxMbPerSec");

        /// <summary>Constant H264RateControlModes.</summary>
        /// <unmanaged>MF_MT_H264_RATE_CONTROL_MODES</unmanaged>
        public static readonly MediaAttributeKey<int> H264RateControlModes = new MediaAttributeKey<int>("705177d8-45cb-11e0-ac7d-b91ce0d72085", "H264RateControlModes");

        /// <summary>Constant H264SimulcastSupport.</summary>
        /// <unmanaged>MF_MT_H264_SIMULCAST_SUPPORT</unmanaged>
        public static readonly MediaAttributeKey<int> H264SimulcastSupport = new MediaAttributeKey<int>("9ea2d63d-53f0-4a34-b94e-9de49a078cb3", "H264SimulcastSupport");

        /// <summary>Constant H264SupportedRateControlModes.</summary>
        /// <unmanaged>MF_MT_H264_SUPPORTED_RATE_CONTROL_MODES</unmanaged>
        public static readonly MediaAttributeKey<int> H264SupportedRateControlModes = new MediaAttributeKey<int>("6a8ac47e-519c-4f18-9bb3-7eeaaea5594d", "H264SupportedRateControlModes");

        /// <summary>Constant H264SupportedSliceModes.</summary>
        /// <unmanaged>MF_MT_H264_SUPPORTED_SLICE_MODES</unmanaged>
        public static readonly MediaAttributeKey<int> H264SupportedSliceModes = new MediaAttributeKey<int>("c8be1937-4d64-4549-8343-a8086c0bfda5", "H264SupportedSliceModes");

        /// <summary>Constant H264SupportedSyncFrameTypes.</summary>
        /// <unmanaged>MF_MT_H264_SUPPORTED_SYNC_FRAME_TYPES</unmanaged>
        public static readonly MediaAttributeKey<int> H264SupportedSyncFrameTypes = new MediaAttributeKey<int>("89a52c01-f282-48d2-b522-22e6ae633199", "H264SupportedSyncFrameTypes");

        /// <summary>Constant H264SupportedUsages.</summary>
        /// <unmanaged>MF_MT_H264_SUPPORTED_USAGES</unmanaged>
        public static readonly MediaAttributeKey<int> H264SupportedUsages = new MediaAttributeKey<int>("60b1a998-dc01-40ce-9736-aba845a2dbdc", "H264SupportedUsages");

        /// <summary>Constant H264SvcCapabilities.</summary>
        /// <unmanaged>MF_MT_H264_SVC_CAPABILITIES</unmanaged>
        public static readonly MediaAttributeKey<int> H264SvcCapabilities = new MediaAttributeKey<int>("f8993abe-d937-4a8f-bbca-6966fe9e1152", "H264SvcCapabilities");

        /// <summary>Constant H264Usage.</summary>
        /// <unmanaged>MF_MT_H264_USAGE</unmanaged>
        public static readonly MediaAttributeKey<int> H264Usage = new MediaAttributeKey<int>("359ce3a5-af00-49ca-a2f4-2ac94ca82b61", "H264Usage");

        /// <summary>Constant ImageLossTolerant.</summary>
        /// <unmanaged>MF_MT_IMAGE_LOSS_TOLERANT</unmanaged>
        public static readonly MediaAttributeKey<int> ImageLossTolerant = new MediaAttributeKey<int>("ed062cf4-e34e-4922-be99-934032133d7c", "ImageLossTolerant");

        /// <summary>Constant InterlaceMode.</summary>
        /// <unmanaged>MF_MT_INTERLACE_MODE</unmanaged>
        public static readonly MediaAttributeKey<int> InterlaceMode = new MediaAttributeKey<int>("e2724bb8-e676-4806-b4b2-a8d6efb44ccd", "InterlaceMode");

        /// <summary>Constant MajorType.</summary>
        /// <unmanaged>MF_MT_MAJOR_TYPE</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> MajorType = new MediaAttributeKey<System.Guid>("48eba18e-f8c9-4687-bf11-0a74c9f96a8f", "MajorType");

        /// <summary>Constant MaxKeyframeSpacing.</summary>
        /// <unmanaged>MF_MT_MAX_KEYFRAME_SPACING</unmanaged>
        public static readonly MediaAttributeKey<int> MaxKeyframeSpacing = new MediaAttributeKey<int>("c16eb52b-73a1-476f-8d62-839d6a020652", "MaxKeyframeSpacing");

        /// <summary>Constant MinimumDisplayAperture.</summary>
        /// <unmanaged>MF_MT_MINIMUM_DISPLAY_APERTURE</unmanaged>
        public static readonly MediaAttributeKey<byte[]> MinimumDisplayAperture = new MediaAttributeKey<byte[]>("d7388766-18fe-48c6-a177-ee894867c8c4", "MinimumDisplayAperture");

        /// <summary>Constant MpegSequenceHeader.</summary>
        /// <unmanaged>MF_MT_MPEG_SEQUENCE_HEADER</unmanaged>
        public static readonly MediaAttributeKey<byte[]> MpegSequenceHeader = new MediaAttributeKey<byte[]>("3c036de7-3ad0-4c9e-9216-ee6d6ac21cb3", "MpegSequenceHeader");

        /// <summary>Constant MpegStartTimeCode.</summary>
        /// <unmanaged>MF_MT_MPEG_START_TIME_CODE</unmanaged>
        public static readonly MediaAttributeKey<int> MpegStartTimeCode = new MediaAttributeKey<int>("91f67885-4333-4280-97cd-bd5a6c03a06e", "MpegStartTimeCode");

        /// <summary>Constant Mpeg2ContentPACKET.</summary>
        /// <unmanaged>MF_MT_MPEG2_CONTENT_PACKET</unmanaged>
        public static readonly MediaAttributeKey<int> Mpeg2ContentPACKET = new MediaAttributeKey<int>("825d55e4-4f12-4197-9eb3-59b6e4710f06", "Mpeg2ContentPACKET");

        /// <summary>Constant Mpeg2Flags.</summary>
        /// <unmanaged>MF_MT_MPEG2_FLAGS</unmanaged>
        public static readonly MediaAttributeKey<int> Mpeg2Flags = new MediaAttributeKey<int>("31e3991d-f701-4b2f-b426-8ae3bda9e04b", "Mpeg2Flags");

        /// <summary>Constant Mpeg2Level.</summary>
        /// <unmanaged>MF_MT_MPEG2_LEVEL</unmanaged>
        public static readonly MediaAttributeKey<int> Mpeg2Level = new MediaAttributeKey<int>("96f66574-11c5-4015-8666-bff516436da7", "Mpeg2Level");

        /// <summary>Constant Mpeg2Profile.</summary>
        /// <unmanaged>MF_MT_MPEG2_PROFILE</unmanaged>
        public static readonly MediaAttributeKey<int> Mpeg2Profile = new MediaAttributeKey<int>("ad76a80b-2d5c-4e0b-b375-64e520137036", "Mpeg2Profile");

        /// <summary>Constant Mpeg2STANDARD.</summary>
        /// <unmanaged>MF_MT_MPEG2_STANDARD</unmanaged>
        public static readonly MediaAttributeKey<int> Mpeg2STANDARD = new MediaAttributeKey<int>("a20af9e8-928a-4b26-aaa9-f05c74cac47c", "Mpeg2STANDARD");

        /// <summary>Constant Mpeg2TIMECODE.</summary>
        /// <unmanaged>MF_MT_MPEG2_TIMECODE</unmanaged>
        public static readonly MediaAttributeKey<int> Mpeg2TIMECODE = new MediaAttributeKey<int>("5229ba10-e29d-4f80-a59c-df4f180207d2", "Mpeg2TIMECODE");

        /// <summary>Constant Mpeg4CurrentSampleEntry.</summary>
        /// <unmanaged>MF_MT_MPEG4_CURRENT_SAMPLE_ENTRY</unmanaged>
        public static readonly MediaAttributeKey<int> Mpeg4CurrentSampleEntry = new MediaAttributeKey<int>("9aa7e155-b64a-4c1d-a500-455d600b6560", "Mpeg4CurrentSampleEntry");

        /// <summary>Constant Mpeg4SampleDescription.</summary>
        /// <unmanaged>MF_MT_MPEG4_SAMPLE_DESCRIPTION</unmanaged>
        public static readonly MediaAttributeKey<byte[]> Mpeg4SampleDescription = new MediaAttributeKey<byte[]>("261e9d83-9529-4b8f-a111-8b9c950a81a9", "Mpeg4SampleDescription");

        /// <summary>Constant Original4cc.</summary>
        /// <unmanaged>MF_MT_ORIGINAL_4CC</unmanaged>
        public static readonly MediaAttributeKey<int> Original4cc = new MediaAttributeKey<int>("d7be3fe0-2bc7-492d-b843-61a1919b70c3", "Original4cc");

        /// <summary>Constant OriginalWaveFormatTag.</summary>
        /// <unmanaged>MF_MT_ORIGINAL_WAVE_FORMAT_TAG</unmanaged>
        public static readonly MediaAttributeKey<int> OriginalWaveFormatTag = new MediaAttributeKey<int>("8cbbc843-9fd9-49c2-882f-a72586c408ad", "OriginalWaveFormatTag");

        /// <summary>Constant PadControlFlags.</summary>
        /// <unmanaged>MF_MT_PAD_CONTROL_FLAGS</unmanaged>
        public static readonly MediaAttributeKey<int> PadControlFlags = new MediaAttributeKey<int>("4d0e73e5-80ea-4354-a9d0-1176ceb028ea", "PadControlFlags");

        /// <summary>Constant Palette.</summary>
        /// <unmanaged>MF_MT_PALETTE</unmanaged>
        public static readonly MediaAttributeKey<byte[]> Palette = new MediaAttributeKey<byte[]>("6d283f42-9846-4410-afd9-654d503b1a54", "Palette");

        /// <summary>Constant PanScanAperture.</summary>
        /// <unmanaged>MF_MT_PAN_SCAN_APERTURE</unmanaged>
        public static readonly MediaAttributeKey<byte[]> PanScanAperture = new MediaAttributeKey<byte[]>("79614dde-9187-48fb-b8c7-4d52689de649", "PanScanAperture");

        /// <summary>Constant PanScanEnabled.</summary>
        /// <unmanaged>MF_MT_PAN_SCAN_ENABLED</unmanaged>
        public static readonly MediaAttributeKey<bool> PanScanEnabled = new MediaAttributeKey<bool>("4b7f6bc3-8b13-40b2-a993-abf630b8204e", "PanScanEnabled");

        /// <summary>Constant PixelAspectRatio.</summary>
        /// <unmanaged>MF_MT_PIXEL_ASPECT_RATIO</unmanaged>
        public static readonly MediaAttributeKey<long> PixelAspectRatio = new MediaAttributeKey<long>("c6376a1e-8d0a-4027-be45-6d9a0ad39bb6", "PixelAspectRatio");

        /// <summary>Constant SampleSize.</summary>
        /// <unmanaged>MF_MT_SAMPLE_SIZE</unmanaged>
        public static readonly MediaAttributeKey<int> SampleSize = new MediaAttributeKey<int>("dad3ab78-1990-408b-bce2-eba673dacc10", "SampleSize");

        /// <summary>Constant SourceContentHint.</summary>
        /// <unmanaged>MF_MT_SOURCE_CONTENT_HINT</unmanaged>
        public static readonly MediaAttributeKey<int> SourceContentHint = new MediaAttributeKey<int>("68aca3cc-22d0-44e6-85f8-28167197fa38", "SourceContentHint");

        /// <summary>Constant Subtype.</summary>
        /// <unmanaged>MF_MT_SUBTYPE</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> Subtype = new MediaAttributeKey<System.Guid>("f7e34c9a-42e8-4714-b74b-cb29d72c35e5", "Subtype");

        /// <summary>Constant TimestampCanBeDTS.</summary>
        /// <unmanaged>MF_MT_TIMESTAMP_CAN_BE_DTS</unmanaged>
        public static readonly MediaAttributeKey<bool> TimestampCanBeDTS = new MediaAttributeKey<bool>("24974215-1b7b-41e4-8625-ac469f2dedaa", "TimestampCanBeDTS");

        /// <summary>Constant TransferFunction.</summary>
        /// <unmanaged>MF_MT_TRANSFER_FUNCTION</unmanaged>
        public static readonly MediaAttributeKey<int> TransferFunction = new MediaAttributeKey<int>("5fb0fce9-be5c-4935-a811-ec838f8eed93", "TransferFunction");

        /// <summary>Constant UserData.</summary>
        /// <unmanaged>MF_MT_USER_DATA</unmanaged>
        public static readonly MediaAttributeKey<byte[]> UserData = new MediaAttributeKey<byte[]>("b6bc765f-4c3b-40a4-bd51-2535b66fe09d", "UserData");

        /// <summary>Constant Video3d.</summary>
        /// <unmanaged>MF_MT_VIDEO_3D</unmanaged>
        public static readonly MediaAttributeKey<bool> Video3d = new MediaAttributeKey<bool>("cb5e88cf-7b5b-476b-85aa-1ca5ae187555", "Video3d");

        /// <summary>Constant Video3dFirstIsLeft.</summary>
        /// <unmanaged>MF_MT_VIDEO_3D_FIRST_IS_LEFT</unmanaged>
        public static readonly MediaAttributeKey<bool> Video3dFirstIsLeft = new MediaAttributeKey<bool>("ec298493-0ada-4ea1-a4fe-cbbd36ce9331", "Video3dFirstIsLeft");

        /// <summary>Constant Video3dFormat.</summary>
        /// <unmanaged>MF_MT_VIDEO_3D_FORMAT</unmanaged>
        public static readonly MediaAttributeKey<int> Video3dFormat = new MediaAttributeKey<int>("5315d8a0-87c5-4697-b793-6606c67c049b", "Video3dFormat");

        /// <summary>Constant Video3dLeftIsBase.</summary>
        /// <unmanaged>MF_MT_VIDEO_3D_LEFT_IS_BASE</unmanaged>
        public static readonly MediaAttributeKey<bool> Video3dLeftIsBase = new MediaAttributeKey<bool>("6d4b7bff-5629-4404-948c-c634f4ce26d4", "Video3dLeftIsBase");

        /// <summary>Constant Video3dNumViews.</summary>
        /// <unmanaged>MF_MT_VIDEO_3D_NUM_VIEWS</unmanaged>
        public static readonly MediaAttributeKey<int> Video3dNumViews = new MediaAttributeKey<int>("bb077e8a-dcbf-42eb-af60-418df98aa495", "Video3dNumViews");

        /// <summary>Constant VideoChromaSiting.</summary>
        /// <unmanaged>MF_MT_VIDEO_CHROMA_SITING</unmanaged>
        public static readonly MediaAttributeKey<int> VideoChromaSiting = new MediaAttributeKey<int>("65df2370-c773-4c33-aa64-843e068efb0c", "VideoChromaSiting");

        /// <summary>Constant VideoLighting.</summary>
        /// <unmanaged>MF_MT_VIDEO_LIGHTING</unmanaged>
        public static readonly MediaAttributeKey<int> VideoLighting = new MediaAttributeKey<int>("53a0529c-890b-4216-8bf9-599367ad6d20", "VideoLighting");

        /// <summary>Constant VideoNominalRange.</summary>
        /// <unmanaged>MF_MT_VIDEO_NOMINAL_RANGE</unmanaged>
        public static readonly MediaAttributeKey<int> VideoNominalRange = new MediaAttributeKey<int>("c21b8ee5-b956-4071-8daf-325edf5cab11", "VideoNominalRange");

        /// <summary>Constant VideoPrimaries.</summary>
        /// <unmanaged>MF_MT_VIDEO_PRIMARIES</unmanaged>
        public static readonly MediaAttributeKey<int> VideoPrimaries = new MediaAttributeKey<int>("dbfbe4d7-0740-4ee0-8192-850ab0e21935", "VideoPrimaries");

        /// <summary>Constant VideoRotation.</summary>
        /// <unmanaged>MF_MT_VIDEO_ROTATION</unmanaged>
        public static readonly MediaAttributeKey<int> VideoRotation = new MediaAttributeKey<int>("c380465d-2271-428c-9b83-ecea3b4a85c1", "VideoRotation");

        /// <summary>Constant WrappedType.</summary>
        /// <unmanaged>MF_MT_WRAPPED_TYPE</unmanaged>
        public static readonly MediaAttributeKey<byte[]> WrappedType = new MediaAttributeKey<byte[]>("4d3f7b23-d02f-4e6c-9bee-e4bf2c6c695d", "WrappedType");

        /// <summary>Constant YuvMatrix.</summary>
        /// <unmanaged>MF_MT_YUV_MATRIX</unmanaged>
        public static readonly MediaAttributeKey<int> YuvMatrix = new MediaAttributeKey<int>("3e23d450-2c75-4d25-a00e-b91670d12327", "YuvMatrix");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.MediaTypeGuids']/*"/>	
    public static partial class MediaTypeGuids
    {

        /// <summary>Constant Default.</summary>
        /// <unmanaged>MFMediaType_Default</unmanaged>
        public static readonly System.Guid Default = new Guid("81a412e6-8103-4b06-857f-1862781024ac");

        /// <summary>Constant Audio.</summary>
        /// <unmanaged>MFMediaType_Audio</unmanaged>
        public static readonly System.Guid Audio = new Guid("73647561-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Video.</summary>
        /// <unmanaged>MFMediaType_Video</unmanaged>
        public static readonly System.Guid Video = new Guid("73646976-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Protected.</summary>
        /// <unmanaged>MFMediaType_Protected</unmanaged>
        public static readonly System.Guid Protected = new Guid("7b4b6fe6-9d04-4494-be14-7e0bd076c8e4");

        /// <summary>Constant Sami.</summary>
        /// <unmanaged>MFMediaType_SAMI</unmanaged>
        public static readonly System.Guid Sami = new Guid("e69669a0-3dcd-40cb-9e2e-3708387c0616");

        /// <summary>Constant Script.</summary>
        /// <unmanaged>MFMediaType_Script</unmanaged>
        public static readonly System.Guid Script = new Guid("72178c22-e45b-11d5-bc2a-00b0d0f3f4ab");

        /// <summary>Constant Image.</summary>
        /// <unmanaged>MFMediaType_Image</unmanaged>
        public static readonly System.Guid Image = new Guid("72178c23-e45b-11d5-bc2a-00b0d0f3f4ab");

        /// <summary>Constant Html.</summary>
        /// <unmanaged>MFMediaType_HTML</unmanaged>
        public static readonly System.Guid Html = new Guid("72178c24-e45b-11d5-bc2a-00b0d0f3f4ab");

        /// <summary>Constant Binary.</summary>
        /// <unmanaged>MFMediaType_Binary</unmanaged>
        public static readonly System.Guid Binary = new Guid("72178c25-e45b-11d5-bc2a-00b0d0f3f4ab");

        /// <summary>Constant FileTransfer.</summary>
        /// <unmanaged>MFMediaType_FileTransfer</unmanaged>
        public static readonly System.Guid FileTransfer = new Guid("72178c26-e45b-11d5-bc2a-00b0d0f3f4ab");

        /// <summary>Constant Stream.</summary>
        /// <unmanaged>MFMediaType_Stream</unmanaged>
        public static readonly System.Guid Stream = new Guid("e436eb83-524f-11ce-9f53-0020af0ba770");

        /// <summary>Constant MultiplexedFrames.</summary>
        /// <unmanaged>MFMediaType_MultiplexedFrames</unmanaged>
        public static readonly System.Guid MultiplexedFrames = new Guid("6ea542b0-281f-4231-a464-fe2f5022501c");

        /// <summary>Constant Subtitle.</summary>
        /// <unmanaged>MFMediaType_Subtitle</unmanaged>
        public static readonly System.Guid Subtitle = new Guid("a6d13581-ed50-4e65-ae08-26065576aacc");

        /// <summary>Constant Perception.</summary>
        /// <unmanaged>MFMediaType_Perception</unmanaged>
        public static readonly System.Guid Perception = new Guid("597ff6f9-6ea2-4670-85b4-ea84073fe940");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.Mpeg4MediaSinkAttributeKeys']/*"/>	
    public static partial class Mpeg4MediaSinkAttributeKeys
    {

        /// <summary>Constant MoovBeforeMdat.</summary>
        /// <unmanaged>MF_MPEG4SINK_MOOV_BEFORE_MDAT</unmanaged>
        public static readonly MediaAttributeKey<int> MoovBeforeMdat = new MediaAttributeKey<int>("f672e3ac-e1e6-4f10-b5ec-5f3b30828816", "MoovBeforeMdat");

        /// <summary>Constant SpsppsPassthrough.</summary>
        /// <unmanaged>MF_MPEG4SINK_SPSPPS_PASSTHROUGH</unmanaged>
        public static readonly MediaAttributeKey<bool> SpsppsPassthrough = new MediaAttributeKey<bool>("5601a134-2005-4ad2-b37d-22a6c554deb2", "SpsppsPassthrough");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.NaluAttributeKeys']/*"/>	
    public static partial class NaluAttributeKeys
    {

        /// <summary>Constant LengthInformation.</summary>
        /// <unmanaged>MF_NALU_LENGTH_INFORMATION</unmanaged>
        public static readonly MediaAttributeKey<byte[]> LengthInformation = new MediaAttributeKey<byte[]>("19124e7c-ad4b-465f-bb18-20186287b6af", "LengthInformation");

        /// <summary>Constant LengthSet.</summary>
        /// <unmanaged>MF_NALU_LENGTH_SET</unmanaged>
        public static readonly MediaAttributeKey<int> LengthSet = new MediaAttributeKey<int>("a7911d53-12a4-4965-ae70-6eadd6ff0551", "LengthSet");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys']/*"/>	
    public static partial class PresentationDescriptionAttributeKeys
    {

        /// <summary>Constant AppContext.</summary>
        /// <unmanaged>MF_PD_APP_CONTEXT</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> AppContext = new MediaAttributeKey<SharpDX.ComObject>("6c990d32-bb8e-477a-8598-0d5d96fcd88a", "AppContext");

        /// <summary>Constant AsfCodeclist.</summary>
        /// <unmanaged>MF_PD_ASF_CODECLIST</unmanaged>
        public static readonly MediaAttributeKey<byte[]> AsfCodeclist = new MediaAttributeKey<byte[]>("e4bb3509-c18d-4df1-bb99-7a36b3cc4119", "AsfCodeclist");

        /// <summary>Constant AsfContentencryptionKeyid.</summary>
        /// <unmanaged>MF_PD_ASF_CONTENTENCRYPTION_KEYID</unmanaged>
        public static readonly MediaAttributeKey<string> AsfContentencryptionKeyid = new MediaAttributeKey<string>("8520fe3e-277e-46ea-99e4-e30a86db12be", "AsfContentencryptionKeyid");

        /// <summary>Constant AsfContentencryptionLicenseUrl.</summary>
        /// <unmanaged>MF_PD_ASF_CONTENTENCRYPTION_LICENSE_URL</unmanaged>
        public static readonly MediaAttributeKey<string> AsfContentencryptionLicenseUrl = new MediaAttributeKey<string>("8520fe40-277e-46ea-99e4-e30a86db12be", "AsfContentencryptionLicenseUrl");

        /// <summary>Constant AsfContentencryptionSecretData.</summary>
        /// <unmanaged>MF_PD_ASF_CONTENTENCRYPTION_SECRET_DATA</unmanaged>
        public static readonly MediaAttributeKey<byte[]> AsfContentencryptionSecretData = new MediaAttributeKey<byte[]>("8520fe3f-277e-46ea-99e4-e30a86db12be", "AsfContentencryptionSecretData");

        /// <summary>Constant AsfContentencryptionType.</summary>
        /// <unmanaged>MF_PD_ASF_CONTENTENCRYPTION_TYPE</unmanaged>
        public static readonly MediaAttributeKey<string> AsfContentencryptionType = new MediaAttributeKey<string>("8520fe3d-277e-46ea-99e4-e30a86db12be", "AsfContentencryptionType");

        /// <summary>Constant AsfContentencryptionexEncryptionData.</summary>
        /// <unmanaged>MF_PD_ASF_CONTENTENCRYPTIONEX_ENCRYPTION_DATA</unmanaged>
        public static readonly MediaAttributeKey<byte[]> AsfContentencryptionexEncryptionData = new MediaAttributeKey<byte[]>("62508be5-ecdf-4924-a359-72bab3397b9d", "AsfContentencryptionexEncryptionData");

        /// <summary>Constant AsfDataLength.</summary>
        /// <unmanaged>MF_PD_ASF_DATA_LENGTH</unmanaged>
        public static readonly MediaAttributeKey<long> AsfDataLength = new MediaAttributeKey<long>("e7d5b3e8-1f29-45d3-8822-3e78fae272ed", "AsfDataLength");

        /// <summary>Constant AsfDataStartOffset.</summary>
        /// <unmanaged>MF_PD_ASF_DATA_START_OFFSET</unmanaged>
        public static readonly MediaAttributeKey<long> AsfDataStartOffset = new MediaAttributeKey<long>("e7d5b3e7-1f29-45d3-8822-3e78fae272ed", "AsfDataStartOffset");

        /// <summary>Constant AsfFilepropertiesCreationTime.</summary>
        /// <unmanaged>MF_PD_ASF_FILEPROPERTIES_CREATION_TIME</unmanaged>
        public static readonly MediaAttributeKey<byte[]> AsfFilepropertiesCreationTime = new MediaAttributeKey<byte[]>("3de649b6-d76d-4e66-9ec9-78120fb4c7e3", "AsfFilepropertiesCreationTime");

        /// <summary>Constant AsfFilepropertiesFileId.</summary>
        /// <unmanaged>MF_PD_ASF_FILEPROPERTIES_FILE_ID</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> AsfFilepropertiesFileId = new MediaAttributeKey<System.Guid>("3de649b4-d76d-4e66-9ec9-78120fb4c7e3", "AsfFilepropertiesFileId");

        /// <summary>Constant AsfFilepropertiesFlags.</summary>
        /// <unmanaged>MF_PD_ASF_FILEPROPERTIES_FLAGS</unmanaged>
        public static readonly MediaAttributeKey<int> AsfFilepropertiesFlags = new MediaAttributeKey<int>("3de649bb-d76d-4e66-9ec9-78120fb4c7e3", "AsfFilepropertiesFlags");

        /// <summary>Constant AsfFilepropertiesMaxBitrate.</summary>
        /// <unmanaged>MF_PD_ASF_FILEPROPERTIES_MAX_BITRATE</unmanaged>
        public static readonly MediaAttributeKey<int> AsfFilepropertiesMaxBitrate = new MediaAttributeKey<int>("3de649be-d76d-4e66-9ec9-78120fb4c7e3", "AsfFilepropertiesMaxBitrate");

        /// <summary>Constant AsfFilepropertiesMaxPacketSize.</summary>
        /// <unmanaged>MF_PD_ASF_FILEPROPERTIES_MAX_PACKET_SIZE</unmanaged>
        public static readonly MediaAttributeKey<int> AsfFilepropertiesMaxPacketSize = new MediaAttributeKey<int>("3de649bd-d76d-4e66-9ec9-78120fb4c7e3", "AsfFilepropertiesMaxPacketSize");

        /// <summary>Constant AsfFilepropertiesMinPacketSize.</summary>
        /// <unmanaged>MF_PD_ASF_FILEPROPERTIES_MIN_PACKET_SIZE</unmanaged>
        public static readonly MediaAttributeKey<int> AsfFilepropertiesMinPacketSize = new MediaAttributeKey<int>("3de649bc-d76d-4e66-9ec9-78120fb4c7e3", "AsfFilepropertiesMinPacketSize");

        /// <summary>Constant AsfFilepropertiesPackets.</summary>
        /// <unmanaged>MF_PD_ASF_FILEPROPERTIES_PACKETS</unmanaged>
        public static readonly MediaAttributeKey<int> AsfFilepropertiesPackets = new MediaAttributeKey<int>("3de649b7-d76d-4e66-9ec9-78120fb4c7e3", "AsfFilepropertiesPackets");

        /// <summary>Constant AsfFilepropertiesPlayDuration.</summary>
        /// <unmanaged>MF_PD_ASF_FILEPROPERTIES_PLAY_DURATION</unmanaged>
        public static readonly MediaAttributeKey<long> AsfFilepropertiesPlayDuration = new MediaAttributeKey<long>("3de649b8-d76d-4e66-9ec9-78120fb4c7e3", "AsfFilepropertiesPlayDuration");

        /// <summary>Constant AsfFilepropertiesPreroll.</summary>
        /// <unmanaged>MF_PD_ASF_FILEPROPERTIES_PREROLL</unmanaged>
        public static readonly MediaAttributeKey<long> AsfFilepropertiesPreroll = new MediaAttributeKey<long>("3de649ba-d76d-4e66-9ec9-78120fb4c7e3", "AsfFilepropertiesPreroll");

        /// <summary>Constant AsfFilepropertiesSendDuration.</summary>
        /// <unmanaged>MF_PD_ASF_FILEPROPERTIES_SEND_DURATION</unmanaged>
        public static readonly MediaAttributeKey<long> AsfFilepropertiesSendDuration = new MediaAttributeKey<long>("3de649b9-d76d-4e66-9ec9-78120fb4c7e3", "AsfFilepropertiesSendDuration");

        /// <summary>Constant AsfInfoHasAudio.</summary>
        /// <unmanaged>MF_PD_ASF_INFO_HAS_AUDIO</unmanaged>
        public static readonly MediaAttributeKey<bool> AsfInfoHasAudio = new MediaAttributeKey<bool>("80e62295-2296-4a44-b31c-d103c6fed23c", "AsfInfoHasAudio");

        /// <summary>Constant AsfInfoHasNonAudioVideo.</summary>
        /// <unmanaged>MF_PD_ASF_INFO_HAS_NON_AUDIO_VIDEO</unmanaged>
        public static readonly MediaAttributeKey<bool> AsfInfoHasNonAudioVideo = new MediaAttributeKey<bool>("80e62297-2296-4a44-b31c-d103c6fed23c", "AsfInfoHasNonAudioVideo");

        /// <summary>Constant AsfInfoHasVideo.</summary>
        /// <unmanaged>MF_PD_ASF_INFO_HAS_VIDEO</unmanaged>
        public static readonly MediaAttributeKey<bool> AsfInfoHasVideo = new MediaAttributeKey<bool>("80e62296-2296-4a44-b31c-d103c6fed23c", "AsfInfoHasVideo");

        /// <summary>Constant AsfLanglist.</summary>
        /// <unmanaged>MF_PD_ASF_LANGLIST</unmanaged>
        public static readonly MediaAttributeKey<byte[]> AsfLanglist = new MediaAttributeKey<byte[]>("f23de43c-9977-460d-a6ec-32937f160f7d", "AsfLanglist");

        /// <summary>Constant AsfLanglistLegacyorder.</summary>
        /// <unmanaged>MF_PD_ASF_LANGLIST_LEGACYORDER</unmanaged>
        public static readonly MediaAttributeKey<byte[]> AsfLanglistLegacyorder = new MediaAttributeKey<byte[]>("f23de43d-9977-460d-a6ec-32937f160f7d", "AsfLanglistLegacyorder");

        /// <summary>Constant AsfMarker.</summary>
        /// <unmanaged>MF_PD_ASF_MARKER</unmanaged>
        public static readonly MediaAttributeKey<byte[]> AsfMarker = new MediaAttributeKey<byte[]>("5134330e-83a6-475e-a9d5-4fb875fb2e31", "AsfMarker");

        /// <summary>Constant AsfMetadataIsVbr.</summary>
        /// <unmanaged>MF_PD_ASF_METADATA_IS_VBR</unmanaged>
        public static readonly MediaAttributeKey<bool> AsfMetadataIsVbr = new MediaAttributeKey<bool>("5fc6947a-ef60-445d-b449-442ecc78b4c1", "AsfMetadataIsVbr");

        /// <summary>Constant AsfMetadataLeakyBucketPairs.</summary>
        /// <unmanaged>MF_PD_ASF_METADATA_LEAKY_BUCKET_PAIRS</unmanaged>
        public static readonly MediaAttributeKey<byte[]> AsfMetadataLeakyBucketPairs = new MediaAttributeKey<byte[]>("5fc6947d-ef60-445d-b449-442ecc78b4c1", "AsfMetadataLeakyBucketPairs");

        /// <summary>Constant AsfMetadataV8Bufferaverage.</summary>
        /// <unmanaged>MF_PD_ASF_METADATA_V8_BUFFERAVERAGE</unmanaged>
        public static readonly MediaAttributeKey<int> AsfMetadataV8Bufferaverage = new MediaAttributeKey<int>("5fc6947c-ef60-445d-b449-442ecc78b4c1", "AsfMetadataV8Bufferaverage");

        /// <summary>Constant AsfMetadataV8Vbrpeak.</summary>
        /// <unmanaged>MF_PD_ASF_METADATA_V8_VBRPEAK</unmanaged>
        public static readonly MediaAttributeKey<int> AsfMetadataV8Vbrpeak = new MediaAttributeKey<int>("5fc6947b-ef60-445d-b449-442ecc78b4c1", "AsfMetadataV8Vbrpeak");

        /// <summary>Constant AsfScript.</summary>
        /// <unmanaged>MF_PD_ASF_SCRIPT</unmanaged>
        public static readonly MediaAttributeKey<byte[]> AsfScript = new MediaAttributeKey<byte[]>("e29cd0d7-d602-4923-a7fe-73fd97ecc650", "AsfScript");

        /// <summary>Constant AudioEncodingBitrate.</summary>
        /// <unmanaged>MF_PD_AUDIO_ENCODING_BITRATE</unmanaged>
        public static readonly MediaAttributeKey<int> AudioEncodingBitrate = new MediaAttributeKey<int>("6c990d35-bb8e-477a-8598-0d5d96fcd88a", "AudioEncodingBitrate");

        /// <summary>Constant AudioIsvariablebitrate.</summary>
        /// <unmanaged>MF_PD_AUDIO_ISVARIABLEBITRATE</unmanaged>
        public static readonly MediaAttributeKey<int> AudioIsvariablebitrate = new MediaAttributeKey<int>("33026ee0-e387-4582-ae0a-34a2ad3baa18", "AudioIsvariablebitrate");

        /// <summary>Constant Duration.</summary>
        /// <unmanaged>MF_PD_DURATION</unmanaged>
        public static readonly MediaAttributeKey<long> Duration = new MediaAttributeKey<long>("6c990d33-bb8e-477a-8598-0d5d96fcd88a", "Duration");

        /// <summary>Constant LastModifiedTime.</summary>
        /// <unmanaged>MF_PD_LAST_MODIFIED_TIME</unmanaged>
        public static readonly MediaAttributeKey<byte[]> LastModifiedTime = new MediaAttributeKey<byte[]>("6c990d38-bb8e-477a-8598-0d5d96fcd88a", "LastModifiedTime");

        /// <summary>Constant MimeType.</summary>
        /// <unmanaged>MF_PD_MIME_TYPE</unmanaged>
        public static readonly MediaAttributeKey<string> MimeType = new MediaAttributeKey<string>("6c990d37-bb8e-477a-8598-0d5d96fcd88a", "MimeType");

        /// <summary>Constant PlaybackBoundaryTime.</summary>
        /// <unmanaged>MF_PD_PLAYBACK_BOUNDARY_TIME</unmanaged>
        public static readonly MediaAttributeKey<long> PlaybackBoundaryTime = new MediaAttributeKey<long>("6c990d3b-bb8e-477a-8598-0d5d96fcd88a", "PlaybackBoundaryTime");

        /// <summary>Constant PlaybackElementId.</summary>
        /// <unmanaged>MF_PD_PLAYBACK_ELEMENT_ID</unmanaged>
        public static readonly MediaAttributeKey<int> PlaybackElementId = new MediaAttributeKey<int>("6c990d39-bb8e-477a-8598-0d5d96fcd88a", "PlaybackElementId");

        /// <summary>Constant PmphostContext.</summary>
        /// <unmanaged>MF_PD_PMPHOST_CONTEXT</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> PmphostContext = new MediaAttributeKey<SharpDX.ComObject>("6c990d31-bb8e-477a-8598-0d5d96fcd88a", "PmphostContext");

        /// <summary>Constant PreferredLanguage.</summary>
        /// <unmanaged>MF_PD_PREFERRED_LANGUAGE</unmanaged>
        public static readonly MediaAttributeKey<string> PreferredLanguage = new MediaAttributeKey<string>("6c990d3a-bb8e-477a-8598-0d5d96fcd88a", "PreferredLanguage");

        /// <summary>Constant SamiStylelist.</summary>
        /// <unmanaged>MF_PD_SAMI_STYLELIST</unmanaged>
        public static readonly MediaAttributeKey<byte[]> SamiStylelist = new MediaAttributeKey<byte[]>("e0b73c7f-486d-484e-9872-4de5192a7bf8", "SamiStylelist");

        /// <summary>Constant TotalFileSize.</summary>
        /// <unmanaged>MF_PD_TOTAL_FILE_SIZE</unmanaged>
        public static readonly MediaAttributeKey<long> TotalFileSize = new MediaAttributeKey<long>("6c990d34-bb8e-477a-8598-0d5d96fcd88a", "TotalFileSize");

        /// <summary>Constant VideoEncodingBitrate.</summary>
        /// <unmanaged>MF_PD_VIDEO_ENCODING_BITRATE</unmanaged>
        public static readonly MediaAttributeKey<int> VideoEncodingBitrate = new MediaAttributeKey<int>("6c990d36-bb8e-477a-8598-0d5d96fcd88a", "VideoEncodingBitrate");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.ProtectionAttributeKeys']/*"/>	
    public static partial class ProtectionAttributeKeys
    {

        /// <summary>Constant GraphicsTransferAesEncryption.</summary>
        /// <unmanaged>MFPROTECTION_GRAPHICS_TRANSFER_AES_ENCRYPTION</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> GraphicsTransferAesEncryption = new MediaAttributeKey<System.Guid>("c873de64-d8a5-49e6-88bb-fb963fd3d4ce", "GraphicsTransferAesEncryption");

        /// <summary>Constant VideoFrames.</summary>
        /// <unmanaged>MFPROTECTION_VIDEO_FRAMES</unmanaged>
        public static readonly MediaAttributeKey<int> VideoFrames = new MediaAttributeKey<int>("36a59cbc-7401-4a8c-bc20-46a7c9e597f0", "VideoFrames");

        /// <summary>Constant BestEffort.</summary>
        /// <unmanaged>MFPROTECTIONATTRIBUTE_BEST_EFFORT</unmanaged>
        public static readonly MediaAttributeKey<bool> BestEffort = new MediaAttributeKey<bool>("c8e06331-75f0-4ec1-8e77-17578f773b46", "BestEffort");

        /// <summary>Constant FailOver.</summary>
        /// <unmanaged>MFPROTECTIONATTRIBUTE_FAIL_OVER</unmanaged>
        public static readonly MediaAttributeKey<bool> FailOver = new MediaAttributeKey<bool>("8536abc5-38f1-4151-9cce-f55d941229ac", "FailOver");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.ResultCode']/*"/>	
    public partial class ResultCode
    {

        /// <summary>Constant DxgiDeviceNotInitializeD.</summary>
        /// <unmanaged>MF_E_DXGI_DEVICE_NOT_INITIALIZED</unmanaged>
        public static readonly SharpDX.ResultDescriptor DxgiDeviceNotInitializeD = new SharpDX.ResultDescriptor(unchecked((int)2147749888UL), "SharpDX.MediaFoundation", "MF_E_DXGI_DEVICE_NOT_INITIALIZED", "DxgiDeviceNotInitializeD");

        /// <summary>Constant DxgiNewVideoDevice.</summary>
        /// <unmanaged>MF_E_DXGI_NEW_VIDEO_DEVICE</unmanaged>
        public static readonly SharpDX.ResultDescriptor DxgiNewVideoDevice = new SharpDX.ResultDescriptor(unchecked((int)2147749889UL), "SharpDX.MediaFoundation", "MF_E_DXGI_NEW_VIDEO_DEVICE", "DxgiNewVideoDevice");

        /// <summary>Constant DxgiVideoDeviceLocked.</summary>
        /// <unmanaged>MF_E_DXGI_VIDEO_DEVICE_LOCKED</unmanaged>
        public static readonly SharpDX.ResultDescriptor DxgiVideoDeviceLocked = new SharpDX.ResultDescriptor(unchecked((int)2147749890UL), "SharpDX.MediaFoundation", "MF_E_DXGI_VIDEO_DEVICE_LOCKED", "DxgiVideoDeviceLocked");

        /// <summary>Constant PlatformNotInitializeD.</summary>
        /// <unmanaged>MF_E_PLATFORM_NOT_INITIALIZED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PlatformNotInitializeD = new SharpDX.ResultDescriptor(unchecked((int)3222091440UL), "SharpDX.MediaFoundation", "MF_E_PLATFORM_NOT_INITIALIZED", "PlatformNotInitializeD");

        /// <summary>Constant BufferTooSmall.</summary>
        /// <unmanaged>MF_E_BUFFERTOOSMALL</unmanaged>
        public static readonly SharpDX.ResultDescriptor BufferTooSmall = new SharpDX.ResultDescriptor(unchecked((int)3222091441UL), "SharpDX.MediaFoundation", "MF_E_BUFFERTOOSMALL", "BufferTooSmall");

        /// <summary>Constant InvalidRequest.</summary>
        /// <unmanaged>MF_E_INVALIDREQUEST</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidRequest = new SharpDX.ResultDescriptor(unchecked((int)3222091442UL), "SharpDX.MediaFoundation", "MF_E_INVALIDREQUEST", "InvalidRequest");

        /// <summary>Constant InvalidStreamNumber.</summary>
        /// <unmanaged>MF_E_INVALIDSTREAMNUMBER</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidStreamNumber = new SharpDX.ResultDescriptor(unchecked((int)3222091443UL), "SharpDX.MediaFoundation", "MF_E_INVALIDSTREAMNUMBER", "InvalidStreamNumber");

        /// <summary>Constant InvalidMediaType.</summary>
        /// <unmanaged>MF_E_INVALIDMEDIATYPE</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidMediaType = new SharpDX.ResultDescriptor(unchecked((int)3222091444UL), "SharpDX.MediaFoundation", "MF_E_INVALIDMEDIATYPE", "InvalidMediaType");

        /// <summary>Constant NotAccepting.</summary>
        /// <unmanaged>MF_E_NOTACCEPTING</unmanaged>
        public static readonly SharpDX.ResultDescriptor NotAccepting = new SharpDX.ResultDescriptor(unchecked((int)3222091445UL), "SharpDX.MediaFoundation", "MF_E_NOTACCEPTING", "NotAccepting");

        /// <summary>Constant NotInitializeD.</summary>
        /// <unmanaged>MF_E_NOT_INITIALIZED</unmanaged>
        public static readonly SharpDX.ResultDescriptor NotInitializeD = new SharpDX.ResultDescriptor(unchecked((int)3222091446UL), "SharpDX.MediaFoundation", "MF_E_NOT_INITIALIZED", "NotInitializeD");

        /// <summary>Constant UnsupportedRepresentation.</summary>
        /// <unmanaged>MF_E_UNSUPPORTED_REPRESENTATION</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedRepresentation = new SharpDX.ResultDescriptor(unchecked((int)3222091447UL), "SharpDX.MediaFoundation", "MF_E_UNSUPPORTED_REPRESENTATION", "UnsupportedRepresentation");

        /// <summary>Constant NoMoreTypes.</summary>
        /// <unmanaged>MF_E_NO_MORE_TYPES</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoMoreTypes = new SharpDX.ResultDescriptor(unchecked((int)3222091449UL), "SharpDX.MediaFoundation", "MF_E_NO_MORE_TYPES", "NoMoreTypes");

        /// <summary>Constant UnsupportedService.</summary>
        /// <unmanaged>MF_E_UNSUPPORTED_SERVICE</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedService = new SharpDX.ResultDescriptor(unchecked((int)3222091450UL), "SharpDX.MediaFoundation", "MF_E_UNSUPPORTED_SERVICE", "UnsupportedService");

        /// <summary>Constant Unexpected.</summary>
        /// <unmanaged>MF_E_UNEXPECTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor Unexpected = new SharpDX.ResultDescriptor(unchecked((int)3222091451UL), "SharpDX.MediaFoundation", "MF_E_UNEXPECTED", "Unexpected");

        /// <summary>Constant InvalidName.</summary>
        /// <unmanaged>MF_E_INVALIDNAME</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidName = new SharpDX.ResultDescriptor(unchecked((int)3222091452UL), "SharpDX.MediaFoundation", "MF_E_INVALIDNAME", "InvalidName");

        /// <summary>Constant InvalidType.</summary>
        /// <unmanaged>MF_E_INVALIDTYPE</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidType = new SharpDX.ResultDescriptor(unchecked((int)3222091453UL), "SharpDX.MediaFoundation", "MF_E_INVALIDTYPE", "InvalidType");

        /// <summary>Constant InvalidFileFormat.</summary>
        /// <unmanaged>MF_E_INVALID_FILE_FORMAT</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidFileFormat = new SharpDX.ResultDescriptor(unchecked((int)3222091454UL), "SharpDX.MediaFoundation", "MF_E_INVALID_FILE_FORMAT", "InvalidFileFormat");

        /// <summary>Constant InvalidIndex.</summary>
        /// <unmanaged>MF_E_INVALIDINDEX</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidIndex = new SharpDX.ResultDescriptor(unchecked((int)3222091455UL), "SharpDX.MediaFoundation", "MF_E_INVALIDINDEX", "InvalidIndex");

        /// <summary>Constant InvalidTimestamp.</summary>
        /// <unmanaged>MF_E_INVALID_TIMESTAMP</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidTimestamp = new SharpDX.ResultDescriptor(unchecked((int)3222091456UL), "SharpDX.MediaFoundation", "MF_E_INVALID_TIMESTAMP", "InvalidTimestamp");

        /// <summary>Constant UnsupportedScheme.</summary>
        /// <unmanaged>MF_E_UNSUPPORTED_SCHEME</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedScheme = new SharpDX.ResultDescriptor(unchecked((int)3222091459UL), "SharpDX.MediaFoundation", "MF_E_UNSUPPORTED_SCHEME", "UnsupportedScheme");

        /// <summary>Constant UnsupportedByteStreamType.</summary>
        /// <unmanaged>MF_E_UNSUPPORTED_BYTESTREAM_TYPE</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedByteStreamType = new SharpDX.ResultDescriptor(unchecked((int)3222091460UL), "SharpDX.MediaFoundation", "MF_E_UNSUPPORTED_BYTESTREAM_TYPE", "UnsupportedByteStreamType");

        /// <summary>Constant UnsupportedTimeFormat.</summary>
        /// <unmanaged>MF_E_UNSUPPORTED_TIME_FORMAT</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedTimeFormat = new SharpDX.ResultDescriptor(unchecked((int)3222091461UL), "SharpDX.MediaFoundation", "MF_E_UNSUPPORTED_TIME_FORMAT", "UnsupportedTimeFormat");

        /// <summary>Constant NoSampleTimestamp.</summary>
        /// <unmanaged>MF_E_NO_SAMPLE_TIMESTAMP</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoSampleTimestamp = new SharpDX.ResultDescriptor(unchecked((int)3222091464UL), "SharpDX.MediaFoundation", "MF_E_NO_SAMPLE_TIMESTAMP", "NoSampleTimestamp");

        /// <summary>Constant NoSampleDuration.</summary>
        /// <unmanaged>MF_E_NO_SAMPLE_DURATION</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoSampleDuration = new SharpDX.ResultDescriptor(unchecked((int)3222091465UL), "SharpDX.MediaFoundation", "MF_E_NO_SAMPLE_DURATION", "NoSampleDuration");

        /// <summary>Constant InvalidStreamData.</summary>
        /// <unmanaged>MF_E_INVALID_STREAM_DATA</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidStreamData = new SharpDX.ResultDescriptor(unchecked((int)3222091467UL), "SharpDX.MediaFoundation", "MF_E_INVALID_STREAM_DATA", "InvalidStreamData");

        /// <summary>Constant RtUnavailable.</summary>
        /// <unmanaged>MF_E_RT_UNAVAILABLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor RtUnavailable = new SharpDX.ResultDescriptor(unchecked((int)3222091471UL), "SharpDX.MediaFoundation", "MF_E_RT_UNAVAILABLE", "RtUnavailable");

        /// <summary>Constant UnsupportedRate.</summary>
        /// <unmanaged>MF_E_UNSUPPORTED_RATE</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedRate = new SharpDX.ResultDescriptor(unchecked((int)3222091472UL), "SharpDX.MediaFoundation", "MF_E_UNSUPPORTED_RATE", "UnsupportedRate");

        /// <summary>Constant ThinningUnsupported.</summary>
        /// <unmanaged>MF_E_THINNING_UNSUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor ThinningUnsupported = new SharpDX.ResultDescriptor(unchecked((int)3222091473UL), "SharpDX.MediaFoundation", "MF_E_THINNING_UNSUPPORTED", "ThinningUnsupported");

        /// <summary>Constant ReverseUnsupported.</summary>
        /// <unmanaged>MF_E_REVERSE_UNSUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor ReverseUnsupported = new SharpDX.ResultDescriptor(unchecked((int)3222091474UL), "SharpDX.MediaFoundation", "MF_E_REVERSE_UNSUPPORTED", "ReverseUnsupported");

        /// <summary>Constant UnsupportedRateTransition.</summary>
        /// <unmanaged>MF_E_UNSUPPORTED_RATE_TRANSITION</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedRateTransition = new SharpDX.ResultDescriptor(unchecked((int)3222091475UL), "SharpDX.MediaFoundation", "MF_E_UNSUPPORTED_RATE_TRANSITION", "UnsupportedRateTransition");

        /// <summary>Constant RateChangePreempted.</summary>
        /// <unmanaged>MF_E_RATE_CHANGE_PREEMPTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor RateChangePreempted = new SharpDX.ResultDescriptor(unchecked((int)3222091476UL), "SharpDX.MediaFoundation", "MF_E_RATE_CHANGE_PREEMPTED", "RateChangePreempted");

        /// <summary>Constant NotFound.</summary>
        /// <unmanaged>MF_E_NOT_FOUND</unmanaged>
        public static readonly SharpDX.ResultDescriptor NotFound = new SharpDX.ResultDescriptor(unchecked((int)3222091477UL), "SharpDX.MediaFoundation", "MF_E_NOT_FOUND", "NotFound");

        /// <summary>Constant NotAvailable.</summary>
        /// <unmanaged>MF_E_NOT_AVAILABLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NotAvailable = new SharpDX.ResultDescriptor(unchecked((int)3222091478UL), "SharpDX.MediaFoundation", "MF_E_NOT_AVAILABLE", "NotAvailable");

        /// <summary>Constant NoClock.</summary>
        /// <unmanaged>MF_E_NO_CLOCK</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoClock = new SharpDX.ResultDescriptor(unchecked((int)3222091479UL), "SharpDX.MediaFoundation", "MF_E_NO_CLOCK", "NoClock");

        /// <summary>Constant MultipleBegin.</summary>
        /// <unmanaged>MF_E_MULTIPLE_BEGIN</unmanaged>
        public static readonly SharpDX.ResultDescriptor MultipleBegin = new SharpDX.ResultDescriptor(unchecked((int)3222091481UL), "SharpDX.MediaFoundation", "MF_E_MULTIPLE_BEGIN", "MultipleBegin");

        /// <summary>Constant MultipleSubScribers.</summary>
        /// <unmanaged>MF_E_MULTIPLE_SUBSCRIBERS</unmanaged>
        public static readonly SharpDX.ResultDescriptor MultipleSubScribers = new SharpDX.ResultDescriptor(unchecked((int)3222091482UL), "SharpDX.MediaFoundation", "MF_E_MULTIPLE_SUBSCRIBERS", "MultipleSubScribers");

        /// <summary>Constant TimerOrphaned.</summary>
        /// <unmanaged>MF_E_TIMER_ORPHANED</unmanaged>
        public static readonly SharpDX.ResultDescriptor TimerOrphaned = new SharpDX.ResultDescriptor(unchecked((int)3222091483UL), "SharpDX.MediaFoundation", "MF_E_TIMER_ORPHANED", "TimerOrphaned");

        /// <summary>Constant StateTransitionPending.</summary>
        /// <unmanaged>MF_E_STATE_TRANSITION_PENDING</unmanaged>
        public static readonly SharpDX.ResultDescriptor StateTransitionPending = new SharpDX.ResultDescriptor(unchecked((int)3222091484UL), "SharpDX.MediaFoundation", "MF_E_STATE_TRANSITION_PENDING", "StateTransitionPending");

        /// <summary>Constant UnsupportedStateTransition.</summary>
        /// <unmanaged>MF_E_UNSUPPORTED_STATE_TRANSITION</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedStateTransition = new SharpDX.ResultDescriptor(unchecked((int)3222091485UL), "SharpDX.MediaFoundation", "MF_E_UNSUPPORTED_STATE_TRANSITION", "UnsupportedStateTransition");

        /// <summary>Constant UnrecoverableErrorOccurred.</summary>
        /// <unmanaged>MF_E_UNRECOVERABLE_ERROR_OCCURRED</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnrecoverableErrorOccurred = new SharpDX.ResultDescriptor(unchecked((int)3222091486UL), "SharpDX.MediaFoundation", "MF_E_UNRECOVERABLE_ERROR_OCCURRED", "UnrecoverableErrorOccurred");

        /// <summary>Constant SampleHasTooManyBuffers.</summary>
        /// <unmanaged>MF_E_SAMPLE_HAS_TOO_MANY_BUFFERS</unmanaged>
        public static readonly SharpDX.ResultDescriptor SampleHasTooManyBuffers = new SharpDX.ResultDescriptor(unchecked((int)3222091487UL), "SharpDX.MediaFoundation", "MF_E_SAMPLE_HAS_TOO_MANY_BUFFERS", "SampleHasTooManyBuffers");

        /// <summary>Constant SampleNotWritable.</summary>
        /// <unmanaged>MF_E_SAMPLE_NOT_WRITABLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor SampleNotWritable = new SharpDX.ResultDescriptor(unchecked((int)3222091488UL), "SharpDX.MediaFoundation", "MF_E_SAMPLE_NOT_WRITABLE", "SampleNotWritable");

        /// <summary>Constant InvalidKey.</summary>
        /// <unmanaged>MF_E_INVALID_KEY</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidKey = new SharpDX.ResultDescriptor(unchecked((int)3222091490UL), "SharpDX.MediaFoundation", "MF_E_INVALID_KEY", "InvalidKey");

        /// <summary>Constant BadStartupVersion.</summary>
        /// <unmanaged>MF_E_BAD_STARTUP_VERSION</unmanaged>
        public static readonly SharpDX.ResultDescriptor BadStartupVersion = new SharpDX.ResultDescriptor(unchecked((int)3222091491UL), "SharpDX.MediaFoundation", "MF_E_BAD_STARTUP_VERSION", "BadStartupVersion");

        /// <summary>Constant UnsupportedCaption.</summary>
        /// <unmanaged>MF_E_UNSUPPORTED_CAPTION</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedCaption = new SharpDX.ResultDescriptor(unchecked((int)3222091492UL), "SharpDX.MediaFoundation", "MF_E_UNSUPPORTED_CAPTION", "UnsupportedCaption");

        /// <summary>Constant InvalidPosition.</summary>
        /// <unmanaged>MF_E_INVALID_POSITION</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidPosition = new SharpDX.ResultDescriptor(unchecked((int)3222091493UL), "SharpDX.MediaFoundation", "MF_E_INVALID_POSITION", "InvalidPosition");

        /// <summary>Constant Attributenotfound.</summary>
        /// <unmanaged>MF_E_ATTRIBUTENOTFOUND</unmanaged>
        public static readonly SharpDX.ResultDescriptor Attributenotfound = new SharpDX.ResultDescriptor(unchecked((int)3222091494UL), "SharpDX.MediaFoundation", "MF_E_ATTRIBUTENOTFOUND", "Attributenotfound");

        /// <summary>Constant PropertyTypeNotAllowEd.</summary>
        /// <unmanaged>MF_E_PROPERTY_TYPE_NOT_ALLOWED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PropertyTypeNotAllowEd = new SharpDX.ResultDescriptor(unchecked((int)3222091495UL), "SharpDX.MediaFoundation", "MF_E_PROPERTY_TYPE_NOT_ALLOWED", "PropertyTypeNotAllowEd");

        /// <summary>Constant PropertyTypeNotSupported.</summary>
        /// <unmanaged>MF_E_PROPERTY_TYPE_NOT_SUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PropertyTypeNotSupported = new SharpDX.ResultDescriptor(unchecked((int)3222091496UL), "SharpDX.MediaFoundation", "MF_E_PROPERTY_TYPE_NOT_SUPPORTED", "PropertyTypeNotSupported");

        /// <summary>Constant PropertyEmpty.</summary>
        /// <unmanaged>MF_E_PROPERTY_EMPTY</unmanaged>
        public static readonly SharpDX.ResultDescriptor PropertyEmpty = new SharpDX.ResultDescriptor(unchecked((int)3222091497UL), "SharpDX.MediaFoundation", "MF_E_PROPERTY_EMPTY", "PropertyEmpty");

        /// <summary>Constant PropertyNotEmpty.</summary>
        /// <unmanaged>MF_E_PROPERTY_NOT_EMPTY</unmanaged>
        public static readonly SharpDX.ResultDescriptor PropertyNotEmpty = new SharpDX.ResultDescriptor(unchecked((int)3222091498UL), "SharpDX.MediaFoundation", "MF_E_PROPERTY_NOT_EMPTY", "PropertyNotEmpty");

        /// <summary>Constant PropertyVectorNotAllowEd.</summary>
        /// <unmanaged>MF_E_PROPERTY_VECTOR_NOT_ALLOWED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PropertyVectorNotAllowEd = new SharpDX.ResultDescriptor(unchecked((int)3222091499UL), "SharpDX.MediaFoundation", "MF_E_PROPERTY_VECTOR_NOT_ALLOWED", "PropertyVectorNotAllowEd");

        /// <summary>Constant PropertyVectorRequired.</summary>
        /// <unmanaged>MF_E_PROPERTY_VECTOR_REQUIRED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PropertyVectorRequired = new SharpDX.ResultDescriptor(unchecked((int)3222091500UL), "SharpDX.MediaFoundation", "MF_E_PROPERTY_VECTOR_REQUIRED", "PropertyVectorRequired");

        /// <summary>Constant OperationCancelled.</summary>
        /// <unmanaged>MF_E_OPERATION_CANCELLED</unmanaged>
        public static readonly SharpDX.ResultDescriptor OperationCancelled = new SharpDX.ResultDescriptor(unchecked((int)3222091501UL), "SharpDX.MediaFoundation", "MF_E_OPERATION_CANCELLED", "OperationCancelled");

        /// <summary>Constant ByteStreamNotSeekable.</summary>
        /// <unmanaged>MF_E_BYTESTREAM_NOT_SEEKABLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor ByteStreamNotSeekable = new SharpDX.ResultDescriptor(unchecked((int)3222091502UL), "SharpDX.MediaFoundation", "MF_E_BYTESTREAM_NOT_SEEKABLE", "ByteStreamNotSeekable");

        /// <summary>Constant DisabledInSafemode.</summary>
        /// <unmanaged>MF_E_DISABLED_IN_SAFEMODE</unmanaged>
        public static readonly SharpDX.ResultDescriptor DisabledInSafemode = new SharpDX.ResultDescriptor(unchecked((int)3222091503UL), "SharpDX.MediaFoundation", "MF_E_DISABLED_IN_SAFEMODE", "DisabledInSafemode");

        /// <summary>Constant CannotParseByteStream.</summary>
        /// <unmanaged>MF_E_CANNOT_PARSE_BYTESTREAM</unmanaged>
        public static readonly SharpDX.ResultDescriptor CannotParseByteStream = new SharpDX.ResultDescriptor(unchecked((int)3222091504UL), "SharpDX.MediaFoundation", "MF_E_CANNOT_PARSE_BYTESTREAM", "CannotParseByteStream");

        /// <summary>Constant SourceResolverMutuallyExclusiveFlags.</summary>
        /// <unmanaged>MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS</unmanaged>
        public static readonly SharpDX.ResultDescriptor SourceResolverMutuallyExclusiveFlags = new SharpDX.ResultDescriptor(unchecked((int)3222091505UL), "SharpDX.MediaFoundation", "MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS", "SourceResolverMutuallyExclusiveFlags");

        /// <summary>Constant MediaProcWrongState.</summary>
        /// <unmanaged>MF_E_MEDIAPROC_WRONGSTATE</unmanaged>
        public static readonly SharpDX.ResultDescriptor MediaProcWrongState = new SharpDX.ResultDescriptor(unchecked((int)3222091506UL), "SharpDX.MediaFoundation", "MF_E_MEDIAPROC_WRONGSTATE", "MediaProcWrongState");

        /// <summary>Constant RtThroughputNotAvailable.</summary>
        /// <unmanaged>MF_E_RT_THROUGHPUT_NOT_AVAILABLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor RtThroughputNotAvailable = new SharpDX.ResultDescriptor(unchecked((int)3222091507UL), "SharpDX.MediaFoundation", "MF_E_RT_THROUGHPUT_NOT_AVAILABLE", "RtThroughputNotAvailable");

        /// <summary>Constant RtTooManyClassEs.</summary>
        /// <unmanaged>MF_E_RT_TOO_MANY_CLASSES</unmanaged>
        public static readonly SharpDX.ResultDescriptor RtTooManyClassEs = new SharpDX.ResultDescriptor(unchecked((int)3222091508UL), "SharpDX.MediaFoundation", "MF_E_RT_TOO_MANY_CLASSES", "RtTooManyClassEs");

        /// <summary>Constant RtWouldblock.</summary>
        /// <unmanaged>MF_E_RT_WOULDBLOCK</unmanaged>
        public static readonly SharpDX.ResultDescriptor RtWouldblock = new SharpDX.ResultDescriptor(unchecked((int)3222091509UL), "SharpDX.MediaFoundation", "MF_E_RT_WOULDBLOCK", "RtWouldblock");

        /// <summary>Constant NoBitpump.</summary>
        /// <unmanaged>MF_E_NO_BITPUMP</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoBitpump = new SharpDX.ResultDescriptor(unchecked((int)3222091510UL), "SharpDX.MediaFoundation", "MF_E_NO_BITPUMP", "NoBitpump");

        /// <summary>Constant RtOufOfMemory.</summary>
        /// <unmanaged>MF_E_RT_OUTOFMEMORY</unmanaged>
        public static readonly SharpDX.ResultDescriptor RtOufOfMemory = new SharpDX.ResultDescriptor(unchecked((int)3222091511UL), "SharpDX.MediaFoundation", "MF_E_RT_OUTOFMEMORY", "RtOufOfMemory");

        /// <summary>Constant RtWorkqueueClassNotSpecified.</summary>
        /// <unmanaged>MF_E_RT_WORKQUEUE_CLASS_NOT_SPECIFIED</unmanaged>
        public static readonly SharpDX.ResultDescriptor RtWorkqueueClassNotSpecified = new SharpDX.ResultDescriptor(unchecked((int)3222091512UL), "SharpDX.MediaFoundation", "MF_E_RT_WORKQUEUE_CLASS_NOT_SPECIFIED", "RtWorkqueueClassNotSpecified");

        /// <summary>Constant InsufficientBuffer.</summary>
        /// <unmanaged>MF_E_INSUFFICIENT_BUFFER</unmanaged>
        public static readonly SharpDX.ResultDescriptor InsufficientBuffer = new SharpDX.ResultDescriptor(unchecked((int)3222106480UL), "SharpDX.MediaFoundation", "MF_E_INSUFFICIENT_BUFFER", "InsufficientBuffer");

        /// <summary>Constant CannotCreateSink.</summary>
        /// <unmanaged>MF_E_CANNOT_CREATE_SINK</unmanaged>
        public static readonly SharpDX.ResultDescriptor CannotCreateSink = new SharpDX.ResultDescriptor(unchecked((int)3222091514UL), "SharpDX.MediaFoundation", "MF_E_CANNOT_CREATE_SINK", "CannotCreateSink");

        /// <summary>Constant ByteStreamUnknownLength.</summary>
        /// <unmanaged>MF_E_BYTESTREAM_UNKNOWN_LENGTH</unmanaged>
        public static readonly SharpDX.ResultDescriptor ByteStreamUnknownLength = new SharpDX.ResultDescriptor(unchecked((int)3222091515UL), "SharpDX.MediaFoundation", "MF_E_BYTESTREAM_UNKNOWN_LENGTH", "ByteStreamUnknownLength");

        /// <summary>Constant SessionPausewhilestopped.</summary>
        /// <unmanaged>MF_E_SESSION_PAUSEWHILESTOPPED</unmanaged>
        public static readonly SharpDX.ResultDescriptor SessionPausewhilestopped = new SharpDX.ResultDescriptor(unchecked((int)3222091516UL), "SharpDX.MediaFoundation", "MF_E_SESSION_PAUSEWHILESTOPPED", "SessionPausewhilestopped");

        /// <summary>Constant FormatChangeNotSupported.</summary>
        /// <unmanaged>MF_E_FORMAT_CHANGE_NOT_SUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor FormatChangeNotSupported = new SharpDX.ResultDescriptor(unchecked((int)3222091518UL), "SharpDX.MediaFoundation", "MF_E_FORMAT_CHANGE_NOT_SUPPORTED", "FormatChangeNotSupported");

        /// <summary>Constant InvalidWorkqueue.</summary>
        /// <unmanaged>MF_E_INVALID_WORKQUEUE</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidWorkqueue = new SharpDX.ResultDescriptor(unchecked((int)3222091519UL), "SharpDX.MediaFoundation", "MF_E_INVALID_WORKQUEUE", "InvalidWorkqueue");

        /// <summary>Constant DrmUnsupported.</summary>
        /// <unmanaged>MF_E_DRM_UNSUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor DrmUnsupported = new SharpDX.ResultDescriptor(unchecked((int)3222091520UL), "SharpDX.MediaFoundation", "MF_E_DRM_UNSUPPORTED", "DrmUnsupported");

        /// <summary>Constant Unauthorized.</summary>
        /// <unmanaged>MF_E_UNAUTHORIZED</unmanaged>
        public static readonly SharpDX.ResultDescriptor Unauthorized = new SharpDX.ResultDescriptor(unchecked((int)3222091521UL), "SharpDX.MediaFoundation", "MF_E_UNAUTHORIZED", "Unauthorized");

        /// <summary>Constant OutOfRange.</summary>
        /// <unmanaged>MF_E_OUT_OF_RANGE</unmanaged>
        public static readonly SharpDX.ResultDescriptor OutOfRange = new SharpDX.ResultDescriptor(unchecked((int)3222091522UL), "SharpDX.MediaFoundation", "MF_E_OUT_OF_RANGE", "OutOfRange");

        /// <summary>Constant InvalidCodecMerit.</summary>
        /// <unmanaged>MF_E_INVALID_CODEC_MERIT</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidCodecMerit = new SharpDX.ResultDescriptor(unchecked((int)3222091523UL), "SharpDX.MediaFoundation", "MF_E_INVALID_CODEC_MERIT", "InvalidCodecMerit");

        /// <summary>Constant HwMftFailedStartStreaming.</summary>
        /// <unmanaged>MF_E_HW_MFT_FAILED_START_STREAMING</unmanaged>
        public static readonly SharpDX.ResultDescriptor HwMftFailedStartStreaming = new SharpDX.ResultDescriptor(unchecked((int)3222091524UL), "SharpDX.MediaFoundation", "MF_E_HW_MFT_FAILED_START_STREAMING", "HwMftFailedStartStreaming");

        /// <summary>Constant OperationInProgress.</summary>
        /// <unmanaged>MF_E_OPERATION_IN_PROGRESS</unmanaged>
        public static readonly SharpDX.ResultDescriptor OperationInProgress = new SharpDX.ResultDescriptor(unchecked((int)3222091525UL), "SharpDX.MediaFoundation", "MF_E_OPERATION_IN_PROGRESS", "OperationInProgress");

        /// <summary>Constant HardwareDrmUnsupported.</summary>
        /// <unmanaged>MF_E_HARDWARE_DRM_UNSUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor HardwareDrmUnsupported = new SharpDX.ResultDescriptor(unchecked((int)3222091526UL), "SharpDX.MediaFoundation", "MF_E_HARDWARE_DRM_UNSUPPORTED", "HardwareDrmUnsupported");

        /// <summary>Constant AsfParsingincomplete.</summary>
        /// <unmanaged>MF_E_ASF_PARSINGINCOMPLETE</unmanaged>
        public static readonly SharpDX.ResultDescriptor AsfParsingincomplete = new SharpDX.ResultDescriptor(unchecked((int)3222092440UL), "SharpDX.MediaFoundation", "MF_E_ASF_PARSINGINCOMPLETE", "AsfParsingincomplete");

        /// <summary>Constant AsfMissingData.</summary>
        /// <unmanaged>MF_E_ASF_MISSINGDATA</unmanaged>
        public static readonly SharpDX.ResultDescriptor AsfMissingData = new SharpDX.ResultDescriptor(unchecked((int)3222092441UL), "SharpDX.MediaFoundation", "MF_E_ASF_MISSINGDATA", "AsfMissingData");

        /// <summary>Constant AsfInvalidData.</summary>
        /// <unmanaged>MF_E_ASF_INVALIDDATA</unmanaged>
        public static readonly SharpDX.ResultDescriptor AsfInvalidData = new SharpDX.ResultDescriptor(unchecked((int)3222092442UL), "SharpDX.MediaFoundation", "MF_E_ASF_INVALIDDATA", "AsfInvalidData");

        /// <summary>Constant AsfOpaquePacket.</summary>
        /// <unmanaged>MF_E_ASF_OPAQUEPACKET</unmanaged>
        public static readonly SharpDX.ResultDescriptor AsfOpaquePacket = new SharpDX.ResultDescriptor(unchecked((int)3222092443UL), "SharpDX.MediaFoundation", "MF_E_ASF_OPAQUEPACKET", "AsfOpaquePacket");

        /// <summary>Constant AsfNoindex.</summary>
        /// <unmanaged>MF_E_ASF_NOINDEX</unmanaged>
        public static readonly SharpDX.ResultDescriptor AsfNoindex = new SharpDX.ResultDescriptor(unchecked((int)3222092444UL), "SharpDX.MediaFoundation", "MF_E_ASF_NOINDEX", "AsfNoindex");

        /// <summary>Constant AsfOufOfRange.</summary>
        /// <unmanaged>MF_E_ASF_OUTOFRANGE</unmanaged>
        public static readonly SharpDX.ResultDescriptor AsfOufOfRange = new SharpDX.ResultDescriptor(unchecked((int)3222092445UL), "SharpDX.MediaFoundation", "MF_E_ASF_OUTOFRANGE", "AsfOufOfRange");

        /// <summary>Constant AsfIndexNotLoaded.</summary>
        /// <unmanaged>MF_E_ASF_INDEXNOTLOADED</unmanaged>
        public static readonly SharpDX.ResultDescriptor AsfIndexNotLoaded = new SharpDX.ResultDescriptor(unchecked((int)3222092446UL), "SharpDX.MediaFoundation", "MF_E_ASF_INDEXNOTLOADED", "AsfIndexNotLoaded");

        /// <summary>Constant AsfTooManyPayloads.</summary>
        /// <unmanaged>MF_E_ASF_TOO_MANY_PAYLOADS</unmanaged>
        public static readonly SharpDX.ResultDescriptor AsfTooManyPayloads = new SharpDX.ResultDescriptor(unchecked((int)3222092447UL), "SharpDX.MediaFoundation", "MF_E_ASF_TOO_MANY_PAYLOADS", "AsfTooManyPayloads");

        /// <summary>Constant AsfUnsupportedStreamType.</summary>
        /// <unmanaged>MF_E_ASF_UNSUPPORTED_STREAM_TYPE</unmanaged>
        public static readonly SharpDX.ResultDescriptor AsfUnsupportedStreamType = new SharpDX.ResultDescriptor(unchecked((int)3222092448UL), "SharpDX.MediaFoundation", "MF_E_ASF_UNSUPPORTED_STREAM_TYPE", "AsfUnsupportedStreamType");

        /// <summary>Constant AsfDroppedPacket.</summary>
        /// <unmanaged>MF_E_ASF_DROPPED_PACKET</unmanaged>
        public static readonly SharpDX.ResultDescriptor AsfDroppedPacket = new SharpDX.ResultDescriptor(unchecked((int)3222092449UL), "SharpDX.MediaFoundation", "MF_E_ASF_DROPPED_PACKET", "AsfDroppedPacket");

        /// <summary>Constant NoEventsAvailable.</summary>
        /// <unmanaged>MF_E_NO_EVENTS_AVAILABLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoEventsAvailable = new SharpDX.ResultDescriptor(unchecked((int)3222093440UL), "SharpDX.MediaFoundation", "MF_E_NO_EVENTS_AVAILABLE", "NoEventsAvailable");

        /// <summary>Constant InvalidStateTransition.</summary>
        /// <unmanaged>MF_E_INVALID_STATE_TRANSITION</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidStateTransition = new SharpDX.ResultDescriptor(unchecked((int)3222093442UL), "SharpDX.MediaFoundation", "MF_E_INVALID_STATE_TRANSITION", "InvalidStateTransition");

        /// <summary>Constant EndOfStream.</summary>
        /// <unmanaged>MF_E_END_OF_STREAM</unmanaged>
        public static readonly SharpDX.ResultDescriptor EndOfStream = new SharpDX.ResultDescriptor(unchecked((int)3222093444UL), "SharpDX.MediaFoundation", "MF_E_END_OF_STREAM", "EndOfStream");

        /// <summary>Constant Shutdown.</summary>
        /// <unmanaged>MF_E_SHUTDOWN</unmanaged>
        public static readonly SharpDX.ResultDescriptor Shutdown = new SharpDX.ResultDescriptor(unchecked((int)3222093445UL), "SharpDX.MediaFoundation", "MF_E_SHUTDOWN", "Shutdown");

        /// <summary>Constant Mp3NotFound.</summary>
        /// <unmanaged>MF_E_MP3_NOTFOUND</unmanaged>
        public static readonly SharpDX.ResultDescriptor Mp3NotFound = new SharpDX.ResultDescriptor(unchecked((int)3222093446UL), "SharpDX.MediaFoundation", "MF_E_MP3_NOTFOUND", "Mp3NotFound");

        /// <summary>Constant Mp3OufOfData.</summary>
        /// <unmanaged>MF_E_MP3_OUTOFDATA</unmanaged>
        public static readonly SharpDX.ResultDescriptor Mp3OufOfData = new SharpDX.ResultDescriptor(unchecked((int)3222093447UL), "SharpDX.MediaFoundation", "MF_E_MP3_OUTOFDATA", "Mp3OufOfData");

        /// <summary>Constant Mp3NotMp3.</summary>
        /// <unmanaged>MF_E_MP3_NOTMP3</unmanaged>
        public static readonly SharpDX.ResultDescriptor Mp3NotMp3 = new SharpDX.ResultDescriptor(unchecked((int)3222093448UL), "SharpDX.MediaFoundation", "MF_E_MP3_NOTMP3", "Mp3NotMp3");

        /// <summary>Constant Mp3NotSupported.</summary>
        /// <unmanaged>MF_E_MP3_NOTSUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor Mp3NotSupported = new SharpDX.ResultDescriptor(unchecked((int)3222093449UL), "SharpDX.MediaFoundation", "MF_E_MP3_NOTSUPPORTED", "Mp3NotSupported");

        /// <summary>Constant NoDuration.</summary>
        /// <unmanaged>MF_E_NO_DURATION</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoDuration = new SharpDX.ResultDescriptor(unchecked((int)3222093450UL), "SharpDX.MediaFoundation", "MF_E_NO_DURATION", "NoDuration");

        /// <summary>Constant InvalidFormat.</summary>
        /// <unmanaged>MF_E_INVALID_FORMAT</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidFormat = new SharpDX.ResultDescriptor(unchecked((int)3222093452UL), "SharpDX.MediaFoundation", "MF_E_INVALID_FORMAT", "InvalidFormat");

        /// <summary>Constant PropertyNotFound.</summary>
        /// <unmanaged>MF_E_PROPERTY_NOT_FOUND</unmanaged>
        public static readonly SharpDX.ResultDescriptor PropertyNotFound = new SharpDX.ResultDescriptor(unchecked((int)3222093453UL), "SharpDX.MediaFoundation", "MF_E_PROPERTY_NOT_FOUND", "PropertyNotFound");

        /// <summary>Constant PropertyReadOnly.</summary>
        /// <unmanaged>MF_E_PROPERTY_READ_ONLY</unmanaged>
        public static readonly SharpDX.ResultDescriptor PropertyReadOnly = new SharpDX.ResultDescriptor(unchecked((int)3222093454UL), "SharpDX.MediaFoundation", "MF_E_PROPERTY_READ_ONLY", "PropertyReadOnly");

        /// <summary>Constant PropertyNotAllowEd.</summary>
        /// <unmanaged>MF_E_PROPERTY_NOT_ALLOWED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PropertyNotAllowEd = new SharpDX.ResultDescriptor(unchecked((int)3222093455UL), "SharpDX.MediaFoundation", "MF_E_PROPERTY_NOT_ALLOWED", "PropertyNotAllowEd");

        /// <summary>Constant MediaSourceNotStarted.</summary>
        /// <unmanaged>MF_E_MEDIA_SOURCE_NOT_STARTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor MediaSourceNotStarted = new SharpDX.ResultDescriptor(unchecked((int)3222093457UL), "SharpDX.MediaFoundation", "MF_E_MEDIA_SOURCE_NOT_STARTED", "MediaSourceNotStarted");

        /// <summary>Constant UnsupportedFormat.</summary>
        /// <unmanaged>MF_E_UNSUPPORTED_FORMAT</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedFormat = new SharpDX.ResultDescriptor(unchecked((int)3222093464UL), "SharpDX.MediaFoundation", "MF_E_UNSUPPORTED_FORMAT", "UnsupportedFormat");

        /// <summary>Constant Mp3BadCrc.</summary>
        /// <unmanaged>MF_E_MP3_BAD_CRC</unmanaged>
        public static readonly SharpDX.ResultDescriptor Mp3BadCrc = new SharpDX.ResultDescriptor(unchecked((int)3222093465UL), "SharpDX.MediaFoundation", "MF_E_MP3_BAD_CRC", "Mp3BadCrc");

        /// <summary>Constant NotProtected.</summary>
        /// <unmanaged>MF_E_NOT_PROTECTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor NotProtected = new SharpDX.ResultDescriptor(unchecked((int)3222093466UL), "SharpDX.MediaFoundation", "MF_E_NOT_PROTECTED", "NotProtected");

        /// <summary>Constant MediaSourceWrongState.</summary>
        /// <unmanaged>MF_E_MEDIA_SOURCE_WRONGSTATE</unmanaged>
        public static readonly SharpDX.ResultDescriptor MediaSourceWrongState = new SharpDX.ResultDescriptor(unchecked((int)3222093467UL), "SharpDX.MediaFoundation", "MF_E_MEDIA_SOURCE_WRONGSTATE", "MediaSourceWrongState");

        /// <summary>Constant MediaSourceNoStreamsSelected.</summary>
        /// <unmanaged>MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor MediaSourceNoStreamsSelected = new SharpDX.ResultDescriptor(unchecked((int)3222093468UL), "SharpDX.MediaFoundation", "MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED", "MediaSourceNoStreamsSelected");

        /// <summary>Constant CannotFindKeyframeSample.</summary>
        /// <unmanaged>MF_E_CANNOT_FIND_KEYFRAME_SAMPLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor CannotFindKeyframeSample = new SharpDX.ResultDescriptor(unchecked((int)3222093469UL), "SharpDX.MediaFoundation", "MF_E_CANNOT_FIND_KEYFRAME_SAMPLE", "CannotFindKeyframeSample");

        /// <summary>Constant UnsupportedCharacteristics.</summary>
        /// <unmanaged>MF_E_UNSUPPORTED_CHARACTERISTICS</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedCharacteristics = new SharpDX.ResultDescriptor(unchecked((int)3222093470UL), "SharpDX.MediaFoundation", "MF_E_UNSUPPORTED_CHARACTERISTICS", "UnsupportedCharacteristics");

        /// <summary>Constant NoAudioRecordingDevice.</summary>
        /// <unmanaged>MF_E_NO_AUDIO_RECORDING_DEVICE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoAudioRecordingDevice = new SharpDX.ResultDescriptor(unchecked((int)3222093471UL), "SharpDX.MediaFoundation", "MF_E_NO_AUDIO_RECORDING_DEVICE", "NoAudioRecordingDevice");

        /// <summary>Constant AudioRecordingDeviceInUse.</summary>
        /// <unmanaged>MF_E_AUDIO_RECORDING_DEVICE_IN_USE</unmanaged>
        public static readonly SharpDX.ResultDescriptor AudioRecordingDeviceInUse = new SharpDX.ResultDescriptor(unchecked((int)3222093472UL), "SharpDX.MediaFoundation", "MF_E_AUDIO_RECORDING_DEVICE_IN_USE", "AudioRecordingDeviceInUse");

        /// <summary>Constant AudioRecordingDeviceInvalidated.</summary>
        /// <unmanaged>MF_E_AUDIO_RECORDING_DEVICE_INVALIDATED</unmanaged>
        public static readonly SharpDX.ResultDescriptor AudioRecordingDeviceInvalidated = new SharpDX.ResultDescriptor(unchecked((int)3222093473UL), "SharpDX.MediaFoundation", "MF_E_AUDIO_RECORDING_DEVICE_INVALIDATED", "AudioRecordingDeviceInvalidated");

        /// <summary>Constant VideoRecordingDeviceInvalidated.</summary>
        /// <unmanaged>MF_E_VIDEO_RECORDING_DEVICE_INVALIDATED</unmanaged>
        public static readonly SharpDX.ResultDescriptor VideoRecordingDeviceInvalidated = new SharpDX.ResultDescriptor(unchecked((int)3222093474UL), "SharpDX.MediaFoundation", "MF_E_VIDEO_RECORDING_DEVICE_INVALIDATED", "VideoRecordingDeviceInvalidated");

        /// <summary>Constant VideoRecordingDevicePreempted.</summary>
        /// <unmanaged>MF_E_VIDEO_RECORDING_DEVICE_PREEMPTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor VideoRecordingDevicePreempted = new SharpDX.ResultDescriptor(unchecked((int)3222093475UL), "SharpDX.MediaFoundation", "MF_E_VIDEO_RECORDING_DEVICE_PREEMPTED", "VideoRecordingDevicePreempted");

        /// <summary>Constant NetworkResourceFailure.</summary>
        /// <unmanaged>MF_E_NETWORK_RESOURCE_FAILURE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetworkResourceFailure = new SharpDX.ResultDescriptor(unchecked((int)3222094440UL), "SharpDX.MediaFoundation", "MF_E_NETWORK_RESOURCE_FAILURE", "NetworkResourceFailure");

        /// <summary>Constant NetWrite.</summary>
        /// <unmanaged>MF_E_NET_WRITE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetWrite = new SharpDX.ResultDescriptor(unchecked((int)3222094441UL), "SharpDX.MediaFoundation", "MF_E_NET_WRITE", "NetWrite");

        /// <summary>Constant NetRead.</summary>
        /// <unmanaged>MF_E_NET_READ</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetRead = new SharpDX.ResultDescriptor(unchecked((int)3222094442UL), "SharpDX.MediaFoundation", "MF_E_NET_READ", "NetRead");

        /// <summary>Constant NetRequireNetwork.</summary>
        /// <unmanaged>MF_E_NET_REQUIRE_NETWORK</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetRequireNetwork = new SharpDX.ResultDescriptor(unchecked((int)3222094443UL), "SharpDX.MediaFoundation", "MF_E_NET_REQUIRE_NETWORK", "NetRequireNetwork");

        /// <summary>Constant NetRequireAsync.</summary>
        /// <unmanaged>MF_E_NET_REQUIRE_ASYNC</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetRequireAsync = new SharpDX.ResultDescriptor(unchecked((int)3222094444UL), "SharpDX.MediaFoundation", "MF_E_NET_REQUIRE_ASYNC", "NetRequireAsync");

        /// <summary>Constant NetBwlevelNotSupported.</summary>
        /// <unmanaged>MF_E_NET_BWLEVEL_NOT_SUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetBwlevelNotSupported = new SharpDX.ResultDescriptor(unchecked((int)3222094445UL), "SharpDX.MediaFoundation", "MF_E_NET_BWLEVEL_NOT_SUPPORTED", "NetBwlevelNotSupported");

        /// <summary>Constant NetStreamGroupsNotSupported.</summary>
        /// <unmanaged>MF_E_NET_STREAMGROUPS_NOT_SUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetStreamGroupsNotSupported = new SharpDX.ResultDescriptor(unchecked((int)3222094446UL), "SharpDX.MediaFoundation", "MF_E_NET_STREAMGROUPS_NOT_SUPPORTED", "NetStreamGroupsNotSupported");

        /// <summary>Constant NetManualssNotSupported.</summary>
        /// <unmanaged>MF_E_NET_MANUALSS_NOT_SUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetManualssNotSupported = new SharpDX.ResultDescriptor(unchecked((int)3222094447UL), "SharpDX.MediaFoundation", "MF_E_NET_MANUALSS_NOT_SUPPORTED", "NetManualssNotSupported");

        /// <summary>Constant NetInvalidPresentationDescriptor.</summary>
        /// <unmanaged>MF_E_NET_INVALID_PRESENTATION_DESCRIPTOR</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetInvalidPresentationDescriptor = new SharpDX.ResultDescriptor(unchecked((int)3222094448UL), "SharpDX.MediaFoundation", "MF_E_NET_INVALID_PRESENTATION_DESCRIPTOR", "NetInvalidPresentationDescriptor");

        /// <summary>Constant NetCachestreamNotFound.</summary>
        /// <unmanaged>MF_E_NET_CACHESTREAM_NOT_FOUND</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetCachestreamNotFound = new SharpDX.ResultDescriptor(unchecked((int)3222094449UL), "SharpDX.MediaFoundation", "MF_E_NET_CACHESTREAM_NOT_FOUND", "NetCachestreamNotFound");

        /// <summary>Constant NetRequireInput.</summary>
        /// <unmanaged>MF_E_NET_REQUIRE_INPUT</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetRequireInput = new SharpDX.ResultDescriptor(unchecked((int)3222094452UL), "SharpDX.MediaFoundation", "MF_E_NET_REQUIRE_INPUT", "NetRequireInput");

        /// <summary>Constant NetRedirect.</summary>
        /// <unmanaged>MF_E_NET_REDIRECT</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetRedirect = new SharpDX.ResultDescriptor(unchecked((int)3222094453UL), "SharpDX.MediaFoundation", "MF_E_NET_REDIRECT", "NetRedirect");

        /// <summary>Constant NetRedirectToProxy.</summary>
        /// <unmanaged>MF_E_NET_REDIRECT_TO_PROXY</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetRedirectToProxy = new SharpDX.ResultDescriptor(unchecked((int)3222094454UL), "SharpDX.MediaFoundation", "MF_E_NET_REDIRECT_TO_PROXY", "NetRedirectToProxy");

        /// <summary>Constant NetTooManyRedirects.</summary>
        /// <unmanaged>MF_E_NET_TOO_MANY_REDIRECTS</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetTooManyRedirects = new SharpDX.ResultDescriptor(unchecked((int)3222094455UL), "SharpDX.MediaFoundation", "MF_E_NET_TOO_MANY_REDIRECTS", "NetTooManyRedirects");

        /// <summary>Constant NetTimeout.</summary>
        /// <unmanaged>MF_E_NET_TIMEOUT</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetTimeout = new SharpDX.ResultDescriptor(unchecked((int)3222094456UL), "SharpDX.MediaFoundation", "MF_E_NET_TIMEOUT", "NetTimeout");

        /// <summary>Constant NetClientClose.</summary>
        /// <unmanaged>MF_E_NET_CLIENT_CLOSE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetClientClose = new SharpDX.ResultDescriptor(unchecked((int)3222094457UL), "SharpDX.MediaFoundation", "MF_E_NET_CLIENT_CLOSE", "NetClientClose");

        /// <summary>Constant NetBadControlData.</summary>
        /// <unmanaged>MF_E_NET_BAD_CONTROL_DATA</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetBadControlData = new SharpDX.ResultDescriptor(unchecked((int)3222094458UL), "SharpDX.MediaFoundation", "MF_E_NET_BAD_CONTROL_DATA", "NetBadControlData");

        /// <summary>Constant NetIncompatibleServer.</summary>
        /// <unmanaged>MF_E_NET_INCOMPATIBLE_SERVER</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetIncompatibleServer = new SharpDX.ResultDescriptor(unchecked((int)3222094459UL), "SharpDX.MediaFoundation", "MF_E_NET_INCOMPATIBLE_SERVER", "NetIncompatibleServer");

        /// <summary>Constant NetUnsafeUrl.</summary>
        /// <unmanaged>MF_E_NET_UNSAFE_URL</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetUnsafeUrl = new SharpDX.ResultDescriptor(unchecked((int)3222094460UL), "SharpDX.MediaFoundation", "MF_E_NET_UNSAFE_URL", "NetUnsafeUrl");

        /// <summary>Constant NetCacheNoData.</summary>
        /// <unmanaged>MF_E_NET_CACHE_NO_DATA</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetCacheNoData = new SharpDX.ResultDescriptor(unchecked((int)3222094461UL), "SharpDX.MediaFoundation", "MF_E_NET_CACHE_NO_DATA", "NetCacheNoData");

        /// <summary>Constant NetEol.</summary>
        /// <unmanaged>MF_E_NET_EOL</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetEol = new SharpDX.ResultDescriptor(unchecked((int)3222094462UL), "SharpDX.MediaFoundation", "MF_E_NET_EOL", "NetEol");

        /// <summary>Constant NetBadRequest.</summary>
        /// <unmanaged>MF_E_NET_BAD_REQUEST</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetBadRequest = new SharpDX.ResultDescriptor(unchecked((int)3222094463UL), "SharpDX.MediaFoundation", "MF_E_NET_BAD_REQUEST", "NetBadRequest");

        /// <summary>Constant NetInternalServerError.</summary>
        /// <unmanaged>MF_E_NET_INTERNAL_SERVER_ERROR</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetInternalServerError = new SharpDX.ResultDescriptor(unchecked((int)3222094464UL), "SharpDX.MediaFoundation", "MF_E_NET_INTERNAL_SERVER_ERROR", "NetInternalServerError");

        /// <summary>Constant NetSessionNotFound.</summary>
        /// <unmanaged>MF_E_NET_SESSION_NOT_FOUND</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetSessionNotFound = new SharpDX.ResultDescriptor(unchecked((int)3222094465UL), "SharpDX.MediaFoundation", "MF_E_NET_SESSION_NOT_FOUND", "NetSessionNotFound");

        /// <summary>Constant NetNoconnection.</summary>
        /// <unmanaged>MF_E_NET_NOCONNECTION</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetNoconnection = new SharpDX.ResultDescriptor(unchecked((int)3222094466UL), "SharpDX.MediaFoundation", "MF_E_NET_NOCONNECTION", "NetNoconnection");

        /// <summary>Constant NetConnectionFailure.</summary>
        /// <unmanaged>MF_E_NET_CONNECTION_FAILURE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetConnectionFailure = new SharpDX.ResultDescriptor(unchecked((int)3222094467UL), "SharpDX.MediaFoundation", "MF_E_NET_CONNECTION_FAILURE", "NetConnectionFailure");

        /// <summary>Constant NetIncompatiblePushserver.</summary>
        /// <unmanaged>MF_E_NET_INCOMPATIBLE_PUSHSERVER</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetIncompatiblePushserver = new SharpDX.ResultDescriptor(unchecked((int)3222094468UL), "SharpDX.MediaFoundation", "MF_E_NET_INCOMPATIBLE_PUSHSERVER", "NetIncompatiblePushserver");

        /// <summary>Constant NetServerAccessDenied.</summary>
        /// <unmanaged>MF_E_NET_SERVER_ACCESSDENIED</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetServerAccessDenied = new SharpDX.ResultDescriptor(unchecked((int)3222094469UL), "SharpDX.MediaFoundation", "MF_E_NET_SERVER_ACCESSDENIED", "NetServerAccessDenied");

        /// <summary>Constant NetProxyAccessDenied.</summary>
        /// <unmanaged>MF_E_NET_PROXY_ACCESSDENIED</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetProxyAccessDenied = new SharpDX.ResultDescriptor(unchecked((int)3222094470UL), "SharpDX.MediaFoundation", "MF_E_NET_PROXY_ACCESSDENIED", "NetProxyAccessDenied");

        /// <summary>Constant NetCannotconnect.</summary>
        /// <unmanaged>MF_E_NET_CANNOTCONNECT</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetCannotconnect = new SharpDX.ResultDescriptor(unchecked((int)3222094471UL), "SharpDX.MediaFoundation", "MF_E_NET_CANNOTCONNECT", "NetCannotconnect");

        /// <summary>Constant NetInvalidPushTemplate.</summary>
        /// <unmanaged>MF_E_NET_INVALID_PUSH_TEMPLATE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetInvalidPushTemplate = new SharpDX.ResultDescriptor(unchecked((int)3222094472UL), "SharpDX.MediaFoundation", "MF_E_NET_INVALID_PUSH_TEMPLATE", "NetInvalidPushTemplate");

        /// <summary>Constant NetInvalidPushPublishingPoint.</summary>
        /// <unmanaged>MF_E_NET_INVALID_PUSH_PUBLISHING_POINT</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetInvalidPushPublishingPoint = new SharpDX.ResultDescriptor(unchecked((int)3222094473UL), "SharpDX.MediaFoundation", "MF_E_NET_INVALID_PUSH_PUBLISHING_POINT", "NetInvalidPushPublishingPoint");

        /// <summary>Constant NetBusy.</summary>
        /// <unmanaged>MF_E_NET_BUSY</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetBusy = new SharpDX.ResultDescriptor(unchecked((int)3222094474UL), "SharpDX.MediaFoundation", "MF_E_NET_BUSY", "NetBusy");

        /// <summary>Constant NetResourceGone.</summary>
        /// <unmanaged>MF_E_NET_RESOURCE_GONE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetResourceGone = new SharpDX.ResultDescriptor(unchecked((int)3222094475UL), "SharpDX.MediaFoundation", "MF_E_NET_RESOURCE_GONE", "NetResourceGone");

        /// <summary>Constant NetErrorFromProxy.</summary>
        /// <unmanaged>MF_E_NET_ERROR_FROM_PROXY</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetErrorFromProxy = new SharpDX.ResultDescriptor(unchecked((int)3222094476UL), "SharpDX.MediaFoundation", "MF_E_NET_ERROR_FROM_PROXY", "NetErrorFromProxy");

        /// <summary>Constant NetProxyTimeout.</summary>
        /// <unmanaged>MF_E_NET_PROXY_TIMEOUT</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetProxyTimeout = new SharpDX.ResultDescriptor(unchecked((int)3222094477UL), "SharpDX.MediaFoundation", "MF_E_NET_PROXY_TIMEOUT", "NetProxyTimeout");

        /// <summary>Constant NetServerUnavailable.</summary>
        /// <unmanaged>MF_E_NET_SERVER_UNAVAILABLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetServerUnavailable = new SharpDX.ResultDescriptor(unchecked((int)3222094478UL), "SharpDX.MediaFoundation", "MF_E_NET_SERVER_UNAVAILABLE", "NetServerUnavailable");

        /// <summary>Constant NetTooMuchData.</summary>
        /// <unmanaged>MF_E_NET_TOO_MUCH_DATA</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetTooMuchData = new SharpDX.ResultDescriptor(unchecked((int)3222094479UL), "SharpDX.MediaFoundation", "MF_E_NET_TOO_MUCH_DATA", "NetTooMuchData");

        /// <summary>Constant NetSessionInvalid.</summary>
        /// <unmanaged>MF_E_NET_SESSION_INVALID</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetSessionInvalid = new SharpDX.ResultDescriptor(unchecked((int)3222094480UL), "SharpDX.MediaFoundation", "MF_E_NET_SESSION_INVALID", "NetSessionInvalid");

        /// <summary>Constant OfflineMode.</summary>
        /// <unmanaged>MF_E_OFFLINE_MODE</unmanaged>
        public static readonly SharpDX.ResultDescriptor OfflineMode = new SharpDX.ResultDescriptor(unchecked((int)3222094481UL), "SharpDX.MediaFoundation", "MF_E_OFFLINE_MODE", "OfflineMode");

        /// <summary>Constant NetUdpBlocked.</summary>
        /// <unmanaged>MF_E_NET_UDP_BLOCKED</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetUdpBlocked = new SharpDX.ResultDescriptor(unchecked((int)3222094482UL), "SharpDX.MediaFoundation", "MF_E_NET_UDP_BLOCKED", "NetUdpBlocked");

        /// <summary>Constant NetUnsupportedConfiguration.</summary>
        /// <unmanaged>MF_E_NET_UNSUPPORTED_CONFIGURATION</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetUnsupportedConfiguration = new SharpDX.ResultDescriptor(unchecked((int)3222094483UL), "SharpDX.MediaFoundation", "MF_E_NET_UNSUPPORTED_CONFIGURATION", "NetUnsupportedConfiguration");

        /// <summary>Constant NetProtocolDisabled.</summary>
        /// <unmanaged>MF_E_NET_PROTOCOL_DISABLED</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetProtocolDisabled = new SharpDX.ResultDescriptor(unchecked((int)3222094484UL), "SharpDX.MediaFoundation", "MF_E_NET_PROTOCOL_DISABLED", "NetProtocolDisabled");

        /// <summary>Constant NetCompanionDriverDisconnect.</summary>
        /// <unmanaged>MF_E_NET_COMPANION_DRIVER_DISCONNECT</unmanaged>
        public static readonly SharpDX.ResultDescriptor NetCompanionDriverDisconnect = new SharpDX.ResultDescriptor(unchecked((int)3222094485UL), "SharpDX.MediaFoundation", "MF_E_NET_COMPANION_DRIVER_DISCONNECT", "NetCompanionDriverDisconnect");

        /// <summary>Constant AlreadyInitializeD.</summary>
        /// <unmanaged>MF_E_ALREADY_INITIALIZED</unmanaged>
        public static readonly SharpDX.ResultDescriptor AlreadyInitializeD = new SharpDX.ResultDescriptor(unchecked((int)3222095440UL), "SharpDX.MediaFoundation", "MF_E_ALREADY_INITIALIZED", "AlreadyInitializeD");

        /// <summary>Constant BandwidthOverrun.</summary>
        /// <unmanaged>MF_E_BANDWIDTH_OVERRUN</unmanaged>
        public static readonly SharpDX.ResultDescriptor BandwidthOverrun = new SharpDX.ResultDescriptor(unchecked((int)3222095441UL), "SharpDX.MediaFoundation", "MF_E_BANDWIDTH_OVERRUN", "BandwidthOverrun");

        /// <summary>Constant LateSample.</summary>
        /// <unmanaged>MF_E_LATE_SAMPLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor LateSample = new SharpDX.ResultDescriptor(unchecked((int)3222095442UL), "SharpDX.MediaFoundation", "MF_E_LATE_SAMPLE", "LateSample");

        /// <summary>Constant FlushNeeded.</summary>
        /// <unmanaged>MF_E_FLUSH_NEEDED</unmanaged>
        public static readonly SharpDX.ResultDescriptor FlushNeeded = new SharpDX.ResultDescriptor(unchecked((int)3222095443UL), "SharpDX.MediaFoundation", "MF_E_FLUSH_NEEDED", "FlushNeeded");

        /// <summary>Constant InvalidProfile.</summary>
        /// <unmanaged>MF_E_INVALID_PROFILE</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidProfile = new SharpDX.ResultDescriptor(unchecked((int)3222095444UL), "SharpDX.MediaFoundation", "MF_E_INVALID_PROFILE", "InvalidProfile");

        /// <summary>Constant IndexNotCommitted.</summary>
        /// <unmanaged>MF_E_INDEX_NOT_COMMITTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor IndexNotCommitted = new SharpDX.ResultDescriptor(unchecked((int)3222095445UL), "SharpDX.MediaFoundation", "MF_E_INDEX_NOT_COMMITTED", "IndexNotCommitted");

        /// <summary>Constant NoIndex.</summary>
        /// <unmanaged>MF_E_NO_INDEX</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoIndex = new SharpDX.ResultDescriptor(unchecked((int)3222095446UL), "SharpDX.MediaFoundation", "MF_E_NO_INDEX", "NoIndex");

        /// <summary>Constant CannotIndexInPlace.</summary>
        /// <unmanaged>MF_E_CANNOT_INDEX_IN_PLACE</unmanaged>
        public static readonly SharpDX.ResultDescriptor CannotIndexInPlace = new SharpDX.ResultDescriptor(unchecked((int)3222095447UL), "SharpDX.MediaFoundation", "MF_E_CANNOT_INDEX_IN_PLACE", "CannotIndexInPlace");

        /// <summary>Constant MissingAsfLeakybucket.</summary>
        /// <unmanaged>MF_E_MISSING_ASF_LEAKYBUCKET</unmanaged>
        public static readonly SharpDX.ResultDescriptor MissingAsfLeakybucket = new SharpDX.ResultDescriptor(unchecked((int)3222095448UL), "SharpDX.MediaFoundation", "MF_E_MISSING_ASF_LEAKYBUCKET", "MissingAsfLeakybucket");

        /// <summary>Constant InvalidAsfStreamId.</summary>
        /// <unmanaged>MF_E_INVALID_ASF_STREAMID</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidAsfStreamId = new SharpDX.ResultDescriptor(unchecked((int)3222095449UL), "SharpDX.MediaFoundation", "MF_E_INVALID_ASF_STREAMID", "InvalidAsfStreamId");

        /// <summary>Constant StreamsInkRemoved.</summary>
        /// <unmanaged>MF_E_STREAMSINK_REMOVED</unmanaged>
        public static readonly SharpDX.ResultDescriptor StreamsInkRemoved = new SharpDX.ResultDescriptor(unchecked((int)3222096440UL), "SharpDX.MediaFoundation", "MF_E_STREAMSINK_REMOVED", "StreamsInkRemoved");

        /// <summary>Constant StreamsInksOutOfSync.</summary>
        /// <unmanaged>MF_E_STREAMSINKS_OUT_OF_SYNC</unmanaged>
        public static readonly SharpDX.ResultDescriptor StreamsInksOutOfSync = new SharpDX.ResultDescriptor(unchecked((int)3222096442UL), "SharpDX.MediaFoundation", "MF_E_STREAMSINKS_OUT_OF_SYNC", "StreamsInksOutOfSync");

        /// <summary>Constant StreamsInksFixed.</summary>
        /// <unmanaged>MF_E_STREAMSINKS_FIXED</unmanaged>
        public static readonly SharpDX.ResultDescriptor StreamsInksFixed = new SharpDX.ResultDescriptor(unchecked((int)3222096443UL), "SharpDX.MediaFoundation", "MF_E_STREAMSINKS_FIXED", "StreamsInksFixed");

        /// <summary>Constant StreamsInkExists.</summary>
        /// <unmanaged>MF_E_STREAMSINK_EXISTS</unmanaged>
        public static readonly SharpDX.ResultDescriptor StreamsInkExists = new SharpDX.ResultDescriptor(unchecked((int)3222096444UL), "SharpDX.MediaFoundation", "MF_E_STREAMSINK_EXISTS", "StreamsInkExists");

        /// <summary>Constant SampleallocatorCanceled.</summary>
        /// <unmanaged>MF_E_SAMPLEALLOCATOR_CANCELED</unmanaged>
        public static readonly SharpDX.ResultDescriptor SampleallocatorCanceled = new SharpDX.ResultDescriptor(unchecked((int)3222096445UL), "SharpDX.MediaFoundation", "MF_E_SAMPLEALLOCATOR_CANCELED", "SampleallocatorCanceled");

        /// <summary>Constant SampleallocatorEmpty.</summary>
        /// <unmanaged>MF_E_SAMPLEALLOCATOR_EMPTY</unmanaged>
        public static readonly SharpDX.ResultDescriptor SampleallocatorEmpty = new SharpDX.ResultDescriptor(unchecked((int)3222096446UL), "SharpDX.MediaFoundation", "MF_E_SAMPLEALLOCATOR_EMPTY", "SampleallocatorEmpty");

        /// <summary>Constant SinkAlreadystopped.</summary>
        /// <unmanaged>MF_E_SINK_ALREADYSTOPPED</unmanaged>
        public static readonly SharpDX.ResultDescriptor SinkAlreadystopped = new SharpDX.ResultDescriptor(unchecked((int)3222096447UL), "SharpDX.MediaFoundation", "MF_E_SINK_ALREADYSTOPPED", "SinkAlreadystopped");

        /// <summary>Constant AsfFilesinkBitRateUnknown.</summary>
        /// <unmanaged>MF_E_ASF_FILESINK_BITRATE_UNKNOWN</unmanaged>
        public static readonly SharpDX.ResultDescriptor AsfFilesinkBitRateUnknown = new SharpDX.ResultDescriptor(unchecked((int)3222096448UL), "SharpDX.MediaFoundation", "MF_E_ASF_FILESINK_BITRATE_UNKNOWN", "AsfFilesinkBitRateUnknown");

        /// <summary>Constant SinkNoStreams.</summary>
        /// <unmanaged>MF_E_SINK_NO_STREAMS</unmanaged>
        public static readonly SharpDX.ResultDescriptor SinkNoStreams = new SharpDX.ResultDescriptor(unchecked((int)3222096449UL), "SharpDX.MediaFoundation", "MF_E_SINK_NO_STREAMS", "SinkNoStreams");

        /// <summary>Constant MetadataTooLong.</summary>
        /// <unmanaged>MF_E_METADATA_TOO_LONG</unmanaged>
        public static readonly SharpDX.ResultDescriptor MetadataTooLong = new SharpDX.ResultDescriptor(unchecked((int)3222096451UL), "SharpDX.MediaFoundation", "MF_E_METADATA_TOO_LONG", "MetadataTooLong");

        /// <summary>Constant SinkNoSamplesProcessed.</summary>
        /// <unmanaged>MF_E_SINK_NO_SAMPLES_PROCESSED</unmanaged>
        public static readonly SharpDX.ResultDescriptor SinkNoSamplesProcessed = new SharpDX.ResultDescriptor(unchecked((int)3222096452UL), "SharpDX.MediaFoundation", "MF_E_SINK_NO_SAMPLES_PROCESSED", "SinkNoSamplesProcessed");

        /// <summary>Constant SinkHeadersNotFound.</summary>
        /// <unmanaged>MF_E_SINK_HEADERS_NOT_FOUND</unmanaged>
        public static readonly SharpDX.ResultDescriptor SinkHeadersNotFound = new SharpDX.ResultDescriptor(unchecked((int)3222096453UL), "SharpDX.MediaFoundation", "MF_E_SINK_HEADERS_NOT_FOUND", "SinkHeadersNotFound");

        /// <summary>Constant VideoRenNoProcampHw.</summary>
        /// <unmanaged>MF_E_VIDEO_REN_NO_PROCAMP_HW</unmanaged>
        public static readonly SharpDX.ResultDescriptor VideoRenNoProcampHw = new SharpDX.ResultDescriptor(unchecked((int)3222097440UL), "SharpDX.MediaFoundation", "MF_E_VIDEO_REN_NO_PROCAMP_HW", "VideoRenNoProcampHw");

        /// <summary>Constant VideoRenNoDeinterlaceHw.</summary>
        /// <unmanaged>MF_E_VIDEO_REN_NO_DEINTERLACE_HW</unmanaged>
        public static readonly SharpDX.ResultDescriptor VideoRenNoDeinterlaceHw = new SharpDX.ResultDescriptor(unchecked((int)3222097441UL), "SharpDX.MediaFoundation", "MF_E_VIDEO_REN_NO_DEINTERLACE_HW", "VideoRenNoDeinterlaceHw");

        /// <summary>Constant VideoRenCopyProtFailed.</summary>
        /// <unmanaged>MF_E_VIDEO_REN_COPYPROT_FAILED</unmanaged>
        public static readonly SharpDX.ResultDescriptor VideoRenCopyProtFailed = new SharpDX.ResultDescriptor(unchecked((int)3222097442UL), "SharpDX.MediaFoundation", "MF_E_VIDEO_REN_COPYPROT_FAILED", "VideoRenCopyProtFailed");

        /// <summary>Constant VideoRenSurfaceNotShared.</summary>
        /// <unmanaged>MF_E_VIDEO_REN_SURFACE_NOT_SHARED</unmanaged>
        public static readonly SharpDX.ResultDescriptor VideoRenSurfaceNotShared = new SharpDX.ResultDescriptor(unchecked((int)3222097443UL), "SharpDX.MediaFoundation", "MF_E_VIDEO_REN_SURFACE_NOT_SHARED", "VideoRenSurfaceNotShared");

        /// <summary>Constant VideoDeviceLocked.</summary>
        /// <unmanaged>MF_E_VIDEO_DEVICE_LOCKED</unmanaged>
        public static readonly SharpDX.ResultDescriptor VideoDeviceLocked = new SharpDX.ResultDescriptor(unchecked((int)3222097444UL), "SharpDX.MediaFoundation", "MF_E_VIDEO_DEVICE_LOCKED", "VideoDeviceLocked");

        /// <summary>Constant NewVideoDevice.</summary>
        /// <unmanaged>MF_E_NEW_VIDEO_DEVICE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NewVideoDevice = new SharpDX.ResultDescriptor(unchecked((int)3222097445UL), "SharpDX.MediaFoundation", "MF_E_NEW_VIDEO_DEVICE", "NewVideoDevice");

        /// <summary>Constant NoVideoSampleAvailable.</summary>
        /// <unmanaged>MF_E_NO_VIDEO_SAMPLE_AVAILABLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoVideoSampleAvailable = new SharpDX.ResultDescriptor(unchecked((int)3222097446UL), "SharpDX.MediaFoundation", "MF_E_NO_VIDEO_SAMPLE_AVAILABLE", "NoVideoSampleAvailable");

        /// <summary>Constant NoAudioPlaybackDevice.</summary>
        /// <unmanaged>MF_E_NO_AUDIO_PLAYBACK_DEVICE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoAudioPlaybackDevice = new SharpDX.ResultDescriptor(unchecked((int)3222097540UL), "SharpDX.MediaFoundation", "MF_E_NO_AUDIO_PLAYBACK_DEVICE", "NoAudioPlaybackDevice");

        /// <summary>Constant AudioPlaybackDeviceInUse.</summary>
        /// <unmanaged>MF_E_AUDIO_PLAYBACK_DEVICE_IN_USE</unmanaged>
        public static readonly SharpDX.ResultDescriptor AudioPlaybackDeviceInUse = new SharpDX.ResultDescriptor(unchecked((int)3222097541UL), "SharpDX.MediaFoundation", "MF_E_AUDIO_PLAYBACK_DEVICE_IN_USE", "AudioPlaybackDeviceInUse");

        /// <summary>Constant AudioPlaybackDeviceInvalidated.</summary>
        /// <unmanaged>MF_E_AUDIO_PLAYBACK_DEVICE_INVALIDATED</unmanaged>
        public static readonly SharpDX.ResultDescriptor AudioPlaybackDeviceInvalidated = new SharpDX.ResultDescriptor(unchecked((int)3222097542UL), "SharpDX.MediaFoundation", "MF_E_AUDIO_PLAYBACK_DEVICE_INVALIDATED", "AudioPlaybackDeviceInvalidated");

        /// <summary>Constant AudioServiceNotRunning.</summary>
        /// <unmanaged>MF_E_AUDIO_SERVICE_NOT_RUNNING</unmanaged>
        public static readonly SharpDX.ResultDescriptor AudioServiceNotRunning = new SharpDX.ResultDescriptor(unchecked((int)3222097543UL), "SharpDX.MediaFoundation", "MF_E_AUDIO_SERVICE_NOT_RUNNING", "AudioServiceNotRunning");

        /// <summary>Constant TopoInvalidOptionalNode.</summary>
        /// <unmanaged>MF_E_TOPO_INVALID_OPTIONAL_NODE</unmanaged>
        public static readonly SharpDX.ResultDescriptor TopoInvalidOptionalNode = new SharpDX.ResultDescriptor(unchecked((int)3222098446UL), "SharpDX.MediaFoundation", "MF_E_TOPO_INVALID_OPTIONAL_NODE", "TopoInvalidOptionalNode");

        /// <summary>Constant TopoCannotFindDecrementYptor.</summary>
        /// <unmanaged>MF_E_TOPO_CANNOT_FIND_DECRYPTOR</unmanaged>
        public static readonly SharpDX.ResultDescriptor TopoCannotFindDecrementYptor = new SharpDX.ResultDescriptor(unchecked((int)3222098449UL), "SharpDX.MediaFoundation", "MF_E_TOPO_CANNOT_FIND_DECRYPTOR", "TopoCannotFindDecrementYptor");

        /// <summary>Constant TopoCodecNotFound.</summary>
        /// <unmanaged>MF_E_TOPO_CODEC_NOT_FOUND</unmanaged>
        public static readonly SharpDX.ResultDescriptor TopoCodecNotFound = new SharpDX.ResultDescriptor(unchecked((int)3222098450UL), "SharpDX.MediaFoundation", "MF_E_TOPO_CODEC_NOT_FOUND", "TopoCodecNotFound");

        /// <summary>Constant TopoCannotConnect.</summary>
        /// <unmanaged>MF_E_TOPO_CANNOT_CONNECT</unmanaged>
        public static readonly SharpDX.ResultDescriptor TopoCannotConnect = new SharpDX.ResultDescriptor(unchecked((int)3222098451UL), "SharpDX.MediaFoundation", "MF_E_TOPO_CANNOT_CONNECT", "TopoCannotConnect");

        /// <summary>Constant TopoUnsupported.</summary>
        /// <unmanaged>MF_E_TOPO_UNSUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor TopoUnsupported = new SharpDX.ResultDescriptor(unchecked((int)3222098452UL), "SharpDX.MediaFoundation", "MF_E_TOPO_UNSUPPORTED", "TopoUnsupported");

        /// <summary>Constant TopoInvalidTimeAttributes.</summary>
        /// <unmanaged>MF_E_TOPO_INVALID_TIME_ATTRIBUTES</unmanaged>
        public static readonly SharpDX.ResultDescriptor TopoInvalidTimeAttributes = new SharpDX.ResultDescriptor(unchecked((int)3222098453UL), "SharpDX.MediaFoundation", "MF_E_TOPO_INVALID_TIME_ATTRIBUTES", "TopoInvalidTimeAttributes");

        /// <summary>Constant TopoLoopsInTopology.</summary>
        /// <unmanaged>MF_E_TOPO_LOOPS_IN_TOPOLOGY</unmanaged>
        public static readonly SharpDX.ResultDescriptor TopoLoopsInTopology = new SharpDX.ResultDescriptor(unchecked((int)3222098454UL), "SharpDX.MediaFoundation", "MF_E_TOPO_LOOPS_IN_TOPOLOGY", "TopoLoopsInTopology");

        /// <summary>Constant TopoMissingPresentationDescriptor.</summary>
        /// <unmanaged>MF_E_TOPO_MISSING_PRESENTATION_DESCRIPTOR</unmanaged>
        public static readonly SharpDX.ResultDescriptor TopoMissingPresentationDescriptor = new SharpDX.ResultDescriptor(unchecked((int)3222098455UL), "SharpDX.MediaFoundation", "MF_E_TOPO_MISSING_PRESENTATION_DESCRIPTOR", "TopoMissingPresentationDescriptor");

        /// <summary>Constant TopoMissingStreamDescriptor.</summary>
        /// <unmanaged>MF_E_TOPO_MISSING_STREAM_DESCRIPTOR</unmanaged>
        public static readonly SharpDX.ResultDescriptor TopoMissingStreamDescriptor = new SharpDX.ResultDescriptor(unchecked((int)3222098456UL), "SharpDX.MediaFoundation", "MF_E_TOPO_MISSING_STREAM_DESCRIPTOR", "TopoMissingStreamDescriptor");

        /// <summary>Constant TopoStreamDescriptorNotSelected.</summary>
        /// <unmanaged>MF_E_TOPO_STREAM_DESCRIPTOR_NOT_SELECTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor TopoStreamDescriptorNotSelected = new SharpDX.ResultDescriptor(unchecked((int)3222098457UL), "SharpDX.MediaFoundation", "MF_E_TOPO_STREAM_DESCRIPTOR_NOT_SELECTED", "TopoStreamDescriptorNotSelected");

        /// <summary>Constant TopoMissingSource.</summary>
        /// <unmanaged>MF_E_TOPO_MISSING_SOURCE</unmanaged>
        public static readonly SharpDX.ResultDescriptor TopoMissingSource = new SharpDX.ResultDescriptor(unchecked((int)3222098458UL), "SharpDX.MediaFoundation", "MF_E_TOPO_MISSING_SOURCE", "TopoMissingSource");

        /// <summary>Constant TopoSinkActivatesUnsupported.</summary>
        /// <unmanaged>MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor TopoSinkActivatesUnsupported = new SharpDX.ResultDescriptor(unchecked((int)3222098459UL), "SharpDX.MediaFoundation", "MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED", "TopoSinkActivatesUnsupported");

        /// <summary>Constant SequencerUnknownSegmentId.</summary>
        /// <unmanaged>MF_E_SEQUENCER_UNKNOWN_SEGMENT_ID</unmanaged>
        public static readonly SharpDX.ResultDescriptor SequencerUnknownSegmentId = new SharpDX.ResultDescriptor(unchecked((int)3222102444UL), "SharpDX.MediaFoundation", "MF_E_SEQUENCER_UNKNOWN_SEGMENT_ID", "SequencerUnknownSegmentId");

        /// <summary>Constant NoSourceInCache.</summary>
        /// <unmanaged>MF_E_NO_SOURCE_IN_CACHE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoSourceInCache = new SharpDX.ResultDescriptor(unchecked((int)3222102446UL), "SharpDX.MediaFoundation", "MF_E_NO_SOURCE_IN_CACHE", "NoSourceInCache");

        /// <summary>Constant TransformTypeNotSet.</summary>
        /// <unmanaged>MF_E_TRANSFORM_TYPE_NOT_SET</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformTypeNotSet = new SharpDX.ResultDescriptor(unchecked((int)3222105440UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_TYPE_NOT_SET", "TransformTypeNotSet");

        /// <summary>Constant TransformStreamChange.</summary>
        /// <unmanaged>MF_E_TRANSFORM_STREAM_CHANGE</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformStreamChange = new SharpDX.ResultDescriptor(unchecked((int)3222105441UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_STREAM_CHANGE", "TransformStreamChange");

        /// <summary>Constant TransformInputRemaining.</summary>
        /// <unmanaged>MF_E_TRANSFORM_INPUT_REMAINING</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformInputRemaining = new SharpDX.ResultDescriptor(unchecked((int)3222105442UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_INPUT_REMAINING", "TransformInputRemaining");

        /// <summary>Constant TransformProfileMissing.</summary>
        /// <unmanaged>MF_E_TRANSFORM_PROFILE_MISSING</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformProfileMissing = new SharpDX.ResultDescriptor(unchecked((int)3222105443UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_PROFILE_MISSING", "TransformProfileMissing");

        /// <summary>Constant TransformProfileInvalidOrCorrupt.</summary>
        /// <unmanaged>MF_E_TRANSFORM_PROFILE_INVALID_OR_CORRUPT</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformProfileInvalidOrCorrupt = new SharpDX.ResultDescriptor(unchecked((int)3222105444UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_PROFILE_INVALID_OR_CORRUPT", "TransformProfileInvalidOrCorrupt");

        /// <summary>Constant TransformProfileTruncated.</summary>
        /// <unmanaged>MF_E_TRANSFORM_PROFILE_TRUNCATED</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformProfileTruncated = new SharpDX.ResultDescriptor(unchecked((int)3222105445UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_PROFILE_TRUNCATED", "TransformProfileTruncated");

        /// <summary>Constant TransformPropertyPidNotRecognized.</summary>
        /// <unmanaged>MF_E_TRANSFORM_PROPERTY_PID_NOT_RECOGNIZED</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformPropertyPidNotRecognized = new SharpDX.ResultDescriptor(unchecked((int)3222105446UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_PROPERTY_PID_NOT_RECOGNIZED", "TransformPropertyPidNotRecognized");

        /// <summary>Constant TransformPropertyVariantTypeWrong.</summary>
        /// <unmanaged>MF_E_TRANSFORM_PROPERTY_VARIANT_TYPE_WRONG</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformPropertyVariantTypeWrong = new SharpDX.ResultDescriptor(unchecked((int)3222105447UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_PROPERTY_VARIANT_TYPE_WRONG", "TransformPropertyVariantTypeWrong");

        /// <summary>Constant TransformPropertyNotWriteAble.</summary>
        /// <unmanaged>MF_E_TRANSFORM_PROPERTY_NOT_WRITEABLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformPropertyNotWriteAble = new SharpDX.ResultDescriptor(unchecked((int)3222105448UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_PROPERTY_NOT_WRITEABLE", "TransformPropertyNotWriteAble");

        /// <summary>Constant TransformPropertyArrayValueWrongNumDim.</summary>
        /// <unmanaged>MF_E_TRANSFORM_PROPERTY_ARRAY_VALUE_WRONG_NUM_DIM</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformPropertyArrayValueWrongNumDim = new SharpDX.ResultDescriptor(unchecked((int)3222105449UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_PROPERTY_ARRAY_VALUE_WRONG_NUM_DIM", "TransformPropertyArrayValueWrongNumDim");

        /// <summary>Constant TransformPropertyValueSizeWrong.</summary>
        /// <unmanaged>MF_E_TRANSFORM_PROPERTY_VALUE_SIZE_WRONG</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformPropertyValueSizeWrong = new SharpDX.ResultDescriptor(unchecked((int)3222105450UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_PROPERTY_VALUE_SIZE_WRONG", "TransformPropertyValueSizeWrong");

        /// <summary>Constant TransformPropertyValueOutOfRange.</summary>
        /// <unmanaged>MF_E_TRANSFORM_PROPERTY_VALUE_OUT_OF_RANGE</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformPropertyValueOutOfRange = new SharpDX.ResultDescriptor(unchecked((int)3222105451UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_PROPERTY_VALUE_OUT_OF_RANGE", "TransformPropertyValueOutOfRange");

        /// <summary>Constant TransformPropertyValueIncompatible.</summary>
        /// <unmanaged>MF_E_TRANSFORM_PROPERTY_VALUE_INCOMPATIBLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformPropertyValueIncompatible = new SharpDX.ResultDescriptor(unchecked((int)3222105452UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_PROPERTY_VALUE_INCOMPATIBLE", "TransformPropertyValueIncompatible");

        /// <summary>Constant TransformNotPossibleForCurrentOutputMediaType.</summary>
        /// <unmanaged>MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_OUTPUT_MEDIATYPE</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformNotPossibleForCurrentOutputMediaType = new SharpDX.ResultDescriptor(unchecked((int)3222105453UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_OUTPUT_MEDIATYPE", "TransformNotPossibleForCurrentOutputMediaType");

        /// <summary>Constant TransformNotPossibleForCurrentInputMediaType.</summary>
        /// <unmanaged>MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_INPUT_MEDIATYPE</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformNotPossibleForCurrentInputMediaType = new SharpDX.ResultDescriptor(unchecked((int)3222105454UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_INPUT_MEDIATYPE", "TransformNotPossibleForCurrentInputMediaType");

        /// <summary>Constant TransformNotPossibleForCurrentMediaTypeCombination.</summary>
        /// <unmanaged>MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_MEDIATYPE_COMBINATION</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformNotPossibleForCurrentMediaTypeCombination = new SharpDX.ResultDescriptor(unchecked((int)3222105455UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_MEDIATYPE_COMBINATION", "TransformNotPossibleForCurrentMediaTypeCombination");

        /// <summary>Constant TransformConflictsWithOtherCurrentlyEnabledFeatures.</summary>
        /// <unmanaged>MF_E_TRANSFORM_CONFLICTS_WITH_OTHER_CURRENTLY_ENABLED_FEATURES</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformConflictsWithOtherCurrentlyEnabledFeatures = new SharpDX.ResultDescriptor(unchecked((int)3222105456UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_CONFLICTS_WITH_OTHER_CURRENTLY_ENABLED_FEATURES", "TransformConflictsWithOtherCurrentlyEnabledFeatures");

        /// <summary>Constant TransformNeedMoreInput.</summary>
        /// <unmanaged>MF_E_TRANSFORM_NEED_MORE_INPUT</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformNeedMoreInput = new SharpDX.ResultDescriptor(unchecked((int)3222105458UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_NEED_MORE_INPUT", "TransformNeedMoreInput");

        /// <summary>Constant TransformNotPossibleForCurrentSpkrConfig.</summary>
        /// <unmanaged>MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_SPKR_CONFIG</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformNotPossibleForCurrentSpkrConfig = new SharpDX.ResultDescriptor(unchecked((int)3222105459UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_SPKR_CONFIG", "TransformNotPossibleForCurrentSpkrConfig");

        /// <summary>Constant TransformCannotChangeMediaTypeWhileProcessing.</summary>
        /// <unmanaged>MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformCannotChangeMediaTypeWhileProcessing = new SharpDX.ResultDescriptor(unchecked((int)3222105460UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING", "TransformCannotChangeMediaTypeWhileProcessing");

        /// <summary>Constant UnsupportedD3DType.</summary>
        /// <unmanaged>MF_E_UNSUPPORTED_D3D_TYPE</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedD3DType = new SharpDX.ResultDescriptor(unchecked((int)3222105462UL), "SharpDX.MediaFoundation", "MF_E_UNSUPPORTED_D3D_TYPE", "UnsupportedD3DType");

        /// <summary>Constant TransformAsyncLocked.</summary>
        /// <unmanaged>MF_E_TRANSFORM_ASYNC_LOCKED</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformAsyncLocked = new SharpDX.ResultDescriptor(unchecked((int)3222105463UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_ASYNC_LOCKED", "TransformAsyncLocked");

        /// <summary>Constant TransformCannotInitializeAcmDriver.</summary>
        /// <unmanaged>MF_E_TRANSFORM_CANNOT_INITIALIZE_ACM_DRIVER</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformCannotInitializeAcmDriver = new SharpDX.ResultDescriptor(unchecked((int)3222105464UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_CANNOT_INITIALIZE_ACM_DRIVER", "TransformCannotInitializeAcmDriver");

        /// <summary>Constant TransformStreamInvalidResolution.</summary>
        /// <unmanaged>MF_E_TRANSFORM_STREAM_INVALID_RESOLUTION</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformStreamInvalidResolution = new SharpDX.ResultDescriptor(unchecked((int)3222105465UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_STREAM_INVALID_RESOLUTION", "TransformStreamInvalidResolution");

        /// <summary>Constant TransformAsyncMftNotSupported.</summary>
        /// <unmanaged>MF_E_TRANSFORM_ASYNC_MFT_NOT_SUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformAsyncMftNotSupported = new SharpDX.ResultDescriptor(unchecked((int)3222105466UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_ASYNC_MFT_NOT_SUPPORTED", "TransformAsyncMftNotSupported");

        /// <summary>Constant TransformExattributeNotSupported.</summary>
        /// <unmanaged>MF_E_TRANSFORM_EXATTRIBUTE_NOT_SUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor TransformExattributeNotSupported = new SharpDX.ResultDescriptor(unchecked((int)3222105468UL), "SharpDX.MediaFoundation", "MF_E_TRANSFORM_EXATTRIBUTE_NOT_SUPPORTED", "TransformExattributeNotSupported");

        /// <summary>Constant LicenseIncorrectRights.</summary>
        /// <unmanaged>MF_E_LICENSE_INCORRECT_RIGHTS</unmanaged>
        public static readonly SharpDX.ResultDescriptor LicenseIncorrectRights = new SharpDX.ResultDescriptor(unchecked((int)3222106440UL), "SharpDX.MediaFoundation", "MF_E_LICENSE_INCORRECT_RIGHTS", "LicenseIncorrectRights");

        /// <summary>Constant LicenseOufOfDate.</summary>
        /// <unmanaged>MF_E_LICENSE_OUTOFDATE</unmanaged>
        public static readonly SharpDX.ResultDescriptor LicenseOufOfDate = new SharpDX.ResultDescriptor(unchecked((int)3222106441UL), "SharpDX.MediaFoundation", "MF_E_LICENSE_OUTOFDATE", "LicenseOufOfDate");

        /// <summary>Constant LicenseRequired.</summary>
        /// <unmanaged>MF_E_LICENSE_REQUIRED</unmanaged>
        public static readonly SharpDX.ResultDescriptor LicenseRequired = new SharpDX.ResultDescriptor(unchecked((int)3222106442UL), "SharpDX.MediaFoundation", "MF_E_LICENSE_REQUIRED", "LicenseRequired");

        /// <summary>Constant DrmHardwareInconsistent.</summary>
        /// <unmanaged>MF_E_DRM_HARDWARE_INCONSISTENT</unmanaged>
        public static readonly SharpDX.ResultDescriptor DrmHardwareInconsistent = new SharpDX.ResultDescriptor(unchecked((int)3222106443UL), "SharpDX.MediaFoundation", "MF_E_DRM_HARDWARE_INCONSISTENT", "DrmHardwareInconsistent");

        /// <summary>Constant NoContentProtectionManager.</summary>
        /// <unmanaged>MF_E_NO_CONTENT_PROTECTION_MANAGER</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoContentProtectionManager = new SharpDX.ResultDescriptor(unchecked((int)3222106444UL), "SharpDX.MediaFoundation", "MF_E_NO_CONTENT_PROTECTION_MANAGER", "NoContentProtectionManager");

        /// <summary>Constant LicenseRestoreNoRights.</summary>
        /// <unmanaged>MF_E_LICENSE_RESTORE_NO_RIGHTS</unmanaged>
        public static readonly SharpDX.ResultDescriptor LicenseRestoreNoRights = new SharpDX.ResultDescriptor(unchecked((int)3222106445UL), "SharpDX.MediaFoundation", "MF_E_LICENSE_RESTORE_NO_RIGHTS", "LicenseRestoreNoRights");

        /// <summary>Constant BackupRestrictedLicense.</summary>
        /// <unmanaged>MF_E_BACKUP_RESTRICTED_LICENSE</unmanaged>
        public static readonly SharpDX.ResultDescriptor BackupRestrictedLicense = new SharpDX.ResultDescriptor(unchecked((int)3222106446UL), "SharpDX.MediaFoundation", "MF_E_BACKUP_RESTRICTED_LICENSE", "BackupRestrictedLicense");

        /// <summary>Constant LicenseRestoreNeedsIndividualization.</summary>
        /// <unmanaged>MF_E_LICENSE_RESTORE_NEEDS_INDIVIDUALIZATION</unmanaged>
        public static readonly SharpDX.ResultDescriptor LicenseRestoreNeedsIndividualization = new SharpDX.ResultDescriptor(unchecked((int)3222106447UL), "SharpDX.MediaFoundation", "MF_E_LICENSE_RESTORE_NEEDS_INDIVIDUALIZATION", "LicenseRestoreNeedsIndividualization");

        /// <summary>Constant ComponentRevoked.</summary>
        /// <unmanaged>MF_E_COMPONENT_REVOKED</unmanaged>
        public static readonly SharpDX.ResultDescriptor ComponentRevoked = new SharpDX.ResultDescriptor(unchecked((int)3222106449UL), "SharpDX.MediaFoundation", "MF_E_COMPONENT_REVOKED", "ComponentRevoked");

        /// <summary>Constant TrustDisabled.</summary>
        /// <unmanaged>MF_E_TRUST_DISABLED</unmanaged>
        public static readonly SharpDX.ResultDescriptor TrustDisabled = new SharpDX.ResultDescriptor(unchecked((int)3222106450UL), "SharpDX.MediaFoundation", "MF_E_TRUST_DISABLED", "TrustDisabled");

        /// <summary>Constant WmdrmotaNoAction.</summary>
        /// <unmanaged>MF_E_WMDRMOTA_NO_ACTION</unmanaged>
        public static readonly SharpDX.ResultDescriptor WmdrmotaNoAction = new SharpDX.ResultDescriptor(unchecked((int)3222106451UL), "SharpDX.MediaFoundation", "MF_E_WMDRMOTA_NO_ACTION", "WmdrmotaNoAction");

        /// <summary>Constant WmdrmotaActionAlreadySet.</summary>
        /// <unmanaged>MF_E_WMDRMOTA_ACTION_ALREADY_SET</unmanaged>
        public static readonly SharpDX.ResultDescriptor WmdrmotaActionAlreadySet = new SharpDX.ResultDescriptor(unchecked((int)3222106452UL), "SharpDX.MediaFoundation", "MF_E_WMDRMOTA_ACTION_ALREADY_SET", "WmdrmotaActionAlreadySet");

        /// <summary>Constant WmdrmotaDrmHeaderNotAvailable.</summary>
        /// <unmanaged>MF_E_WMDRMOTA_DRM_HEADER_NOT_AVAILABLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor WmdrmotaDrmHeaderNotAvailable = new SharpDX.ResultDescriptor(unchecked((int)3222106453UL), "SharpDX.MediaFoundation", "MF_E_WMDRMOTA_DRM_HEADER_NOT_AVAILABLE", "WmdrmotaDrmHeaderNotAvailable");

        /// <summary>Constant WmdrmotaDrmEncryptionSchemeNotSupported.</summary>
        /// <unmanaged>MF_E_WMDRMOTA_DRM_ENCRYPTION_SCHEME_NOT_SUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor WmdrmotaDrmEncryptionSchemeNotSupported = new SharpDX.ResultDescriptor(unchecked((int)3222106454UL), "SharpDX.MediaFoundation", "MF_E_WMDRMOTA_DRM_ENCRYPTION_SCHEME_NOT_SUPPORTED", "WmdrmotaDrmEncryptionSchemeNotSupported");

        /// <summary>Constant WmdrmotaActionMismatch.</summary>
        /// <unmanaged>MF_E_WMDRMOTA_ACTION_MISMATCH</unmanaged>
        public static readonly SharpDX.ResultDescriptor WmdrmotaActionMismatch = new SharpDX.ResultDescriptor(unchecked((int)3222106455UL), "SharpDX.MediaFoundation", "MF_E_WMDRMOTA_ACTION_MISMATCH", "WmdrmotaActionMismatch");

        /// <summary>Constant WmdrmotaInvalidPolicy.</summary>
        /// <unmanaged>MF_E_WMDRMOTA_INVALID_POLICY</unmanaged>
        public static readonly SharpDX.ResultDescriptor WmdrmotaInvalidPolicy = new SharpDX.ResultDescriptor(unchecked((int)3222106456UL), "SharpDX.MediaFoundation", "MF_E_WMDRMOTA_INVALID_POLICY", "WmdrmotaInvalidPolicy");

        /// <summary>Constant PolicyUnsupported.</summary>
        /// <unmanaged>MF_E_POLICY_UNSUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PolicyUnsupported = new SharpDX.ResultDescriptor(unchecked((int)3222106457UL), "SharpDX.MediaFoundation", "MF_E_POLICY_UNSUPPORTED", "PolicyUnsupported");

        /// <summary>Constant OperationLNotSupported.</summary>
        /// <unmanaged>MF_E_OPL_NOT_SUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor OperationLNotSupported = new SharpDX.ResultDescriptor(unchecked((int)3222106458UL), "SharpDX.MediaFoundation", "MF_E_OPL_NOT_SUPPORTED", "OperationLNotSupported");

        /// <summary>Constant TopologyVerificationFailed.</summary>
        /// <unmanaged>MF_E_TOPOLOGY_VERIFICATION_FAILED</unmanaged>
        public static readonly SharpDX.ResultDescriptor TopologyVerificationFailed = new SharpDX.ResultDescriptor(unchecked((int)3222106459UL), "SharpDX.MediaFoundation", "MF_E_TOPOLOGY_VERIFICATION_FAILED", "TopologyVerificationFailed");

        /// <summary>Constant SignatureVerificationFailed.</summary>
        /// <unmanaged>MF_E_SIGNATURE_VERIFICATION_FAILED</unmanaged>
        public static readonly SharpDX.ResultDescriptor SignatureVerificationFailed = new SharpDX.ResultDescriptor(unchecked((int)3222106460UL), "SharpDX.MediaFoundation", "MF_E_SIGNATURE_VERIFICATION_FAILED", "SignatureVerificationFailed");

        /// <summary>Constant DebuggingNotAllowEd.</summary>
        /// <unmanaged>MF_E_DEBUGGING_NOT_ALLOWED</unmanaged>
        public static readonly SharpDX.ResultDescriptor DebuggingNotAllowEd = new SharpDX.ResultDescriptor(unchecked((int)3222106461UL), "SharpDX.MediaFoundation", "MF_E_DEBUGGING_NOT_ALLOWED", "DebuggingNotAllowEd");

        /// <summary>Constant CodeExpired.</summary>
        /// <unmanaged>MF_E_CODE_EXPIRED</unmanaged>
        public static readonly SharpDX.ResultDescriptor CodeExpired = new SharpDX.ResultDescriptor(unchecked((int)3222106462UL), "SharpDX.MediaFoundation", "MF_E_CODE_EXPIRED", "CodeExpired");

        /// <summary>Constant GrlVersionTooLow.</summary>
        /// <unmanaged>MF_E_GRL_VERSION_TOO_LOW</unmanaged>
        public static readonly SharpDX.ResultDescriptor GrlVersionTooLow = new SharpDX.ResultDescriptor(unchecked((int)3222106463UL), "SharpDX.MediaFoundation", "MF_E_GRL_VERSION_TOO_LOW", "GrlVersionTooLow");

        /// <summary>Constant GrlRenewalNotFound.</summary>
        /// <unmanaged>MF_E_GRL_RENEWAL_NOT_FOUND</unmanaged>
        public static readonly SharpDX.ResultDescriptor GrlRenewalNotFound = new SharpDX.ResultDescriptor(unchecked((int)3222106464UL), "SharpDX.MediaFoundation", "MF_E_GRL_RENEWAL_NOT_FOUND", "GrlRenewalNotFound");

        /// <summary>Constant GrlExtensibleEntryNotFound.</summary>
        /// <unmanaged>MF_E_GRL_EXTENSIBLE_ENTRY_NOT_FOUND</unmanaged>
        public static readonly SharpDX.ResultDescriptor GrlExtensibleEntryNotFound = new SharpDX.ResultDescriptor(unchecked((int)3222106465UL), "SharpDX.MediaFoundation", "MF_E_GRL_EXTENSIBLE_ENTRY_NOT_FOUND", "GrlExtensibleEntryNotFound");

        /// <summary>Constant KernelUntrusted.</summary>
        /// <unmanaged>MF_E_KERNEL_UNTRUSTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor KernelUntrusted = new SharpDX.ResultDescriptor(unchecked((int)3222106466UL), "SharpDX.MediaFoundation", "MF_E_KERNEL_UNTRUSTED", "KernelUntrusted");

        /// <summary>Constant PeauthUntrusted.</summary>
        /// <unmanaged>MF_E_PEAUTH_UNTRUSTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PeauthUntrusted = new SharpDX.ResultDescriptor(unchecked((int)3222106467UL), "SharpDX.MediaFoundation", "MF_E_PEAUTH_UNTRUSTED", "PeauthUntrusted");

        /// <summary>Constant NonPeProcess.</summary>
        /// <unmanaged>MF_E_NON_PE_PROCESS</unmanaged>
        public static readonly SharpDX.ResultDescriptor NonPeProcess = new SharpDX.ResultDescriptor(unchecked((int)3222106469UL), "SharpDX.MediaFoundation", "MF_E_NON_PE_PROCESS", "NonPeProcess");

        /// <summary>Constant RebootRequired.</summary>
        /// <unmanaged>MF_E_REBOOT_REQUIRED</unmanaged>
        public static readonly SharpDX.ResultDescriptor RebootRequired = new SharpDX.ResultDescriptor(unchecked((int)3222106471UL), "SharpDX.MediaFoundation", "MF_E_REBOOT_REQUIRED", "RebootRequired");

        /// <summary>Constant GrlInvalidFormat.</summary>
        /// <unmanaged>MF_E_GRL_INVALID_FORMAT</unmanaged>
        public static readonly SharpDX.ResultDescriptor GrlInvalidFormat = new SharpDX.ResultDescriptor(unchecked((int)3222106474UL), "SharpDX.MediaFoundation", "MF_E_GRL_INVALID_FORMAT", "GrlInvalidFormat");

        /// <summary>Constant GrlUnrecognizedFormat.</summary>
        /// <unmanaged>MF_E_GRL_UNRECOGNIZED_FORMAT</unmanaged>
        public static readonly SharpDX.ResultDescriptor GrlUnrecognizedFormat = new SharpDX.ResultDescriptor(unchecked((int)3222106475UL), "SharpDX.MediaFoundation", "MF_E_GRL_UNRECOGNIZED_FORMAT", "GrlUnrecognizedFormat");

        /// <summary>Constant AllProcessRestartRequired.</summary>
        /// <unmanaged>MF_E_ALL_PROCESS_RESTART_REQUIRED</unmanaged>
        public static readonly SharpDX.ResultDescriptor AllProcessRestartRequired = new SharpDX.ResultDescriptor(unchecked((int)3222106476UL), "SharpDX.MediaFoundation", "MF_E_ALL_PROCESS_RESTART_REQUIRED", "AllProcessRestartRequired");

        /// <summary>Constant ProcessRestartRequired.</summary>
        /// <unmanaged>MF_E_PROCESS_RESTART_REQUIRED</unmanaged>
        public static readonly SharpDX.ResultDescriptor ProcessRestartRequired = new SharpDX.ResultDescriptor(unchecked((int)3222106477UL), "SharpDX.MediaFoundation", "MF_E_PROCESS_RESTART_REQUIRED", "ProcessRestartRequired");

        /// <summary>Constant UsermodeUntrusted.</summary>
        /// <unmanaged>MF_E_USERMODE_UNTRUSTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor UsermodeUntrusted = new SharpDX.ResultDescriptor(unchecked((int)3222106478UL), "SharpDX.MediaFoundation", "MF_E_USERMODE_UNTRUSTED", "UsermodeUntrusted");

        /// <summary>Constant PeauthSessionNotStarted.</summary>
        /// <unmanaged>MF_E_PEAUTH_SESSION_NOT_STARTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PeauthSessionNotStarted = new SharpDX.ResultDescriptor(unchecked((int)3222106479UL), "SharpDX.MediaFoundation", "MF_E_PEAUTH_SESSION_NOT_STARTED", "PeauthSessionNotStarted");

        /// <summary>Constant PeauthPublickeyRevoked.</summary>
        /// <unmanaged>MF_E_PEAUTH_PUBLICKEY_REVOKED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PeauthPublickeyRevoked = new SharpDX.ResultDescriptor(unchecked((int)3222106481UL), "SharpDX.MediaFoundation", "MF_E_PEAUTH_PUBLICKEY_REVOKED", "PeauthPublickeyRevoked");

        /// <summary>Constant GrlAbsent.</summary>
        /// <unmanaged>MF_E_GRL_ABSENT</unmanaged>
        public static readonly SharpDX.ResultDescriptor GrlAbsent = new SharpDX.ResultDescriptor(unchecked((int)3222106482UL), "SharpDX.MediaFoundation", "MF_E_GRL_ABSENT", "GrlAbsent");

        /// <summary>Constant PeUntrusted.</summary>
        /// <unmanaged>MF_E_PE_UNTRUSTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PeUntrusted = new SharpDX.ResultDescriptor(unchecked((int)3222106484UL), "SharpDX.MediaFoundation", "MF_E_PE_UNTRUSTED", "PeUntrusted");

        /// <summary>Constant PeauthNotStarted.</summary>
        /// <unmanaged>MF_E_PEAUTH_NOT_STARTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PeauthNotStarted = new SharpDX.ResultDescriptor(unchecked((int)3222106485UL), "SharpDX.MediaFoundation", "MF_E_PEAUTH_NOT_STARTED", "PeauthNotStarted");

        /// <summary>Constant IncompatibleSampleProtection.</summary>
        /// <unmanaged>MF_E_INCOMPATIBLE_SAMPLE_PROTECTION</unmanaged>
        public static readonly SharpDX.ResultDescriptor IncompatibleSampleProtection = new SharpDX.ResultDescriptor(unchecked((int)3222106486UL), "SharpDX.MediaFoundation", "MF_E_INCOMPATIBLE_SAMPLE_PROTECTION", "IncompatibleSampleProtection");

        /// <summary>Constant PeSessionsMaximumEd.</summary>
        /// <unmanaged>MF_E_PE_SESSIONS_MAXED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PeSessionsMaximumEd = new SharpDX.ResultDescriptor(unchecked((int)3222106487UL), "SharpDX.MediaFoundation", "MF_E_PE_SESSIONS_MAXED", "PeSessionsMaximumEd");

        /// <summary>Constant HighSecurityLevelContentNotAllowEd.</summary>
        /// <unmanaged>MF_E_HIGH_SECURITY_LEVEL_CONTENT_NOT_ALLOWED</unmanaged>
        public static readonly SharpDX.ResultDescriptor HighSecurityLevelContentNotAllowEd = new SharpDX.ResultDescriptor(unchecked((int)3222106488UL), "SharpDX.MediaFoundation", "MF_E_HIGH_SECURITY_LEVEL_CONTENT_NOT_ALLOWED", "HighSecurityLevelContentNotAllowEd");

        /// <summary>Constant TestSignedComponentsNotAllowEd.</summary>
        /// <unmanaged>MF_E_TEST_SIGNED_COMPONENTS_NOT_ALLOWED</unmanaged>
        public static readonly SharpDX.ResultDescriptor TestSignedComponentsNotAllowEd = new SharpDX.ResultDescriptor(unchecked((int)3222106489UL), "SharpDX.MediaFoundation", "MF_E_TEST_SIGNED_COMPONENTS_NOT_ALLOWED", "TestSignedComponentsNotAllowEd");

        /// <summary>Constant ItaUnsupportedAction.</summary>
        /// <unmanaged>MF_E_ITA_UNSUPPORTED_ACTION</unmanaged>
        public static readonly SharpDX.ResultDescriptor ItaUnsupportedAction = new SharpDX.ResultDescriptor(unchecked((int)3222106490UL), "SharpDX.MediaFoundation", "MF_E_ITA_UNSUPPORTED_ACTION", "ItaUnsupportedAction");

        /// <summary>Constant ItaErrorParsingSapParameters.</summary>
        /// <unmanaged>MF_E_ITA_ERROR_PARSING_SAP_PARAMETERS</unmanaged>
        public static readonly SharpDX.ResultDescriptor ItaErrorParsingSapParameters = new SharpDX.ResultDescriptor(unchecked((int)3222106491UL), "SharpDX.MediaFoundation", "MF_E_ITA_ERROR_PARSING_SAP_PARAMETERS", "ItaErrorParsingSapParameters");

        /// <summary>Constant PolicyMgrActionOufOfBounds.</summary>
        /// <unmanaged>MF_E_POLICY_MGR_ACTION_OUTOFBOUNDS</unmanaged>
        public static readonly SharpDX.ResultDescriptor PolicyMgrActionOufOfBounds = new SharpDX.ResultDescriptor(unchecked((int)3222106492UL), "SharpDX.MediaFoundation", "MF_E_POLICY_MGR_ACTION_OUTOFBOUNDS", "PolicyMgrActionOufOfBounds");

        /// <summary>Constant BadOperationLStructureFormat.</summary>
        /// <unmanaged>MF_E_BAD_OPL_STRUCTURE_FORMAT</unmanaged>
        public static readonly SharpDX.ResultDescriptor BadOperationLStructureFormat = new SharpDX.ResultDescriptor(unchecked((int)3222106493UL), "SharpDX.MediaFoundation", "MF_E_BAD_OPL_STRUCTURE_FORMAT", "BadOperationLStructureFormat");

        /// <summary>Constant ItaUnrecognizedAnalogVideoProtectionGuid.</summary>
        /// <unmanaged>MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_PROTECTION_GUID</unmanaged>
        public static readonly SharpDX.ResultDescriptor ItaUnrecognizedAnalogVideoProtectionGuid = new SharpDX.ResultDescriptor(unchecked((int)3222106494UL), "SharpDX.MediaFoundation", "MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_PROTECTION_GUID", "ItaUnrecognizedAnalogVideoProtectionGuid");

        /// <summary>Constant NoPmpHost.</summary>
        /// <unmanaged>MF_E_NO_PMP_HOST</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoPmpHost = new SharpDX.ResultDescriptor(unchecked((int)3222106495UL), "SharpDX.MediaFoundation", "MF_E_NO_PMP_HOST", "NoPmpHost");

        /// <summary>Constant ItaOperationLDataNotInitializeD.</summary>
        /// <unmanaged>MF_E_ITA_OPL_DATA_NOT_INITIALIZED</unmanaged>
        public static readonly SharpDX.ResultDescriptor ItaOperationLDataNotInitializeD = new SharpDX.ResultDescriptor(unchecked((int)3222106496UL), "SharpDX.MediaFoundation", "MF_E_ITA_OPL_DATA_NOT_INITIALIZED", "ItaOperationLDataNotInitializeD");

        /// <summary>Constant ItaUnrecognizedAnalogVideoOutput.</summary>
        /// <unmanaged>MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_OUTPUT</unmanaged>
        public static readonly SharpDX.ResultDescriptor ItaUnrecognizedAnalogVideoOutput = new SharpDX.ResultDescriptor(unchecked((int)3222106497UL), "SharpDX.MediaFoundation", "MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_OUTPUT", "ItaUnrecognizedAnalogVideoOutput");

        /// <summary>Constant ItaUnrecognizedDigitalVideoOutput.</summary>
        /// <unmanaged>MF_E_ITA_UNRECOGNIZED_DIGITAL_VIDEO_OUTPUT</unmanaged>
        public static readonly SharpDX.ResultDescriptor ItaUnrecognizedDigitalVideoOutput = new SharpDX.ResultDescriptor(unchecked((int)3222106498UL), "SharpDX.MediaFoundation", "MF_E_ITA_UNRECOGNIZED_DIGITAL_VIDEO_OUTPUT", "ItaUnrecognizedDigitalVideoOutput");

        /// <summary>Constant ResolutionRequiresPmpCreationCallback.</summary>
        /// <unmanaged>MF_E_RESOLUTION_REQUIRES_PMP_CREATION_CALLBACK</unmanaged>
        public static readonly SharpDX.ResultDescriptor ResolutionRequiresPmpCreationCallback = new SharpDX.ResultDescriptor(unchecked((int)3222106499UL), "SharpDX.MediaFoundation", "MF_E_RESOLUTION_REQUIRES_PMP_CREATION_CALLBACK", "ResolutionRequiresPmpCreationCallback");

        /// <summary>Constant InvalidAkeChannelParameters.</summary>
        /// <unmanaged>MF_E_INVALID_AKE_CHANNEL_PARAMETERS</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidAkeChannelParameters = new SharpDX.ResultDescriptor(unchecked((int)3222106500UL), "SharpDX.MediaFoundation", "MF_E_INVALID_AKE_CHANNEL_PARAMETERS", "InvalidAkeChannelParameters");

        /// <summary>Constant ContentProtectionSystemNotEnabled.</summary>
        /// <unmanaged>MF_E_CONTENT_PROTECTION_SYSTEM_NOT_ENABLED</unmanaged>
        public static readonly SharpDX.ResultDescriptor ContentProtectionSystemNotEnabled = new SharpDX.ResultDescriptor(unchecked((int)3222106501UL), "SharpDX.MediaFoundation", "MF_E_CONTENT_PROTECTION_SYSTEM_NOT_ENABLED", "ContentProtectionSystemNotEnabled");

        /// <summary>Constant UnsupportedContentProtectionSystem.</summary>
        /// <unmanaged>MF_E_UNSUPPORTED_CONTENT_PROTECTION_SYSTEM</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedContentProtectionSystem = new SharpDX.ResultDescriptor(unchecked((int)3222106502UL), "SharpDX.MediaFoundation", "MF_E_UNSUPPORTED_CONTENT_PROTECTION_SYSTEM", "UnsupportedContentProtectionSystem");

        /// <summary>Constant DrmMigrationNotSupported.</summary>
        /// <unmanaged>MF_E_DRM_MIGRATION_NOT_SUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor DrmMigrationNotSupported = new SharpDX.ResultDescriptor(unchecked((int)3222106503UL), "SharpDX.MediaFoundation", "MF_E_DRM_MIGRATION_NOT_SUPPORTED", "DrmMigrationNotSupported");

        /// <summary>Constant HdcpAuthenticationFailure.</summary>
        /// <unmanaged>MF_E_HDCP_AUTHENTICATION_FAILURE</unmanaged>
        public static readonly SharpDX.ResultDescriptor HdcpAuthenticationFailure = new SharpDX.ResultDescriptor(unchecked((int)3222106504UL), "SharpDX.MediaFoundation", "MF_E_HDCP_AUTHENTICATION_FAILURE", "HdcpAuthenticationFailure");

        /// <summary>Constant HdcpLinkFailure.</summary>
        /// <unmanaged>MF_E_HDCP_LINK_FAILURE</unmanaged>
        public static readonly SharpDX.ResultDescriptor HdcpLinkFailure = new SharpDX.ResultDescriptor(unchecked((int)3222106505UL), "SharpDX.MediaFoundation", "MF_E_HDCP_LINK_FAILURE", "HdcpLinkFailure");

        /// <summary>Constant ClockInvalidContinuityKey.</summary>
        /// <unmanaged>MF_E_CLOCK_INVALID_CONTINUITY_KEY</unmanaged>
        public static readonly SharpDX.ResultDescriptor ClockInvalidContinuityKey = new SharpDX.ResultDescriptor(unchecked((int)3222117440UL), "SharpDX.MediaFoundation", "MF_E_CLOCK_INVALID_CONTINUITY_KEY", "ClockInvalidContinuityKey");

        /// <summary>Constant ClockNoTimeSource.</summary>
        /// <unmanaged>MF_E_CLOCK_NO_TIME_SOURCE</unmanaged>
        public static readonly SharpDX.ResultDescriptor ClockNoTimeSource = new SharpDX.ResultDescriptor(unchecked((int)3222117441UL), "SharpDX.MediaFoundation", "MF_E_CLOCK_NO_TIME_SOURCE", "ClockNoTimeSource");

        /// <summary>Constant ClockStateAlreadySet.</summary>
        /// <unmanaged>MF_E_CLOCK_STATE_ALREADY_SET</unmanaged>
        public static readonly SharpDX.ResultDescriptor ClockStateAlreadySet = new SharpDX.ResultDescriptor(unchecked((int)3222117442UL), "SharpDX.MediaFoundation", "MF_E_CLOCK_STATE_ALREADY_SET", "ClockStateAlreadySet");

        /// <summary>Constant ClockNotSimple.</summary>
        /// <unmanaged>MF_E_CLOCK_NOT_SIMPLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor ClockNotSimple = new SharpDX.ResultDescriptor(unchecked((int)3222117443UL), "SharpDX.MediaFoundation", "MF_E_CLOCK_NOT_SIMPLE", "ClockNotSimple");

        /// <summary>Constant NoMoreDropModes.</summary>
        /// <unmanaged>MF_E_NO_MORE_DROP_MODES</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoMoreDropModes = new SharpDX.ResultDescriptor(unchecked((int)3222118440UL), "SharpDX.MediaFoundation", "MF_E_NO_MORE_DROP_MODES", "NoMoreDropModes");

        /// <summary>Constant NoMoreQualityLevels.</summary>
        /// <unmanaged>MF_E_NO_MORE_QUALITY_LEVELS</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoMoreQualityLevels = new SharpDX.ResultDescriptor(unchecked((int)3222118441UL), "SharpDX.MediaFoundation", "MF_E_NO_MORE_QUALITY_LEVELS", "NoMoreQualityLevels");

        /// <summary>Constant DroptimeNotSupported.</summary>
        /// <unmanaged>MF_E_DROPTIME_NOT_SUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor DroptimeNotSupported = new SharpDX.ResultDescriptor(unchecked((int)3222118442UL), "SharpDX.MediaFoundation", "MF_E_DROPTIME_NOT_SUPPORTED", "DroptimeNotSupported");

        /// <summary>Constant QualityknobWaitLonger.</summary>
        /// <unmanaged>MF_E_QUALITYKNOB_WAIT_LONGER</unmanaged>
        public static readonly SharpDX.ResultDescriptor QualityknobWaitLonger = new SharpDX.ResultDescriptor(unchecked((int)3222118443UL), "SharpDX.MediaFoundation", "MF_E_QUALITYKNOB_WAIT_LONGER", "QualityknobWaitLonger");

        /// <summary>Constant QmInvalidState.</summary>
        /// <unmanaged>MF_E_QM_INVALIDSTATE</unmanaged>
        public static readonly SharpDX.ResultDescriptor QmInvalidState = new SharpDX.ResultDescriptor(unchecked((int)3222118444UL), "SharpDX.MediaFoundation", "MF_E_QM_INVALIDSTATE", "QmInvalidState");

        /// <summary>Constant TranscodeNoContainertype.</summary>
        /// <unmanaged>MF_E_TRANSCODE_NO_CONTAINERTYPE</unmanaged>
        public static readonly SharpDX.ResultDescriptor TranscodeNoContainertype = new SharpDX.ResultDescriptor(unchecked((int)3222119440UL), "SharpDX.MediaFoundation", "MF_E_TRANSCODE_NO_CONTAINERTYPE", "TranscodeNoContainertype");

        /// <summary>Constant TranscodeProfileNoMatchingStreams.</summary>
        /// <unmanaged>MF_E_TRANSCODE_PROFILE_NO_MATCHING_STREAMS</unmanaged>
        public static readonly SharpDX.ResultDescriptor TranscodeProfileNoMatchingStreams = new SharpDX.ResultDescriptor(unchecked((int)3222119441UL), "SharpDX.MediaFoundation", "MF_E_TRANSCODE_PROFILE_NO_MATCHING_STREAMS", "TranscodeProfileNoMatchingStreams");

        /// <summary>Constant TranscodeNoMatchingEncoder.</summary>
        /// <unmanaged>MF_E_TRANSCODE_NO_MATCHING_ENCODER</unmanaged>
        public static readonly SharpDX.ResultDescriptor TranscodeNoMatchingEncoder = new SharpDX.ResultDescriptor(unchecked((int)3222119442UL), "SharpDX.MediaFoundation", "MF_E_TRANSCODE_NO_MATCHING_ENCODER", "TranscodeNoMatchingEncoder");

        /// <summary>Constant TranscodeInvalidProfile.</summary>
        /// <unmanaged>MF_E_TRANSCODE_INVALID_PROFILE</unmanaged>
        public static readonly SharpDX.ResultDescriptor TranscodeInvalidProfile = new SharpDX.ResultDescriptor(unchecked((int)3222119443UL), "SharpDX.MediaFoundation", "MF_E_TRANSCODE_INVALID_PROFILE", "TranscodeInvalidProfile");

        /// <summary>Constant AllOcatorNotInitializeD.</summary>
        /// <unmanaged>MF_E_ALLOCATOR_NOT_INITIALIZED</unmanaged>
        public static readonly SharpDX.ResultDescriptor AllOcatorNotInitializeD = new SharpDX.ResultDescriptor(unchecked((int)3222120440UL), "SharpDX.MediaFoundation", "MF_E_ALLOCATOR_NOT_INITIALIZED", "AllOcatorNotInitializeD");

        /// <summary>Constant AllOcatorNotCommited.</summary>
        /// <unmanaged>MF_E_ALLOCATOR_NOT_COMMITED</unmanaged>
        public static readonly SharpDX.ResultDescriptor AllOcatorNotCommited = new SharpDX.ResultDescriptor(unchecked((int)3222120441UL), "SharpDX.MediaFoundation", "MF_E_ALLOCATOR_NOT_COMMITED", "AllOcatorNotCommited");

        /// <summary>Constant AllOcatorAlreadyCommited.</summary>
        /// <unmanaged>MF_E_ALLOCATOR_ALREADY_COMMITED</unmanaged>
        public static readonly SharpDX.ResultDescriptor AllOcatorAlreadyCommited = new SharpDX.ResultDescriptor(unchecked((int)3222120442UL), "SharpDX.MediaFoundation", "MF_E_ALLOCATOR_ALREADY_COMMITED", "AllOcatorAlreadyCommited");

        /// <summary>Constant StreamError.</summary>
        /// <unmanaged>MF_E_STREAM_ERROR</unmanaged>
        public static readonly SharpDX.ResultDescriptor StreamError = new SharpDX.ResultDescriptor(unchecked((int)3222120443UL), "SharpDX.MediaFoundation", "MF_E_STREAM_ERROR", "StreamError");

        /// <summary>Constant InvalidStreamState.</summary>
        /// <unmanaged>MF_E_INVALID_STREAM_STATE</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidStreamState = new SharpDX.ResultDescriptor(unchecked((int)3222120444UL), "SharpDX.MediaFoundation", "MF_E_INVALID_STREAM_STATE", "InvalidStreamState");

        /// <summary>Constant HwStreamNotConnected.</summary>
        /// <unmanaged>MF_E_HW_STREAM_NOT_CONNECTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor HwStreamNotConnected = new SharpDX.ResultDescriptor(unchecked((int)3222120445UL), "SharpDX.MediaFoundation", "MF_E_HW_STREAM_NOT_CONNECTED", "HwStreamNotConnected");

        /// <summary>Constant NoCaptureDevicesAvailable.</summary>
        /// <unmanaged>MF_E_NO_CAPTURE_DEVICES_AVAILABLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoCaptureDevicesAvailable = new SharpDX.ResultDescriptor(unchecked((int)3222121440UL), "SharpDX.MediaFoundation", "MF_E_NO_CAPTURE_DEVICES_AVAILABLE", "NoCaptureDevicesAvailable");

        /// <summary>Constant CaptureSinkOutputNotSet.</summary>
        /// <unmanaged>MF_E_CAPTURE_SINK_OUTPUT_NOT_SET</unmanaged>
        public static readonly SharpDX.ResultDescriptor CaptureSinkOutputNotSet = new SharpDX.ResultDescriptor(unchecked((int)3222121441UL), "SharpDX.MediaFoundation", "MF_E_CAPTURE_SINK_OUTPUT_NOT_SET", "CaptureSinkOutputNotSet");

        /// <summary>Constant CaptureSinkMirrorError.</summary>
        /// <unmanaged>MF_E_CAPTURE_SINK_MIRROR_ERROR</unmanaged>
        public static readonly SharpDX.ResultDescriptor CaptureSinkMirrorError = new SharpDX.ResultDescriptor(unchecked((int)3222121442UL), "SharpDX.MediaFoundation", "MF_E_CAPTURE_SINK_MIRROR_ERROR", "CaptureSinkMirrorError");

        /// <summary>Constant CaptureSinkRotateError.</summary>
        /// <unmanaged>MF_E_CAPTURE_SINK_ROTATE_ERROR</unmanaged>
        public static readonly SharpDX.ResultDescriptor CaptureSinkRotateError = new SharpDX.ResultDescriptor(unchecked((int)3222121443UL), "SharpDX.MediaFoundation", "MF_E_CAPTURE_SINK_ROTATE_ERROR", "CaptureSinkRotateError");

        /// <summary>Constant CaptureEngineInvalidOperation.</summary>
        /// <unmanaged>MF_E_CAPTURE_ENGINE_INVALID_OP</unmanaged>
        public static readonly SharpDX.ResultDescriptor CaptureEngineInvalidOperation = new SharpDX.ResultDescriptor(unchecked((int)3222121444UL), "SharpDX.MediaFoundation", "MF_E_CAPTURE_ENGINE_INVALID_OP", "CaptureEngineInvalidOperation");

        /// <summary>Constant CaptureEngineAllEffectsRemoved.</summary>
        /// <unmanaged>MF_E_CAPTURE_ENGINE_ALL_EFFECTS_REMOVED</unmanaged>
        public static readonly SharpDX.ResultDescriptor CaptureEngineAllEffectsRemoved = new SharpDX.ResultDescriptor(unchecked((int)3222121445UL), "SharpDX.MediaFoundation", "MF_E_CAPTURE_ENGINE_ALL_EFFECTS_REMOVED", "CaptureEngineAllEffectsRemoved");

        /// <summary>Constant CaptureSourceNoIndependentPhotoStreamPresent.</summary>
        /// <unmanaged>MF_E_CAPTURE_SOURCE_NO_INDEPENDENT_PHOTO_STREAM_PRESENT</unmanaged>
        public static readonly SharpDX.ResultDescriptor CaptureSourceNoIndependentPhotoStreamPresent = new SharpDX.ResultDescriptor(unchecked((int)3222121446UL), "SharpDX.MediaFoundation", "MF_E_CAPTURE_SOURCE_NO_INDEPENDENT_PHOTO_STREAM_PRESENT", "CaptureSourceNoIndependentPhotoStreamPresent");

        /// <summary>Constant CaptureSourceNoVideoStreamPresent.</summary>
        /// <unmanaged>MF_E_CAPTURE_SOURCE_NO_VIDEO_STREAM_PRESENT</unmanaged>
        public static readonly SharpDX.ResultDescriptor CaptureSourceNoVideoStreamPresent = new SharpDX.ResultDescriptor(unchecked((int)3222121447UL), "SharpDX.MediaFoundation", "MF_E_CAPTURE_SOURCE_NO_VIDEO_STREAM_PRESENT", "CaptureSourceNoVideoStreamPresent");

        /// <summary>Constant CaptureSourceNoAudioStreamPresent.</summary>
        /// <unmanaged>MF_E_CAPTURE_SOURCE_NO_AUDIO_STREAM_PRESENT</unmanaged>
        public static readonly SharpDX.ResultDescriptor CaptureSourceNoAudioStreamPresent = new SharpDX.ResultDescriptor(unchecked((int)3222121448UL), "SharpDX.MediaFoundation", "MF_E_CAPTURE_SOURCE_NO_AUDIO_STREAM_PRESENT", "CaptureSourceNoAudioStreamPresent");

        /// <summary>Constant CaptureSourceDeviceExtendedpropOperationInProgress.</summary>
        /// <unmanaged>MF_E_CAPTURE_SOURCE_DEVICE_EXTENDEDPROP_OP_IN_PROGRESS</unmanaged>
        public static readonly SharpDX.ResultDescriptor CaptureSourceDeviceExtendedpropOperationInProgress = new SharpDX.ResultDescriptor(unchecked((int)3222121449UL), "SharpDX.MediaFoundation", "MF_E_CAPTURE_SOURCE_DEVICE_EXTENDEDPROP_OP_IN_PROGRESS", "CaptureSourceDeviceExtendedpropOperationInProgress");

        /// <summary>Constant CapturePropertySetDuringPhoto.</summary>
        /// <unmanaged>MF_E_CAPTURE_PROPERTY_SET_DURING_PHOTO</unmanaged>
        public static readonly SharpDX.ResultDescriptor CapturePropertySetDuringPhoto = new SharpDX.ResultDescriptor(unchecked((int)3222121450UL), "SharpDX.MediaFoundation", "MF_E_CAPTURE_PROPERTY_SET_DURING_PHOTO", "CapturePropertySetDuringPhoto");

        /// <summary>Constant CaptureNoSamplesInQueue.</summary>
        /// <unmanaged>MF_E_CAPTURE_NO_SAMPLES_IN_QUEUE</unmanaged>
        public static readonly SharpDX.ResultDescriptor CaptureNoSamplesInQueue = new SharpDX.ResultDescriptor(unchecked((int)3222121451UL), "SharpDX.MediaFoundation", "MF_E_CAPTURE_NO_SAMPLES_IN_QUEUE", "CaptureNoSamplesInQueue");

        /// <summary>Constant HwAcceleratedThumbnailNotSupported.</summary>
        /// <unmanaged>MF_E_HW_ACCELERATED_THUMBNAIL_NOT_SUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor HwAcceleratedThumbnailNotSupported = new SharpDX.ResultDescriptor(unchecked((int)3222121452UL), "SharpDX.MediaFoundation", "MF_E_HW_ACCELERATED_THUMBNAIL_NOT_SUPPORTED", "HwAcceleratedThumbnailNotSupported");

        /// <summary>Constant UnsupportedCaptureDevicePresent.</summary>
        /// <unmanaged>MF_E_UNSUPPORTED_CAPTURE_DEVICE_PRESENT</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedCaptureDevicePresent = new SharpDX.ResultDescriptor(unchecked((int)3222121453UL), "SharpDX.MediaFoundation", "MF_E_UNSUPPORTED_CAPTURE_DEVICE_PRESENT", "UnsupportedCaptureDevicePresent");

        /// <summary>Constant TimelinecontrollerUnsupportedSourceType.</summary>
        /// <unmanaged>MF_E_TIMELINECONTROLLER_UNSUPPORTED_SOURCE_TYPE</unmanaged>
        public static readonly SharpDX.ResultDescriptor TimelinecontrollerUnsupportedSourceType = new SharpDX.ResultDescriptor(unchecked((int)3222122440UL), "SharpDX.MediaFoundation", "MF_E_TIMELINECONTROLLER_UNSUPPORTED_SOURCE_TYPE", "TimelinecontrollerUnsupportedSourceType");

        /// <summary>Constant TimelinecontrollerNotAllowEd.</summary>
        /// <unmanaged>MF_E_TIMELINECONTROLLER_NOT_ALLOWED</unmanaged>
        public static readonly SharpDX.ResultDescriptor TimelinecontrollerNotAllowEd = new SharpDX.ResultDescriptor(unchecked((int)3222122441UL), "SharpDX.MediaFoundation", "MF_E_TIMELINECONTROLLER_NOT_ALLOWED", "TimelinecontrollerNotAllowEd");

        /// <summary>Constant TimelinecontrollerCannotAttach.</summary>
        /// <unmanaged>MF_E_TIMELINECONTROLLER_CANNOT_ATTACH</unmanaged>
        public static readonly SharpDX.ResultDescriptor TimelinecontrollerCannotAttach = new SharpDX.ResultDescriptor(unchecked((int)3222122442UL), "SharpDX.MediaFoundation", "MF_E_TIMELINECONTROLLER_CANNOT_ATTACH", "TimelinecontrollerCannotAttach");

        /// <summary>Constant MediaExtensionAppserviceConnectionFailed.</summary>
        /// <unmanaged>MF_E_MEDIA_EXTENSION_APPSERVICE_CONNECTION_FAILED</unmanaged>
        public static readonly SharpDX.ResultDescriptor MediaExtensionAppserviceConnectionFailed = new SharpDX.ResultDescriptor(unchecked((int)3222123440UL), "SharpDX.MediaFoundation", "MF_E_MEDIA_EXTENSION_APPSERVICE_CONNECTION_FAILED", "MediaExtensionAppserviceConnectionFailed");

        /// <summary>Constant MediaExtensionAppserviceRequestFailed.</summary>
        /// <unmanaged>MF_E_MEDIA_EXTENSION_APPSERVICE_REQUEST_FAILED</unmanaged>
        public static readonly SharpDX.ResultDescriptor MediaExtensionAppserviceRequestFailed = new SharpDX.ResultDescriptor(unchecked((int)3222123441UL), "SharpDX.MediaFoundation", "MF_E_MEDIA_EXTENSION_APPSERVICE_REQUEST_FAILED", "MediaExtensionAppserviceRequestFailed");

        /// <summary>Constant MediaExtensionPackageIntegrityCheckFailed.</summary>
        /// <unmanaged>MF_E_MEDIA_EXTENSION_PACKAGE_INTEGRITY_CHECK_FAILED</unmanaged>
        public static readonly SharpDX.ResultDescriptor MediaExtensionPackageIntegrityCheckFailed = new SharpDX.ResultDescriptor(unchecked((int)3222123442UL), "SharpDX.MediaFoundation", "MF_E_MEDIA_EXTENSION_PACKAGE_INTEGRITY_CHECK_FAILED", "MediaExtensionPackageIntegrityCheckFailed");

        /// <summary>Constant MediaExtensionPackageLicenseInvalid.</summary>
        /// <unmanaged>MF_E_MEDIA_EXTENSION_PACKAGE_LICENSE_INVALID</unmanaged>
        public static readonly SharpDX.ResultDescriptor MediaExtensionPackageLicenseInvalid = new SharpDX.ResultDescriptor(unchecked((int)3222123443UL), "SharpDX.MediaFoundation", "MF_E_MEDIA_EXTENSION_PACKAGE_LICENSE_INVALID", "MediaExtensionPackageLicenseInvalid");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.SampleAttributeKeys']/*"/>	
    public static partial class SampleAttributeKeys
    {

        /// <summary>Constant Video3D.</summary>
        /// <unmanaged>MFSampleExtension_3DVideo</unmanaged>
        public static readonly MediaAttributeKey<bool> Video3D = new MediaAttributeKey<bool>("f86f97a4-dd54-4e2e-9a5e-55fc2d74a005", "Video3D");

        /// <summary>Constant Video3DSampleFormat.</summary>
        /// <unmanaged>MFSampleExtension_3DVideo_SampleFormat</unmanaged>
        public static readonly MediaAttributeKey<int> Video3DSampleFormat = new MediaAttributeKey<int>("08671772-e36f-4cff-97b3-d72e20987a48", "Video3DSampleFormat");

        /// <summary>Constant BottomFieldFirst.</summary>
        /// <unmanaged>MFSampleExtension_BottomFieldFirst</unmanaged>
        public static readonly MediaAttributeKey<bool> BottomFieldFirst = new MediaAttributeKey<bool>("941ce0a3-6ae3-4dda-9a08-a64298340617", "BottomFieldFirst");

        /// <summary>Constant CleanPoint.</summary>
        /// <unmanaged>MFSampleExtension_CleanPoint</unmanaged>
        public static readonly MediaAttributeKey<bool> CleanPoint = new MediaAttributeKey<bool>("9cdf01d8-a0f0-43ba-b077-eaa06cbd728a", "CleanPoint");

        /// <summary>Constant DecodeTimestamp.</summary>
        /// <unmanaged>MFSampleExtension_DecodeTimestamp</unmanaged>
        public static readonly MediaAttributeKey<long> DecodeTimestamp = new MediaAttributeKey<long>("73a954d4-09e2-4861-befc-94bd97c08e6e", "DecodeTimestamp");

        /// <summary>Constant DerivedFromTopField.</summary>
        /// <unmanaged>MFSampleExtension_DerivedFromTopField</unmanaged>
        public static readonly MediaAttributeKey<bool> DerivedFromTopField = new MediaAttributeKey<bool>("6852465a-ae1c-4553-8e9b-c3420fcb1637", "DerivedFromTopField");

        /// <summary>Constant DeviceTimestamp.</summary>
        /// <unmanaged>MFSampleExtension_DeviceTimestamp</unmanaged>
        public static readonly MediaAttributeKey<long> DeviceTimestamp = new MediaAttributeKey<long>("8f3e35e7-2dcd-4887-8622-2a58baa652b0", "DeviceTimestamp");

        /// <summary>Constant Discontinuity.</summary>
        /// <unmanaged>MFSampleExtension_Discontinuity</unmanaged>
        public static readonly MediaAttributeKey<bool> Discontinuity = new MediaAttributeKey<bool>("9cdf01d9-a0f0-43ba-b077-eaa06cbd728a", "Discontinuity");

        /// <summary>Constant FrameCorruption.</summary>
        /// <unmanaged>MFSampleExtension_FrameCorruption</unmanaged>
        public static readonly MediaAttributeKey<int> FrameCorruption = new MediaAttributeKey<int>("b4dd4a8c-0beb-44c4-8b75-b02b913b04f0", "FrameCorruption");

        /// <summary>Constant Interlaced.</summary>
        /// <unmanaged>MFSampleExtension_Interlaced</unmanaged>
        public static readonly MediaAttributeKey<bool> Interlaced = new MediaAttributeKey<bool>("b1d5830a-deb8-40e3-90fa-389943716461", "Interlaced");

        /// <summary>Constant PacketCrossOffsets.</summary>
        /// <unmanaged>MFSampleExtension_PacketCrossOffsets</unmanaged>
        public static readonly MediaAttributeKey<byte[]> PacketCrossOffsets = new MediaAttributeKey<byte[]>("2789671d-389f-40bb-90d9-c282f77f9abd", "PacketCrossOffsets");

        /// <summary>Constant RepeatFirstField.</summary>
        /// <unmanaged>MFSampleExtension_RepeatFirstField</unmanaged>
        public static readonly MediaAttributeKey<bool> RepeatFirstField = new MediaAttributeKey<bool>("304d257c-7493-4fbd-b149-9228de8d9a99", "RepeatFirstField");

        /// <summary>Constant SingleField.</summary>
        /// <unmanaged>MFSampleExtension_SingleField</unmanaged>
        public static readonly MediaAttributeKey<bool> SingleField = new MediaAttributeKey<bool>("9d85f816-658b-455a-bde0-9fa7e15ab8f9", "SingleField");

        /// <summary>Constant Token.</summary>
        /// <unmanaged>MFSampleExtension_Token</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> Token = new MediaAttributeKey<SharpDX.ComObject>("8294da66-f328-4805-b551-00deb4c57a61", "Token");

        /// <summary>Constant VideoEncodePictureType.</summary>
        /// <unmanaged>MFSampleExtension_VideoEncodePictureType</unmanaged>
        public static readonly MediaAttributeKey<int> VideoEncodePictureType = new MediaAttributeKey<int>("973704e6-cd14-483c-8f20-c9fc0928bad5", "VideoEncodePictureType");

        /// <summary>Constant VideoEncodeQP.</summary>
        /// <unmanaged>MFSampleExtension_VideoEncodeQP</unmanaged>
        public static readonly MediaAttributeKey<long> VideoEncodeQP = new MediaAttributeKey<long>("b2efe478-f979-4c66-b95e-ee2b82c82f36", "VideoEncodeQP");

        /// <summary>Constant DescrambleData.</summary>
        /// <unmanaged>MFSampleExtension_DescrambleData</unmanaged>
        public static readonly MediaAttributeKey<long> DescrambleData = new MediaAttributeKey<long>("43483be6-4903-4314-b032-2951365936fc", "DescrambleData");

        /// <summary>Constant SampleKeyID.</summary>
        /// <unmanaged>MFSampleExtension_SampleKeyID</unmanaged>
        public static readonly MediaAttributeKey<int> SampleKeyID = new MediaAttributeKey<int>("9ed713c8-9b87-4b26-8297-a93b0c5a8acc", "SampleKeyID");

        /// <summary>Constant GenKeyFunc.</summary>
        /// <unmanaged>MFSampleExtension_GenKeyFunc</unmanaged>
        public static readonly MediaAttributeKey<long> GenKeyFunc = new MediaAttributeKey<long>("441ca1ee-6b1f-4501-903a-de87df42f6ed", "GenKeyFunc");

        /// <summary>Constant GenKeyCtx.</summary>
        /// <unmanaged>MFSampleExtension_GenKeyCtx</unmanaged>
        public static readonly MediaAttributeKey<long> GenKeyCtx = new MediaAttributeKey<long>("188120cb-d7da-4b59-9b3e-9252fd37301c", "GenKeyCtx");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.SampleGrabberSinkAttributeKeys']/*"/>	
    public static partial class SampleGrabberSinkAttributeKeys
    {

        /// <summary>Constant IgnoreClock.</summary>
        /// <unmanaged>MF_SAMPLEGRABBERSINK_IGNORE_CLOCK</unmanaged>
        public static readonly MediaAttributeKey<int> IgnoreClock = new MediaAttributeKey<int>("0efda2c0-2b69-4e2e-ab8d-46dcbff7d25d", "IgnoreClock");

        /// <summary>Constant SampleTimeOffset.</summary>
        /// <unmanaged>MF_SAMPLEGRABBERSINK_SAMPLE_TIME_OFFSET</unmanaged>
        public static readonly MediaAttributeKey<long> SampleTimeOffset = new MediaAttributeKey<long>("62e3d776-8100-4e03-a6e8-bd3857ac9c47", "SampleTimeOffset");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.SinkWriterAttributeKeys']/*"/>	
    public static partial class SinkWriterAttributeKeys
    {

        /// <summary>Constant LowLatency.</summary>
        /// <unmanaged>MF_LOW_LATENCY</unmanaged>
        public static readonly MediaAttributeKey<bool> LowLatency = new MediaAttributeKey<bool>("9c27891a-ed7a-40e1-88e8-b22727a024ee", "LowLatency");

        /// <summary>Constant ReadwriteD3DOptional.</summary>
        /// <unmanaged>MF_READWRITE_D3D_OPTIONAL</unmanaged>
        public static readonly MediaAttributeKey<bool> ReadwriteD3DOptional = new MediaAttributeKey<bool>("216479d9-3071-42ca-bb6c-4c22102e1d18", "ReadwriteD3DOptional");

        /// <summary>Constant ReadwriteDisableConverters.</summary>
        /// <unmanaged>MF_READWRITE_DISABLE_CONVERTERS</unmanaged>
        public static readonly MediaAttributeKey<int> ReadwriteDisableConverters = new MediaAttributeKey<int>("98d5b065-1374-4847-8d5d-31520fee7156", "ReadwriteDisableConverters");

        /// <summary>Constant ReadwriteEnableHardwareTransforms.</summary>
        /// <unmanaged>MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS</unmanaged>
        public static readonly MediaAttributeKey<int> ReadwriteEnableHardwareTransforms = new MediaAttributeKey<int>("a634a91c-822b-41b9-a494-4de4643612b0", "ReadwriteEnableHardwareTransforms");

        /// <summary>Constant ReadwriteMmcssClass.</summary>
        /// <unmanaged>MF_READWRITE_MMCSS_CLASS</unmanaged>
        public static readonly MediaAttributeKey<string> ReadwriteMmcssClass = new MediaAttributeKey<string>("39384300-d0eb-40b1-87a0-3318871b5a53", "ReadwriteMmcssClass");

        /// <summary>Constant ReadwriteMmcssClassAudio.</summary>
        /// <unmanaged>MF_READWRITE_MMCSS_CLASS_AUDIO</unmanaged>
        public static readonly MediaAttributeKey<string> ReadwriteMmcssClassAudio = new MediaAttributeKey<string>("430847da-0890-4b0e-938c-054332c547e1", "ReadwriteMmcssClassAudio");

        /// <summary>Constant ReadwriteMmcssPriority.</summary>
        /// <unmanaged>MF_READWRITE_MMCSS_PRIORITY</unmanaged>
        public static readonly MediaAttributeKey<int> ReadwriteMmcssPriority = new MediaAttributeKey<int>("43ad19ce-f33f-4ba9-a580-e4cd12f2d144", "ReadwriteMmcssPriority");

        /// <summary>Constant ReadwriteMmcssPriorityAudio.</summary>
        /// <unmanaged>MF_READWRITE_MMCSS_PRIORITY_AUDIO</unmanaged>
        public static readonly MediaAttributeKey<int> ReadwriteMmcssPriorityAudio = new MediaAttributeKey<int>("273db885-2de2-4db2-a6a7-fdb66fb40b61", "ReadwriteMmcssPriorityAudio");

        /// <summary>Constant AsyncCallback.</summary>
        /// <unmanaged>MF_SINK_WRITER_ASYNC_CALLBACK</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> AsyncCallback = new MediaAttributeKey<SharpDX.ComObject>("48cb183e-7b0b-46f4-822e-5e1d2dda4354", "AsyncCallback");

        /// <summary>Constant D3DManager.</summary>
        /// <unmanaged>MF_SINK_WRITER_D3D_MANAGER</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> D3DManager = new MediaAttributeKey<SharpDX.ComObject>("ec822da2-e1e9-4b29-a0d8-563c719f5269", "D3DManager");

        /// <summary>Constant DisableThrottling.</summary>
        /// <unmanaged>MF_SINK_WRITER_DISABLE_THROTTLING</unmanaged>
        public static readonly MediaAttributeKey<int> DisableThrottling = new MediaAttributeKey<int>("08b845d8-2b74-4afe-9d53-be16d2d5ae4f", "DisableThrottling");

        /// <summary>Constant EncoderConfig.</summary>
        /// <unmanaged>MF_SINK_WRITER_ENCODER_CONFIG</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> EncoderConfig = new MediaAttributeKey<SharpDX.ComObject>("ad91cd04-a7cc-4ac7-99b6-a57b9a4a7c70", "EncoderConfig");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.SourceReaderAttributeKeys']/*"/>	
    public static partial class SourceReaderAttributeKeys
    {

        /// <summary>Constant AsyncCallback.</summary>
        /// <unmanaged>MF_SOURCE_READER_ASYNC_CALLBACK</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> AsyncCallback = new MediaAttributeKey<SharpDX.ComObject>("1e3dbeac-bb43-4c35-b507-cd644464c965", "AsyncCallback");

        /// <summary>Constant D3DManager.</summary>
        /// <unmanaged>MF_SOURCE_READER_D3D_MANAGER</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> D3DManager = new MediaAttributeKey<SharpDX.ComObject>("ec822da2-e1e9-4b29-a0d8-563c719f5269", "D3DManager");

        /// <summary>Constant DisableCameraPlugins.</summary>
        /// <unmanaged>MF_SOURCE_READER_DISABLE_CAMERA_PLUGINS</unmanaged>
        public static readonly MediaAttributeKey<bool> DisableCameraPlugins = new MediaAttributeKey<bool>("9d3365dd-058f-4cfb-9f97-b314cc99c8ad", "DisableCameraPlugins");

        /// <summary>Constant DisableDxva.</summary>
        /// <unmanaged>MF_SOURCE_READER_DISABLE_DXVA</unmanaged>
        public static readonly MediaAttributeKey<int> DisableDxva = new MediaAttributeKey<int>("aa456cfd-3943-4a1e-a77d-1838c0ea2e35", "DisableDxva");

        /// <summary>Constant DisconnectMediasourceOnShutdown.</summary>
        /// <unmanaged>MF_SOURCE_READER_DISCONNECT_MEDIASOURCE_ON_SHUTDOWN</unmanaged>
        public static readonly MediaAttributeKey<int> DisconnectMediasourceOnShutdown = new MediaAttributeKey<int>("56b67165-219e-456d-a22e-2d3004c7fe56", "DisconnectMediasourceOnShutdown");

        /// <summary>Constant EnableAdvancedVideoProcessing.</summary>
        /// <unmanaged>MF_SOURCE_READER_ENABLE_ADVANCED_VIDEO_PROCESSING</unmanaged>
        public static readonly MediaAttributeKey<bool> EnableAdvancedVideoProcessing = new MediaAttributeKey<bool>("0f81da2c-b537-4672-a8b2-a681b17307a3", "EnableAdvancedVideoProcessing");

        /// <summary>Constant EnableTranscodeOnlyTransforms.</summary>
        /// <unmanaged>MF_SOURCE_READER_ENABLE_TRANSCODE_ONLY_TRANSFORMS</unmanaged>
        public static readonly MediaAttributeKey<bool> EnableTranscodeOnlyTransforms = new MediaAttributeKey<bool>("dfd4f008-b5fd-4e78-ae44-62a1e67bbe27", "EnableTranscodeOnlyTransforms");

        /// <summary>Constant EnableVideoProcessing.</summary>
        /// <unmanaged>MF_SOURCE_READER_ENABLE_VIDEO_PROCESSING</unmanaged>
        public static readonly MediaAttributeKey<int> EnableVideoProcessing = new MediaAttributeKey<int>("fb394f3d-ccf1-42ee-bbb3-f9b845d5681d", "EnableVideoProcessing");

        /// <summary>Constant MediaSourceCharacteristics.</summary>
        /// <unmanaged>MF_SOURCE_READER_MEDIASOURCE_CHARACTERISTICS</unmanaged>
        public static readonly MediaAttributeKey<int> MediaSourceCharacteristics = new MediaAttributeKey<int>("6d23f5c8-c5d7-4a9b-9971-5d11f8bca880", "MediaSourceCharacteristics");

        /// <summary>Constant MediaSourceConfig.</summary>
        /// <unmanaged>MF_SOURCE_READER_MEDIASOURCE_CONFIG</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> MediaSourceConfig = new MediaAttributeKey<SharpDX.ComObject>("9085abeb-0354-48f9-abb5-200df838c68e", "MediaSourceConfig");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.StreamDescriptorAttributeKeys']/*"/>	
    public static partial class StreamDescriptorAttributeKeys
    {

        /// <summary>Constant AsfExtstrmpropAvgBuffersize.</summary>
        /// <unmanaged>MF_SD_ASF_EXTSTRMPROP_AVG_BUFFERSIZE</unmanaged>
        public static readonly MediaAttributeKey<int> AsfExtstrmpropAvgBuffersize = new MediaAttributeKey<int>("48f8a524-305d-422d-8524-2502dda33680", "AsfExtstrmpropAvgBuffersize");

        /// <summary>Constant AsfExtstrmpropAvgDataBitrate.</summary>
        /// <unmanaged>MF_SD_ASF_EXTSTRMPROP_AVG_DATA_BITRATE</unmanaged>
        public static readonly MediaAttributeKey<int> AsfExtstrmpropAvgDataBitrate = new MediaAttributeKey<int>("48f8a523-305d-422d-8524-2502dda33680", "AsfExtstrmpropAvgDataBitrate");

        /// <summary>Constant AsfExtstrmpropLanguageIdIndex.</summary>
        /// <unmanaged>MF_SD_ASF_EXTSTRMPROP_LANGUAGE_ID_INDEX</unmanaged>
        public static readonly MediaAttributeKey<int> AsfExtstrmpropLanguageIdIndex = new MediaAttributeKey<int>("48f8a522-305d-422d-8524-2502dda33680", "AsfExtstrmpropLanguageIdIndex");

        /// <summary>Constant AsfExtstrmpropMaxBuffersize.</summary>
        /// <unmanaged>MF_SD_ASF_EXTSTRMPROP_MAX_BUFFERSIZE</unmanaged>
        public static readonly MediaAttributeKey<int> AsfExtstrmpropMaxBuffersize = new MediaAttributeKey<int>("48f8a526-305d-422d-8524-2502dda33680", "AsfExtstrmpropMaxBuffersize");

        /// <summary>Constant AsfExtstrmpropMaxDataBitrate.</summary>
        /// <unmanaged>MF_SD_ASF_EXTSTRMPROP_MAX_DATA_BITRATE</unmanaged>
        public static readonly MediaAttributeKey<int> AsfExtstrmpropMaxDataBitrate = new MediaAttributeKey<int>("48f8a525-305d-422d-8524-2502dda33680", "AsfExtstrmpropMaxDataBitrate");

        /// <summary>Constant AsfMetadataDeviceConformanceTemplate.</summary>
        /// <unmanaged>MF_SD_ASF_METADATA_DEVICE_CONFORMANCE_TEMPLATE</unmanaged>
        public static readonly MediaAttributeKey<string> AsfMetadataDeviceConformanceTemplate = new MediaAttributeKey<string>("245e929d-c44e-4f7e-bb3c-77d4dfd27f8a", "AsfMetadataDeviceConformanceTemplate");

        /// <summary>Constant AsfStreambitratesBitrate.</summary>
        /// <unmanaged>MF_SD_ASF_STREAMBITRATES_BITRATE</unmanaged>
        public static readonly MediaAttributeKey<int> AsfStreambitratesBitrate = new MediaAttributeKey<int>("a8e182ed-afc8-43d0-b0d1-f65bad9da558", "AsfStreambitratesBitrate");

        /// <summary>Constant Language.</summary>
        /// <unmanaged>MF_SD_LANGUAGE</unmanaged>
        public static readonly MediaAttributeKey<string> Language = new MediaAttributeKey<string>("00af2180-bdc2-423c-abca-f503593bc121", "Language");

        /// <summary>Constant MutuallyExclusive.</summary>
        /// <unmanaged>MF_SD_MUTUALLY_EXCLUSIVE</unmanaged>
        public static readonly MediaAttributeKey<int> MutuallyExclusive = new MediaAttributeKey<int>("023ef79c-388d-487f-ac17-696cd6e3c6f5", "MutuallyExclusive");

        /// <summary>Constant Protected.</summary>
        /// <unmanaged>MF_SD_PROTECTED</unmanaged>
        public static readonly MediaAttributeKey<bool> Protected = new MediaAttributeKey<bool>("00af2181-bdc2-423c-abca-f503593bc121", "Protected");

        /// <summary>Constant SamiLanguage.</summary>
        /// <unmanaged>MF_SD_SAMI_LANGUAGE</unmanaged>
        public static readonly MediaAttributeKey<string> SamiLanguage = new MediaAttributeKey<string>("36fcb98a-6cd0-44cb-acb9-a8f5600dd0bb", "SamiLanguage");

        /// <summary>Constant StreamName.</summary>
        /// <unmanaged>MF_SD_STREAM_NAME</unmanaged>
        public static readonly MediaAttributeKey<string> StreamName = new MediaAttributeKey<string>("4f1b099d-d314-41e5-a781-7fefaa4c501f", "StreamName");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.TopologyAttributeKeys']/*"/>	
    public static partial class TopologyAttributeKeys
    {

        /// <summary>Constant DXVAMode.</summary>
        /// <unmanaged>MF_TOPOLOGY_DXVA_MODE</unmanaged>
        public static readonly MediaAttributeKey<int> DXVAMode = new MediaAttributeKey<int>("1e8d34f6-f5ab-4e23-bb88-874aa3a1a74d", "DXVAMode");

        /// <summary>Constant DynamicChangeNotAllowed.</summary>
        /// <unmanaged>MF_TOPOLOGY_DYNAMIC_CHANGE_NOT_ALLOWED</unmanaged>
        public static readonly MediaAttributeKey<int> DynamicChangeNotAllowed = new MediaAttributeKey<int>("d529950b-d484-4527-a9cd-b1909532b5b0", "DynamicChangeNotAllowed");

        /// <summary>Constant EnumerateSourceTypes.</summary>
        /// <unmanaged>MF_TOPOLOGY_ENUMERATE_SOURCE_TYPES</unmanaged>
        public static readonly MediaAttributeKey<int> EnumerateSourceTypes = new MediaAttributeKey<int>("6248c36d-5d0b-4f40-a0bb-b0b305f77698", "EnumerateSourceTypes");

        /// <summary>Constant HardwareMode.</summary>
        /// <unmanaged>MF_TOPOLOGY_HARDWARE_MODE</unmanaged>
        public static readonly MediaAttributeKey<int> HardwareMode = new MediaAttributeKey<int>("d2d362fd-4e4f-4191-a579-c618b66706af", "HardwareMode");

        /// <summary>Constant NoMarkinMarkout.</summary>
        /// <unmanaged>MF_TOPOLOGY_NO_MARKIN_MARKOUT</unmanaged>
        public static readonly MediaAttributeKey<bool> NoMarkinMarkout = new MediaAttributeKey<bool>("7ed3f804-86bb-4b3f-b7e4-7cb43afd4b80", "NoMarkinMarkout");

        /// <summary>Constant PlaybackFramerate.</summary>
        /// <unmanaged>MF_TOPOLOGY_PLAYBACK_FRAMERATE</unmanaged>
        public static readonly MediaAttributeKey<long> PlaybackFramerate = new MediaAttributeKey<long>("c164737a-c2b1-4553-83bb-5a526072448f", "PlaybackFramerate");

        /// <summary>Constant PlaybackMaxDimensions.</summary>
        /// <unmanaged>MF_TOPOLOGY_PLAYBACK_MAX_DIMS</unmanaged>
        public static readonly MediaAttributeKey<long> PlaybackMaxDimensions = new MediaAttributeKey<long>("5715cf19-5768-44aa-ad6e-8721f1b0f9bb", "PlaybackMaxDimensions");

        /// <summary>Constant ProjectStart.</summary>
        /// <unmanaged>MF_TOPOLOGY_PROJECTSTART</unmanaged>
        public static readonly MediaAttributeKey<long> ProjectStart = new MediaAttributeKey<long>("7ed3f802-86bb-4b3f-b7e4-7cb43afd4b80", "ProjectStart");

        /// <summary>Constant ProjectStop.</summary>
        /// <unmanaged>MF_TOPOLOGY_PROJECTSTOP</unmanaged>
        public static readonly MediaAttributeKey<long> ProjectStop = new MediaAttributeKey<long>("7ed3f803-86bb-4b3f-b7e4-7cb43afd4b80", "ProjectStop");

        /// <summary>Constant ResolutionStatus.</summary>
        /// <unmanaged>MF_TOPOLOGY_RESOLUTION_STATUS</unmanaged>
        public static readonly MediaAttributeKey<int> ResolutionStatus = new MediaAttributeKey<int>("494bbcde-b031-4e38-97c4-d5422dd618dc", "ResolutionStatus");

        /// <summary>Constant StartTimeOnPresentationSwitch.</summary>
        /// <unmanaged>MF_TOPOLOGY_START_TIME_ON_PRESENTATION_SWITCH</unmanaged>
        public static readonly MediaAttributeKey<long> StartTimeOnPresentationSwitch = new MediaAttributeKey<long>("c8cc113f-7951-4548-aad6-9ed6202e62b3", "StartTimeOnPresentationSwitch");

        /// <summary>Constant StaticPlaybackOptimizations.</summary>
        /// <unmanaged>MF_TOPOLOGY_STATIC_PLAYBACK_OPTIMIZATIONS</unmanaged>
        public static readonly MediaAttributeKey<int> StaticPlaybackOptimizations = new MediaAttributeKey<int>("b86cac42-41a6-4b79-897a-1ab0e52b4a1b", "StaticPlaybackOptimizations");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.TopologyNodeAttributeKeys']/*"/>	
    public static partial class TopologyNodeAttributeKeys
    {

        /// <summary>Constant ConnectMethod.</summary>
        /// <unmanaged>MF_TOPONODE_CONNECT_METHOD</unmanaged>
        public static readonly MediaAttributeKey<int> ConnectMethod = new MediaAttributeKey<int>("494bbcf1-b031-4e38-97c4-d5422dd618dc", "ConnectMethod");

        /// <summary>Constant D3DAWARE.</summary>
        /// <unmanaged>MF_TOPONODE_D3DAWARE</unmanaged>
        public static readonly MediaAttributeKey<bool> D3DAWARE = new MediaAttributeKey<bool>("494bbced-b031-4e38-97c4-d5422dd618dc", "D3DAWARE");

        /// <summary>Constant Decoder.</summary>
        /// <unmanaged>MF_TOPONODE_DECODER</unmanaged>
        public static readonly MediaAttributeKey<bool> Decoder = new MediaAttributeKey<bool>("494bbd02-b031-4e38-97c4-d5422dd618dc", "Decoder");

        /// <summary>Constant Decryptor.</summary>
        /// <unmanaged>MF_TOPONODE_DECRYPTOR</unmanaged>
        public static readonly MediaAttributeKey<bool> Decryptor = new MediaAttributeKey<bool>("494bbcfa-b031-4e38-97c4-d5422dd618dc", "Decryptor");

        /// <summary>Constant DisablePreroll.</summary>
        /// <unmanaged>MF_TOPONODE_DISABLE_PREROLL</unmanaged>
        public static readonly MediaAttributeKey<bool> DisablePreroll = new MediaAttributeKey<bool>("14932f9e-9087-4bb4-8412-5167145cbe04", "DisablePreroll");

        /// <summary>Constant Discardable.</summary>
        /// <unmanaged>MF_TOPONODE_DISCARDABLE</unmanaged>
        public static readonly MediaAttributeKey<byte[]> Discardable = new MediaAttributeKey<byte[]>("494bbcfb-b031-4e38-97c4-d5422dd618dc", "Discardable");

        /// <summary>Constant Drain.</summary>
        /// <unmanaged>MF_TOPONODE_DRAIN</unmanaged>
        public static readonly MediaAttributeKey<int> Drain = new MediaAttributeKey<int>("494bbce9-b031-4e38-97c4-d5422dd618dc", "Drain");

        /// <summary>Constant ErrorMajortype.</summary>
        /// <unmanaged>MF_TOPONODE_ERROR_MAJORTYPE</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> ErrorMajortype = new MediaAttributeKey<System.Guid>("494bbcfd-b031-4e38-97c4-d5422dd618dc", "ErrorMajortype");

        /// <summary>Constant ErrorSubtype.</summary>
        /// <unmanaged>MF_TOPONODE_ERROR_SUBTYPE</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> ErrorSubtype = new MediaAttributeKey<System.Guid>("494bbcfe-b031-4e38-97c4-d5422dd618dc", "ErrorSubtype");

        /// <summary>Constant Errorcode.</summary>
        /// <unmanaged>MF_TOPONODE_ERRORCODE</unmanaged>
        public static readonly MediaAttributeKey<int> Errorcode = new MediaAttributeKey<int>("494bbcee-b031-4e38-97c4-d5422dd618dc", "Errorcode");

        /// <summary>Constant Flush.</summary>
        /// <unmanaged>MF_TOPONODE_FLUSH</unmanaged>
        public static readonly MediaAttributeKey<int> Flush = new MediaAttributeKey<int>("494bbce8-b031-4e38-97c4-d5422dd618dc", "Flush");

        /// <summary>Constant Locked.</summary>
        /// <unmanaged>MF_TOPONODE_LOCKED</unmanaged>
        public static readonly MediaAttributeKey<bool> Locked = new MediaAttributeKey<bool>("494bbcf7-b031-4e38-97c4-d5422dd618dc", "Locked");

        /// <summary>Constant MarkinHere.</summary>
        /// <unmanaged>MF_TOPONODE_MARKIN_HERE</unmanaged>
        public static readonly MediaAttributeKey<bool> MarkinHere = new MediaAttributeKey<bool>("494bbd00-b031-4e38-97c4-d5422dd618dc", "MarkinHere");

        /// <summary>Constant MarkoutHere.</summary>
        /// <unmanaged>MF_TOPONODE_MARKOUT_HERE</unmanaged>
        public static readonly MediaAttributeKey<bool> MarkoutHere = new MediaAttributeKey<bool>("494bbd01-b031-4e38-97c4-d5422dd618dc", "MarkoutHere");

        /// <summary>Constant Mediastart.</summary>
        /// <unmanaged>MF_TOPONODE_MEDIASTART</unmanaged>
        public static readonly MediaAttributeKey<long> Mediastart = new MediaAttributeKey<long>("835c58ea-e075-4bc7-bcba-4de000df9ae6", "Mediastart");

        /// <summary>Constant Mediastop.</summary>
        /// <unmanaged>MF_TOPONODE_MEDIASTOP</unmanaged>
        public static readonly MediaAttributeKey<long> Mediastop = new MediaAttributeKey<long>("835c58eb-e075-4bc7-bcba-4de000df9ae6", "Mediastop");

        /// <summary>Constant NoshutdownOnRemove.</summary>
        /// <unmanaged>MF_TOPONODE_NOSHUTDOWN_ON_REMOVE</unmanaged>
        public static readonly MediaAttributeKey<bool> NoshutdownOnRemove = new MediaAttributeKey<bool>("14932f9c-9087-4bb4-8412-5167145cbe04", "NoshutdownOnRemove");

        /// <summary>Constant PresentationDescriptor.</summary>
        /// <unmanaged>MF_TOPONODE_PRESENTATION_DESCRIPTOR</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> PresentationDescriptor = new MediaAttributeKey<SharpDX.ComObject>("835c58ed-e075-4bc7-bcba-4de000df9ae6", "PresentationDescriptor");

        /// <summary>Constant Primaryoutput.</summary>
        /// <unmanaged>MF_TOPONODE_PRIMARYOUTPUT</unmanaged>
        public static readonly MediaAttributeKey<int> Primaryoutput = new MediaAttributeKey<int>("6304ef99-16b2-4ebe-9d67-e4c539b3a259", "Primaryoutput");

        /// <summary>Constant Rateless.</summary>
        /// <unmanaged>MF_TOPONODE_RATELESS</unmanaged>
        public static readonly MediaAttributeKey<bool> Rateless = new MediaAttributeKey<bool>("14932f9d-9087-4bb4-8412-5167145cbe04", "Rateless");

        /// <summary>Constant SequenceElementid.</summary>
        /// <unmanaged>MF_TOPONODE_SEQUENCE_ELEMENTID</unmanaged>
        public static readonly MediaAttributeKey<int> SequenceElementid = new MediaAttributeKey<int>("835c58ef-e075-4bc7-bcba-4de000df9ae6", "SequenceElementid");

        /// <summary>Constant Source.</summary>
        /// <unmanaged>MF_TOPONODE_SOURCE</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> Source = new MediaAttributeKey<SharpDX.ComObject>("835c58ec-e075-4bc7-bcba-4de000df9ae6", "Source");

        /// <summary>Constant StreamDescriptor.</summary>
        /// <unmanaged>MF_TOPONODE_STREAM_DESCRIPTOR</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> StreamDescriptor = new MediaAttributeKey<SharpDX.ComObject>("835c58ee-e075-4bc7-bcba-4de000df9ae6", "StreamDescriptor");

        /// <summary>Constant Streamid.</summary>
        /// <unmanaged>MF_TOPONODE_STREAMID</unmanaged>
        public static readonly MediaAttributeKey<int> Streamid = new MediaAttributeKey<int>("14932f9b-9087-4bb4-8412-5167145cbe04", "Streamid");

        /// <summary>Constant TransformObjectid.</summary>
        /// <unmanaged>MF_TOPONODE_TRANSFORM_OBJECTID</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> TransformObjectid = new MediaAttributeKey<System.Guid>("88dcc0c9-293e-4e8b-9aeb-0ad64cc016b0", "TransformObjectid");

        /// <summary>Constant WorkqueueId.</summary>
        /// <unmanaged>MF_TOPONODE_WORKQUEUE_ID</unmanaged>
        public static readonly MediaAttributeKey<int> WorkqueueId = new MediaAttributeKey<int>("494bbcf8-b031-4e38-97c4-d5422dd618dc", "WorkqueueId");

        /// <summary>Constant WorkqueueItemPriority.</summary>
        /// <unmanaged>MF_TOPONODE_WORKQUEUE_ITEM_PRIORITY</unmanaged>
        public static readonly MediaAttributeKey<int> WorkqueueItemPriority = new MediaAttributeKey<int>("a1ff99be-5e97-4a53-b494-568c642c0ff3", "WorkqueueItemPriority");

        /// <summary>Constant WorkqueueMmcssClass.</summary>
        /// <unmanaged>MF_TOPONODE_WORKQUEUE_MMCSS_CLASS</unmanaged>
        public static readonly MediaAttributeKey<string> WorkqueueMmcssClass = new MediaAttributeKey<string>("494bbcf9-b031-4e38-97c4-d5422dd618dc", "WorkqueueMmcssClass");

        /// <summary>Constant WorkqueueMmcssPriority.</summary>
        /// <unmanaged>MF_TOPONODE_WORKQUEUE_MMCSS_PRIORITY</unmanaged>
        public static readonly MediaAttributeKey<int> WorkqueueMmcssPriority = new MediaAttributeKey<int>("5001f840-2816-48f4-9364-ad1ef661a123", "WorkqueueMmcssPriority");

        /// <summary>Constant WorkqueueMmcssTaskid.</summary>
        /// <unmanaged>MF_TOPONODE_WORKQUEUE_MMCSS_TASKID</unmanaged>
        public static readonly MediaAttributeKey<int> WorkqueueMmcssTaskid = new MediaAttributeKey<int>("494bbcff-b031-4e38-97c4-d5422dd618dc", "WorkqueueMmcssTaskid");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.TranscodeAttributeKeys']/*"/>	
    public static partial class TranscodeAttributeKeys
    {

        /// <summary>Constant TranscodeAdjustProfile.</summary>
        /// <unmanaged>MF_TRANSCODE_ADJUST_PROFILE</unmanaged>
        public static readonly MediaAttributeKey<int> TranscodeAdjustProfile = new MediaAttributeKey<int>("9c37c21b-060f-487c-a690-80d7f50d1c72", "TranscodeAdjustProfile");

        /// <summary>Constant TranscodeContainertype.</summary>
        /// <unmanaged>MF_TRANSCODE_CONTAINERTYPE</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> TranscodeContainertype = new MediaAttributeKey<System.Guid>("150ff23f-4abc-478b-ac4f-e1916fba1cca", "TranscodeContainertype");

        /// <summary>Constant TranscodeDonotInsertEncoder.</summary>
        /// <unmanaged>MF_TRANSCODE_DONOT_INSERT_ENCODER</unmanaged>
        public static readonly MediaAttributeKey<int> TranscodeDonotInsertEncoder = new MediaAttributeKey<int>("f45aa7ce-ab24-4012-a11b-dc8220201410", "TranscodeDonotInsertEncoder");

        /// <summary>Constant TranscodeEncodingprofile.</summary>
        /// <unmanaged>MF_TRANSCODE_ENCODINGPROFILE</unmanaged>
        public static readonly MediaAttributeKey<string> TranscodeEncodingprofile = new MediaAttributeKey<string>("6947787c-f508-4ea9-b1e9-a1fe3a49fbc9", "TranscodeEncodingprofile");

        /// <summary>Constant TranscodeQualityvsspeed.</summary>
        /// <unmanaged>MF_TRANSCODE_QUALITYVSSPEED</unmanaged>
        public static readonly MediaAttributeKey<int> TranscodeQualityvsspeed = new MediaAttributeKey<int>("98332df8-03cd-476b-89fa-3f9e442dec9f", "TranscodeQualityvsspeed");

        /// <summary>Constant TranscodeSkipMetadataTransfer.</summary>
        /// <unmanaged>MF_TRANSCODE_SKIP_METADATA_TRANSFER</unmanaged>
        public static readonly MediaAttributeKey<int> TranscodeSkipMetadataTransfer = new MediaAttributeKey<int>("4e4469ef-b571-4959-8f83-3dcfba33a393", "TranscodeSkipMetadataTransfer");

        /// <summary>Constant TranscodeTopologymode.</summary>
        /// <unmanaged>MF_TRANSCODE_TOPOLOGYMODE</unmanaged>
        public static readonly MediaAttributeKey<int> TranscodeTopologymode = new MediaAttributeKey<int>("3e3df610-394a-40b2-9dea-3bab650bebf2", "TranscodeTopologymode");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.TranscodeContainerTypeGuids']/*"/>	
    public static partial class TranscodeContainerTypeGuids
    {

        /// <summary>Constant Asf.</summary>
        /// <unmanaged>MFTranscodeContainerType_ASF</unmanaged>
        public static readonly System.Guid Asf = new Guid("430f6f6e-b6bf-4fc1-a0bd-9ee46eee2afb");

        /// <summary>Constant Mpeg4.</summary>
        /// <unmanaged>MFTranscodeContainerType_MPEG4</unmanaged>
        public static readonly System.Guid Mpeg4 = new Guid("dc6cd05d-b9d0-40ef-bd35-fa622c1ab28a");

        /// <summary>Constant Mp3.</summary>
        /// <unmanaged>MFTranscodeContainerType_MP3</unmanaged>
        public static readonly System.Guid Mp3 = new Guid("e438b912-83f1-4de6-9e3a-9ffbc6dd24d1");

        /// <summary>Constant Flac.</summary>
        /// <unmanaged>MFTranscodeContainerType_FLAC</unmanaged>
        public static readonly System.Guid Flac = new Guid("31344aa3-05a9-42b5-901b-8e9d4257f75e");

        /// <summary>Constant Ac3.</summary>
        /// <unmanaged>MFTranscodeContainerType_AC3</unmanaged>
        public static readonly System.Guid Ac3 = new Guid("6d8d91c3-8c91-4ed1-8742-8c347d5b44d0");

        /// <summary>Constant Adts.</summary>
        /// <unmanaged>MFTranscodeContainerType_ADTS</unmanaged>
        public static readonly System.Guid Adts = new Guid("132fd27d-0f02-43de-a301-38fbbbb3834e");

        /// <summary>Constant Mpeg2.</summary>
        /// <unmanaged>MFTranscodeContainerType_MPEG2</unmanaged>
        public static readonly System.Guid Mpeg2 = new Guid("bfc2dbf9-7bb4-4f8f-afde-e112c44ba882");

        /// <summary>Constant Wave.</summary>
        /// <unmanaged>MFTranscodeContainerType_WAVE</unmanaged>
        public static readonly System.Guid Wave = new Guid("64c3453c-0f26-4741-be63-87bdf8bb935b");

        /// <summary>Constant Avi.</summary>
        /// <unmanaged>MFTranscodeContainerType_AVI</unmanaged>
        public static readonly System.Guid Avi = new Guid("7edfe8af-402f-4d76-a33c-619fd157d0f1");

        /// <summary>Constant Fmpeg4.</summary>
        /// <unmanaged>MFTranscodeContainerType_FMPEG4</unmanaged>
        public static readonly System.Guid Fmpeg4 = new Guid("9ba876f1-419f-4b77-a1e0-35959d9d4004");

        /// <summary>Constant Amr.</summary>
        /// <unmanaged>MFTranscodeContainerType_AMR</unmanaged>
        public static readonly System.Guid Amr = new Guid("025d5ad3-621a-475b-964d-66b1c824f079");

        /// <summary>Constant Mobile3gp.</summary>
        /// <unmanaged>MFTranscodeContainerType_3GP</unmanaged>
        public static readonly System.Guid Mobile3gp = new Guid("34c50167-4472-4f34-9ea0-c49fbacf037d");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.TransformAttributeKeys']/*"/>	
    public static partial class TransformAttributeKeys
    {

        /// <summary>Constant ActivateMftLocked.</summary>
        /// <unmanaged>MF_ACTIVATE_MFT_LOCKED</unmanaged>
        public static readonly MediaAttributeKey<bool> ActivateMftLocked = new MediaAttributeKey<bool>("c1f6093c-7f65-4fbd-9e39-5faec3c4fbd7", "ActivateMftLocked");

        /// <summary>Constant DisableLocallyRegisteredPlugins.</summary>
        /// <unmanaged>MF_DISABLE_LOCALLY_REGISTERED_PLUGINS</unmanaged>
        public static readonly MediaAttributeKey<int> DisableLocallyRegisteredPlugins = new MediaAttributeKey<int>("66b16da9-add4-47e0-a16b-5af1fb483634", "DisableLocallyRegisteredPlugins");

        /// <summary>Constant Enable3dvideoOutput.</summary>
        /// <unmanaged>MF_ENABLE_3DVIDEO_OUTPUT</unmanaged>
        public static readonly MediaAttributeKey<int> Enable3dvideoOutput = new MediaAttributeKey<int>("bdad7bca-0e5f-4b10-ab16-26de381b6293", "Enable3dvideoOutput");

        /// <summary>Constant BuffersPerSample.</summary>
        /// <unmanaged>MF_SA_BUFFERS_PER_SAMPLE</unmanaged>
        public static readonly MediaAttributeKey<int> BuffersPerSample = new MediaAttributeKey<int>("873c5171-1e3d-4e25-988d-b433ce041983", "BuffersPerSample");

        /// <summary>Constant D3DAware.</summary>
        /// <unmanaged>MF_SA_D3D_AWARE</unmanaged>
        public static readonly MediaAttributeKey<bool> D3DAware = new MediaAttributeKey<bool>("eaa35c29-775e-488e-9b61-b3283e49583b", "D3DAware");

        /// <summary>Constant D3D11Aware.</summary>
        /// <unmanaged>MF_SA_D3D11_AWARE</unmanaged>
        public static readonly MediaAttributeKey<bool> D3D11Aware = new MediaAttributeKey<bool>("206b4fc8-fcf9-4c51-afe3-9764369e33a0", "D3D11Aware");

        /// <summary>Constant D3D11Bindflags.</summary>
        /// <unmanaged>MF_SA_D3D11_BINDFLAGS</unmanaged>
        public static readonly MediaAttributeKey<int> D3D11Bindflags = new MediaAttributeKey<int>("eacf97ad-065c-4408-bee3-fdcbfd128be2", "D3D11Bindflags");

        /// <summary>Constant D3D11Usage.</summary>
        /// <unmanaged>MF_SA_D3D11_USAGE</unmanaged>
        public static readonly MediaAttributeKey<int> D3D11Usage = new MediaAttributeKey<int>("e85fe442-2ca3-486e-a9c7-109dda609880", "D3D11Usage");

        /// <summary>Constant TransformAsync.</summary>
        /// <unmanaged>MF_TRANSFORM_ASYNC</unmanaged>
        public static readonly MediaAttributeKey<int> TransformAsync = new MediaAttributeKey<int>("f81a699a-649a-497d-8c73-29f8fed6ad7a", "TransformAsync");

        /// <summary>Constant TransformAsyncUnlock.</summary>
        /// <unmanaged>MF_TRANSFORM_ASYNC_UNLOCK</unmanaged>
        public static readonly MediaAttributeKey<int> TransformAsyncUnlock = new MediaAttributeKey<int>("e5666d6b-3422-4eb6-a421-da7db1f8e207", "TransformAsyncUnlock");

        /// <summary>Constant TransformCategoryAttribute.</summary>
        /// <unmanaged>MF_TRANSFORM_CATEGORY_Attribute</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> TransformCategoryAttribute = new MediaAttributeKey<System.Guid>("ceabba49-506d-4757-a6ff-66c184987e4e", "TransformCategoryAttribute");

        /// <summary>Constant TransformFlagsAttribute.</summary>
        /// <unmanaged>MF_TRANSFORM_FLAGS_Attribute</unmanaged>
        public static readonly MediaAttributeKey<int> TransformFlagsAttribute = new MediaAttributeKey<int>("9359bb7e-6275-46c4-a025-1c01e45f1a86", "TransformFlagsAttribute");

        /// <summary>Constant MftCodecMeritAttribute.</summary>
        /// <unmanaged>MFT_CODEC_MERIT_Attribute</unmanaged>
        public static readonly MediaAttributeKey<int> MftCodecMeritAttribute = new MediaAttributeKey<int>("88a7cb15-7b07-4a34-9128-e64c6703c4d3", "MftCodecMeritAttribute");

        /// <summary>Constant MftConnectedStreamAttribute.</summary>
        /// <unmanaged>MFT_CONNECTED_STREAM_ATTRIBUTE</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> MftConnectedStreamAttribute = new MediaAttributeKey<SharpDX.ComObject>("71eeb820-a59f-4de2-bcec-38db1dd611a4", "MftConnectedStreamAttribute");

        /// <summary>Constant MftConnectedToHwStream.</summary>
        /// <unmanaged>MFT_CONNECTED_TO_HW_STREAM</unmanaged>
        public static readonly MediaAttributeKey<int> MftConnectedToHwStream = new MediaAttributeKey<int>("34e6e728-06d6-4491-a553-4795650db912", "MftConnectedToHwStream");

        /// <summary>Constant MftDecoderExposeOutputTypesInNativeOrder.</summary>
        /// <unmanaged>MFT_DECODER_EXPOSE_OUTPUT_TYPES_IN_NATIVE_ORDER</unmanaged>
        public static readonly MediaAttributeKey<int> MftDecoderExposeOutputTypesInNativeOrder = new MediaAttributeKey<int>("ef80833f-f8fa-44d9-80d8-41ed6232670c", "MftDecoderExposeOutputTypesInNativeOrder");

        /// <summary>Constant MftDecoderFinalVideoResolutionHint.</summary>
        /// <unmanaged>MFT_DECODER_FINAL_VIDEO_RESOLUTION_HINT</unmanaged>
        public static readonly MediaAttributeKey<long> MftDecoderFinalVideoResolutionHint = new MediaAttributeKey<long>("dc2f8496-15c4-407a-b6f0-1b66ab5fbf53", "MftDecoderFinalVideoResolutionHint");

        /// <summary>Constant MftEnumHardwareUrlAttribute.</summary>
        /// <unmanaged>MFT_ENUM_HARDWARE_URL_Attribute</unmanaged>
        public static readonly MediaAttributeKey<string> MftEnumHardwareUrlAttribute = new MediaAttributeKey<string>("2fb866ac-b078-4942-ab6c-003d05cda674", "MftEnumHardwareUrlAttribute");

        /// <summary>Constant MftEnumHardwareVendorIdAttribute.</summary>
        /// <unmanaged>MFT_ENUM_HARDWARE_VENDOR_ID_Attribute</unmanaged>
        public static readonly MediaAttributeKey<string> MftEnumHardwareVendorIdAttribute = new MediaAttributeKey<string>("3aecb0cc-035b-4bcc-8185-2b8d551ef3af", "MftEnumHardwareVendorIdAttribute");

        /// <summary>Constant MftEnumTranscodeOnlyAttribute.</summary>
        /// <unmanaged>MFT_ENUM_TRANSCODE_ONLY_ATTRIBUTE</unmanaged>
        public static readonly MediaAttributeKey<int> MftEnumTranscodeOnlyAttribute = new MediaAttributeKey<int>("111ea8cd-b62a-4bdb-89f6-67ffcdc2458b", "MftEnumTranscodeOnlyAttribute");

        /// <summary>Constant MftFieldofuseUnlockAttribute.</summary>
        /// <unmanaged>MFT_FIELDOFUSE_UNLOCK_Attribute</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> MftFieldofuseUnlockAttribute = new MediaAttributeKey<SharpDX.ComObject>("8ec2e9fd-9148-410d-831e-702439461a8e", "MftFieldofuseUnlockAttribute");

        /// <summary>Constant MftFriendlyNameAttribute.</summary>
        /// <unmanaged>MFT_FRIENDLY_NAME_Attribute</unmanaged>
        public static readonly MediaAttributeKey<string> MftFriendlyNameAttribute = new MediaAttributeKey<string>("314ffbae-5b41-4c95-9c19-4e7d586face3", "MftFriendlyNameAttribute");

        /// <summary>Constant MftHwTimestampWithQpcAttribute.</summary>
        /// <unmanaged>MFT_HW_TIMESTAMP_WITH_QPC_Attribute</unmanaged>
        public static readonly MediaAttributeKey<int> MftHwTimestampWithQpcAttribute = new MediaAttributeKey<int>("8d030fb8-cc43-4258-a22e-9210bef89be4", "MftHwTimestampWithQpcAttribute");

        /// <summary>Constant MftInputTypesAttributes.</summary>
        /// <unmanaged>MFT_INPUT_TYPES_Attributes</unmanaged>
        public static readonly MediaAttributeKey<byte[]> MftInputTypesAttributes = new MediaAttributeKey<byte[]>("4276c9b1-759d-4bf3-9cd0-0d723d138f96", "MftInputTypesAttributes");

        /// <summary>Constant MftOutputTypesAttributes.</summary>
        /// <unmanaged>MFT_OUTPUT_TYPES_Attributes</unmanaged>
        public static readonly MediaAttributeKey<byte[]> MftOutputTypesAttributes = new MediaAttributeKey<byte[]>("8eae8cf3-a44f-4306-ba5c-bf5dda242818", "MftOutputTypesAttributes");

        /// <summary>Constant MftPreferredEncoderProfile.</summary>
        /// <unmanaged>MFT_PREFERRED_ENCODER_PROFILE</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> MftPreferredEncoderProfile = new MediaAttributeKey<SharpDX.ComObject>("53004909-1ef5-46d7-a18e-5a75f8b5905f", "MftPreferredEncoderProfile");

        /// <summary>Constant MftPreferredOutputtypeAttribute.</summary>
        /// <unmanaged>MFT_PREFERRED_OUTPUTTYPE_Attribute</unmanaged>
        public static readonly MediaAttributeKey<SharpDX.ComObject> MftPreferredOutputtypeAttribute = new MediaAttributeKey<SharpDX.ComObject>("7e700499-396a-49ee-b1b4-f628021e8c9d", "MftPreferredOutputtypeAttribute");

        /// <summary>Constant MftProcessLocalAttribute.</summary>
        /// <unmanaged>MFT_PROCESS_LOCAL_Attribute</unmanaged>
        public static readonly MediaAttributeKey<int> MftProcessLocalAttribute = new MediaAttributeKey<int>("543186e4-4649-4e65-b588-4aa352aff379", "MftProcessLocalAttribute");

        /// <summary>Constant MftSupport3dvideo.</summary>
        /// <unmanaged>MFT_SUPPORT_3DVIDEO</unmanaged>
        public static readonly MediaAttributeKey<bool> MftSupport3dvideo = new MediaAttributeKey<bool>("093f81b1-4f2e-4631-8168-7934032a01d3", "MftSupport3dvideo");

        /// <summary>Constant MftSupportDynamicFormatChange.</summary>
        /// <unmanaged>MFT_SUPPORT_DYNAMIC_FORMAT_CHANGE</unmanaged>
        public static readonly MediaAttributeKey<bool> MftSupportDynamicFormatChange = new MediaAttributeKey<bool>("53476a11-3f13-49fb-ac42-ee2733c96741", "MftSupportDynamicFormatChange");

        /// <summary>Constant MftTransformClsidAttribute.</summary>
        /// <unmanaged>MFT_TRANSFORM_CLSID_Attribute</unmanaged>
        public static readonly MediaAttributeKey<System.Guid> MftTransformClsidAttribute = new MediaAttributeKey<System.Guid>("6821c42b-65a4-4e82-99bc-9a88205ecd0c", "MftTransformClsidAttribute");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.TransformCategoryGuids']/*"/>	
    public static partial class TransformCategoryGuids
    {

        /// <summary>Constant VideoDecoder.</summary>
        /// <unmanaged>MFT_CATEGORY_VIDEO_DECODER</unmanaged>
        public static readonly System.Guid VideoDecoder = new Guid("d6c02d4b-6833-45b4-971a-05a4b04bab91");

        /// <summary>Constant VideoEncoder.</summary>
        /// <unmanaged>MFT_CATEGORY_VIDEO_ENCODER</unmanaged>
        public static readonly System.Guid VideoEncoder = new Guid("f79eac7d-e545-4387-bdee-d647d7bde42a");

        /// <summary>Constant VideoEffect.</summary>
        /// <unmanaged>MFT_CATEGORY_VIDEO_EFFECT</unmanaged>
        public static readonly System.Guid VideoEffect = new Guid("12e17c21-532c-4a6e-8a1c-40825a736397");

        /// <summary>Constant Multiplexer.</summary>
        /// <unmanaged>MFT_CATEGORY_MULTIPLEXER</unmanaged>
        public static readonly System.Guid Multiplexer = new Guid("059c561e-05ae-4b61-b69d-55b61ee54a7b");

        /// <summary>Constant Demultiplexer.</summary>
        /// <unmanaged>MFT_CATEGORY_DEMULTIPLEXER</unmanaged>
        public static readonly System.Guid Demultiplexer = new Guid("a8700a7a-939b-44c5-99d7-76226b23b3f1");

        /// <summary>Constant AudioDecoder.</summary>
        /// <unmanaged>MFT_CATEGORY_AUDIO_DECODER</unmanaged>
        public static readonly System.Guid AudioDecoder = new Guid("9ea73fb4-ef7a-4559-8d5d-719d8f0426c7");

        /// <summary>Constant AudioEncoder.</summary>
        /// <unmanaged>MFT_CATEGORY_AUDIO_ENCODER</unmanaged>
        public static readonly System.Guid AudioEncoder = new Guid("91c64bd0-f91e-4d8c-9276-db248279d975");

        /// <summary>Constant AudioEffect.</summary>
        /// <unmanaged>MFT_CATEGORY_AUDIO_EFFECT</unmanaged>
        public static readonly System.Guid AudioEffect = new Guid("11064c48-3648-4ed0-932e-05ce8ac811b7");

        /// <summary>Constant VideoProcessor.</summary>
        /// <unmanaged>MFT_CATEGORY_VIDEO_PROCESSOR</unmanaged>
        public static readonly System.Guid VideoProcessor = new Guid("302ea3fc-aa5f-47f9-9f7a-c2188bb16302");

        /// <summary>Constant Other.</summary>
        /// <unmanaged>MFT_CATEGORY_OTHER</unmanaged>
        public static readonly System.Guid Other = new Guid("90175d57-b7ea-4901-aeb3-933a8747756f");

        /// <summary>Constant Encryptor.</summary>
        /// <unmanaged>MFT_CATEGORY_ENCRYPTOR</unmanaged>
        public static readonly System.Guid Encryptor = new Guid("b0c687be-01cd-44b5-b8b2-7c1d7e058b1f");
    }
    /// <summary>	
    /// Functions	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.MediaFoundation.VideoFormatGuids']/*"/>	
    public static partial class VideoFormatGuids
    {

        /// <summary>Constant Base.</summary>
        /// <unmanaged>MFVideoFormat_Base</unmanaged>
        public static readonly System.Guid Base = new Guid("00000000-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Rgb32.</summary>
        /// <unmanaged>MFVideoFormat_RGB32</unmanaged>
        public static readonly System.Guid Rgb32 = new Guid("00000016-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Argb32.</summary>
        /// <unmanaged>MFVideoFormat_ARGB32</unmanaged>
        public static readonly System.Guid Argb32 = new Guid("00000015-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Rgb24.</summary>
        /// <unmanaged>MFVideoFormat_RGB24</unmanaged>
        public static readonly System.Guid Rgb24 = new Guid("00000014-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Rgb555.</summary>
        /// <unmanaged>MFVideoFormat_RGB555</unmanaged>
        public static readonly System.Guid Rgb555 = new Guid("00000018-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Rgb565.</summary>
        /// <unmanaged>MFVideoFormat_RGB565</unmanaged>
        public static readonly System.Guid Rgb565 = new Guid("00000017-0000-0010-8000-00aa00389b71");

        /// <summary>Constant Rgb8.</summary>
        /// <unmanaged>MFVideoFormat_RGB8</unmanaged>
        public static readonly System.Guid Rgb8 = new Guid("00000029-0000-0010-8000-00aa00389b71");

        /// <summary>Constant L8.</summary>
        /// <unmanaged>MFVideoFormat_L8</unmanaged>
        public static readonly System.Guid L8 = new Guid("00000032-0000-0010-8000-00aa00389b71");

        /// <summary>Constant L16.</summary>
        /// <unmanaged>MFVideoFormat_L16</unmanaged>
        public static readonly System.Guid L16 = new Guid("00000051-0000-0010-8000-00aa00389b71");

        /// <summary>Constant D16.</summary>
        /// <unmanaged>MFVideoFormat_D16</unmanaged>
        public static readonly System.Guid D16 = new Guid("00000050-0000-0010-8000-00aa00389b71");

        /// <summary>Constant A2R10G10B10.</summary>
        /// <unmanaged>MFVideoFormat_A2R10G10B10</unmanaged>
        public static readonly System.Guid A2R10G10B10 = new Guid("0000001f-0000-0010-8000-00aa00389b71");

        /// <summary>Constant A16B16G16R16F.</summary>
        /// <unmanaged>MFVideoFormat_A16B16G16R16F</unmanaged>
        public static readonly System.Guid A16B16G16R16F = new Guid("00000071-0000-0010-8000-00aa00389b71");

        /// <summary>Constant H264Es.</summary>
        /// <unmanaged>MFVideoFormat_H264_ES</unmanaged>
        public static readonly System.Guid H264Es = new Guid("3f40f4f0-5622-4ff8-b6d8-a17a584bee5e");

        /// <summary>Constant Mpeg2.</summary>
        /// <unmanaged>MFVideoFormat_MPEG2</unmanaged>
        public static readonly System.Guid Mpeg2 = new Guid("e06d8026-db46-11cf-b4d1-00805f6cbbea");

        /// <summary>Constant H264Hdcp.</summary>
        /// <unmanaged>MFVideoFormat_H264_HDCP</unmanaged>
        public static readonly System.Guid H264Hdcp = new Guid("5d0ce9dd-9817-49da-bdfd-f5f5b98f18a6");

        /// <summary>Constant HevcHdcp.</summary>
        /// <unmanaged>MFVideoFormat_HEVC_HDCP</unmanaged>
        public static readonly System.Guid HevcHdcp = new Guid("3cfe0fe6-05c4-47dc-9d70-4bdb2959720f");

        /// <summary>Constant BaseHdcp.</summary>
        /// <unmanaged>MFVideoFormat_Base_HDCP</unmanaged>
        public static readonly System.Guid BaseHdcp = new Guid("eac3b9d5-bd14-4237-8f1f-bab428e49312");
    }
}

