// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.MediaFoundation namespace.
//     This code was generated by a tool.
//     Date : 2017/7/15 0:31:22
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.MediaFoundation
{

    // Disable warning : XML comment is not placed on a valid language element
#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574
#pragma warning disable 1570
#pragma warning disable 0465

    /// <summary>	
    /// <p>Enables the application to defer the creation of an object. This interface is exposed by activation objects.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Typically, the application calls some function that returns an <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> reference and then passes that reference to another component. The other component calls <strong>ActivateObject</strong> at a later time to create the object. In the protected media path (PMP), the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> reference might be marshaled to the protected process, so that the object can be created in that process.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFActivate']/*"/>	
    /// <msdn-id>ms703039</msdn-id>	
    /// <unmanaged>IMFActivate</unmanaged>	
    /// <unmanaged-short>IMFActivate</unmanaged-short>	
    [Guid("7FEE9E9A-4A89-47a6-899C-B6A53A70FB67")]
    public partial class Activate : SharpDX.MediaFoundation.MediaAttributes
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.Activate"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Activate(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.Activate"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.Activate(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.Activate(nativePointer);
        }


        /// <summary>	
        /// <p> Creates the object associated with this activation object. </p>	
        /// </summary>	
        /// <param name="riid"><dd> <p> Interface identifier (IID) of the requested interface. </p> </dd></param>	
        /// <param name="vOut"><dd> <p> Receives a reference to the requested interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Some Microsoft Media Foundation objects must be shut down before being released. If so, the caller is responsible for shutting down the object that is returned in <em>ppv</em>. To shut down the object, do one of the following:</p><ul> <li>Call <strong><see cref="SharpDX.MediaFoundation.Activate.ShutdownObject"/></strong> on the activation object, or</li> <li>Call the object-specific shutdown method. This method will depend on the type of object. Possibilities include:<ul> <li>Media sources: Call <strong><see cref="SharpDX.MediaFoundation.MediaSource.Shutdown"/></strong>.</li> <li>Media sinks: Call <strong><see cref="SharpDX.MediaFoundation.MediaSink.Shutdown"/></strong>.</li> <li>Any object that supports the <strong><see cref="SharpDX.MediaFoundation.Shutdownable"/></strong> interface: Call <strong><see cref="SharpDX.MediaFoundation.Shutdownable.Shutdown"/></strong>.</li> </ul> </li> </ul><p>The <strong><see cref="SharpDX.MediaFoundation.Activate.ShutdownObject"/></strong> method is generic to all object types. If the object does not require a shutdown method, <strong>ShutdownObject</strong> succeeds and has no effect. If you do not know the specific shutdown method for the object (or do not know the object type), call <strong><see cref="SharpDX.MediaFoundation.Activate.ShutdownObject"/></strong>.</p><p> After the first call to <strong>ActivateObject</strong>, subsequent calls return a reference to the same instance, until the client calls either <strong>ShutdownObject</strong> or <strong><see cref="SharpDX.MediaFoundation.Activate.DetachObject"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFActivate::ActivateObject']/*"/>	
        /// <msdn-id>ms694292</msdn-id>	
        /// <unmanaged>HRESULT IMFActivate::ActivateObject([In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>	
        /// <unmanaged-short>IMFActivate::ActivateObject</unmanaged-short>	
        public void ActivateObject(System.Guid riid, out System.IntPtr vOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vOut_ = &vOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &riid, vOut_, ((void**)(*(void**)_nativePointer))[33]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Shuts down the created object.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If you create an object by calling <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong>, call <strong>ShutdownObject</strong> when you are done using the object.</p><p>The component that calls <strong>ActivateObject</strong>?not the component that creates the activation object?is responsible for calling <strong>ShutdownObject</strong>. For example, in a typical playback application, the application creates activation objects for the media sinks, but the Media Session calls <strong>ActivateObject</strong>. Therefore the Media Session, not the application, calls <strong>ShutdownObject</strong>.</p><p>After <strong>ShutdownObject</strong> is called, the activation object releases all of its internal references to the created object. If you call <strong>ActivateObject</strong> again, the activation object will create a new instance of the other object.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFActivate::ShutdownObject']/*"/>	
        /// <msdn-id>ms695228</msdn-id>	
        /// <unmanaged>HRESULT IMFActivate::ShutdownObject()</unmanaged>	
        /// <unmanaged-short>IMFActivate::ShutdownObject</unmanaged-short>	
        public void ShutdownObject()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[34]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Detaches the created object from the activation object.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>Not implemented.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The activation object releases all of its internal references to the created object. If you call <strong>ActivateObject</strong> again, the activation object will create a new instance of the other object.</p><p>The <strong>DetachObject</strong> method does not shut down the created object. If the <strong>DetachObject</strong> method succeeds, the client must shut down the created object. This rule applies only to objects that have a shutdown method or that support the <strong><see cref="SharpDX.MediaFoundation.Shutdownable"/></strong> interface. See the remarks for <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong>.</p><p>Implementation of this method is optional. If the activation object does not support this method, the method returns E_NOTIMPL.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFActivate::DetachObject']/*"/>	
        /// <msdn-id>aa367342</msdn-id>	
        /// <unmanaged>HRESULT IMFActivate::DetachObject()</unmanaged>	
        /// <unmanaged-short>IMFActivate::DetachObject</unmanaged-short>	
        public void DetachObject()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[35]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Uses profile data from a profile object to configure settings in the ContentInfo object.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If there is already information in the ContentInfo object when this method is called, it is replaced by the information from the profile object.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFContentInfo']/*"/>	
    /// <msdn-id>ms699846</msdn-id>	
    /// <unmanaged>IMFASFContentInfo</unmanaged>	
    /// <unmanaged-short>IMFASFContentInfo</unmanaged-short>	
    [Guid("B1DCA5CD-D5DA-4451-8E9E-DB5C59914EAD")]
    public partial class ASFContentInfo : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ASFContentInfo"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ASFContentInfo(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ASFContentInfo"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ASFContentInfo(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ASFContentInfo(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves an Advanced Systems Format (ASF) profile that describes the ASF content.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The profile is set by calling either <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo.SetProfile"/></strong> or <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo.ParseHeader"/></strong>.</p><p>The ASF profile object returned by this method does not include any of the <strong>MF_PD_ASF_xxx</strong> attributes (see Presentation Descriptor Attributes). To get these attributes, do the following:</p><ol> <li> <p>Call <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo.GeneratePresentationDescriptor"/></strong> to get the ASF presentation descriptor. You can query the presentation descriptor for the <strong>MF_PD_ASF_xxx</strong> attributes.</p> </li> <li> <p>(Optional.) Call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateASFProfileFromPresentationDescriptor"/></strong> to convert the presentation descriptor into an ASF profile. The profile object created by this function contains the <strong>MF_PD_ASF_xxx</strong> attributes.</p> </li> </ol><p>An ASF profile is a template for file encoding, and is intended mainly for creating ASF content. If you are reading an existing ASF file, it is recommended that you use the presentation descriptor to get information about the file. One exception is that the profile contains the mutual exclusion and stream prioritization objects, which are not exposed directly from the presentation descriptor.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFContentInfo::GetProfile']/*"/>	
        /// <msdn-id>ms698931</msdn-id>	
        /// <unmanaged>GetProfile / SetProfile</unmanaged>	
        /// <unmanaged-short>GetProfile</unmanaged-short>	
        /// <unmanaged>HRESULT IMFASFContentInfo::GetProfile([In] IMFASFProfile** ppIProfile)</unmanaged>
        public SharpDX.MediaFoundation.ASFProfile Profile
        {
            get { SharpDX.MediaFoundation.ASFProfile __output__; GetProfile(out __output__); return __output__; }
            set { SetProfile(value); }
        }

        /// <summary>	
        /// <p> Retrieves the size of the header section of an Advanced Systems Format (ASF) file. </p>	
        /// </summary>	
        /// <param name="iStartOfContentRef"><dd> <p>The <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of a buffer object containing the beginning of ASF content. The size of the valid data in the buffer must be at least MFASF_MIN_HEADER_BYTES in bytes.</p> </dd></param>	
        /// <param name="cbHeaderSize"><dd> <p>Receives the size, in bytes, of the header section of the content. The value includes the size of the ASF Header Object plus the size of the header section of the Data Object. Therefore, the resulting value is the offset to the start of the data packets in the ASF Data Object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.AsfInvalidData"/></strong></dt> </dl> </td><td> <p> The buffer does not contain valid ASF data. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.BufferTooSmall"/></strong></dt> </dl> </td><td> <p> The buffer does not contain enough valid data. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The header of an ASF file or stream can be passed to the <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo.ParseHeader"/></strong> method to populate the ContentInfo object with the header information.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFContentInfo::GetHeaderSize']/*"/>	
        /// <msdn-id>ms703043</msdn-id>	
        /// <unmanaged>HRESULT IMFASFContentInfo::GetHeaderSize([In] IMFMediaBuffer* pIStartOfContent,[In] unsigned longlong* cbHeaderSize)</unmanaged>	
        /// <unmanaged-short>IMFASFContentInfo::GetHeaderSize</unmanaged-short>	
        public void GetHeaderSize(SharpDX.MediaFoundation.MediaBuffer iStartOfContentRef, long cbHeaderSize)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iStartOfContentRef == null) ? IntPtr.Zero : iStartOfContentRef.NativePointer), &cbHeaderSize, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Parses the information in an ASF header and uses that information to set values in the ContentInfo object. You can pass the entire header in a single buffer or send it in several pieces.</p>	
        /// </summary>	
        /// <param name="iHeaderBufferRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of a buffer object containing some or all of the header. The buffer must contain at least 30 bytes, which is the size of the Header Object, not including the objects contained in the Header Object (that is, everything up to and including the Reserved2 field in the Header Object).</p> </dd></param>	
        /// <param name="cbOffsetWithinHeader"><dd> <p>Offset, in bytes, of the first byte in the buffer relative to the beginning of the header.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The header is completely parsed and validated.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.AsfInvalidData"/></strong></dt> </dl> </td><td> <p>The input buffer does not contain valid ASF data.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.BufferTooSmall"/></strong></dt> </dl> </td><td> <p>The input buffer is to small.</p> </td></tr> <tr><td> <dl> <dt><strong>MF_S_ASF_PARSEINPROGRESS</strong></dt> </dl> </td><td> <p>The method succeeded, but the header passed was incomplete. This is the successful return code for all calls but the last one when passing the header in pieces.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If you pass the header in pieces, the ContentInfo object will keep references to the buffer objects until the entire header is parsed. Therefore, do not write over the buffers passed into this method.</p><p>The start of the Header object has the following layout in memory:</p><table> <tr><th>Field Name</th><th>Size in bytes</th></tr> <tr><td>Object ID</td><td>16</td></tr> <tr><td>Object Size</td><td>8</td></tr> <tr><td>Number of Header Objects</td><td>4</td></tr> <tr><td>Reserved1</td><td>1</td></tr> <tr><td>Reserved2</td><td>1</td></tr> </table><p>?</p><p>The first call to <strong>ParseHeader</strong> reads everything up to and including Rerserved2, so it requires a minimum of 30 bytes. (Note that the <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo.GetHeaderSize"/></strong> method reads only the Object ID and Object Size fields, so that method requires a minimum of 24 bytes.)</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFContentInfo::ParseHeader']/*"/>	
        /// <msdn-id>ms694306</msdn-id>	
        /// <unmanaged>HRESULT IMFASFContentInfo::ParseHeader([In] IMFMediaBuffer* pIHeaderBuffer,[In] unsigned longlong cbOffsetWithinHeader)</unmanaged>	
        /// <unmanaged-short>IMFASFContentInfo::ParseHeader</unmanaged-short>	
        public void ParseHeader(SharpDX.MediaFoundation.MediaBuffer iHeaderBufferRef, long cbOffsetWithinHeader)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iHeaderBufferRef == null) ? IntPtr.Zero : iHeaderBufferRef.NativePointer), cbOffsetWithinHeader, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Encodes the data in the <strong>MFASFContentInfo</strong> object into a binary Advanced Systems Format (ASF) header.</p>	
        /// </summary>	
        /// <param name="iHeaderRef"><dd> <p> A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of the buffer object that will receive the encoded header. Set to <strong><c>null</c></strong> to retrieve the size of the header. </p> </dd></param>	
        /// <param name="cbHeaderRef"><dd> <p> Size of the encoded ASF header in bytes. If <em>pIHeader</em> is <strong><c>null</c></strong>, this value is set to the buffer size required to hold the encoded header. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p> The ASF Header Objects do not exist for the media that the ContentInfo object holds reference to. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.AsfInvalidData"/></strong></dt> </dl> </td><td> <p> The ASF Header Object size exceeds 10 MB. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.BufferTooSmall"/></strong></dt> </dl> </td><td> <p> The buffer passed in <em>pIHeader</em> is not large enough to hold the ASF Header Object information. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The size received in the <em>pcbHeader</em> parameter includes the padding size. The content information shrinks or expands the padding data depending on the size of the ASF Header Objects.</p><p>During this call, the stream properties are set based on the encoding properties of the profile. These properties are available through the <strong><see cref="SharpDX.MediaFoundation.Metadata"/></strong> interface.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFContentInfo::GenerateHeader']/*"/>	
        /// <msdn-id>ms701575</msdn-id>	
        /// <unmanaged>HRESULT IMFASFContentInfo::GenerateHeader([In] IMFMediaBuffer* pIHeader,[In] unsigned int* pcbHeader)</unmanaged>	
        /// <unmanaged-short>IMFASFContentInfo::GenerateHeader</unmanaged-short>	
        public void GenerateHeader(SharpDX.MediaFoundation.MediaBuffer iHeaderRef, int cbHeaderRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iHeaderRef == null) ? IntPtr.Zero : iHeaderRef.NativePointer), &cbHeaderRef, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves an Advanced Systems Format (ASF) profile that describes the ASF content.</p>	
        /// </summary>	
        /// <param name="iProfileOut"><dd> <p>Receives an <strong><see cref="SharpDX.MediaFoundation.ASFProfile"/></strong> interface reference. The caller must release the interface. If the object does not have an ASF profile, this parameter receives the value <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The profile is set by calling either <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo.SetProfile"/></strong> or <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo.ParseHeader"/></strong>.</p><p>The ASF profile object returned by this method does not include any of the <strong>MF_PD_ASF_xxx</strong> attributes (see Presentation Descriptor Attributes). To get these attributes, do the following:</p><ol> <li> <p>Call <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo.GeneratePresentationDescriptor"/></strong> to get the ASF presentation descriptor. You can query the presentation descriptor for the <strong>MF_PD_ASF_xxx</strong> attributes.</p> </li> <li> <p>(Optional.) Call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateASFProfileFromPresentationDescriptor"/></strong> to convert the presentation descriptor into an ASF profile. The profile object created by this function contains the <strong>MF_PD_ASF_xxx</strong> attributes.</p> </li> </ol><p>An ASF profile is a template for file encoding, and is intended mainly for creating ASF content. If you are reading an existing ASF file, it is recommended that you use the presentation descriptor to get information about the file. One exception is that the profile contains the mutual exclusion and stream prioritization objects, which are not exposed directly from the presentation descriptor.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFContentInfo::GetProfile']/*"/>	
        /// <msdn-id>ms698931</msdn-id>	
        /// <unmanaged>HRESULT IMFASFContentInfo::GetProfile([In] IMFASFProfile** ppIProfile)</unmanaged>	
        /// <unmanaged-short>IMFASFContentInfo::GetProfile</unmanaged-short>	
        internal void GetProfile(out SharpDX.MediaFoundation.ASFProfile iProfileOut)
        {
            unsafe
            {
                IntPtr iProfileOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &iProfileOut_, ((void**)(*(void**)_nativePointer))[6]);
                iProfileOut = (iProfileOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFProfile(iProfileOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Uses profile data from a profile object to configure settings in the ContentInfo object.</p>	
        /// </summary>	
        /// <param name="iProfileRef"><dd> <p>The <strong><see cref="SharpDX.MediaFoundation.ASFProfile"/></strong> interface of the profile object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If there is already information in the ContentInfo object when this method is called, it is replaced by the information from the profile object.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFContentInfo::SetProfile']/*"/>	
        /// <msdn-id>ms699846</msdn-id>	
        /// <unmanaged>HRESULT IMFASFContentInfo::SetProfile([In] IMFASFProfile* pIProfile)</unmanaged>	
        /// <unmanaged-short>IMFASFContentInfo::SetProfile</unmanaged-short>	
        internal void SetProfile(SharpDX.MediaFoundation.ASFProfile iProfileRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iProfileRef == null) ? IntPtr.Zero : iProfileRef.NativePointer), ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Creates a presentation descriptor for ASF content.</p>	
        /// </summary>	
        /// <param name="iPresentationDescriptorOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFContentInfo::GeneratePresentationDescriptor']/*"/>	
        /// <msdn-id>ms704860</msdn-id>	
        /// <unmanaged>HRESULT IMFASFContentInfo::GeneratePresentationDescriptor([In] IMFPresentationDescriptor** ppIPresentationDescriptor)</unmanaged>	
        /// <unmanaged-short>IMFASFContentInfo::GeneratePresentationDescriptor</unmanaged-short>	
        public void GeneratePresentationDescriptor(out SharpDX.MediaFoundation.PresentationDescriptor iPresentationDescriptorOut)
        {
            unsafe
            {
                IntPtr iPresentationDescriptorOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &iPresentationDescriptorOut_, ((void**)(*(void**)_nativePointer))[8]);
                iPresentationDescriptorOut = (iPresentationDescriptorOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PresentationDescriptor(iPresentationDescriptorOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a property store that can be used to set encoding properties.</p>	
        /// </summary>	
        /// <param name="wStreamNumber"><dd> <p>Stream number to configure. Set to zero to configure file-level encoding properties.</p> </dd></param>	
        /// <param name="iStoreOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFContentInfo::GetEncodingConfigurationPropertyStore']/*"/>	
        /// <msdn-id>ms704750</msdn-id>	
        /// <unmanaged>HRESULT IMFASFContentInfo::GetEncodingConfigurationPropertyStore([In] unsigned short wStreamNumber,[In] IPropertyStore** ppIStore)</unmanaged>	
        /// <unmanaged-short>IMFASFContentInfo::GetEncodingConfigurationPropertyStore</unmanaged-short>	
        public void GetEncodingConfigurationPropertyStore(short wStreamNumber, out SharpDX.ComObject iStoreOut)
        {
            unsafe
            {
                IntPtr iStoreOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, wStreamNumber, &iStoreOut_, ((void**)(*(void**)_nativePointer))[9]);
                iStoreOut = (iStoreOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(iStoreOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Retrieves the flags that indicate the selected indexer options.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>You must call this method before initializing the indexer object with <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.Initialize"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFIndexer']/*"/>	
    /// <msdn-id>ms701578</msdn-id>	
    /// <unmanaged>IMFASFIndexer</unmanaged>	
    /// <unmanaged-short>IMFASFIndexer</unmanaged-short>	
    [Guid("53590F48-DC3B-4297-813F-787761AD7B3E")]
    public partial class ASFIndexer : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ASFIndexer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ASFIndexer(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ASFIndexer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ASFIndexer(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ASFIndexer(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Sets indexer options.</p>	
        /// </summary>	
        /// <param name="dwFlags"><dd> <p>Bitwise OR of zero or more flags from the <strong>MFASF_INDEXER_FLAGS</strong> enumeration specifying the indexer options to use.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The indexer object was  initialized before setting flags for it.  For more information, see Remarks.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.MediaFoundation.ASFIndexer.SetFlags"/></strong> must be called before <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.Initialize"/></strong>. Attempting to call <strong>SetFlags</strong> after <strong>Initialize</strong> will return <see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/> as a result.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFIndexer::SetFlags']/*"/>	
        /// <msdn-id>ms699840</msdn-id>	
        /// <unmanaged>HRESULT IMFASFIndexer::SetFlags([In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IMFASFIndexer::SetFlags</unmanaged-short>	
        public void SetFlags(int dwFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwFlags, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the flags that indicate the selected indexer options.</p>	
        /// </summary>	
        /// <param name="dwFlagsRef"><dd> <p>Receives a bitwise OR of zero or more flags from the <strong>MFASF_INDEXER_FLAGS</strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pdwFlags</em> is <strong><c>null</c></strong>.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You must call this method before initializing the indexer object with <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.Initialize"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFIndexer::GetFlags']/*"/>	
        /// <msdn-id>ms701578</msdn-id>	
        /// <unmanaged>HRESULT IMFASFIndexer::GetFlags([In] unsigned int* pdwFlags)</unmanaged>	
        /// <unmanaged-short>IMFASFIndexer::GetFlags</unmanaged-short>	
        public void GetFlags(int dwFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &dwFlagsRef, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Initializes the indexer object. This method reads information in a ContentInfo object about the configuration of the content and the properties of the existing index, if present. Use this method before using the indexer for either writing or reading an index. You must make this call before using any of the other methods of the <strong><see cref="SharpDX.MediaFoundation.ASFIndexer"/></strong> interface.</p>	
        /// </summary>	
        /// <param name="iContentInfoRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.AsfInvalidData"/></strong></dt> </dl> </td><td> <p>Invalid ASF data.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Unexpected"/></strong></dt> </dl> </td><td> <p>Unexpected error.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The indexer needs to examine the data in the ContentInfo object to properly write or read the index for the content. The indexer will not make changes to the content information and will not hold any references to the <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo"/></strong> interface.</p><p>In the ASF header, the maximum data-packet size must equal the minimum data-packet size. Otherwise, the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.Unexpected"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFIndexer::Initialize']/*"/>	
        /// <msdn-id>ms703030</msdn-id>	
        /// <unmanaged>HRESULT IMFASFIndexer::Initialize([In] IMFASFContentInfo* pIContentInfo)</unmanaged>	
        /// <unmanaged-short>IMFASFIndexer::Initialize</unmanaged-short>	
        public void Initialize(SharpDX.MediaFoundation.ASFContentInfo iContentInfoRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iContentInfoRef == null) ? IntPtr.Zero : iContentInfoRef.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the offset of the index object from the start of the content.</p>	
        /// </summary>	
        /// <param name="iContentInfoRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo"/></strong> interface of the ContentInfo object that describes the content.</p> </dd></param>	
        /// <param name="cbIndexOffsetRef"><dd> <p>Receives the offset of the index relative to the beginning of the content described by the ContentInfo object. This is the position relative to the beginning of the ASF file.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pIContentInfo</em> is <strong><c>null</c></strong> or <em>pcbIndexOffset</em> is <strong><c>null</c></strong></p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The index continues from the offset retrieved by this method to the end of the file.</p><p>You must call <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.Initialize"/></strong> to set up the indexer before calling this method.</p><p>If the index is retrieved by using more than one call to <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.GetCompletedIndex"/></strong>, the position of individual index portions is equal to the index offset plus the offset of the portion within the index.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFIndexer::GetIndexPosition']/*"/>	
        /// <msdn-id>ms699858</msdn-id>	
        /// <unmanaged>HRESULT IMFASFIndexer::GetIndexPosition([In] IMFASFContentInfo* pIContentInfo,[In] unsigned longlong* pcbIndexOffset)</unmanaged>	
        /// <unmanaged-short>IMFASFIndexer::GetIndexPosition</unmanaged-short>	
        public void GetIndexPosition(SharpDX.MediaFoundation.ASFContentInfo iContentInfoRef, long cbIndexOffsetRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iContentInfoRef == null) ? IntPtr.Zero : iContentInfoRef.NativePointer), &cbIndexOffsetRef, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Adds byte streams to be indexed.</p>	
        /// </summary>	
        /// <param name="iByteStreamsOut"><dd> <p>An array of <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface references. To get the byte stream, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateASFIndexerByteStream"/></strong>.</p> </dd></param>	
        /// <param name="cByteStreams"><dd> <p>The number of references in the <em>ppIByteStreams</em> array.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.AlreadyInitializeD"/></strong></dt> </dl> </td><td> <p>The indexer object has already been initialized and it  has packets which have been indexed.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>For a reading scenario, only one byte stream should be used by the indexer object. For an index generating scenario, it depends how many index objects are needed to be generated. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFIndexer::SetIndexByteStreams']/*"/>	
        /// <msdn-id>ms704843</msdn-id>	
        /// <unmanaged>HRESULT IMFASFIndexer::SetIndexByteStreams([In] IMFByteStream** ppIByteStreams,[In] unsigned int cByteStreams)</unmanaged>	
        /// <unmanaged-short>IMFASFIndexer::SetIndexByteStreams</unmanaged-short>	
        public void SetIndexByteStreams(out SharpDX.MediaFoundation.IByteStream iByteStreamsOut, int cByteStreams)
        {
            unsafe
            {
                IntPtr iByteStreamsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &iByteStreamsOut_, cByteStreams, ((void**)(*(void**)_nativePointer))[7]);
                iByteStreamsOut = (iByteStreamsOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ByteStream(iByteStreamsOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of byte streams that are  in use by the  indexer object.</p>	
        /// </summary>	
        /// <param name="cByteStreamsRef"><dd> <p>Receives the number of byte streams that are  in use by the indexer object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pcByteStreams</em> is <strong><c>null</c></strong>.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFIndexer::GetIndexByteStreamCount']/*"/>	
        /// <msdn-id>ms701789</msdn-id>	
        /// <unmanaged>HRESULT IMFASFIndexer::GetIndexByteStreamCount([In] unsigned int* pcByteStreams)</unmanaged>	
        /// <unmanaged-short>IMFASFIndexer::GetIndexByteStreamCount</unmanaged-short>	
        public void GetIndexByteStreamCount(int cByteStreamsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &cByteStreamsRef, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the index settings for a specified stream and index type.</p>	
        /// </summary>	
        /// <param name="indexIdentifierRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.MediaFoundation.AsfIndexIdentifier"/></strong> structure that contains the stream number and index type for which to get the status.</p> </dd></param>	
        /// <param name="fIsIndexedRef"><dd> <p>A variable that retrieves a Boolean value specifying whether the index described by <em>pIndexIdentifier</em> has been created.</p> </dd></param>	
        /// <param name="bIndexDescriptorRef"><dd> <p>A buffer that receives the index descriptor. The index descriptor consists of an <strong><see cref="SharpDX.MediaFoundation.AsfIndexDescriptor"/></strong> structure, optionally followed by index-specific data.</p> </dd></param>	
        /// <param name="cbIndexDescriptorRef"><dd> <p>On input, specifies the size, in bytes, of the buffer that <em>pbIndexDescriptor</em> points to. The value can be zero if <em>pbIndexDescriptor</em> is <strong><c>null</c></strong>. On output, receives the size of the index descriptor, in bytes.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.BufferTooSmall"/></strong></dt> </dl> </td><td> <p>The buffer size specified in <em>pcbIndexDescriptor</em> is too small.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To read an existing ASF index, call <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.SetIndexByteStreams"/></strong> before calling this method.</p><p>If an index exists for the stream and the value passed into <em>pcbIndexDescriptor</em> is smaller than the required size of the <em>pbIndexDescriptor</em> buffer, the method returns <see cref="SharpDX.MediaFoundation.ResultCode.BufferTooSmall"/>. The required buffer size is returned in the <em>pcbIndexDescriptor</em> parameter.</p><p>If there is no index for the specified stream, the method returns <strong><see cref="SharpDX.Result.False"/></strong> in the <em>pfIsIndexed</em> parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFIndexer::GetIndexStatus']/*"/>	
        /// <msdn-id>ms704012</msdn-id>	
        /// <unmanaged>HRESULT IMFASFIndexer::GetIndexStatus([In] ASF_INDEX_IDENTIFIER* pIndexIdentifier,[In] BOOL* pfIsIndexed,[In] unsigned char* pbIndexDescriptor,[In] unsigned int* pcbIndexDescriptor)</unmanaged>	
        /// <unmanaged-short>IMFASFIndexer::GetIndexStatus</unmanaged-short>	
        public void GetIndexStatus(ref SharpDX.MediaFoundation.AsfIndexIdentifier indexIdentifierRef, SharpDX.Mathematics.Interop.RawBool fIsIndexedRef, byte bIndexDescriptorRef, int cbIndexDescriptorRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* indexIdentifierRef_ = &indexIdentifierRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, indexIdentifierRef_, &fIsIndexedRef, &bIndexDescriptorRef, &cbIndexDescriptorRef, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Configures the index for a stream.</p>	
        /// </summary>	
        /// <param name="bIndexDescriptorRef"><dd> <p>The index descriptor to set. The index descriptor is an <strong><see cref="SharpDX.MediaFoundation.AsfIndexDescriptor"/></strong> structure, optionally followed by index-specific data.</p> </dd></param>	
        /// <param name="cbIndexDescriptor"><dd> <p>The size, in bytes, of the index descriptor.</p> </dd></param>	
        /// <param name="fGenerateIndex"><dd> <p>A Boolean value. Set to <strong>TRUE</strong> to have the indexer create an index of the type specified for the stream specified in the index descriptor.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>At attempt was made to change the index status in a seek-only scenario. For more information, see Remarks.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You must make all calls to <strong>SetIndexStatus</strong> before making any calls to <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.GenerateIndexEntries"/></strong>.</p><p>The indexer object is configured to create temporal indexes for each stream by default. Call this method only if you want to override the default settings.</p><p>You cannot use this method in an index reading scenario.  You can only use this method when writing indexes.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFIndexer::SetIndexStatus']/*"/>	
        /// <msdn-id>ms702981</msdn-id>	
        /// <unmanaged>HRESULT IMFASFIndexer::SetIndexStatus([In] unsigned char* pbIndexDescriptor,[In] unsigned int cbIndexDescriptor,[In] BOOL fGenerateIndex)</unmanaged>	
        /// <unmanaged-short>IMFASFIndexer::SetIndexStatus</unmanaged-short>	
        public void SetIndexStatus(byte bIndexDescriptorRef, int cbIndexDescriptor, SharpDX.Mathematics.Interop.RawBool fGenerateIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint39(_nativePointer, &bIndexDescriptorRef, cbIndexDescriptor, fGenerateIndex, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Given a desired seek time, gets the offset from which the client should start reading data. </p>	
        /// </summary>	
        /// <param name="varValueRef"><dd> <p> The value of the index entry for which to get the position. The format of this value varies depending on the type of index, which is specified in the index identifier. For time-based indexing, the variant type is <strong>VT_I8</strong> and the value is the desired seek time, in 100-nanosecond units. </p> </dd></param>	
        /// <param name="indexIdentifierRef"><dd> <p> Pointer to an <strong><see cref="SharpDX.MediaFoundation.AsfIndexIdentifier"/></strong> structure that identifies the stream number and index type. </p> </dd></param>	
        /// <param name="cbOffsetWithinDataRef"><dd> <p> Receives the offset within the data segment of the ASF Data Object. The offset is in bytes, and is relative to the start of packet 0. The offset gives the starting location from which the client should begin reading from the stream. This location might not correspond exactly to the requested seek time. </p> <p> For reverse playback, if no key frame exists after the desired seek position, this parameter receives the value <strong>MFASFINDEXER_READ_FOR_REVERSEPLAYBACK_OUTOFDATASEGMENT</strong>. In that case, the seek position should be 1 byte pass the end of the data segment. </p> </dd></param>	
        /// <param name="hnsApproxTimeRef"><dd> <p> Receives the approximate time stamp of the data that is located at the offset returned in the <em>pcbOffsetWithinData</em> parameter. The accuracy of this value is equal to the indexing interval of the ASF index, typically about 1 second. </p> <ul> <li> If the index type specified in <em>pIndexIdentifier</em> is <strong>GUID_NULL</strong> (time indexing), this parameter can be <strong><c>null</c></strong>. </li> <li> For all other index types, this parameter must be <strong><c>null</c></strong>. </li> </ul> <p> If the approximate time stamp cannot be determined, this parameter receives the value <strong>MFASFINDEXER_APPROX_SEEK_TIME_UNKNOWN</strong>. </p> </dd></param>	
        /// <param name="dwPayloadNumberOfStreamWithinPacketRef"><dd> <p> Receives the payload number of the payload that contains the information for the specified stream. Packets can contain multiple payloads, each containing data for a different stream. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.AsfOufOfRange"/></strong></dt> </dl> </td><td> <p> The requested seek time is out of range. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoIndex"/></strong></dt> </dl> </td><td> <p> No index exists of the specified type for the specified stream. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFIndexer::GetSeekPositionForValue']/*"/>	
        /// <msdn-id>ms703125</msdn-id>	
        /// <unmanaged>HRESULT IMFASFIndexer::GetSeekPositionForValue([In] const void* pvarValue,[In] ASF_INDEX_IDENTIFIER* pIndexIdentifier,[In] unsigned longlong* pcbOffsetWithinData,[In] longlong* phnsApproxTime,[In] unsigned int* pdwPayloadNumberOfStreamWithinPacket)</unmanaged>	
        /// <unmanaged-short>IMFASFIndexer::GetSeekPositionForValue</unmanaged-short>	
        public void GetSeekPositionForValue(System.IntPtr varValueRef, ref SharpDX.MediaFoundation.AsfIndexIdentifier indexIdentifierRef, long cbOffsetWithinDataRef, long hnsApproxTimeRef, int dwPayloadNumberOfStreamWithinPacketRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* indexIdentifierRef_ = &indexIdentifierRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)varValueRef, indexIdentifierRef_, &cbOffsetWithinDataRef, &hnsApproxTimeRef, &dwPayloadNumberOfStreamWithinPacketRef, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Accepts an ASF packet for the file and creates index entries for them.</p>	
        /// </summary>	
        /// <param name="iASFPacketSampleRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface of a media sample that contains the ASF packet. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The argument passed in is <strong><c>null</c></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotInitializeD"/></strong></dt> </dl> </td><td> <p>The indexer is not initialized.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The ASF indexer creates indexes for a file internally. You can get the completed index for all data packets sent to the indexer by committing the index with <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.CommitIndex"/></strong> and then calling <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.GetCompletedIndex"/></strong> to write the index entries into a media buffer. To determine the size of the index so you can allocate a buffer large enough to hold the index, call <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.GetIndexWriteSpace"/></strong>.</p><p> When this method creates index entries, they are immediately available for use by <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.GetSeekPositionForValue"/></strong>. </p><p> The media sample specified in   <em>pIASFPacketSample</em> must hold a buffer that contains a single ASF packet. Get the sample from the  ASF multiplexer by calling the <strong><see cref="SharpDX.MediaFoundation.ASFMultiplexer.GetNextPacket"/></strong> method. </p><p>You cannot use this method while reading an index, only when writing an index.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFIndexer::GenerateIndexEntries']/*"/>	
        /// <msdn-id>ms705660</msdn-id>	
        /// <unmanaged>HRESULT IMFASFIndexer::GenerateIndexEntries([In] IMFSample* pIASFPacketSample)</unmanaged>	
        /// <unmanaged-short>IMFASFIndexer::GenerateIndexEntries</unmanaged-short>	
        public void GenerateIndexEntries(SharpDX.MediaFoundation.Sample iASFPacketSampleRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iASFPacketSampleRef == null) ? IntPtr.Zero : iASFPacketSampleRef.NativePointer), ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Adds information about a new index to the ContentInfo object associated with ASF content. You must call this method before copying the index to the content so that the index will be readable by the indexer later.</p>	
        /// </summary>	
        /// <param name="iContentInfoRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo"/></strong> interface of the ContentInfo object that describes the content.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The caller made an invalid request. For more information, see Remarks.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>For the index to function properly, you must call this method after all ASF packets in the file have been passed to the indexer by using the <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.GenerateIndexEntries"/></strong> method. After you call this method, you must retrieve the indexes by calling <strong>GetCompletedIndex</strong> and write them to the appropriate location in the file. Finally, you must generate a new ASF header by calling the <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo.GenerateHeader"/></strong> method of the ASF ContentInfo object.</p><p> An application must use the <strong>CommitIndex</strong> method only when writing a new index otherwise <strong>CommitIndex</strong> may return <see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/> as a result. For example, <see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/> is returned if the application has flags other than <see cref="SharpDX.MediaFoundation.AsfIndexerFlags.WriteNewIndex"/>  set on the indexer object. <strong>CommitIndex</strong> can also return <see cref="SharpDX.MediaFoundation.AsfIndexerFlags.WriteNewIndex"/> if the index entries have already been committed through an earlier <strong>CommitIndex</strong> call.</p><p>You cannot use this method in an index reading scenario.  You can only use this method when writing indexes.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFIndexer::CommitIndex']/*"/>	
        /// <msdn-id>ms696994</msdn-id>	
        /// <unmanaged>HRESULT IMFASFIndexer::CommitIndex([In] IMFASFContentInfo* pIContentInfo)</unmanaged>	
        /// <unmanaged-short>IMFASFIndexer::CommitIndex</unmanaged-short>	
        public void CommitIndex(SharpDX.MediaFoundation.ASFContentInfo iContentInfoRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iContentInfoRef == null) ? IntPtr.Zero : iContentInfoRef.NativePointer), ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the size, in bytes, of the buffer required to store the completed index.</p>	
        /// </summary>	
        /// <param name="cbIndexWriteSpaceRef"><dd> <p>Receives the size of the index, in bytes</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.IndexNotCommitted"/></strong></dt> </dl> </td><td> <p>The index has not been committed. For more information; see Remarks.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Use this method to get the size of the index and then allocate a buffer big enough to hold it. </p><p>The index must be committed with a call to<strong><see cref="SharpDX.MediaFoundation.ASFIndexer.CommitIndex"/></strong> before calling <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.GetIndexWriteSpace"/></strong>.  If the index is not committed before <strong>GetIndexWriteSpace</strong> is called, then <see cref="SharpDX.MediaFoundation.ResultCode.IndexNotCommitted"/> will be returned as a result. </p><p>Call <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.GetCompletedIndex"/></strong> to write the completed index into a media buffer.</p><p>You cannot use this method in a reading scenario.  You can only use this method when writing indexes.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFIndexer::GetIndexWriteSpace']/*"/>	
        /// <msdn-id>ms700198</msdn-id>	
        /// <unmanaged>HRESULT IMFASFIndexer::GetIndexWriteSpace([In] unsigned longlong* pcbIndexWriteSpace)</unmanaged>	
        /// <unmanaged-short>IMFASFIndexer::GetIndexWriteSpace</unmanaged-short>	
        public void GetIndexWriteSpace(long cbIndexWriteSpaceRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &cbIndexWriteSpaceRef, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the completed index from the ASF indexer object.</p>	
        /// </summary>	
        /// <param name="iIndexBufferRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of a media buffer that receives the index data.</p> </dd></param>	
        /// <param name="cbOffsetWithinIndex"><dd> <p>The offset of the data to be retrieved, in bytes from the start of the index data. Set to 0 for the first call. If subsequent calls are needed (the buffer is not large enough to hold the entire index), set to the byte following the last one retrieved.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.IndexNotCommitted"/></strong></dt> </dl> </td><td> <p>The index was not committed before attempting to get the completed index. For more information, see Remarks.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method uses as much of the buffer as possible, and updates the length of the buffer appropriately.</p><p>If <em>pIIndexBuffer</em> is large enough to contain the entire buffer, <em>cbOffsetWithinIndex</em> should be 0, and the call needs to be made only once. Otherwise, there should be no gaps between successive buffers.</p><p>The user must write this data to the content at <em>cbOffsetFromIndexStart</em> bytes after the end of the ASF data object. You can call <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.GetIndexPosition"/></strong> to determine the start position of the ASF index.</p><p>This call will not succeed unless <strong><see cref="SharpDX.MediaFoundation.ASFIndexer.CommitIndex"/></strong> has been called. After calling <strong>GetCompletedIndex</strong>, the caller must call <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo.GenerateHeader"/></strong> and overwrite the existing ASF header with the new header; otherwise, the ASF header will not match the content, and the file is not guaranteed to play correctly.</p><p>You cannot use this method in an index reading scenario.  You can only use this method when writing indexes.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFIndexer::GetCompletedIndex']/*"/>	
        /// <msdn-id>ms702077</msdn-id>	
        /// <unmanaged>HRESULT IMFASFIndexer::GetCompletedIndex([In] IMFMediaBuffer* pIIndexBuffer,[In] unsigned longlong cbOffsetWithinIndex)</unmanaged>	
        /// <unmanaged-short>IMFASFIndexer::GetCompletedIndex</unmanaged-short>	
        public void GetCompletedIndex(SharpDX.MediaFoundation.MediaBuffer iIndexBufferRef, long cbOffsetWithinIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iIndexBufferRef == null) ? IntPtr.Zero : iIndexBufferRef.NativePointer), cbOffsetWithinIndex, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides methods to create Advanced Systems Format (ASF) data packets. The methods of this interface process input samples into the packets that make up an ASF data section. The ASF multiplexer exposes this interface. To create the ASF multiplexer, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateASFMultiplexer"/></strong>.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMultiplexer']/*"/>	
    /// <msdn-id>ms703009</msdn-id>	
    /// <unmanaged>IMFASFMultiplexer</unmanaged>	
    /// <unmanaged-short>IMFASFMultiplexer</unmanaged-short>	
    [Guid("57BDD80A-9B38-4838-B737-C58F670D7D4F")]
    public partial class ASFMultiplexer : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ASFMultiplexer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ASFMultiplexer(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ASFMultiplexer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ASFMultiplexer(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ASFMultiplexer(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Sets the maximum time by which samples from various streams can be out of synchronization. The multiplexer will not accept a sample with a time stamp that is out of synchronization with the latest samples from any other stream by an amount that exceeds the synchronization tolerance.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The synchronization tolerance is the maximum difference in presentation times at any given point between samples of different streams that the ASF multiplexer can accommodate. That is, if the synchronization tolerance is 3 seconds, no stream can be more than 3 seconds behind any other stream in the time stamps passed to the multiplexer. The multiplexer determines a default synchronization tolerance to use, but this method overrides it (usually to increase it). More tolerance means the potential for greater latency in the multiplexer. If the time stamps are synchronized among the streams, actual latency will be much lower than <em>msSyncTolerance</em>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMultiplexer::SetSyncTolerance']/*"/>	
        /// <msdn-id>ms697206</msdn-id>	
        /// <unmanaged>SetSyncTolerance</unmanaged>	
        /// <unmanaged-short>SetSyncTolerance</unmanaged-short>	
        /// <unmanaged>HRESULT IMFASFMultiplexer::SetSyncTolerance([In] unsigned int msSyncTolerance)</unmanaged>
        public int SyncTolerance
        {
            set { SetSyncTolerance(value); }
        }

        /// <summary>	
        /// <p> </p><p>Initializes the multiplexer with the data from an ASF ContentInfo object.</p>	
        /// </summary>	
        /// <param name="iContentInfoRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo"/></strong> interface of the <strong>MFASFContentInfo</strong> object that contains the header information of the new ASF file. The multiplexer will generate data packets for this file.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This call must be made once at the beginning of encoding, with <em>pIContentInfo</em> pointing to the ASF ContentInfo object that describes the content to be encoded. This enables the ASF multiplexer to see, among other things, which streams will be present in the encoding session. This call typically does not affect the data in the ASF ContentInfo object.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMultiplexer::Initialize']/*"/>	
        /// <msdn-id>ms697469</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMultiplexer::Initialize([In] IMFASFContentInfo* pIContentInfo)</unmanaged>	
        /// <unmanaged-short>IMFASFMultiplexer::Initialize</unmanaged-short>	
        public void Initialize(SharpDX.MediaFoundation.ASFContentInfo iContentInfoRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iContentInfoRef == null) ? IntPtr.Zero : iContentInfoRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets multiplexer options.</p>	
        /// </summary>	
        /// <param name="dwFlags"><dd> <p>Bitwise <strong>OR</strong> of zero or more members of the <strong><see cref="SharpDX.MediaFoundation.AsfMultiplexerflags"/></strong> enumeration. These flags specify which multiplexer options to use. For more information, see "Multiplexer Initialization and Leaky Bucket Settings" in Creating the Multiplexer Object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMultiplexer::SetFlags']/*"/>	
        /// <msdn-id>ms703986</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMultiplexer::SetFlags([In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IMFASFMultiplexer::SetFlags</unmanaged-short>	
        public void SetFlags(int dwFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwFlags, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves flags indicating the configured multiplexer options.</p>	
        /// </summary>	
        /// <param name="dwFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more values from the <strong><see cref="SharpDX.MediaFoundation.AsfMultiplexerflags"/></strong> enumeration. To set these flags, call <strong><see cref="SharpDX.MediaFoundation.ASFMultiplexer.SetFlags"/></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMultiplexer::GetFlags']/*"/>	
        /// <msdn-id>ms702166</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMultiplexer::GetFlags([In] unsigned int* pdwFlags)</unmanaged>	
        /// <unmanaged-short>IMFASFMultiplexer::GetFlags</unmanaged-short>	
        public void GetFlags(int dwFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &dwFlagsRef, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Delivers input samples to the multiplexer. </p>	
        /// </summary>	
        /// <param name="wStreamNumber"><dd> <p> The stream number of the stream to which the sample belongs. </p> </dd></param>	
        /// <param name="iSampleRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface of the input sample. The input sample contains the media data to be converted to ASF data packets. When possible, the time stamp of this sample should be accurate. </p> </dd></param>	
        /// <param name="hnsTimestampAdjust"><dd> <p> The adjustment to apply to the time stamp of the sample. This parameter is used if the caller wants to shift the sample time on <em>pISample</em>. This value should be positive if the time stamp should be pushed ahead and negative if the time stamp should be pushed back. This time stamp is added to sample time on <em>pISample</em>, and the resulting time is used by the multiplexer instead of the original sample time. If no adjustment is needed, set this value to 0. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotAccepting"/></strong></dt> </dl> </td><td> <p> There are too many packets waiting to be retrieved from the multiplexer. Call <strong><see cref="SharpDX.MediaFoundation.ASFMultiplexer.GetNextPacket"/></strong> to get the packets.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.BandwidthOverrun"/></strong></dt> </dl> </td><td> <p> The sample that was processed violates the bandwidth limitations specified for the stream in the ASF ContentInfo object. When this error is generated, the sample is dropped. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> The value passed in <em>wStreamNumber</em> is invalid. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.LateSample"/></strong></dt> </dl> </td><td> <p> The presentation time of the input media sample is earlier than the send time. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> The application passes samples to <strong>ProcessSample</strong>, and the ASF multiplexer queues them internally until they are ready to be placed into ASF packets. Call <strong><see cref="SharpDX.MediaFoundation.ASFMultiplexer.GetNextPacket"/></strong> to get the ASF data packet. </p><p>After each call to <strong>ProcessSample</strong>, call <strong>GetNextPacket</strong> in a loop to get all of the available data packets. For a code example, see Generating New ASF Data Packets.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMultiplexer::ProcessSample']/*"/>	
        /// <msdn-id>ms696206</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMultiplexer::ProcessSample([In] unsigned short wStreamNumber,[In] IMFSample* pISample,[In] longlong hnsTimestampAdjust)</unmanaged>	
        /// <unmanaged-short>IMFASFMultiplexer::ProcessSample</unmanaged-short>	
        public void ProcessSample(short wStreamNumber, SharpDX.MediaFoundation.Sample iSampleRef, long hnsTimestampAdjust)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, wStreamNumber, (void*)((iSampleRef == null) ? IntPtr.Zero : iSampleRef.NativePointer), hnsTimestampAdjust, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the next output ASF packet from the multiplexer.</p>	
        /// </summary>	
        /// <param name="dwStatusFlagsRef"><dd> <p> Receives zero or more status flags. If more than one packet is waiting, the method sets the <strong><see cref="SharpDX.MediaFoundation.AsfStatusflags.Incomplete"/></strong> flag. </p> </dd></param>	
        /// <param name="iPacketOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface of the first output sample of the data packet. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> The client needs to call this method, ideally after every call to <strong><see cref="SharpDX.MediaFoundation.ASFMultiplexer.ProcessSample"/></strong>, to get the output ASF packets. Call this method in a loop as long as the <strong><see cref="SharpDX.MediaFoundation.AsfStatusflags.Incomplete"/></strong> flag is received. </p><p>If no packets are ready, the method returns <strong><see cref="SharpDX.Result.Ok"/></strong> but does not return a sample in <em>ppIPacket</em>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMultiplexer::GetNextPacket']/*"/>	
        /// <msdn-id>ms696243</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMultiplexer::GetNextPacket([Out] ASF_STATUSFLAGS* pdwStatusFlags,[In] IMFSample** ppIPacket)</unmanaged>	
        /// <unmanaged-short>IMFASFMultiplexer::GetNextPacket</unmanaged-short>	
        public void GetNextPacket(out SharpDX.MediaFoundation.AsfStatusflags dwStatusFlagsRef, out SharpDX.MediaFoundation.Sample iPacketOut)
        {
            unsafe
            {
                IntPtr iPacketOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* dwStatusFlagsRef_ = &dwStatusFlagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStatusFlagsRef_, &iPacketOut_, ((void**)(*(void**)_nativePointer))[7]);
                iPacketOut = (iPacketOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Sample(iPacketOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Signals the multiplexer to process all queued output media samples. Call this method after passing the last sample to the multiplexer.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You must call <strong>Flush</strong> after the last sample has been passed into the ASF multiplexer and before you call <strong><see cref="SharpDX.MediaFoundation.ASFMultiplexer.End"/></strong>. This causes all output media samples in progress to be completed. After calling <strong>Flush</strong>, call <strong><see cref="SharpDX.MediaFoundation.ASFMultiplexer.GetNextPacket"/></strong> in a loop until all the pending media samples have been packetized.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMultiplexer::Flush']/*"/>	
        /// <msdn-id>ms696991</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMultiplexer::Flush()</unmanaged>	
        /// <unmanaged-short>IMFASFMultiplexer::Flush</unmanaged-short>	
        public void Flush()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Collects data from the multiplexer and updates the ASF ContentInfo object to include that information in the ASF Header Object.</p>	
        /// </summary>	
        /// <param name="iContentInfoRef"><dd> <p>Pointer to the  <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo"/></strong> interface of the ContentInfo object. This must be the same object that was used to initialize the multiplexer. The ContentInfo object represents the ASF Header Object of the file for which the multiplexer generated data packets.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.FlushNeeded"/></strong></dt> </dl> </td><td> <p>There are pending output media samples waiting in the multiplexer. Call <strong><see cref="SharpDX.MediaFoundation.ASFMultiplexer.Flush"/></strong> to force the media samples to be packetized.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>For non-live encoding scenarios (such as encoding to a file), the user should call <strong>End</strong> to update the specified ContentInfo object, adding data that the multiplexer has collected during the packet generation process. The user should then call <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo.GenerateHeader"/></strong> and write the output header at the beginning of the ASF file (overwriting the header obtained at the beginning of the encoding session). For more information, see Writing an ASF Header Object for a New File.</p><p>During live encoding, it is usually not possible to rewrite the header, so this call is not required for live encoding. (The header in those cases will simply lack some of the information that was not available until the end of the encoding session.)</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMultiplexer::End']/*"/>	
        /// <msdn-id>ms696172</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMultiplexer::End([In] IMFASFContentInfo* pIContentInfo)</unmanaged>	
        /// <unmanaged-short>IMFASFMultiplexer::End</unmanaged-short>	
        public void End(SharpDX.MediaFoundation.ASFContentInfo iContentInfoRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iContentInfoRef == null) ? IntPtr.Zero : iContentInfoRef.NativePointer), ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves multiplexer statistics.</p>	
        /// </summary>	
        /// <param name="wStreamNumber"><dd> <p>The stream number for which to obtain statistics.</p> </dd></param>	
        /// <param name="muxStatsRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.MediaFoundation.AsfMuxStatistics"/></strong> structure that receives the statistics.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMultiplexer::GetStatistics']/*"/>	
        /// <msdn-id>ms697232</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMultiplexer::GetStatistics([In] unsigned short wStreamNumber,[In] ASF_MUX_STATISTICS* pMuxStats)</unmanaged>	
        /// <unmanaged-short>IMFASFMultiplexer::GetStatistics</unmanaged-short>	
        public void GetStatistics(short wStreamNumber, SharpDX.MediaFoundation.AsfMuxStatistics muxStatsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, wStreamNumber, &muxStatsRef, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the maximum time by which samples from various streams can be out of synchronization. The multiplexer will not accept a sample with a time stamp that is out of synchronization with the latest samples from any other stream by an amount that exceeds the synchronization tolerance.</p>	
        /// </summary>	
        /// <param name="msSyncTolerance"><dd> <p>Synchronization tolerance in milliseconds.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The synchronization tolerance is the maximum difference in presentation times at any given point between samples of different streams that the ASF multiplexer can accommodate. That is, if the synchronization tolerance is 3 seconds, no stream can be more than 3 seconds behind any other stream in the time stamps passed to the multiplexer. The multiplexer determines a default synchronization tolerance to use, but this method overrides it (usually to increase it). More tolerance means the potential for greater latency in the multiplexer. If the time stamps are synchronized among the streams, actual latency will be much lower than <em>msSyncTolerance</em>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMultiplexer::SetSyncTolerance']/*"/>	
        /// <msdn-id>ms697206</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMultiplexer::SetSyncTolerance([In] unsigned int msSyncTolerance)</unmanaged>	
        /// <unmanaged-short>IMFASFMultiplexer::SetSyncTolerance</unmanaged-short>	
        internal void SetSyncTolerance(int msSyncTolerance)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, msSyncTolerance, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Configures an Advanced Systems Format (ASF) mutual exclusion object, which manages information about a group of streams in an ASF profile that are mutually exclusive. When streams or groups of streams are mutually exclusive, only one of them is read at a time, they are not read concurrently.</p><p>A common example of mutual exclusion is a set of streams that each include the same content encoded at a different bit rate. The stream that is used is determined by the available bandwidth to the reader.</p><p>An <strong><see cref="SharpDX.MediaFoundation.ASFMutualExclusion"/></strong> interface exists for every ASF mutual exclusion object. A reference to this interface is obtained when you create the object using the <strong><see cref="SharpDX.MediaFoundation.ASFProfile.CreateMutualExclusion"/></strong> method.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An ASF profile object can support multiple mutual exclusions. Each must be configured using a separate ASF mutual exclusion object.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMutualExclusion']/*"/>	
    /// <msdn-id>ms701603</msdn-id>	
    /// <unmanaged>IMFASFMutualExclusion</unmanaged>	
    /// <unmanaged-short>IMFASFMutualExclusion</unmanaged-short>	
    [Guid("12558291-E399-11D5-BC2A-00B0D0F3F4AB")]
    public partial class ASFMutualExclusion : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ASFMutualExclusion"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ASFMutualExclusion(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ASFMutualExclusion"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ASFMutualExclusion(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ASFMutualExclusion(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Sets the type of mutual exclusion that is represented by the Advanced Systems Format (ASF) mutual exclusion object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Sometimes, content must be made mutually exclusive in more than one way. For example, a video file might contain audio streams in several bit rates for each of several languages. To handle this type of complex mutual exclusion, you must configure more than one ASF mutual exclusion object. For more information, see <strong><see cref="SharpDX.MediaFoundation.ASFMutualExclusion.AddRecord"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMutualExclusion::SetType']/*"/>	
        /// <msdn-id>ms697261</msdn-id>	
        /// <unmanaged>SetType</unmanaged>	
        /// <unmanaged-short>SetType</unmanaged-short>	
        /// <unmanaged>HRESULT IMFASFMutualExclusion::SetType([In] const GUID& guidType)</unmanaged>
        public System.Guid Type
        {
            set { SetType(value); }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the type of mutual exclusion represented by the Advanced Systems Format (ASF) mutual exclusion object.</p>	
        /// </summary>	
        /// <param name="guidTypeRef"><dd> <p>A variable that receives the type identifier. For a list of predefined mutual exclusion type constants, see ASF Mutual Exclusion Type GUIDs.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Sometimes, content must be made mutually exclusive in more than one way. For example, a video file might contain audio streams of several bit rates for each of several languages. To handle this type of complex mutual exclusion, you must configure more than one ASF mutual exclusion object. For more information, see <strong><see cref="SharpDX.MediaFoundation.ASFMutualExclusion.AddRecord"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMutualExclusion::GetType']/*"/>	
        /// <msdn-id>ms703095</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMutualExclusion::GetType([In] GUID* pguidType)</unmanaged>	
        /// <unmanaged-short>IMFASFMutualExclusion::GetType</unmanaged-short>	
        public void GetTypeInfo(System.Guid guidTypeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidTypeRef, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the type of mutual exclusion that is represented by the Advanced Systems Format (ASF) mutual exclusion object.</p>	
        /// </summary>	
        /// <param name="guidType"><dd> <p>The type of mutual exclusion that is represented by the ASF mutual exclusion object. For a list of predefined mutual exclusion type constants, see ASF Mutual Exclusion Type GUIDs.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Sometimes, content must be made mutually exclusive in more than one way. For example, a video file might contain audio streams in several bit rates for each of several languages. To handle this type of complex mutual exclusion, you must configure more than one ASF mutual exclusion object. For more information, see <strong><see cref="SharpDX.MediaFoundation.ASFMutualExclusion.AddRecord"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMutualExclusion::SetType']/*"/>	
        /// <msdn-id>ms697261</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMutualExclusion::SetType([In] const GUID&amp; guidType)</unmanaged>	
        /// <unmanaged-short>IMFASFMutualExclusion::SetType</unmanaged-short>	
        internal void SetType(System.Guid guidType)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidType, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of records in the Advanced Systems Format mutual exclusion object.</p>	
        /// </summary>	
        /// <param name="dwRecordCountRef"><dd> <p>Receives the count of records.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Each record includes one or more streams. Every stream in a record is mutually exclusive of streams in every other record.</p><p>Use this method in conjunction with <strong><see cref="SharpDX.MediaFoundation.ASFMutualExclusion.GetStreamsForRecord"/></strong> to retrieve the streams that are included in each record.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMutualExclusion::GetRecordCount']/*"/>	
        /// <msdn-id>ms700201</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMutualExclusion::GetRecordCount([In] unsigned int* pdwRecordCount)</unmanaged>	
        /// <unmanaged-short>IMFASFMutualExclusion::GetRecordCount</unmanaged-short>	
        public void GetRecordCount(int dwRecordCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &dwRecordCountRef, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the stream numbers contained in a record in the Advanced Systems Format mutual exclusion object.</p>	
        /// </summary>	
        /// <param name="dwRecordNumber"><dd> <p>The number of the record for which to retrieve the stream numbers.</p> </dd></param>	
        /// <param name="wStreamNumArrayRef"><dd> <p>An array that receives the stream numbers. Set to <strong><c>null</c></strong> to get the number of elements required, which is indicated by the value of <em>pcStreams</em> on return. If this parameter is not <strong><c>null</c></strong>, the method will copy as many stream numbers to the array as there are elements indicated by the value of <em>pcStreams</em>.</p> </dd></param>	
        /// <param name="cStreamsRef"><dd> <p>On input, the number of elements in the array referenced by <em>pwStreamNumArray</em>. On output, the method sets this value to the count of stream numbers in the record. You can call <strong>GetStreamsForRecord</strong> with <em>pwStreamNumArray</em> set to <strong><c>null</c></strong> to retrieve the number of elements required to hold all of the stream numbers.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMutualExclusion::GetStreamsForRecord']/*"/>	
        /// <msdn-id>ms703200</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMutualExclusion::GetStreamsForRecord([In] unsigned int dwRecordNumber,[In] unsigned short* pwStreamNumArray,[In] unsigned int* pcStreams)</unmanaged>	
        /// <unmanaged-short>IMFASFMutualExclusion::GetStreamsForRecord</unmanaged-short>	
        public void GetStreamsForRecord(int dwRecordNumber, short wStreamNumArrayRef, int cStreamsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwRecordNumber, &wStreamNumArrayRef, &cStreamsRef, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Adds a stream number to a record in the Advanced Systems Format mutual exclusion object.</p>	
        /// </summary>	
        /// <param name="dwRecordNumber"><dd> <p>The record number to which the stream is added. A record number is set by the <strong><see cref="SharpDX.MediaFoundation.ASFMutualExclusion.AddRecord"/></strong> method.</p> </dd></param>	
        /// <param name="wStreamNumber"><dd> <p>The stream number to add to the record.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The specified stream number is already associated with the record.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Each record includes one or more streams. Every stream in a record is mutually exclusive of all streams in every other record.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMutualExclusion::AddStreamForRecord']/*"/>	
        /// <msdn-id>ms703794</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMutualExclusion::AddStreamForRecord([In] unsigned int dwRecordNumber,[In] unsigned short wStreamNumber)</unmanaged>	
        /// <unmanaged-short>IMFASFMutualExclusion::AddStreamForRecord</unmanaged-short>	
        public void AddStreamForRecord(int dwRecordNumber, short wStreamNumber)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwRecordNumber, wStreamNumber, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Removes a stream number from a record in the Advanced Systems Format mutual exclusion object.</p>	
        /// </summary>	
        /// <param name="dwRecordNumber"><dd> <p>The record number from which to remove the stream number.</p> </dd></param>	
        /// <param name="wStreamNumber"><dd> <p>The stream number to remove from the record.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The stream number is not listed for the specified record.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMutualExclusion::RemoveStreamFromRecord']/*"/>	
        /// <msdn-id>ms703971</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMutualExclusion::RemoveStreamFromRecord([In] unsigned int dwRecordNumber,[In] unsigned short wStreamNumber)</unmanaged>	
        /// <unmanaged-short>IMFASFMutualExclusion::RemoveStreamFromRecord</unmanaged-short>	
        public void RemoveStreamFromRecord(int dwRecordNumber, short wStreamNumber)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwRecordNumber, wStreamNumber, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Removes a record from the Advanced Systems Format (ASF) mutual exclusion object.</p>	
        /// </summary>	
        /// <param name="dwRecordNumber"><dd> <p>The index of the record to remove.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When a record is removed, the ASF mutual exclusion object indexes the remaining records so that they are sequential starting with zero. You should enumerate the records to ensure that you have the correct index for each record. If the record removed is the one with the highest index, removing it has no effect on the other indexes.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMutualExclusion::RemoveRecord']/*"/>	
        /// <msdn-id>ms704808</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMutualExclusion::RemoveRecord([In] unsigned int dwRecordNumber)</unmanaged>	
        /// <unmanaged-short>IMFASFMutualExclusion::RemoveRecord</unmanaged-short>	
        public void RemoveRecord(int dwRecordNumber)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwRecordNumber, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Adds a record to the mutual exclusion object. A record specifies streams that are mutually exclusive with the streams in all other records.</p>	
        /// </summary>	
        /// <param name="dwRecordNumberRef"><dd> <p>Receives the index assigned to the new record. Record indexes are zero-based and sequential.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>A record can include one or more stream numbers. All of the streams in a record are mutually exclusive with all the streams in all other records in the ASF mutual exclusion object.</p><p>You can use records to create complex mutual exclusion scenarios by using multiple ASF mutual exclusion objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMutualExclusion::AddRecord']/*"/>	
        /// <msdn-id>ms705615</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMutualExclusion::AddRecord([In] unsigned int* pdwRecordNumber)</unmanaged>	
        /// <unmanaged-short>IMFASFMutualExclusion::AddRecord</unmanaged-short>	
        public void AddRecord(int dwRecordNumberRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &dwRecordNumberRef, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Creates a copy of the Advanced Systems Format mutual exclusion object.</p>	
        /// </summary>	
        /// <param name="iMutexOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.ASFMutualExclusion"/></strong> interface of the new object. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The cloned object is a new object, completely independent of the object from which it was cloned.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFMutualExclusion::Clone']/*"/>	
        /// <msdn-id>ms696217</msdn-id>	
        /// <unmanaged>HRESULT IMFASFMutualExclusion::Clone([In] IMFASFMutualExclusion** ppIMutex)</unmanaged>	
        /// <unmanaged-short>IMFASFMutualExclusion::Clone</unmanaged-short>	
        public void Clone(out SharpDX.MediaFoundation.ASFMutualExclusion iMutexOut)
        {
            unsafe
            {
                IntPtr iMutexOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &iMutexOut_, ((void**)(*(void**)_nativePointer))[11]);
                iMutexOut = (iMutexOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFMutualExclusion(iMutexOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Retrieves the number of streams in the profile.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile']/*"/>	
    /// <msdn-id>ms703024</msdn-id>	
    /// <unmanaged>IMFASFProfile</unmanaged>	
    /// <unmanaged-short>IMFASFProfile</unmanaged-short>	
    [Guid("D267BF6A-028B-4e0d-903D-43F0EF82D0D4")]
    public partial class ASFProfile : SharpDX.MediaFoundation.MediaAttributes
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ASFProfile"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ASFProfile(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ASFProfile"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ASFProfile(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ASFProfile(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Adds a stream to the profile or reconfigures an existing stream.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If the stream number in the ASF stream configuration object is already included in the profile, the information in the new object replaces the old one. If the profile does not contain a stream for the stream number, the ASF stream configuration object is added as a new stream.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::SetStream']/*"/>	
        /// <msdn-id>ms703051</msdn-id>	
        /// <unmanaged>SetStream</unmanaged>	
        /// <unmanaged-short>SetStream</unmanaged-short>	
        /// <unmanaged>HRESULT IMFASFProfile::SetStream([In] IMFASFStreamConfig* pIStream)</unmanaged>
        public SharpDX.MediaFoundation.ASFStreamConfig Stream
        {
            set { SetStream(value); }
        }

        /// <summary>	
        /// <strong>Note</strong>??This method is not supported.?	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::GetStreamPrioritization']/*"/>	
        /// <msdn-id>ms695410</msdn-id>	
        /// <unmanaged>GetStreamPrioritization</unmanaged>	
        /// <unmanaged-short>GetStreamPrioritization</unmanaged-short>	
        /// <unmanaged>HRESULT IMFASFProfile::GetStreamPrioritization([In] IMFASFStreamPrioritization** ppIStreamPrioritization)</unmanaged>
        public SharpDX.MediaFoundation.ASFStreamPrioritization StreamPrioritization
        {
            get { SharpDX.MediaFoundation.ASFStreamPrioritization __output__; GetStreamPrioritization(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of streams in the profile.</p>	
        /// </summary>	
        /// <param name="cStreamsRef"><dd> <p>Receives the number of streams in the profile.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::GetStreamCount']/*"/>	
        /// <msdn-id>ms703024</msdn-id>	
        /// <unmanaged>HRESULT IMFASFProfile::GetStreamCount([In] unsigned int* pcStreams)</unmanaged>	
        /// <unmanaged-short>IMFASFProfile::GetStreamCount</unmanaged-short>	
        public void GetStreamCount(int cStreamsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &cStreamsRef, ((void**)(*(void**)_nativePointer))[33]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a stream from the profile by stream index, and/or retrieves the stream number for a stream index.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The index of the stream to retrieve. Stream indexes are sequential and zero-based. You can get the number of streams that are in the profile by calling the <strong><see cref="SharpDX.MediaFoundation.ASFProfile.GetStreamCount"/></strong> method.</p> </dd></param>	
        /// <param name="wStreamNumberRef"><dd> <p>Receives the stream number of the requested stream. Stream numbers are one-based and are not necessarily sequential. This parameter can be set to <strong><c>null</c></strong> if the stream number is not required.</p> </dd></param>	
        /// <param name="iStreamOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.ASFStreamConfig"/></strong> interface of the ASF stream configuration object. The caller must release the interface. This parameter can be <strong><c>null</c></strong> if you want to retrieve the stream number without accessing the stream configuration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method does not create a copy of the stream configuration object. The reference that is retrieved points to the object within the profile object. You must not make any changes to the stream configuration object using this reference, because doing so can affect the profile object in unexpected ways.</p><p>To change the configuration of the stream configuration object in the profile, you must first clone the stream configuration object by calling <strong><see cref="SharpDX.MediaFoundation.ASFStreamConfig.Clone"/></strong>. Make whatever changes are required to the clone of the object and then add the updated object by calling the <strong><see cref="SharpDX.MediaFoundation.ASFProfile.SetStream"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::GetStream']/*"/>	
        /// <msdn-id>ms700799</msdn-id>	
        /// <unmanaged>HRESULT IMFASFProfile::GetStream([In] unsigned int dwStreamIndex,[In] unsigned short* pwStreamNumber,[In] IMFASFStreamConfig** ppIStream)</unmanaged>	
        /// <unmanaged-short>IMFASFProfile::GetStream</unmanaged-short>	
        public void GetStream(int dwStreamIndex, short wStreamNumberRef, out SharpDX.MediaFoundation.ASFStreamConfig iStreamOut)
        {
            unsafe
            {
                IntPtr iStreamOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, &wStreamNumberRef, &iStreamOut_, ((void**)(*(void**)_nativePointer))[34]);
                iStreamOut = (iStreamOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFStreamConfig(iStreamOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves an Advanced Systems Format (ASF) stream configuration object for a stream in the profile. This method references the stream by stream number instead of stream index.</p>	
        /// </summary>	
        /// <param name="wStreamNumber"><dd> <p>The stream number for which to obtain the interface reference.</p> </dd></param>	
        /// <param name="iStreamOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.ASFStreamConfig"/></strong> interface of the ASF stream configuration object. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method does not create a copy of the stream configuration object. The reference that is retrieved points to the object within the profile object. You must not make any changes to the stream configuration object using this reference, because doing so can affect the profile object in unexpected ways.</p><p>To change the configuration of the stream configuration object in the profile, you must first clone the stream configuration object by calling <strong><see cref="SharpDX.MediaFoundation.ASFStreamConfig.Clone"/></strong>. Make whatever changes are required to the clone of the object and then add the updated object by calling the <strong><see cref="SharpDX.MediaFoundation.ASFProfile.SetStream"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::GetStreamByNumber']/*"/>	
        /// <msdn-id>ms694981</msdn-id>	
        /// <unmanaged>HRESULT IMFASFProfile::GetStreamByNumber([In] unsigned short wStreamNumber,[In] IMFASFStreamConfig** ppIStream)</unmanaged>	
        /// <unmanaged-short>IMFASFProfile::GetStreamByNumber</unmanaged-short>	
        public void GetStreamByNumber(short wStreamNumber, out SharpDX.MediaFoundation.ASFStreamConfig iStreamOut)
        {
            unsafe
            {
                IntPtr iStreamOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, wStreamNumber, &iStreamOut_, ((void**)(*(void**)_nativePointer))[35]);
                iStreamOut = (iStreamOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFStreamConfig(iStreamOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Adds a stream to the profile or reconfigures an existing stream.</p>	
        /// </summary>	
        /// <param name="iStreamRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.ASFStreamConfig"/></strong> interface of a configured ASF stream configuration object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the stream number in the ASF stream configuration object is already included in the profile, the information in the new object replaces the old one. If the profile does not contain a stream for the stream number, the ASF stream configuration object is added as a new stream.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::SetStream']/*"/>	
        /// <msdn-id>ms703051</msdn-id>	
        /// <unmanaged>HRESULT IMFASFProfile::SetStream([In] IMFASFStreamConfig* pIStream)</unmanaged>	
        /// <unmanaged-short>IMFASFProfile::SetStream</unmanaged-short>	
        internal void SetStream(SharpDX.MediaFoundation.ASFStreamConfig iStreamRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iStreamRef == null) ? IntPtr.Zero : iStreamRef.NativePointer), ((void**)(*(void**)_nativePointer))[36]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Removes a stream from the Advanced Systems Format (ASF) profile object.</p>	
        /// </summary>	
        /// <param name="wStreamNumber"><dd> <p>Stream number of the stream to remove.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>After a stream is removed, the ASF profile object reassigns stream indexes so that the index values are sequential starting from zero. Any previously stored stream index numbers are no longer valid after deleting a stream.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::RemoveStream']/*"/>	
        /// <msdn-id>ms704569</msdn-id>	
        /// <unmanaged>HRESULT IMFASFProfile::RemoveStream([In] unsigned short wStreamNumber)</unmanaged>	
        /// <unmanaged-short>IMFASFProfile::RemoveStream</unmanaged-short>	
        public void RemoveStream(short wStreamNumber)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, wStreamNumber, ((void**)(*(void**)_nativePointer))[37]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Creates an Advanced Systems Format (ASF) stream configuration object.</p>	
        /// </summary>	
        /// <param name="iMediaTypeRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of a configured media type.</p> </dd></param>	
        /// <param name="iStreamOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.ASFStreamConfig"/></strong> interface of the new ASF stream configuration object. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>ppIStream</em> is <strong><c>null</c></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p>stream configuration object could not be created due to insufficient memory.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The ASF stream configuration object created by this method is not included in the profile. To include the stream, you must first configure the stream configuration and then call <strong><see cref="SharpDX.MediaFoundation.ASFProfile.SetStream"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::CreateStream']/*"/>	
        /// <msdn-id>ms696264</msdn-id>	
        /// <unmanaged>HRESULT IMFASFProfile::CreateStream([In] IMFMediaType* pIMediaType,[In] IMFASFStreamConfig** ppIStream)</unmanaged>	
        /// <unmanaged-short>IMFASFProfile::CreateStream</unmanaged-short>	
        public void CreateStream(SharpDX.MediaFoundation.MediaType iMediaTypeRef, out SharpDX.MediaFoundation.ASFStreamConfig iStreamOut)
        {
            unsafe
            {
                IntPtr iStreamOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iMediaTypeRef == null) ? IntPtr.Zero : iMediaTypeRef.NativePointer), &iStreamOut_, ((void**)(*(void**)_nativePointer))[38]);
                iStreamOut = (iStreamOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFStreamConfig(iStreamOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of Advanced Systems Format (ASF) mutual exclusion objects that are associated with the profile.</p>	
        /// </summary>	
        /// <param name="cMutexsRef"><dd> <p>Receives the number of mutual exclusion objects.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Multiple mutual exclusion objects may be required for streams that are mutually exclusive in more than one way. For more information, see <strong><see cref="SharpDX.MediaFoundation.ASFMutualExclusion.AddRecord"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::GetMutualExclusionCount']/*"/>	
        /// <msdn-id>ms697361</msdn-id>	
        /// <unmanaged>HRESULT IMFASFProfile::GetMutualExclusionCount([In] unsigned int* pcMutexs)</unmanaged>	
        /// <unmanaged-short>IMFASFProfile::GetMutualExclusionCount</unmanaged-short>	
        public void GetMutualExclusionCount(int cMutexsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &cMutexsRef, ((void**)(*(void**)_nativePointer))[39]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves an Advanced Systems Format (ASF) mutual exclusion object from the profile.</p>	
        /// </summary>	
        /// <param name="dwMutexIndex"><dd> <p>Index of the mutual exclusion object in the profile.</p> </dd></param>	
        /// <param name="iMutexOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.ASFMutualExclusion"/></strong> interface of the ASF mutual exclusion object. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method does not create a copy of the mutual exclusion object. The returned reference refers to the mutual exclusion contained in the profile object. You must not make any changes to the mutual exclusion object using this reference, because doing so can affect the profile object in unexpected ways.</p><p>To change the configuration of the mutual exclusion object in the profile, you must first clone the mutual exclusion object by calling <strong><see cref="SharpDX.MediaFoundation.ASFMutualExclusion.Clone"/></strong>. Make whatever changes are required to the clone of the object, remove the old mutual exclusion object from the profile by calling the <strong><see cref="SharpDX.MediaFoundation.ASFProfile.RemoveMutualExclusion"/></strong> method, and then add the updated object by calling the <strong><see cref="SharpDX.MediaFoundation.ASFProfile.AddMutualExclusion"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::GetMutualExclusion']/*"/>	
        /// <msdn-id>ms701598</msdn-id>	
        /// <unmanaged>HRESULT IMFASFProfile::GetMutualExclusion([In] unsigned int dwMutexIndex,[In] IMFASFMutualExclusion** ppIMutex)</unmanaged>	
        /// <unmanaged-short>IMFASFProfile::GetMutualExclusion</unmanaged-short>	
        public void GetMutualExclusion(int dwMutexIndex, out SharpDX.MediaFoundation.ASFMutualExclusion iMutexOut)
        {
            unsafe
            {
                IntPtr iMutexOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwMutexIndex, &iMutexOut_, ((void**)(*(void**)_nativePointer))[40]);
                iMutexOut = (iMutexOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFMutualExclusion(iMutexOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Adds a configured Advanced Systems Format (ASF) mutual exclusion object to the profile.</p>	
        /// </summary>	
        /// <param name="iMutexRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.ASFMutualExclusion"/></strong> interface of a configured ASF mutual exclusion object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You can create a mutual exclusion object by calling the <strong><see cref="SharpDX.MediaFoundation.ASFProfile.CreateMutualExclusion"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::AddMutualExclusion']/*"/>	
        /// <msdn-id>ms703965</msdn-id>	
        /// <unmanaged>HRESULT IMFASFProfile::AddMutualExclusion([In] IMFASFMutualExclusion* pIMutex)</unmanaged>	
        /// <unmanaged-short>IMFASFProfile::AddMutualExclusion</unmanaged-short>	
        public void AddMutualExclusion(SharpDX.MediaFoundation.ASFMutualExclusion iMutexRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iMutexRef == null) ? IntPtr.Zero : iMutexRef.NativePointer), ((void**)(*(void**)_nativePointer))[41]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Removes an Advanced Systems Format (ASF) mutual exclusion object from the profile.</p>	
        /// </summary>	
        /// <param name="dwMutexIndex"><dd> <p>The index of the mutual exclusion object to remove from the profile.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When a mutual exclusion object is removed from the profile, the ASF profile object reassigns the mutual exclusion indexes so that they are sequential starting with zero. Any previously stored indexes are no longer valid after calling this method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::RemoveMutualExclusion']/*"/>	
        /// <msdn-id>ms704007</msdn-id>	
        /// <unmanaged>HRESULT IMFASFProfile::RemoveMutualExclusion([In] unsigned int dwMutexIndex)</unmanaged>	
        /// <unmanaged-short>IMFASFProfile::RemoveMutualExclusion</unmanaged-short>	
        public void RemoveMutualExclusion(int dwMutexIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwMutexIndex, ((void**)(*(void**)_nativePointer))[42]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Creates a new Advanced Systems Format (ASF) mutual exclusion object. Mutual exclusion objects can be added to a profile by calling the <strong>AddMutualExclusion</strong> method.</p>	
        /// </summary>	
        /// <param name="iMutexOut">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The ASF mutual exclusion object created by this method is not associated with the profile. Call <strong><see cref="SharpDX.MediaFoundation.ASFProfile.AddMutualExclusion"/></strong> after configuring the object to make this association.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::CreateMutualExclusion']/*"/>	
        /// <msdn-id>ms697002</msdn-id>	
        /// <unmanaged>HRESULT IMFASFProfile::CreateMutualExclusion([In] IMFASFMutualExclusion** ppIMutex)</unmanaged>	
        /// <unmanaged-short>IMFASFProfile::CreateMutualExclusion</unmanaged-short>	
        public void CreateMutualExclusion(out SharpDX.MediaFoundation.ASFMutualExclusion iMutexOut)
        {
            unsafe
            {
                IntPtr iMutexOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &iMutexOut_, ((void**)(*(void**)_nativePointer))[43]);
                iMutexOut = (iMutexOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFMutualExclusion(iMutexOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <strong>Note</strong>??This method is not supported.?	
        /// </summary>	
        /// <param name="iStreamPrioritizationOut"><dd> <p>Reserved.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::GetStreamPrioritization']/*"/>	
        /// <msdn-id>ms695410</msdn-id>	
        /// <unmanaged>HRESULT IMFASFProfile::GetStreamPrioritization([In] IMFASFStreamPrioritization** ppIStreamPrioritization)</unmanaged>	
        /// <unmanaged-short>IMFASFProfile::GetStreamPrioritization</unmanaged-short>	
        internal void GetStreamPrioritization(out SharpDX.MediaFoundation.ASFStreamPrioritization iStreamPrioritizationOut)
        {
            unsafe
            {
                IntPtr iStreamPrioritizationOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &iStreamPrioritizationOut_, ((void**)(*(void**)_nativePointer))[44]);
                iStreamPrioritizationOut = (iStreamPrioritizationOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFStreamPrioritization(iStreamPrioritizationOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <strong>Note</strong>??This method is not supported.?	
        /// </summary>	
        /// <param name="iStreamPrioritizationRef"><dd> <p>Reserved. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::AddStreamPrioritization']/*"/>	
        /// <msdn-id>ms697516</msdn-id>	
        /// <unmanaged>HRESULT IMFASFProfile::AddStreamPrioritization([In] IMFASFStreamPrioritization* pIStreamPrioritization)</unmanaged>	
        /// <unmanaged-short>IMFASFProfile::AddStreamPrioritization</unmanaged-short>	
        public void AddStreamPrioritization(SharpDX.MediaFoundation.ASFStreamPrioritization iStreamPrioritizationRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iStreamPrioritizationRef == null) ? IntPtr.Zero : iStreamPrioritizationRef.NativePointer), ((void**)(*(void**)_nativePointer))[45]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <strong>Note</strong>??This method is not supported.?	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::RemoveStreamPrioritization']/*"/>	
        /// <msdn-id>ms701838</msdn-id>	
        /// <unmanaged>HRESULT IMFASFProfile::RemoveStreamPrioritization()</unmanaged>	
        /// <unmanaged-short>IMFASFProfile::RemoveStreamPrioritization</unmanaged-short>	
        public void RemoveStreamPrioritization()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[46]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <strong>Note</strong>??This method is not implemented.?	
        /// </summary>	
        /// <param name="iStreamPrioritizationOut"><dd> <p>Reserved. </p> </dd></param>	
        /// <returns><p> Returns <strong>E_NOTIMPL</strong>. </p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::CreateStreamPrioritization']/*"/>	
        /// <msdn-id>ms694914</msdn-id>	
        /// <unmanaged>HRESULT IMFASFProfile::CreateStreamPrioritization([In] IMFASFStreamPrioritization** ppIStreamPrioritization)</unmanaged>	
        /// <unmanaged-short>IMFASFProfile::CreateStreamPrioritization</unmanaged-short>	
        public void CreateStreamPrioritization(out SharpDX.MediaFoundation.ASFStreamPrioritization iStreamPrioritizationOut)
        {
            unsafe
            {
                IntPtr iStreamPrioritizationOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &iStreamPrioritizationOut_, ((void**)(*(void**)_nativePointer))[47]);
                iStreamPrioritizationOut = (iStreamPrioritizationOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFStreamPrioritization(iStreamPrioritizationOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Creates a copy of the Advanced Systems Format profile object.</p>	
        /// </summary>	
        /// <param name="iProfileOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.ASFProfile"/></strong> interface of the new object. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The cloned object is completely independent of the original.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFProfile::Clone']/*"/>	
        /// <msdn-id>ms704773</msdn-id>	
        /// <unmanaged>HRESULT IMFASFProfile::Clone([In] IMFASFProfile** ppIProfile)</unmanaged>	
        /// <unmanaged-short>IMFASFProfile::Clone</unmanaged-short>	
        public void Clone(out SharpDX.MediaFoundation.ASFProfile iProfileOut)
        {
            unsafe
            {
                IntPtr iProfileOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &iProfileOut_, ((void**)(*(void**)_nativePointer))[48]);
                iProfileOut = (iProfileOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFProfile(iProfileOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Retrieves the option flags that are set on the ASF splitter.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFSplitter']/*"/>	
    /// <msdn-id>ms702288</msdn-id>	
    /// <unmanaged>IMFASFSplitter</unmanaged>	
    /// <unmanaged-short>IMFASFSplitter</unmanaged-short>	
    [Guid("12558295-E399-11D5-BC2A-00B0D0F3F4AB")]
    public partial class ASFSplitter : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ASFSplitter"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ASFSplitter(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ASFSplitter"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ASFSplitter(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ASFSplitter(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Resets the Advanced Systems Format (ASF) splitter and configures it to parse data from an ASF data section.</p>	
        /// </summary>	
        /// <param name="iContentInfoRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo"/></strong> interface of a ContentInfo object that describes the data to be parsed.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The <em>pIContentInfo</em> parameter is <strong><c>null</c></strong>.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFSplitter::Initialize']/*"/>	
        /// <msdn-id>ms704048</msdn-id>	
        /// <unmanaged>HRESULT IMFASFSplitter::Initialize([In] IMFASFContentInfo* pIContentInfo)</unmanaged>	
        /// <unmanaged-short>IMFASFSplitter::Initialize</unmanaged-short>	
        public void Initialize(SharpDX.MediaFoundation.ASFContentInfo iContentInfoRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iContentInfoRef == null) ? IntPtr.Zero : iContentInfoRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets option flags on the Advanced Systems Format (ASF) splitter.</p>	
        /// </summary>	
        /// <param name="dwFlags"><dd> <p>A bitwise combination of zero or more members of the <strong><see cref="SharpDX.MediaFoundation.AsfSplitterflags"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotInitializeD"/></strong></dt> </dl> </td><td> <p>The splitter is not initialized.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The <em>dwFlags</em> parameter does not contain a valid flag.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The <see cref="SharpDX.MediaFoundation.AsfSplitterflags.Reverse"/> flag is set, but the content cannot be parsed in reverse.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method can only be called after the splitter is initialized.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFSplitter::SetFlags']/*"/>	
        /// <msdn-id>ms697337</msdn-id>	
        /// <unmanaged>HRESULT IMFASFSplitter::SetFlags([In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IMFASFSplitter::SetFlags</unmanaged-short>	
        public void SetFlags(int dwFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwFlags, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the option flags that are set on the ASF splitter.</p>	
        /// </summary>	
        /// <param name="dwFlagsRef"><dd> <p>Receives the option flags. This value is a bitwise <strong>OR</strong> of zero or more members of the <strong><see cref="SharpDX.MediaFoundation.AsfSplitterflags"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pdwFlags</em> is <strong><c>null</c></strong>.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFSplitter::GetFlags']/*"/>	
        /// <msdn-id>ms702288</msdn-id>	
        /// <unmanaged>HRESULT IMFASFSplitter::GetFlags([In] unsigned int* pdwFlags)</unmanaged>	
        /// <unmanaged-short>IMFASFSplitter::GetFlags</unmanaged-short>	
        public void GetFlags(int dwFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &dwFlagsRef, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the streams to be parsed by the Advanced Systems Format (ASF) splitter.</p>	
        /// </summary>	
        /// <param name="wStreamNumbersRef"><dd> <p>An array of variables containing the list of stream numbers to select.</p> </dd></param>	
        /// <param name="wNumStreams"><dd> <p>The number of valid elements in the stream number array.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pwStreamNumbers</em> is <strong><c>null</c></strong> and <em>wNumStreams</em> contains a value greater than zero.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>Invalid stream number was passed in the array.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Calling this method supersedes any previous stream selections; only the streams specified in the <em>pwStreamNumbers</em> array will be selected.</p><p>By default, no streams are selected by the splitter.</p><p>You can obtain a list of the currently selected streams by calling the <strong><see cref="SharpDX.MediaFoundation.ASFSplitter.GetSelectedStreams"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFSplitter::SelectStreams']/*"/>	
        /// <msdn-id>ms701631</msdn-id>	
        /// <unmanaged>HRESULT IMFASFSplitter::SelectStreams([In] unsigned short* pwStreamNumbers,[In] unsigned short wNumStreams)</unmanaged>	
        /// <unmanaged-short>IMFASFSplitter::SelectStreams</unmanaged-short>	
        public void SelectStreams(short wStreamNumbersRef, short wNumStreams)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &wStreamNumbersRef, wNumStreams, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets a list of currently selected streams. </p>	
        /// </summary>	
        /// <param name="wStreamNumbersRef"><dd> <p> The address of an array of <strong>WORDs</strong>. This array receives the stream numbers of the selected streams. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="wNumStreamsRef"><dd> <p>On input, points to a variable that contains the number of elements in the <em>pwStreamNumbers</em> array. Set the variable to zero if <em>pwStreamNumbers</em> is <strong><c>null</c></strong>. </p> <p>On output, receives the number of elements that were copied into <em>pwStreamNumbers</em>. Each element is the identifier of a selected stream.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> Invalid argument. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.BufferTooSmall"/></strong></dt> </dl> </td><td> <p> The <em>pwStreamNumbers</em> array is smaller than the number of selected streams. See Remarks.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To get the number of selected streams, set <em>pwStreamNumbers</em> to <strong><c>null</c></strong>. The method will return <strong>MF_E_BUFFERTOSMALL</strong> but will also set the value of <code>*pwNumStreams</code> equal  to the number of selected streams. Then allocate an array of that size and call the method again, passing the array in the <em>pwStreamNumbers</em> parameter.</p><p>The following code shows these steps:</p><pre><see cref="SharpDX.Result"/> DisplaySelectedStreams(<see cref="SharpDX.MediaFoundation.ASFSplitter"/> *pSplitter)	
        /// { WORD count = 0; <see cref="SharpDX.Result"/> hr = pSplitter-&gt;GetSelectedStreams(<c>null</c>, &amp;count); if (hr == <see cref="SharpDX.MediaFoundation.ResultCode.BufferTooSmall"/>) { WORD *pStreamIds = new (std::nothrow) WORD[count]; if (pStreamIds) { hr = pSplitter-&gt;GetSelectedStreams(pStreamIds, &amp;count); if (SUCCEEDED(hr)) { for (WORD i = 0; i &lt; count; i++) { printf("Selected stream ID: %d\n", pStreamIds[i]); } } delete [] pStreamIds; } else { hr = E_OUTOFMEMORY; } } return hr;	
        /// }	
        /// </pre><p>Alternatively, you can allocate an array that is equal to the total number of streams and pass that to <em>pwStreamNumbers</em>.</p><p>Before calling this method, initialize <code>*pwNumStreams</code> to the number of elements in <em>pwStreamNumbers</em>. If <em>pwStreamNumbers</em> is <strong><c>null</c></strong>, set <code>*pwNumStreams</code> to zero.</p><p> By default, no streams are selected by the splitter. Select streams by calling the <strong><see cref="SharpDX.MediaFoundation.ASFSplitter.SelectStreams"/></strong> method. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFSplitter::GetSelectedStreams']/*"/>	
        /// <msdn-id>ms705602</msdn-id>	
        /// <unmanaged>HRESULT IMFASFSplitter::GetSelectedStreams([In] unsigned short* pwStreamNumbers,[In] unsigned short* pwNumStreams)</unmanaged>	
        /// <unmanaged-short>IMFASFSplitter::GetSelectedStreams</unmanaged-short>	
        public void GetSelectedStreams(short wStreamNumbersRef, short wNumStreamsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &wStreamNumbersRef, &wNumStreamsRef, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sends packetized Advanced Systems Format (ASF) data to the ASF splitter for processing.</p>	
        /// </summary>	
        /// <param name="iBufferRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of a buffer object containing data to be parsed.</p> </dd></param>	
        /// <param name="cbBufferOffset"><dd> <p>The offset into the data buffer where the splitter should begin parsing. This value is typically set to 0.</p> </dd></param>	
        /// <param name="cbLength"><dd> <p>The length, in bytes, of the data to parse. This value is measured from the offset specified by <em>cbBufferOffset</em>. Set to 0 to process to the end of the buffer.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The <em>pIBuffer</em> parameter is <strong><c>null</c></strong>.</p> <p>The specified offset value in <em>cbBufferOffset</em> is greater than the length of the buffer.</p> <p>The total value of <em>cbBufferOffset</em> and <em>cbLength</em> is greater than the length of the buffer.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotInitializeD"/></strong></dt> </dl> </td><td> <p>The <strong><see cref="SharpDX.MediaFoundation.ASFSplitter.Initialize"/></strong> method was not called or the call failed.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotAccepting"/></strong></dt> </dl> </td><td> <p>The splitter cannot process more input at this time.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>After using this method to parse data, you must call <strong><see cref="SharpDX.MediaFoundation.ASFSplitter.GetNextSample"/></strong> to retrieve parsed media samples.</p><p>If your ASF data contains variable-sized packets, you must set the <strong><see cref="SharpDX.MediaFoundation.AsfSplitterAttributeKeys.PacketBoundary"/></strong> attribute on the buffers to indicate the sample boundaries, and the buffers cannot span multiple packets.</p><p>If the method returns ME_E_NOTACCEPTING, call <strong>GetNextSample</strong> to get the output samples, or call <strong><see cref="SharpDX.MediaFoundation.ASFSplitter.Flush"/></strong> to clear the splitter.</p><p>The splitter might hold a reference count on the input buffer. Therefore, do not write over the valid data in the buffer after calling this method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFSplitter::ParseData']/*"/>	
        /// <msdn-id>ms694299</msdn-id>	
        /// <unmanaged>HRESULT IMFASFSplitter::ParseData([In] IMFMediaBuffer* pIBuffer,[In] unsigned int cbBufferOffset,[In] unsigned int cbLength)</unmanaged>	
        /// <unmanaged-short>IMFASFSplitter::ParseData</unmanaged-short>	
        public void ParseData(SharpDX.MediaFoundation.MediaBuffer iBufferRef, int cbBufferOffset, int cbLength)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iBufferRef == null) ? IntPtr.Zero : iBufferRef.NativePointer), cbBufferOffset, cbLength, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a sample from the Advanced Systems Format (ASF) splitter after the data has been parsed.</p>	
        /// </summary>	
        /// <param name="dwStatusFlagsRef"><dd> <p>Receives one of the following values.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.AsfStatusflags.Incomplete"/></strong></dt> </dl> </td><td> <p>More samples are ready to be retrieved. Call <strong>GetNextSample</strong> in a loop until the <em>pdwStatusFlags</em> parameter receives the value zero.</p> </td></tr> <tr><td><dl> <dt><strong>Zero</strong></dt> </dl> </td><td> <p>No additional samples are ready. Call <strong><see cref="SharpDX.MediaFoundation.ASFSplitter.ParseData"/></strong> to give more input data to the splitter.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="wStreamNumberRef"><dd> <p>If the method returns a sample in the <em>ppISample</em> parameter, this parameter receives the number of the stream to which the sample belongs.</p> </dd></param>	
        /// <param name="iSampleOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface of the parsed sample. The caller must release the interface. If no samples are ready, this parameter receives the value <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.AsfInvalidData"/></strong></dt> </dl> </td><td> <p>The ASF data in the buffer is invalid.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.AsfMissingData"/></strong></dt> </dl> </td><td> <p>There is a gap in the ASF data.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Before calling this method, call <strong><see cref="SharpDX.MediaFoundation.ASFSplitter.ParseData"/></strong> to give input data to the splitter. If the input does not contain enough data for a complete sample, the <strong>GetNextSample</strong> method succeeds but returns <strong><c>null</c></strong> in the <em>ppISample</em> parameter.</p><p>The ASF splitter skips samples for unselected streams. To select streams, call <strong><see cref="SharpDX.MediaFoundation.ASFSplitter.SelectStreams"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFSplitter::GetNextSample']/*"/>	
        /// <msdn-id>ms700167</msdn-id>	
        /// <unmanaged>HRESULT IMFASFSplitter::GetNextSample([In] unsigned int* pdwStatusFlags,[In] unsigned short* pwStreamNumber,[In] IMFSample** ppISample)</unmanaged>	
        /// <unmanaged-short>IMFASFSplitter::GetNextSample</unmanaged-short>	
        public void GetNextSample(int dwStatusFlagsRef, short wStreamNumberRef, out SharpDX.MediaFoundation.Sample iSampleOut)
        {
            unsafe
            {
                IntPtr iSampleOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &dwStatusFlagsRef, &wStreamNumberRef, &iSampleOut_, ((void**)(*(void**)_nativePointer))[9]);
                iSampleOut = (iSampleOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Sample(iSampleOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Resets the Advanced Systems Format (ASF) splitter and releases all pending samples.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Any samples waiting to be retrieved when <strong>Flush</strong> is called are lost.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFSplitter::Flush']/*"/>	
        /// <msdn-id>ms703013</msdn-id>	
        /// <unmanaged>HRESULT IMFASFSplitter::Flush()</unmanaged>	
        /// <unmanaged-short>IMFASFSplitter::Flush</unmanaged-short>	
        public void Flush()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the send time of the last sample received.</p>	
        /// </summary>	
        /// <param name="dwLastSendTimeRef"><dd> <p>Receives the send time of the last sample received.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pdwLastSendTime</em> is <strong><c>null</c></strong>.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFSplitter::GetLastSendTime']/*"/>	
        /// <msdn-id>ms697272</msdn-id>	
        /// <unmanaged>HRESULT IMFASFSplitter::GetLastSendTime([In] unsigned int* pdwLastSendTime)</unmanaged>	
        /// <unmanaged-short>IMFASFSplitter::GetLastSendTime</unmanaged-short>	
        public void GetLastSendTime(int dwLastSendTimeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &dwLastSendTimeRef, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Retrieves information about an existing payload extension.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamConfig']/*"/>	
    /// <msdn-id>ms697305</msdn-id>	
    /// <unmanaged>IMFASFStreamConfig</unmanaged>	
    /// <unmanaged-short>IMFASFStreamConfig</unmanaged-short>	
    [Guid("9E8AE8D2-DBBD-4200-9ACA-06E6DF484913")]
    public partial class ASFStreamConfig : SharpDX.MediaFoundation.MediaAttributes
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ASFStreamConfig"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ASFStreamConfig(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ASFStreamConfig"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ASFStreamConfig(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ASFStreamConfig(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the stream number of the stream.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamConfig::GetStreamNumber']/*"/>	
        /// <msdn-id>ms703172</msdn-id>	
        /// <unmanaged>GetStreamNumber / SetStreamNumber</unmanaged>	
        /// <unmanaged-short>GetStreamNumber</unmanaged-short>	
        /// <unmanaged>unsigned short IMFASFStreamConfig::GetStreamNumber()</unmanaged>
        public short StreamNumber
        {
            get { return GetStreamNumber(); }
            set { SetStreamNumber(value); }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the media type of the stream.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>To reduce unnecessary copying, the method returns a reference to the media type  that is stored internally by the object. Do not modify the returned media type,  as the results are not defined.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamConfig::GetMediaType']/*"/>	
        /// <msdn-id>ms697489</msdn-id>	
        /// <unmanaged>GetMediaType / SetMediaType</unmanaged>	
        /// <unmanaged-short>GetMediaType</unmanaged-short>	
        /// <unmanaged>HRESULT IMFASFStreamConfig::GetMediaType([In] IMFMediaType** ppIMediaType)</unmanaged>
        public SharpDX.MediaFoundation.MediaType MediaType
        {
            get { SharpDX.MediaFoundation.MediaType __output__; GetMediaType(out __output__); return __output__; }
            set { SetMediaType(value); }
        }

        /// <summary>	
        /// <p>Gets the major media type of the stream. </p>	
        /// </summary>	
        /// <param name="guidStreamTypeRef"><dd> <p>Receives the major media type for the stream. For a list of possible values, see Major Media Types. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamConfig::GetStreamType']/*"/>	
        /// <msdn-id>ms697390</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamConfig::GetStreamType([In] GUID* pguidStreamType)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamConfig::GetStreamType</unmanaged-short>	
        public void GetStreamType(System.Guid guidStreamTypeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidStreamTypeRef, ((void**)(*(void**)_nativePointer))[33]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the stream number of the stream.</p>	
        /// </summary>	
        /// <returns><p>The method returns the  stream number.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamConfig::GetStreamNumber']/*"/>	
        /// <msdn-id>ms703172</msdn-id>	
        /// <unmanaged>unsigned short IMFASFStreamConfig::GetStreamNumber()</unmanaged>	
        /// <unmanaged-short>IMFASFStreamConfig::GetStreamNumber</unmanaged-short>	
        internal short GetStreamNumber()
        {
            unsafe
            {
                short __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callishort(_nativePointer, ((void**)(*(void**)_nativePointer))[34]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> </p><p>Assigns a stream number to the stream.</p>	
        /// </summary>	
        /// <param name="wStreamNum"><dd> <p>The number to assign to the stream.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Stream numbers start from 1 and do not need to be sequential.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamConfig::SetStreamNumber']/*"/>	
        /// <msdn-id>ms697298</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamConfig::SetStreamNumber([In] unsigned short wStreamNum)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamConfig::SetStreamNumber</unmanaged-short>	
        internal void SetStreamNumber(short wStreamNum)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, wStreamNum, ((void**)(*(void**)_nativePointer))[35]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the media type of the stream.</p>	
        /// </summary>	
        /// <param name="iMediaTypeOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type object associated with the stream. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To reduce unnecessary copying, the method returns a reference to the media type  that is stored internally by the object. Do not modify the returned media type,  as the results are not defined.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamConfig::GetMediaType']/*"/>	
        /// <msdn-id>ms697489</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamConfig::GetMediaType([In] IMFMediaType** ppIMediaType)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamConfig::GetMediaType</unmanaged-short>	
        internal void GetMediaType(out SharpDX.MediaFoundation.MediaType iMediaTypeOut)
        {
            unsafe
            {
                IntPtr iMediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &iMediaTypeOut_, ((void**)(*(void**)_nativePointer))[36]);
                iMediaTypeOut = (iMediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(iMediaTypeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the media type for the Advanced Systems Format (ASF) stream configuration object.</p>	
        /// </summary>	
        /// <param name="iMediaTypeRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of a configured media type object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Some validation of the media type is performed by this method. However, a media type can be successfully set, but cause an error when the stream is added to the profile.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamConfig::SetMediaType']/*"/>	
        /// <msdn-id>ms697185</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamConfig::SetMediaType([In] IMFMediaType* pIMediaType)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamConfig::SetMediaType</unmanaged-short>	
        internal void SetMediaType(SharpDX.MediaFoundation.MediaType iMediaTypeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iMediaTypeRef == null) ? IntPtr.Zero : iMediaTypeRef.NativePointer), ((void**)(*(void**)_nativePointer))[37]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of payload extensions that are configured for the stream.</p>	
        /// </summary>	
        /// <param name="cPayloadExtensionsRef"><dd> <p>Receives the number of payload extensions.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamConfig::GetPayloadExtensionCount']/*"/>	
        /// <msdn-id>ms696251</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamConfig::GetPayloadExtensionCount([In] unsigned short* pcPayloadExtensions)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamConfig::GetPayloadExtensionCount</unmanaged-short>	
        public void GetPayloadExtensionCount(short cPayloadExtensionsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &cPayloadExtensionsRef, ((void**)(*(void**)_nativePointer))[38]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves information about an existing payload extension.</p>	
        /// </summary>	
        /// <param name="wPayloadExtensionNumber"><dd> <p>The payload extension index. Valid indexes range from 0, to one less than the number of extensions obtained by calling <strong><see cref="SharpDX.MediaFoundation.ASFStreamConfig.GetPayloadExtensionCount"/></strong>.</p> </dd></param>	
        /// <param name="guidExtensionSystemIDRef"><dd> <p>Receives a <see cref="System.Guid"/> that identifies the payload extension. For a list of predefined payload extensions, see ASF Payload Extension GUIDs. Applications can also define custom payload extensions.</p> </dd></param>	
        /// <param name="cbExtensionDataSizeRef"><dd> <p>Receives the number of bytes added to each sample for the extension.</p> </dd></param>	
        /// <param name="bExtensionSystemInfoRef"><dd> <p>Pointer to a buffer that receives information about this extension system. This information is the same for all samples and is stored in the content header (not in each sample). This parameter can be <strong><c>null</c></strong>. To find the required size of the buffer, set this parameter to <strong><c>null</c></strong>; the size is returned in <em>pcbExtensionSystemInfo</em>.</p> </dd></param>	
        /// <param name="cbExtensionSystemInfoRef"><dd> <p>On input, specifies the size of the buffer pointed to by <em>pbExtensionSystemInfo</em>. On output, receives the required size of the <em>pbExtensionSystemInfo</em> buffer in bytes.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.BufferTooSmall"/></strong></dt> </dl> </td><td> <p>The buffer specified in <em>pbExtensionSystemInfo</em> is too small.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidIndex"/></strong></dt> </dl> </td><td> <p>The <em>wPayloadExtensionNumber</em> parameter is out of range.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamConfig::GetPayloadExtension']/*"/>	
        /// <msdn-id>ms697305</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamConfig::GetPayloadExtension([In] unsigned short wPayloadExtensionNumber,[In] GUID* pguidExtensionSystemID,[In] unsigned short* pcbExtensionDataSize,[In] unsigned char* pbExtensionSystemInfo,[In] unsigned int* pcbExtensionSystemInfo)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamConfig::GetPayloadExtension</unmanaged-short>	
        public void GetPayloadExtension(short wPayloadExtensionNumber, System.Guid guidExtensionSystemIDRef, short cbExtensionDataSizeRef, byte bExtensionSystemInfoRef, int cbExtensionSystemInfoRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, wPayloadExtensionNumber, &guidExtensionSystemIDRef, &cbExtensionDataSizeRef, &bExtensionSystemInfoRef, &cbExtensionSystemInfoRef, ((void**)(*(void**)_nativePointer))[39]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Configures a payload extension for the stream.</p>	
        /// </summary>	
        /// <param name="guidExtensionSystemID"><dd> <p>Pointer to a <see cref="System.Guid"/> that identifies the payload extension. For a list of predefined payload extensions, see ASF Payload Extension GUIDs. Applications can also define custom payload extensions.</p> </dd></param>	
        /// <param name="cbExtensionDataSize"><dd> <p>Number of bytes added to each sample for the extension.</p> </dd></param>	
        /// <param name="bExtensionSystemInfoRef"><dd> <p>A reference to a buffer that contains information about this extension system. This information is the same for all samples and is stored in the content header (not with each sample). This parameter can be <strong><c>null</c></strong> if <em>cbExtensionSystemInfo</em> is 0.</p> </dd></param>	
        /// <param name="cbExtensionSystemInfo"><dd> <p>Amount of data, in bytes, that describes this extension system. If this value is 0, then <em>pbExtensionSystemInfo</em> can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamConfig::AddPayloadExtension']/*"/>	
        /// <msdn-id>ms697229</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamConfig::AddPayloadExtension([In] GUID guidExtensionSystemID,[In] unsigned short cbExtensionDataSize,[In] unsigned char* pbExtensionSystemInfo,[In] unsigned int cbExtensionSystemInfo)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamConfig::AddPayloadExtension</unmanaged-short>	
        public void AddPayloadExtension(System.Guid guidExtensionSystemID, short cbExtensionDataSize, byte bExtensionSystemInfoRef, int cbExtensionSystemInfo)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, guidExtensionSystemID, cbExtensionDataSize, &bExtensionSystemInfoRef, cbExtensionSystemInfo, ((void**)(*(void**)_nativePointer))[40]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Removes all payload extensions that are configured for the stream.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>None.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamConfig::RemoveAllPayloadExtensions']/*"/>	
        /// <msdn-id>ms699009</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamConfig::RemoveAllPayloadExtensions()</unmanaged>	
        /// <unmanaged-short>IMFASFStreamConfig::RemoveAllPayloadExtensions</unmanaged-short>	
        public void RemoveAllPayloadExtensions()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[41]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Creates a copy of the Advanced Systems Format (ASF) stream configuration object.</p>	
        /// </summary>	
        /// <param name="iStreamConfigOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.ASFStreamConfig"/></strong> interface of the new object. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The cloned object is completely independent of the original.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamConfig::Clone']/*"/>	
        /// <msdn-id>ms703117</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamConfig::Clone([In] IMFASFStreamConfig** ppIStreamConfig)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamConfig::Clone</unmanaged-short>	
        public void Clone(out SharpDX.MediaFoundation.ASFStreamConfig iStreamConfigOut)
        {
            unsafe
            {
                IntPtr iStreamConfigOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &iStreamConfigOut_, ((void**)(*(void**)_nativePointer))[42]);
                iStreamConfigOut = (iStreamConfigOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFStreamConfig(iStreamConfigOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><strong>Note</strong>??This interface is not implemented in this version of Media Foundation.?<p>Adds a stream to the stream priority list.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The stream priority list is built by appending entries to the list with each call to <strong>AddStream</strong>. The list is evaluated in descending order of importance. The most important stream should be added first, and the least important should be added last.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamPrioritization']/*"/>	
    /// <msdn-id>ms696987</msdn-id>	
    /// <unmanaged>IMFASFStreamPrioritization</unmanaged>	
    /// <unmanaged-short>IMFASFStreamPrioritization</unmanaged-short>	
    [Guid("699bdc27-bbaf-49ff-8e38-9c39c9b5e088")]
    public partial class ASFStreamPrioritization : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ASFStreamPrioritization"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ASFStreamPrioritization(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ASFStreamPrioritization"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ASFStreamPrioritization(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ASFStreamPrioritization(nativePointer);
        }


        /// <summary>	
        /// <p> </p><strong>Note</strong>??This interface is not implemented in this version of Media Foundation.?<p>Retrieves the number of entries in the stream priority list.</p>	
        /// </summary>	
        /// <param name="dwStreamCountRef"><dd> <p>Receives the number of streams in the stream priority list.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamPrioritization::GetStreamCount']/*"/>	
        /// <msdn-id>bb970449</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamPrioritization::GetStreamCount([In] unsigned int* pdwStreamCount)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamPrioritization::GetStreamCount</unmanaged-short>	
        public void GetStreamCount(int dwStreamCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &dwStreamCountRef, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Note</strong>??This interface is not implemented in this version of Media Foundation.?<p>Retrieves the stream number of a stream in the stream priority list.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>Zero-based index of the entry to retrieve from the stream priority list. To get the number of entries in the priority list, call <strong><see cref="SharpDX.MediaFoundation.ASFStreamPrioritization.GetStreamCount"/></strong>.</p> </dd></param>	
        /// <param name="wStreamNumberRef"><dd> <p>Receives the stream number of the stream priority entry.</p> </dd></param>	
        /// <param name="wStreamFlagsRef"><dd> <p>Receives a Boolean value. If <strong>TRUE</strong>, the stream is mandatory.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument or the <em>dwStreamIndex</em> parameter is out of range.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamPrioritization::GetStream']/*"/>	
        /// <msdn-id>ms697005</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamPrioritization::GetStream([In] unsigned int dwStreamIndex,[In] unsigned short* pwStreamNumber,[In] unsigned short* pwStreamFlags)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamPrioritization::GetStream</unmanaged-short>	
        public void GetStream(int dwStreamIndex, short wStreamNumberRef, short wStreamFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, &wStreamNumberRef, &wStreamFlagsRef, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Note</strong>??This interface is not implemented in this version of Media Foundation.?<p>Adds a stream to the stream priority list.</p>	
        /// </summary>	
        /// <param name="wStreamNumber"><dd> <p>Stream number of the stream to add.</p> </dd></param>	
        /// <param name="wStreamFlags"><dd> <p>If <strong>TRUE</strong>, the stream is mandatory.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid stream number.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The stream priority list is built by appending entries to the list with each call to <strong>AddStream</strong>. The list is evaluated in descending order of importance. The most important stream should be added first, and the least important should be added last.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamPrioritization::AddStream']/*"/>	
        /// <msdn-id>ms696987</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamPrioritization::AddStream([In] unsigned short wStreamNumber,[In] unsigned short wStreamFlags)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamPrioritization::AddStream</unmanaged-short>	
        public void AddStream(short wStreamNumber, short wStreamFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, wStreamNumber, wStreamFlags, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Note</strong>??This interface is not implemented in this version of Media Foundation.?<p>Removes a stream from the stream priority list.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>Index of the entry in the stream priority list to remove. Values range from zero, to one less than the stream count retrieved by calling <strong><see cref="SharpDX.MediaFoundation.ASFStreamPrioritization.GetStreamCount"/></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When a stream is removed from the stream priority list, the index values of all streams that follow it in the list are decremented.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamPrioritization::RemoveStream']/*"/>	
        /// <msdn-id>bb970482</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamPrioritization::RemoveStream([In] unsigned int dwStreamIndex)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamPrioritization::RemoveStream</unmanaged-short>	
        public void RemoveStream(int dwStreamIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Note</strong>??This interface is not implemented in this version of Media Foundation.?<p>Creates a copy of the ASF stream prioritization object.</p>	
        /// </summary>	
        /// <param name="iStreamPrioritizationOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.ASFStreamPrioritization"/></strong> interface of the new object. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The new object is completely independent of the original.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamPrioritization::Clone']/*"/>	
        /// <msdn-id>ms704679</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamPrioritization::Clone([In] IMFASFStreamPrioritization** ppIStreamPrioritization)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamPrioritization::Clone</unmanaged-short>	
        public void Clone(out SharpDX.MediaFoundation.ASFStreamPrioritization iStreamPrioritizationOut)
        {
            unsafe
            {
                IntPtr iStreamPrioritizationOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &iStreamPrioritizationOut_, ((void**)(*(void**)_nativePointer))[7]);
                iStreamPrioritizationOut = (iStreamPrioritizationOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ASFStreamPrioritization(iStreamPrioritizationOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Retrieves the number of bandwidth steps that exist for the content. This method is used for multiple bit rate (MBR) content.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Bandwidth steps are bandwidth levels used for multiple bit rate (MBR) content. If you stream MBR content, you can choose the bandwidth step that matches the network conditions to avoid interruptions during playback.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamSelector']/*"/>	
    /// <msdn-id>ms698868</msdn-id>	
    /// <unmanaged>IMFASFStreamSelector</unmanaged>	
    /// <unmanaged-short>IMFASFStreamSelector</unmanaged-short>	
    [Guid("d01bad4a-4fa0-4a60-9349-c27e62da9d41")]
    public partial class ASFStreamSelector : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ASFStreamSelector"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ASFStreamSelector(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ASFStreamSelector"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ASFStreamSelector(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ASFStreamSelector(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Sets options for the stream selector.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamSelector::SetStreamSelectorFlags']/*"/>	
        /// <msdn-id>ms701635</msdn-id>	
        /// <unmanaged>SetStreamSelectorFlags</unmanaged>	
        /// <unmanaged-short>SetStreamSelectorFlags</unmanaged-short>	
        /// <unmanaged>HRESULT IMFASFStreamSelector::SetStreamSelectorFlags([In] unsigned int dwStreamSelectorFlags)</unmanaged>
        public int StreamSelectorFlags
        {
            set { SetStreamSelectorFlags(value); }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of streams that are in the Advanced Systems Format (ASF) content.</p>	
        /// </summary>	
        /// <param name="cStreamsRef"><dd> <p>Receives the number of streams in the content.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamSelector::GetStreamCount']/*"/>	
        /// <msdn-id>ms704621</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamSelector::GetStreamCount([In] unsigned int* pcStreams)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamSelector::GetStreamCount</unmanaged-short>	
        public void GetStreamCount(int cStreamsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &cStreamsRef, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of outputs for the Advanced Systems Format (ASF) content.</p>	
        /// </summary>	
        /// <param name="cOutputsRef"><dd> <p>Receives the number of outputs.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Outputs are streams in the ASF data section that will be parsed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamSelector::GetOutputCount']/*"/>	
        /// <msdn-id>ms694076</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamSelector::GetOutputCount([In] unsigned int* pcOutputs)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamSelector::GetOutputCount</unmanaged-short>	
        public void GetOutputCount(int cOutputsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &cOutputsRef, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of streams associated with an output.</p>	
        /// </summary>	
        /// <param name="dwOutputNum"><dd> <p>The output number for which to retrieve the stream count.</p> </dd></param>	
        /// <param name="cStreamsRef"><dd> <p>Receives the number of streams associated with the output.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid output number.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>An output is a stream in an ASF data section that will be parsed. If mutual exclusion is used, mutually exclusive streams share the same output.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamSelector::GetOutputStreamCount']/*"/>	
        /// <msdn-id>ms700815</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamSelector::GetOutputStreamCount([In] unsigned int dwOutputNum,[In] unsigned int* pcStreams)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamSelector::GetOutputStreamCount</unmanaged-short>	
        public void GetOutputStreamCount(int dwOutputNum, int cStreamsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputNum, &cStreamsRef, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the stream numbers for all of the streams that are associated with an output.</p>	
        /// </summary>	
        /// <param name="dwOutputNum"><dd> <p>The output number for which to retrieve stream numbers.</p> </dd></param>	
        /// <param name="rgwStreamNumbers"><dd> <p>Address of an array that receives the stream numbers associated with the output. The caller allocates the array. The array size must be at least as large as the value returned by the <strong><see cref="SharpDX.MediaFoundation.ASFStreamSelector.GetOutputStreamCount"/></strong> method.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid output number.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>An output is a stream in an ASF data section that will be parsed. If mutual exclusion is used, mutually exclusive streams share the same output.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamSelector::GetOutputStreamNumbers']/*"/>	
        /// <msdn-id>ms697025</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamSelector::GetOutputStreamNumbers([In] unsigned int dwOutputNum,[In] unsigned short* rgwStreamNumbers)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamSelector::GetOutputStreamNumbers</unmanaged-short>	
        public void GetOutputStreamNumbers(int dwOutputNum, short rgwStreamNumbers)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputNum, &rgwStreamNumbers, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the output number associated with a stream.</p>	
        /// </summary>	
        /// <param name="wStreamNum"><dd> <p>The stream number for which to retrieve an output number.</p> </dd></param>	
        /// <param name="dwOutputRef"><dd> <p>Receives the output number.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid stream number.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Outputs are streams in the ASF data section that will be parsed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamSelector::GetOutputFromStream']/*"/>	
        /// <msdn-id>ms701979</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamSelector::GetOutputFromStream([In] unsigned short wStreamNum,[In] unsigned int* pdwOutput)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamSelector::GetOutputFromStream</unmanaged-short>	
        public void GetOutputFromStream(short wStreamNum, int dwOutputRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, wStreamNum, &dwOutputRef, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the manual output override selection that is set for a stream.</p>	
        /// </summary>	
        /// <param name="dwOutputNum"><dd> <p>Stream number for which to retrieve the output override selection.</p> </dd></param>	
        /// <param name="selectionRef"><dd> <p>Receives the output override selection. The value is a member of the <strong><see cref="SharpDX.MediaFoundation.AsfSelectionStatus"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamSelector::GetOutputOverride']/*"/>	
        /// <msdn-id>ms697510</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamSelector::GetOutputOverride([In] unsigned int dwOutputNum,[In] ASF_SELECTION_STATUS* pSelection)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamSelector::GetOutputOverride</unmanaged-short>	
        public void GetOutputOverride(int dwOutputNum, SharpDX.MediaFoundation.AsfSelectionStatus selectionRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputNum, &selectionRef, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the selection status of an output, overriding other selection criteria.</p>	
        /// </summary>	
        /// <param name="dwOutputNum"><dd> <p>Output number for which to set selection.</p> </dd></param>	
        /// <param name="selection"><dd> <p>Member of the <strong><see cref="SharpDX.MediaFoundation.AsfSelectionStatus"/></strong> enumeration specifying the level of selection for the output.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamSelector::SetOutputOverride']/*"/>	
        /// <msdn-id>ms703122</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamSelector::SetOutputOverride([In] unsigned int dwOutputNum,[In] ASF_SELECTION_STATUS Selection)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamSelector::SetOutputOverride</unmanaged-short>	
        public void SetOutputOverride(int dwOutputNum, SharpDX.MediaFoundation.AsfSelectionStatus selection)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputNum, unchecked((int)selection), ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of mutual exclusion objects associated with an output.</p>	
        /// </summary>	
        /// <param name="dwOutputNum"><dd> <p>Output number for which to retrieve the count of mutually exclusive relationships.</p> </dd></param>	
        /// <param name="cMutexesRef"><dd> <p>Receives the number of mutual exclusions.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamSelector::GetOutputMutexCount']/*"/>	
        /// <msdn-id>ms703918</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamSelector::GetOutputMutexCount([In] unsigned int dwOutputNum,[In] unsigned int* pcMutexes)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamSelector::GetOutputMutexCount</unmanaged-short>	
        public void GetOutputMutexCount(int dwOutputNum, int cMutexesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputNum, &cMutexesRef, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a mutual exclusion object for an output.</p>	
        /// </summary>	
        /// <param name="dwOutputNum"><dd> <p>Output number for which to retrieve a mutual exclusion object.</p> </dd></param>	
        /// <param name="dwMutexNum"><dd> <p>Mutual exclusion number. This is an index of mutually exclusive relationships associated with the output. Set to a number between 0, and 1 less than the number of mutual exclusion objects retrieved by calling <strong><see cref="SharpDX.MediaFoundation.ASFStreamSelector.GetOutputMutexCount"/></strong>.</p> </dd></param>	
        /// <param name="mutexOut"><dd> <p>Receives a reference to the mutual exclusion object's <strong><see cref="SharpDX.ComObject"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Outputs are streams in the ASF data section that will be parsed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamSelector::GetOutputMutex']/*"/>	
        /// <msdn-id>ms703819</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamSelector::GetOutputMutex([In] unsigned int dwOutputNum,[In] unsigned int dwMutexNum,[In] IUnknown** ppMutex)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamSelector::GetOutputMutex</unmanaged-short>	
        public void GetOutputMutex(int dwOutputNum, int dwMutexNum, out SharpDX.ComObject mutexOut)
        {
            unsafe
            {
                IntPtr mutexOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputNum, dwMutexNum, &mutexOut_, ((void**)(*(void**)_nativePointer))[11]);
                mutexOut = (mutexOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(mutexOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Selects a mutual exclusion record to use for a mutual exclusion object associated with an output.</p>	
        /// </summary>	
        /// <param name="dwOutputNum"><dd> <p>The output number for which to set a stream.</p> </dd></param>	
        /// <param name="dwMutexNum"><dd> <p>Index of the mutual exclusion for which to select.</p> </dd></param>	
        /// <param name="wSelectedRecord"><dd> <p>Record of the specified mutual exclusion to select.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>An output is a stream in an Advanced Systems Format (ASF) data section that will be parsed. If mutual exclusion is used, mutually exclusive streams share the same output.</p><p>An ASF file can contain multiple mutually exclusive relationships, such as a file with both language based and bit-rate based mutual exclusion. If an output is involved in multiple mutually exclusive relationships, a record from each must be selected.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamSelector::SetOutputMutexSelection']/*"/>	
        /// <msdn-id>ms704822</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamSelector::SetOutputMutexSelection([In] unsigned int dwOutputNum,[In] unsigned int dwMutexNum,[In] unsigned short wSelectedRecord)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamSelector::SetOutputMutexSelection</unmanaged-short>	
        public void SetOutputMutexSelection(int dwOutputNum, int dwMutexNum, short wSelectedRecord)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputNum, dwMutexNum, wSelectedRecord, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of bandwidth steps that exist for the content. This method is used for multiple bit rate (MBR) content.</p>	
        /// </summary>	
        /// <param name="cStepCountRef"><dd> <p>Receives the number of bandwidth steps.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Bandwidth steps are bandwidth levels used for multiple bit rate (MBR) content. If you stream MBR content, you can choose the bandwidth step that matches the network conditions to avoid interruptions during playback.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamSelector::GetBandwidthStepCount']/*"/>	
        /// <msdn-id>ms698868</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamSelector::GetBandwidthStepCount([In] unsigned int* pcStepCount)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamSelector::GetBandwidthStepCount</unmanaged-short>	
        public void GetBandwidthStepCount(int cStepCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &cStepCountRef, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the stream numbers that apply to a bandwidth step. This method is used for multiple bit rate (MBR) content.</p>	
        /// </summary>	
        /// <param name="dwStepNum"><dd> <p>Bandwidth step number for which to retrieve information. Set this value to a number between 0, and 1 less than the number of bandwidth steps returned by <strong><see cref="SharpDX.MediaFoundation.ASFStreamSelector.GetBandwidthStepCount"/></strong>.</p> </dd></param>	
        /// <param name="dwBitrateRef"><dd> <p>Receives the bit rate associated with the bandwidth step.</p> </dd></param>	
        /// <param name="rgwStreamNumbers"><dd> <p>Address of an array that receives the stream numbers. The caller allocates the array. The array size must be at least as large as the value returned by the <strong><see cref="SharpDX.MediaFoundation.ASFStreamSelector.GetStreamCount"/></strong> method.</p> </dd></param>	
        /// <param name="rgSelections"><dd> <p>Address of an array that receives the selection status of each stream, as an <strong><see cref="SharpDX.MediaFoundation.AsfSelectionStatus"/></strong> value. The members of this array correspond to the members of the <em>rgwStreamNumbers</em> array by index. The caller allocates the array. The array size must be at least as large as the value returned by the <strong><see cref="SharpDX.MediaFoundation.ASFStreamSelector.GetStreamCount"/></strong> method.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Bandwidth steps are bandwidth levels used for MBR content. If you stream MBR content, you can choose the bandwidth step that matches the network conditions to avoid interruptions during playback.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamSelector::GetBandwidthStep']/*"/>	
        /// <msdn-id>ms700131</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamSelector::GetBandwidthStep([In] unsigned int dwStepNum,[In] unsigned int* pdwBitrate,[In] unsigned short* rgwStreamNumbers,[In] ASF_SELECTION_STATUS* rgSelections)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamSelector::GetBandwidthStep</unmanaged-short>	
        public void GetBandwidthStep(int dwStepNum, int dwBitrateRef, short rgwStreamNumbers, SharpDX.MediaFoundation.AsfSelectionStatus rgSelections)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStepNum, &dwBitrateRef, &rgwStreamNumbers, &rgSelections, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the index of a bandwidth step that is appropriate for a specified bit rate. This method is used for multiple bit rate (MBR) content.</p>	
        /// </summary>	
        /// <param name="dwBitrate"><dd> <p>The bit rate to find a bandwidth step for.</p> </dd></param>	
        /// <param name="dwStepNumRef"><dd> <p>Receives the step number. Use this number to retrieve information about the step by calling <strong><see cref="SharpDX.MediaFoundation.ASFStreamSelector.GetBandwidthStep"/></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>In a streaming multiple bit rate (MBR) scenario, call this method with the current data rate of the network connection to determine the correct step to use. You can also call this method periodically throughout streaming to ensure that the best step is used.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamSelector::BitrateToStepNumber']/*"/>	
        /// <msdn-id>ms704645</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamSelector::BitrateToStepNumber([In] unsigned int dwBitrate,[In] unsigned int* pdwStepNum)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamSelector::BitrateToStepNumber</unmanaged-short>	
        public void BitrateToStepNumber(int dwBitrate, int dwStepNumRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwBitrate, &dwStepNumRef, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets options for the stream selector.</p>	
        /// </summary>	
        /// <param name="dwStreamSelectorFlags"><dd> <p>Bitwise <strong>OR</strong> of zero or more members of the <strong>MFASF_STREAMSELECTOR_FLAGS</strong> enumeration specifying the options to use.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFASFStreamSelector::SetStreamSelectorFlags']/*"/>	
        /// <msdn-id>ms701635</msdn-id>	
        /// <unmanaged>HRESULT IMFASFStreamSelector::SetStreamSelectorFlags([In] unsigned int dwStreamSelectorFlags)</unmanaged>	
        /// <unmanaged-short>IMFASFStreamSelector::SetStreamSelectorFlags</unmanaged-short>	
        internal void SetStreamSelectorFlags(int dwStreamSelectorFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamSelectorFlags, ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Provides information about the result of an asynchronous operation. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Use this interface to complete an asynchronous operation. You get a reference to this interface when your callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. To complete the operation, pass the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> reference to the <strong>End...</strong> method that corresponds to the <strong>Begin...</strong> method that starts the operation. For example, if the asynchronous method is named <strong>BeginRead</strong>, call the <strong>EndRead</strong> method. For more information, see Calling Asynchronous Methods.</p><p>If you are implementing an asynchronous method, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAsyncResult"/></strong> to create an instance of this object. For more information, see Writing an Asynchronous Method.</p><p>Any custom implementation of this interface must inherit the <strong><see cref="SharpDX.MediaFoundation.Mfasyncresult"/></strong> structure.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAsyncResult']/*"/>	
    /// <msdn-id>ms700196</msdn-id>	
    /// <unmanaged>IMFAsyncResult</unmanaged>	
    /// <unmanaged-short>IMFAsyncResult</unmanaged-short>	
    [Guid("ac6b7889-0740-4d51-8619-905994a55cc6")]
    public partial class AsyncResult : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.AsyncResult"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public AsyncResult(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.AsyncResult"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.AsyncResult(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.AsyncResult(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Returns the state object specified by the caller in the asynchronous <strong>Begin</strong> method.</p>	
        /// </summary>	
        /// <param name="unkStateOut"><dd> <p>Receives a reference to the state object's <strong><see cref="SharpDX.ComObject"/></strong> interface. If the value is not <strong><c>null</c></strong>, the caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>There is no state object associated with this asynchronous result.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The caller of the asynchronous method specifies the state object, and can use it for any caller-defined purpose. The state object can be <strong><c>null</c></strong>. If the state object is <strong><c>null</c></strong>, <strong>GetState</strong> returns <strong>E_POINTER</strong>.</p><p>If you are implementing an asynchronous method, set the state object on the through the <em>punkState</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAsyncResult"/></strong> function.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAsyncResult::GetState']/*"/>	
        /// <msdn-id>bb970576</msdn-id>	
        /// <unmanaged>HRESULT IMFAsyncResult::GetState([Out] void** ppunkState)</unmanaged>	
        /// <unmanaged-short>IMFAsyncResult::GetState</unmanaged-short>	
        internal void GetState(out System.IntPtr unkStateOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* unkStateOut_ = &unkStateOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unkStateOut_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Returns the status of the asynchronous operation.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The operation completed successfully.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAsyncResult::GetStatus']/*"/>	
        /// <msdn-id>ms702095</msdn-id>	
        /// <unmanaged>HRESULT IMFAsyncResult::GetStatus()</unmanaged>	
        /// <unmanaged-short>IMFAsyncResult::GetStatus</unmanaged-short>	
        internal SharpDX.Result GetStatus()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
                return __result__;
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the status of the asynchronous operation.</p>	
        /// </summary>	
        /// <param name="hrStatus"><dd> <p>The status of the asynchronous operation.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If you implement an asynchronous method, call <strong>SetStatus</strong> to set the status code for the operation.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAsyncResult::SetStatus']/*"/>	
        /// <msdn-id>bb970435</msdn-id>	
        /// <unmanaged>HRESULT IMFAsyncResult::SetStatus([In] HRESULT hrStatus)</unmanaged>	
        /// <unmanaged-short>IMFAsyncResult::SetStatus</unmanaged-short>	
        internal void SetStatus(SharpDX.Result hrStatus)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint45(_nativePointer, hrStatus, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Returns an object associated with the asynchronous operation. The type of object, if any, depends on the asynchronous method that was called.</p>	
        /// </summary>	
        /// <param name="objectOut"><dd> <p>Receives a reference to the object's <strong><see cref="SharpDX.ComObject"/></strong> interface. If no object is associated with the operation, this parameter receives the value <strong><c>null</c></strong>. If the value is not <strong><c>null</c></strong>, the caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>There is no object associated with this asynchronous result.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Typically, this object is used by the component that implements the asynchronous method. It provides a way for the function that invokes the callback to pass information to the asynchronous <strong>End...</strong> method that completes the operation.</p><p>If you are implementing an asynchronous method, you can set the object through the <em>punkObject</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAsyncResult"/></strong> function.</p><p>If the asynchronous result object's internal <strong><see cref="SharpDX.ComObject"/></strong> reference is <strong><c>null</c></strong>, the method returns <strong>E_POINTER</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAsyncResult::GetObjectW']/*"/>	
        /// <msdn-id>bb970500</msdn-id>	
        /// <unmanaged>HRESULT IMFAsyncResult::GetObjectW([Out] IUnknown** ppObject)</unmanaged>	
        /// <unmanaged-short>IMFAsyncResult::GetObjectW</unmanaged-short>	
        internal void GetObject(out SharpDX.ComObject objectOut)
        {
            unsafe
            {
                IntPtr objectOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &objectOut_, ((void**)(*(void**)_nativePointer))[6]);
                objectOut = (objectOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(objectOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Returns the state object specified by the caller in the asynchronous <strong>Begin</strong> method, without incrementing the object's reference count.</p>	
        /// </summary>	
        /// <returns><p>Returns a reference to the state object's <strong><see cref="SharpDX.ComObject"/></strong> interface, or <strong><c>null</c></strong> if no object was set. This reference does not have an outstanding reference count. If you store this reference, you must call <strong>AddRef</strong> on the reference.</p></returns>	
        /// <remarks>	
        /// <p>This method cannot be called remotely.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAsyncResult::GetStateNoAddRef']/*"/>	
        /// <msdn-id>ms696238</msdn-id>	
        /// <unmanaged>IUnknown* IMFAsyncResult::GetStateNoAddRef()</unmanaged>	
        /// <unmanaged-short>IMFAsyncResult::GetStateNoAddRef</unmanaged-short>	
        internal SharpDX.ComObject GetStateNoAddRef()
        {
            unsafe
            {
                SharpDX.ComObject __result__;
                __result__ =
                new SharpDX.ComObject((IntPtr)SharpDX.MediaFoundation.LocalInterop.CalliSystemIntPtr(_nativePointer, ((void**)(*(void**)_nativePointer))[7]));
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>[<strong><see cref="SharpDX.MediaFoundation.AudioMediaType"/></strong> is no longer available for use as of Windows?7. Instead, use the media type attributes to get the properties of the audio format.]</p><p> Represents a description of an audio format.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><strong>Windows Server?2008 and Windows?Vista:??</strong>If the major type of a media type is <strong><see cref="SharpDX.MediaFoundation.MediaTypeGuids.Audio"/></strong>, you can query the media type object for the <strong><see cref="SharpDX.MediaFoundation.AudioMediaType"/></strong> interface.</p><p> To convert an audio media type into a <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateWaveFormatExFromMFMediaType"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioMediaType']/*"/>	
    /// <msdn-id>aa473793</msdn-id>	
    /// <unmanaged>IMFAudioMediaType</unmanaged>	
    /// <unmanaged-short>IMFAudioMediaType</unmanaged-short>	
    [Guid("26a0adc3-ce26-4672-9304-69552edd3faf")]
    public partial class AudioMediaType : SharpDX.MediaFoundation.MediaType
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.AudioMediaType"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public AudioMediaType(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.AudioMediaType"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.AudioMediaType(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.AudioMediaType(nativePointer);
        }


        /// <summary>	
        /// <p>[<strong>GetAudioFormat</strong> is no longer available for use as of Windows?7. Instead, use the media type attributes to get the properties of the audio format.]</p><p> Returns a reference to a <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure that describes the audio format.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If you need to convert the media type into a <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateWaveFormatExFromMFMediaType"/></strong>.</p><p> There are no guarantees about how long the returned reference is valid.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioMediaType::GetAudioFormat']/*"/>	
        /// <msdn-id>aa473803</msdn-id>	
        /// <unmanaged>GetAudioFormat</unmanaged>	
        /// <unmanaged-short>GetAudioFormat</unmanaged-short>	
        /// <unmanaged>const WAVEFORMATEX* IMFAudioMediaType::GetAudioFormat()</unmanaged>
        public SharpDX.Multimedia.WaveFormat AudioFormat
        {
            get { return GetAudioFormat(); }
        }

        /// <summary>	
        /// <p>[<strong>GetAudioFormat</strong> is no longer available for use as of Windows?7. Instead, use the media type attributes to get the properties of the audio format.]</p><p> Returns a reference to a <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure that describes the audio format.</p>	
        /// </summary>	
        /// <returns><p> This method returns a reference to a <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure.</p></returns>	
        /// <remarks>	
        /// <p>If you need to convert the media type into a <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateWaveFormatExFromMFMediaType"/></strong>.</p><p> There are no guarantees about how long the returned reference is valid.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioMediaType::GetAudioFormat']/*"/>	
        /// <msdn-id>aa473803</msdn-id>	
        /// <unmanaged>const WAVEFORMATEX* IMFAudioMediaType::GetAudioFormat()</unmanaged>	
        /// <unmanaged-short>IMFAudioMediaType::GetAudioFormat</unmanaged-short>	
        internal SharpDX.Multimedia.WaveFormat GetAudioFormat()
        {
            unsafe
            {
                SharpDX.Multimedia.WaveFormat __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMultimediaWaveFormat(_nativePointer, ((void**)(*(void**)_nativePointer))[38]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Configures the audio session that is associated with the streaming audio renderer (SAR). Use this interface to change how the audio session appears in the Windows volume control.</p><p>The SAR exposes this interface as a service. To get a reference to the interface, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> with the service identifier <see cref="SharpDX.MediaFoundation.MediaServiceKeys.AudioPolicy"/>. You can call <strong>GetService</strong> directly on the SAR or call it on the Media Session.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioPolicy']/*"/>	
    /// <msdn-id>ms705651</msdn-id>	
    /// <unmanaged>IMFAudioPolicy</unmanaged>	
    /// <unmanaged-short>IMFAudioPolicy</unmanaged-short>	
    [Guid("a0638c2b-6465-4395-9ae7-a321a9fd2856")]
    public partial class AudioPolicy : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.AudioPolicy"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public AudioPolicy(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.AudioPolicy"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.AudioPolicy(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.AudioPolicy(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the group of sessions to which this audio session belongs.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If two or more audio sessions share the same group, the Windows volume control displays one slider control for the entire group. Otherwise, it displays a slider for each session. For more information, see <strong>IAudioSessionControl::SetGroupingParam</strong> in the core audio API documentation.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioPolicy::GetGroupingParam']/*"/>	
        /// <msdn-id>ms698967</msdn-id>	
        /// <unmanaged>GetGroupingParam / SetGroupingParam</unmanaged>	
        /// <unmanaged-short>GetGroupingParam</unmanaged-short>	
        /// <unmanaged>HRESULT IMFAudioPolicy::GetGroupingParam([Out] GUID* pguidClass)</unmanaged>
        public System.Guid GroupingParam
        {
            get { System.Guid __output__; GetGroupingParam(out __output__); return __output__; }
            set { SetGroupingParam(value); }
        }

        /// <summary>	
        /// <p> </p><p>Assigns the audio session to a group of sessions.</p>	
        /// </summary>	
        /// <param name="rguidClass"><dd> <p>A <strong><see cref="System.Guid"/></strong> that identifies the session group. Groups are application-defined. To create a new session group, assign a new <see cref="System.Guid"/>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If two or more audio sessions share the same group, the Windows volume control displays one slider control for the entire group. Otherwise, it displays a slider for each session. For more information, see <strong>IAudioSessionControl::SetGroupingParam</strong> in the core audio API documentation.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioPolicy::SetGroupingParam']/*"/>	
        /// <msdn-id>ms696185</msdn-id>	
        /// <unmanaged>HRESULT IMFAudioPolicy::SetGroupingParam([In] const GUID&amp; rguidClass)</unmanaged>	
        /// <unmanaged-short>IMFAudioPolicy::SetGroupingParam</unmanaged-short>	
        internal void SetGroupingParam(System.Guid rguidClass)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &rguidClass, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the group of sessions to which this audio session belongs.</p>	
        /// </summary>	
        /// <param name="guidClassRef"><dd> <p>Receives a <see cref="System.Guid"/> that identifies the session group.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If two or more audio sessions share the same group, the Windows volume control displays one slider control for the entire group. Otherwise, it displays a slider for each session. For more information, see <strong>IAudioSessionControl::SetGroupingParam</strong> in the core audio API documentation.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioPolicy::GetGroupingParam']/*"/>	
        /// <msdn-id>ms698967</msdn-id>	
        /// <unmanaged>HRESULT IMFAudioPolicy::GetGroupingParam([Out] GUID* pguidClass)</unmanaged>	
        /// <unmanaged-short>IMFAudioPolicy::GetGroupingParam</unmanaged-short>	
        internal void GetGroupingParam(out System.Guid guidClassRef)
        {
            unsafe
            {
                guidClassRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* guidClassRef_ = &guidClassRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, guidClassRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the display name of the audio session. The Windows volume control displays this name.</p>	
        /// </summary>	
        /// <param name="szNameRef"><dd> <p>A null-terminated wide-character string that contains the display name.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the application does not set a display name, Windows creates one.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioPolicy::SetDisplayName']/*"/>	
        /// <msdn-id>ms697038</msdn-id>	
        /// <unmanaged>HRESULT IMFAudioPolicy::SetDisplayName([In] const wchar_t* pszName)</unmanaged>	
        /// <unmanaged-short>IMFAudioPolicy::SetDisplayName</unmanaged-short>	
        public void SetDisplayName(string szNameRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* szNameRef_ = szNameRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szNameRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the display name of the audio session. The Windows volume control displays this name.</p>	
        /// </summary>	
        /// <param name="szNameRef"><dd> <p>Receives a reference to the display name string. The caller must free the memory allocated for the string by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the application does not set a display name, Windows creates one.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioPolicy::GetDisplayName']/*"/>	
        /// <msdn-id>ms698992</msdn-id>	
        /// <unmanaged>HRESULT IMFAudioPolicy::GetDisplayName([Out] wchar_t** pszName)</unmanaged>	
        /// <unmanaged-short>IMFAudioPolicy::GetDisplayName</unmanaged-short>	
        public void GetDisplayName(System.IntPtr szNameRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szNameRef, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the icon resource for the audio session. The Windows volume control displays this icon. </p>	
        /// </summary>	
        /// <param name="szPathRef"><dd> <p>A wide-character string that specifies the icon. See Remarks.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The icon path has the format "path,index" or "path,-id", where <em>path</em> is the fully qualified path to a DLL, executable file, or icon file; <em>index</em> is the zero-based index of the icon within the file; and <em>id</em> is a resource identifier. Note that resource identifiers are preceded by a minus sign (-) to distinguish them from indexes. The path can contain environment variables, such as "%windir%". For more information, see <strong>IAudioSessionControl::SetIconPath</strong> in the Windows SDK.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioPolicy::SetIconPath']/*"/>	
        /// <msdn-id>ms694065</msdn-id>	
        /// <unmanaged>HRESULT IMFAudioPolicy::SetIconPath([In] const wchar_t* pszPath)</unmanaged>	
        /// <unmanaged-short>IMFAudioPolicy::SetIconPath</unmanaged-short>	
        public void SetIconPath(string szPathRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* szPathRef_ = szPathRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szPathRef_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the icon resource for the audio session. The Windows volume control displays this icon.</p>	
        /// </summary>	
        /// <param name="szPathRef"><dd> <p>Receives a reference to a wide-character string that specifies a shell resource. The format of the string is described in the topic <strong><see cref="SharpDX.MediaFoundation.AudioPolicy.SetIconPath"/></strong>. The caller must free the memory allocated for the string by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the application did not set an icon path, the method returns an empty string ("").</p><p>For more information, see <strong>IAudioSessionControl::GetIconPath</strong> in the core audio API documentation.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioPolicy::GetIconPath']/*"/>	
        /// <msdn-id>ms704858</msdn-id>	
        /// <unmanaged>HRESULT IMFAudioPolicy::GetIconPath([Out] wchar_t** pszPath)</unmanaged>	
        /// <unmanaged-short>IMFAudioPolicy::GetIconPath</unmanaged-short>	
        public void GetIconPath(System.IntPtr szPathRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szPathRef, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Controls the volume levels of individual audio channels.</p><p>The streaming audio renderer (SAR) exposes this interface as a service. To get a reference to the interface, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> with the service identifier <strong><see cref="SharpDX.MediaFoundation.MediaServiceKeys.StreamVolume"/></strong>. You can call <strong>GetService</strong> directly on the SAR or call it on the Media Session.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If your application does not require channel-level volume control, you can use the <strong><see cref="SharpDX.MediaFoundation.SimpleAudioVolume"/></strong> interface to control the master volume level of the audio session.</p><p>Volume is expressed as an attenuation level, where 0.0 indicates silence and 1.0 indicates full volume (no attenuation). For each channel, the attenuation level is the product of:</p><ul> <li> The master volume level of the audio session. </li> <li> The volume level of the channel. </li> </ul><p>For example, if the master volume is 0.8 and the channel volume is 0.5, the attenuation for that channel is 0.8 ? 0.5 = 0.4. Volume levels can exceed 1.0 (positive gain), but the audio engine clips any audio samples that exceed zero decibels.</p><p>Use the following formula to convert the volume level to the decibel (dB) scale:</p><p>Attenuation (dB) = 20 * log10(<em>Level</em>)</p><p>For example, a volume level of 0.50 represents 6.02 dB of attenuation.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioStreamVolume']/*"/>	
    /// <msdn-id>aa378344</msdn-id>	
    /// <unmanaged>IMFAudioStreamVolume</unmanaged>	
    /// <unmanaged-short>IMFAudioStreamVolume</unmanaged-short>	
    [Guid("76B1BBDB-4EC8-4f36-B106-70A9316DF593")]
    public partial class AudioStreamVolume : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.AudioStreamVolume"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public AudioStreamVolume(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.AudioStreamVolume"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.AudioStreamVolume(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.AudioStreamVolume(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the number of channels in the audio stream.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioStreamVolume::GetChannelCount']/*"/>	
        /// <msdn-id>aa373760</msdn-id>	
        /// <unmanaged>GetChannelCount</unmanaged>	
        /// <unmanaged-short>GetChannelCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFAudioStreamVolume::GetChannelCount([Out] unsigned int* pdwCount)</unmanaged>
        public int ChannelCount
        {
            get { int __output__; GetChannelCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of channels in the audio stream.</p>	
        /// </summary>	
        /// <param name="dwCountRef"><dd> <p>Receives the number of channels in the audio stream.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioStreamVolume::GetChannelCount']/*"/>	
        /// <msdn-id>aa373760</msdn-id>	
        /// <unmanaged>HRESULT IMFAudioStreamVolume::GetChannelCount([Out] unsigned int* pdwCount)</unmanaged>	
        /// <unmanaged-short>IMFAudioStreamVolume::GetChannelCount</unmanaged-short>	
        internal void GetChannelCount(out int dwCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwCountRef_ = &dwCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwCountRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the volume level for a specified channel in the audio stream.</p>	
        /// </summary>	
        /// <param name="dwIndex"><dd> <p>Zero-based index of the audio channel. To get the number of channels, call <strong><see cref="SharpDX.MediaFoundation.AudioStreamVolume.GetChannelCount"/></strong>.</p> </dd></param>	
        /// <param name="fLevel"><dd> <p>Volume level for the channel.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioStreamVolume::SetChannelVolume']/*"/>	
        /// <msdn-id>aa370771</msdn-id>	
        /// <unmanaged>HRESULT IMFAudioStreamVolume::SetChannelVolume([In] unsigned int dwIndex,[In] const float fLevel)</unmanaged>	
        /// <unmanaged-short>IMFAudioStreamVolume::SetChannelVolume</unmanaged-short>	
        public void SetChannelVolume(int dwIndex, float fLevel)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwIndex, fLevel, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the volume level for a specified channel in the audio stream.</p>	
        /// </summary>	
        /// <param name="dwIndex"><dd> <p>Zero-based index of the audio channel. To get the number of channels, call <strong><see cref="SharpDX.MediaFoundation.AudioStreamVolume.GetChannelCount"/></strong>.</p> </dd></param>	
        /// <param name="fLevelRef"><dd> <p>Receives the volume level for the channel.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioStreamVolume::GetChannelVolume']/*"/>	
        /// <msdn-id>aa369737</msdn-id>	
        /// <unmanaged>HRESULT IMFAudioStreamVolume::GetChannelVolume([In] unsigned int dwIndex,[Out] float* pfLevel)</unmanaged>	
        /// <unmanaged-short>IMFAudioStreamVolume::GetChannelVolume</unmanaged-short>	
        public void GetChannelVolume(int dwIndex, out float fLevelRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* fLevelRef_ = &fLevelRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwIndex, fLevelRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the individual volume levels for all of the channels in the audio stream.</p>	
        /// </summary>	
        /// <param name="dwCount"><dd> <p>Number of elements in the <em>pfVolumes</em> array. The value must equal the number of channels. To get the number of channels, call <strong><see cref="SharpDX.MediaFoundation.AudioStreamVolume.GetChannelCount"/></strong>.</p> </dd></param>	
        /// <param name="fVolumesRef"><dd> <p>Address of an array of size <em>dwCount</em>, allocated by the caller. The array specifies the volume levels for all of the channels. Before calling the method, set each element of the array to the desired volume level for the channel.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioStreamVolume::SetAllVolumes']/*"/>	
        /// <msdn-id>aa370454</msdn-id>	
        /// <unmanaged>HRESULT IMFAudioStreamVolume::SetAllVolumes([In] unsigned int dwCount,[In, Buffer] const float* pfVolumes)</unmanaged>	
        /// <unmanaged-short>IMFAudioStreamVolume::SetAllVolumes</unmanaged-short>	
        public void SetAllVolumes(int dwCount, float[] fVolumesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* fVolumesRef_ = fVolumesRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwCount, fVolumesRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the volume levels for all of the channels in the audio stream.</p>	
        /// </summary>	
        /// <param name="dwCount"><dd> <p>Number of elements in the <em>pfVolumes</em> array. The value must equal the number of channels. To get the number of channels, call <strong><see cref="SharpDX.MediaFoundation.AudioStreamVolume.GetChannelCount"/></strong>.</p> </dd></param>	
        /// <param name="fVolumesRef"><dd> <p>Address of an array of size <em>dwCount</em>, allocated by the caller. The method fills the array with the volume level for each channel in the stream.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAudioStreamVolume::GetAllVolumes']/*"/>	
        /// <msdn-id>aa373642</msdn-id>	
        /// <unmanaged>HRESULT IMFAudioStreamVolume::GetAllVolumes([In] unsigned int dwCount,[Out, Buffer] float* pfVolumes)</unmanaged>	
        /// <unmanaged-short>IMFAudioStreamVolume::GetAllVolumes</unmanaged-short>	
        public void GetAllVolumes(int dwCount, float[] fVolumesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* fVolumesRef_ = fVolumesRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwCount, fVolumesRef_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Represents a buffer that contains a two-dimensional surface, such as a video frame. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To get a reference to this interface, call <strong>QueryInterface</strong> on the media buffer.</p><p>To use a 2-D buffer, it is important to know the <em>stride</em>, which is the number of bytes needed to go from one row of pixels to the next. The stride may be larger than the image width, because the surface may contain padding bytes after each row of pixels. Stride can also be negative, if the pixels are oriented bottom-up in memory. For more information, see Image Stride.</p><p>Every video format defines a <em>contiguous</em> or <em>packed</em> representation. This representation is compatible with the standard layout of a DirectX surface in system memory, with no additional padding. For RGB video, the contiguous representation has a pitch equal to the image width in bytes, rounded up to the nearest <strong>DWORD</strong> boundary. For YUV video, the layout of the contiguous representation depends on the YUV format. For planar YUV formats, the Y plane might have a different pitch than the U and V planes.</p><p>If a media buffer supports the <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong> interface, the underlying buffer is not guaranteed to have a contiguous representation, because there might be additional padding bytes after each row of pixels. When a buffer is non-contiguous, the <strong>Lock</strong> and <strong>Lock2D</strong> methods have different behaviors:</p><ul> <li> The <strong>Lock2D</strong> method returns a reference to the underlying buffer. The buffer might not be contiguous. </li> <li> The <strong>Lock</strong> method returns a buffer that is guaranteed to be contiguous. If the underlying buffer is not contiguous, the method copies the data into a new buffer, and the <strong>Unlock</strong> method copies it back into the original buffer. </li> </ul><p>Call the <strong>Lock2D</strong> method to access the 2-D buffer in its native format. The native format might not be contiguous. The buffer's <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.Lock"/></strong> method returns a contiguous representation of the buffer. However, this might require an internal copy from the native format. For 2-D buffers, therefore, you should use the <strong>Lock2D</strong> method and avoid the <strong>Lock</strong> method. Because the <strong>Lock</strong> method might cause up to two buffer copies, the <strong>Lock2D</strong> method is generally more efficient and should be used when possible. To find out if the underlying buffer is contiguous, call <strong><see cref="SharpDX.MediaFoundation.Buffer2D.IsContiguousFormat_"/></strong>.</p><p>For uncompressed images, the amount of valid data in the buffer is determined by the width, height, and pixel layout of the image. For this reason, if you call <strong>Lock2D</strong> to access the buffer, do not rely on the values returned by <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.GetCurrentLength"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.GetMaxLength"/></strong>. Similarly, if you modify the data in the buffer, you do not have to call <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.SetCurrentLength"/></strong> to update the size. Generally, you should avoid mixing calls to <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong> and <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> methods on the same media buffer.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMF2DBuffer']/*"/>	
    /// <msdn-id>ms699894</msdn-id>	
    /// <unmanaged>IMF2DBuffer</unmanaged>	
    /// <unmanaged-short>IMF2DBuffer</unmanaged-short>	
    [Guid("7DC9D5F9-9ED9-44ec-9BBF-0600BB589FBB")]
    public partial class Buffer2D : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.Buffer2D"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Buffer2D(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.Buffer2D"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.Buffer2D(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.Buffer2D(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Queries whether the buffer is contiguous in its native format.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>For a definition of contiguous as it applies to 2-D buffers, see the Remarks section in <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong> interface. For non-contiguous buffers, the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.Lock"/></strong> method must perform an internal copy.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMF2DBuffer::IsContiguousFormat']/*"/>	
        /// <msdn-id>ms701629</msdn-id>	
        /// <unmanaged>IsContiguousFormat</unmanaged>	
        /// <unmanaged-short>IsContiguousFormat</unmanaged-short>	
        /// <unmanaged>HRESULT IMF2DBuffer::IsContiguousFormat([Out] BOOL* pfIsContiguous)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsContiguousFormat
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; IsContiguousFormat_(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of bytes needed to store the contents of the buffer in contiguous format.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>For a definition of contiguous as it applies to 2-D buffers, see the Remarks section in <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong> interface.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMF2DBuffer::GetContiguousLength']/*"/>	
        /// <msdn-id>ms696971</msdn-id>	
        /// <unmanaged>GetContiguousLength</unmanaged>	
        /// <unmanaged-short>GetContiguousLength</unmanaged-short>	
        /// <unmanaged>HRESULT IMF2DBuffer::GetContiguousLength([Out] unsigned int* pcbLength)</unmanaged>
        public int ContiguousLength
        {
            get { int __output__; GetContiguousLength(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Gives the caller access to the memory in the buffer.</p>	
        /// </summary>	
        /// <param name="bScanline0Out"><dd> <p>Receives a reference to the first byte of the top row of pixels in the image. The top row is defined as the top row when the image is presented to the viewer, and might not be the first row in memory.</p> </dd></param>	
        /// <param name="lPitchRef"><dd> <p>Receives the surface stride, in bytes. The stride might be negative, indicating that the image is oriented from the bottom up in memory.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>D3DERR_INVALIDCALL</strong></dt> </dl> </td><td> <p>Cannot lock the Direct3D surface.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The buffer cannot be locked at this time.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If <em>p</em> is a reference to the first byte in a row of pixels, <em>p</em> + (*<em>plPitch</em>) points to the first byte in the next row of pixels. A buffer might contain padding after each row of pixels, so the stride might be wider than the width of the image in bytes. Do not access the memory that is reserved for padding bytes, because it might not be read-accessible or write-accessible. For more information, see Image Stride.</p><p>The reference returned in <em>pbScanline0</em> remains valid as long as the caller holds the lock. When you are done accessing the memory, call <strong><see cref="SharpDX.MediaFoundation.Buffer2D.Unlock2D"/></strong> to unlock the buffer. You must call <strong>Unlock2D</strong> once for each call to <strong>Lock2D</strong>. After you unlock the buffer, the reference returned in <em>pbScanline0</em> is no longer valid and should not be used. Generally, it is best to call <strong>Lock2D</strong> only when you need to access the buffer memory, and not earlier.</p><p>The values returned by the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.GetCurrentLength"/></strong> and <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.GetMaxLength"/></strong> methods do not apply to the buffer that is returned by the <strong>Lock2D</strong> method. For the same reason, you do not need to call <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.SetCurrentLength"/></strong> after manipulating the data in the buffer returned by the <strong>Lock2D</strong> method.</p><p>The <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.Lock"/></strong> method fails while the <strong>Lock2D</strong> lock is held, and vice-versa. Applications should use only one of these methods at a time.</p><p>When the underlying buffer is a Direct3D surface, the method fails if the surface is not lockable.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMF2DBuffer::Lock2D']/*"/>	
        /// <msdn-id>ms700182</msdn-id>	
        /// <unmanaged>HRESULT IMF2DBuffer::Lock2D([Out, Buffer] unsigned char** ppbScanline0,[Out] int* plPitch)</unmanaged>	
        /// <unmanaged-short>IMF2DBuffer::Lock2D</unmanaged-short>	
        public void Lock2D(byte[] bScanline0Out, out int lPitchRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* bScanline0Out_ = bScanline0Out)
                fixed (void* lPitchRef_ = &lPitchRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bScanline0Out_, lPitchRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Unlocks a buffer that was previously locked. Call this method once for each call to <strong><see cref="SharpDX.MediaFoundation.Buffer2D.Lock2D"/></strong>.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMF2DBuffer::Unlock2D']/*"/>	
        /// <msdn-id>ms697066</msdn-id>	
        /// <unmanaged>HRESULT IMF2DBuffer::Unlock2D()</unmanaged>	
        /// <unmanaged-short>IMF2DBuffer::Unlock2D</unmanaged-short>	
        public void Unlock2D()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a reference to the buffer memory and the surface stride.</p>	
        /// </summary>	
        /// <param name="bScanline0Ref"><dd> <p>Receives a reference to the first byte of the top row of pixels in the image.</p> </dd></param>	
        /// <param name="lPitchRef"><dd> <p>Receives the stride, in bytes. For more information, see Image Stride.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Win32.ErrorCode.InvalidFunction"/></strong></dt> </dl> </td><td> <p>You must lock the buffer before calling this method.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Before calling this method, you must lock the buffer by calling <strong><see cref="SharpDX.MediaFoundation.Buffer2D.Lock2D"/></strong>. The reference returned in <em>plPitch</em> is valid only while the buffer remains locked.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMF2DBuffer::GetScanline0AndPitch']/*"/>	
        /// <msdn-id>ms694042</msdn-id>	
        /// <unmanaged>HRESULT IMF2DBuffer::GetScanline0AndPitch([Out] unsigned char** pbScanline0,[Out] int* plPitch)</unmanaged>	
        /// <unmanaged-short>IMF2DBuffer::GetScanline0AndPitch</unmanaged-short>	
        public void GetScanline0AndPitch(out byte bScanline0Ref, out int lPitchRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* bScanline0Ref_ = &bScanline0Ref)
                fixed (void* lPitchRef_ = &lPitchRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bScanline0Ref_, lPitchRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Queries whether the buffer is contiguous in its native format.</p>	
        /// </summary>	
        /// <param name="fIsContiguousRef"><dd> <p>Receives a Boolean value. The value is <strong>TRUE</strong> if the buffer is contiguous, and <strong><see cref="SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>For a definition of contiguous as it applies to 2-D buffers, see the Remarks section in <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong> interface. For non-contiguous buffers, the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.Lock"/></strong> method must perform an internal copy.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMF2DBuffer::IsContiguousFormat']/*"/>	
        /// <msdn-id>ms701629</msdn-id>	
        /// <unmanaged>HRESULT IMF2DBuffer::IsContiguousFormat([Out] BOOL* pfIsContiguous)</unmanaged>	
        /// <unmanaged-short>IMF2DBuffer::IsContiguousFormat</unmanaged-short>	
        internal void IsContiguousFormat_(out SharpDX.Mathematics.Interop.RawBool fIsContiguousRef)
        {
            unsafe
            {
                fIsContiguousRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fIsContiguousRef_ = &fIsContiguousRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fIsContiguousRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of bytes needed to store the contents of the buffer in contiguous format.</p>	
        /// </summary>	
        /// <param name="cbLengthRef"><dd> <p>Receives the number of bytes needed to store the contents of the buffer in contiguous format.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>For a definition of contiguous as it applies to 2-D buffers, see the Remarks section in <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong> interface.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMF2DBuffer::GetContiguousLength']/*"/>	
        /// <msdn-id>ms696971</msdn-id>	
        /// <unmanaged>HRESULT IMF2DBuffer::GetContiguousLength([Out] unsigned int* pcbLength)</unmanaged>	
        /// <unmanaged-short>IMF2DBuffer::GetContiguousLength</unmanaged-short>	
        internal void GetContiguousLength(out int cbLengthRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cbLengthRef_ = &cbLengthRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cbLengthRef_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Copies this buffer into the caller's buffer, converting the data to contiguous format.</p>	
        /// </summary>	
        /// <param name="bDestBufferRef"><dd> <p>Pointer to the destination buffer where the data will be copied. The caller allocates the buffer.</p> </dd></param>	
        /// <param name="cbDestBuffer"><dd> <p>Size of the destination buffer, in bytes. To get the required size, call <strong><see cref="SharpDX.MediaFoundation.Buffer2D.GetContiguousLength"/></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid size specified in <em>pbDestBuffer</em>.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the original buffer is not contiguous, this method converts the contents into contiguous format during the copy. For a definition of contiguous as it applies to 2-D buffers, see the Remarks section in <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong> interface.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMF2DBuffer::ContiguousCopyTo']/*"/>	
        /// <msdn-id>ms696215</msdn-id>	
        /// <unmanaged>HRESULT IMF2DBuffer::ContiguousCopyTo([Out, Buffer] unsigned char* pbDestBuffer,[In] unsigned int cbDestBuffer)</unmanaged>	
        /// <unmanaged-short>IMF2DBuffer::ContiguousCopyTo</unmanaged-short>	
        public void ContiguousCopyTo(byte[] bDestBufferRef, int cbDestBuffer)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* bDestBufferRef_ = bDestBufferRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bDestBufferRef_, cbDestBuffer, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Copies data to this buffer from a buffer that has a contiguous format.</p>	
        /// </summary>	
        /// <param name="bSrcBufferRef"><dd> <p>Pointer to the source buffer. The caller allocates the buffer.</p> </dd></param>	
        /// <param name="cbSrcBuffer"><dd> <p>Size of the source buffer, in bytes. To get the maximum size of the buffer, call <strong><see cref="SharpDX.MediaFoundation.Buffer2D.GetContiguousLength"/></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method copies the contents of the source buffer into the buffer that is managed by this <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong> object. The source buffer must be in contiguous format. While copying, the method converts the contents into the destination buffer's native format, correcting for the buffer's pitch if necessary.</p><p>For a definition of contiguous as it applies to 2-D buffers, see the Remarks section in the <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong> interface topic.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMF2DBuffer::ContiguousCopyFrom']/*"/>	
        /// <msdn-id>ms700162</msdn-id>	
        /// <unmanaged>HRESULT IMF2DBuffer::ContiguousCopyFrom([In, Buffer] const unsigned char* pbSrcBuffer,[In] unsigned int cbSrcBuffer)</unmanaged>	
        /// <unmanaged-short>IMF2DBuffer::ContiguousCopyFrom</unmanaged-short>	
        public void ContiguousCopyFrom(byte[] bSrcBufferRef, int cbSrcBuffer)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* bSrcBufferRef_ = bSrcBufferRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bSrcBufferRef_, cbSrcBuffer, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a buffer that contains a two-dimensional surface, such as a video frame.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface extends the <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong> interface and adds a safer version of the <strong><see cref="SharpDX.MediaFoundation.Buffer2D.Lock2D"/></strong> method.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMF2DBuffer2']/*"/>	
    /// <msdn-id>hh447827</msdn-id>	
    /// <unmanaged>IMF2DBuffer2</unmanaged>	
    /// <unmanaged-short>IMF2DBuffer2</unmanaged-short>	
    [Guid("33ae5ea6-4316-436f-8ddd-d73d22f829ec")]
    public partial class Buffer2D2 : SharpDX.MediaFoundation.Buffer2D
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.Buffer2D2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Buffer2D2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.Buffer2D2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.Buffer2D2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.Buffer2D2(nativePointer);
        }


        /// <summary>	
        /// <p>Gives the caller access to the memory in the buffer.</p>	
        /// </summary>	
        /// <param name="lockFlags"><dd> <p>A member of the <strong><see cref="SharpDX.MediaFoundation.Buffer2DLockFlags"/></strong> enumeration that specifies whether to lock the buffer for reading, writing, or both.</p> </dd></param>	
        /// <param name="bScanline0Out"><dd> <p>Receives a reference to the first byte of the top row of pixels in the image. The top row is defined as the top row when the image is presented to the viewer, and might not be the first row in memory. </p> </dd></param>	
        /// <param name="lPitchRef"><dd> <p>Receives the surface stride, in bytes. The stride might be negative, indicating that the image is oriented from the bottom up in memory. </p> </dd></param>	
        /// <param name="bBufferStartOut"><dd> <p>Receives a reference to the start of the accessible buffer in memory.</p> </dd></param>	
        /// <param name="cbBufferLengthRef"><dd> <p>Receives the length of the buffer, in bytes.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid request. The buffer might already be locked with an incompatible locking flag. See Remarks.</p> </td></tr> <tr><td> <dl> <dt><strong> E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p>There is insufficient memory to complete the operation. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When you are done accessing the memory, call <strong><see cref="SharpDX.MediaFoundation.Buffer2D.Unlock2D"/></strong> to unlock the buffer. You must call <strong>Unlock2D</strong> once for each call to <strong>Lock2DSize</strong>.</p><p>This method is equivalent to the <strong><see cref="SharpDX.MediaFoundation.Buffer2D.Lock2D"/></strong> method. However, <strong>Lock2DSize</strong> is preferred because it enables the caller to validate memory references, and because it supports read-only locks. A buffer is not guaranteed to support the <strong><see cref="SharpDX.MediaFoundation.Buffer2D2"/></strong> interface. To access a buffer, you should try the following methods in the order listed:</p><ol> <li><strong><see cref="SharpDX.MediaFoundation.Buffer2D2.Lock2DSize"/></strong></li> <li> <strong><see cref="SharpDX.MediaFoundation.Buffer2D.Lock2D"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.Lock"/></strong> </li> </ol><p>The <em>ppbBufferStart</em> and <em>pcbBufferLength</em> parameters receive the bounds of the buffer memory. Use these values to guard against buffer overruns. Use the values of <em>ppbScanline0</em> and <em>plPitch</em> to access the image data. If the image is bottom-up in memory, <em>ppbScanline0</em> will point to the last scan line in memory and <em>plPitch</em> will be negative. For more information, see Image Stride.</p><p>The <em>lockFlags</em> parameter specifies whether the buffer is locked for read-only access, write-only access,  or read/write access. </p><ul> <li>If the buffer is already locked for read-only access, it cannot be locked for write access.</li> <li>If the buffer is already locked for write-only access, it cannot be locked for read access.</li> <li>If the buffer is already locked for read/write acess, it can be locked for read or write acess.</li> </ul><p>When possible, use a read-only or write-only lock, and avoid locking the buffer for read/write access. If the buffer represents a DirectX Graphics Infrastructure (DXGI) surface, a read/write lock can cause an extra copy between CPU memory and GPU memory.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMF2DBuffer2::Lock2DSize']/*"/>	
        /// <msdn-id>hh447829</msdn-id>	
        /// <unmanaged>HRESULT IMF2DBuffer2::Lock2DSize([In] MF2DBuffer_LockFlags lockFlags,[Out, Buffer] unsigned char** ppbScanline0,[Out] int* plPitch,[Out, Buffer] unsigned char** ppbBufferStart,[Out] unsigned int* pcbBufferLength)</unmanaged>	
        /// <unmanaged-short>IMF2DBuffer2::Lock2DSize</unmanaged-short>	
        public void Lock2DSize(SharpDX.MediaFoundation.Buffer2DLockFlags lockFlags, byte[] bScanline0Out, out int lPitchRef, byte[] bBufferStartOut, out int cbBufferLengthRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* bScanline0Out_ = bScanline0Out)
                fixed (void* lPitchRef_ = &lPitchRef)
                fixed (void* bBufferStartOut_ = bBufferStartOut)
                fixed (void* cbBufferLengthRef_ = &cbBufferLengthRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)lockFlags), bScanline0Out_, lPitchRef_, bBufferStartOut_, cbBufferLengthRef_, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Copies the buffer to another 2D buffer object.</p>	
        /// </summary>	
        /// <param name="destBufferRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.Buffer2D2"/></strong> interface of the destination buffer.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The destination buffer must be at least as large as the source buffer.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMF2DBuffer2::Copy2DTo']/*"/>	
        /// <msdn-id>hh447828</msdn-id>	
        /// <unmanaged>HRESULT IMF2DBuffer2::Copy2DTo([In] IMF2DBuffer2* pDestBuffer)</unmanaged>	
        /// <unmanaged-short>IMF2DBuffer2::Copy2DTo</unmanaged-short>	
        public void Copy2DTo(SharpDX.MediaFoundation.Buffer2D2 destBufferRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((destBufferRef == null) ? IntPtr.Zero : destBufferRef.NativePointer), ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables <strong><see cref="SharpDX.MediaFoundation.SourceBufferList"/></strong> object to notify its clients of important state changes.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFBufferListNotify']/*"/>	
    /// <msdn-id>dn280674</msdn-id>	
    /// <unmanaged>IMFBufferListNotify</unmanaged>	
    /// <unmanaged-short>IMFBufferListNotify</unmanaged-short>	
    [Guid("24cd47f7-81d8-4785-adb2-af697a963cd2")]
    public partial class BufferListNotify : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.BufferListNotify"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BufferListNotify(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.BufferListNotify"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.BufferListNotify(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.BufferListNotify(nativePointer);
        }


        /// <summary>	
        /// <p>Indicates that a <strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong> has been added.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFBufferListNotify::OnAddSourceBuffer']/*"/>	
        /// <msdn-id>dn280675</msdn-id>	
        /// <unmanaged>void IMFBufferListNotify::OnAddSourceBuffer()</unmanaged>	
        /// <unmanaged-short>IMFBufferListNotify::OnAddSourceBuffer</unmanaged-short>	
        public void OnAddSourceBuffer()
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
            }
        }

        /// <summary>	
        /// <p>Indicates that a <strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong> has been removed.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFBufferListNotify::OnRemoveSourceBuffer']/*"/>	
        /// <msdn-id>dn280676</msdn-id>	
        /// <unmanaged>void IMFBufferListNotify::OnRemoveSourceBuffer()</unmanaged>	
        /// <unmanaged-short>IMFBufferListNotify::OnRemoveSourceBuffer</unmanaged-short>	
        public void OnRemoveSourceBuffer()
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
            }
        }
    }
    /// <summary>	
    /// <p>Represents a byte stream from some data source, which might be a local file, a network file, or some other source. The <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface supports the typical stream operations, such as reading, writing, and seeking. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p> The following functions return <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> references for local files: </p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.BeginCreateFile"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateFile"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateTempFile"/></strong> </li> </ul><p> A byte stream for a media souce can be opened with read access. A byte stream for an archive media sink should be opened with both read and write access. (Read access may be required, because the archive sink might need to read portions of the file as it writes.) </p><p>Some implementations of this interface also expose one or more of the following interfaces:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.ByteStreamBuffering"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.ByteStreamCacheControl"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.ServiceProvider"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator"/></strong> </li> </ul><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream']/*"/>	
    /// <msdn-id>ms698720</msdn-id>	
    /// <unmanaged>IMFByteStream</unmanaged>	
    /// <unmanaged-short>IMFByteStream</unmanaged-short>	
    [Guid("ad4c1b00-4bf7-422f-9175-756693d9130d")]
    public partial class ByteStream : SharpDX.ComObjectCallback, SharpDX.MediaFoundation.IByteStream
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ByteStream"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ByteStream(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ByteStream"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ByteStream(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ByteStream(nativePointer);
        }


        /// <summary>	
        /// <p> Retrieves the characteristics of the byte stream. </p>	
        /// </summary>	
        /// <param name="dwCapabilitiesRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags. The following flags are defined.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_READABLE</strong></dt> <dt>0x00000001</dt> </dl> </td><td> <p> The byte stream can be read. </p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_WRITABLE</strong></dt> <dt>0x00000002</dt> </dl> </td><td> <p> The byte stream can be written to. </p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_SEEKABLE</strong></dt> <dt>0x00000004</dt> </dl> </td><td> <p> The byte stream can be seeked. </p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_REMOTE</strong></dt> <dt>0x00000008</dt> </dl> </td><td> <p> The byte stream is from a remote source, such as a network. </p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_DIRECTORY</strong></dt> <dt>0x00000080</dt> </dl> </td><td> <p> The byte stream represents a file directory. </p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_HAS_SLOW_SEEK</strong></dt> <dt>0x00000100</dt> </dl> </td><td> <p> Seeking within this stream might be slow. For example, the byte stream might download from a network.</p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_PARTIALLY_DOWNLOADED</strong></dt> <dt>0x00000200</dt> </dl> </td><td> <p>The byte stream is currently downloading data to a local cache. Read operations on the byte stream might take longer until the data is completely downloaded.</p> <p>This flag is cleared after all of the data has been downloaded.</p> <p>If the <strong>MFBYTESTREAM_HAS_SLOW_SEEK</strong> flag is also set, it means the byte stream must download the entire file sequentially. Otherwise, the byte stream can respond to seek requests by restarting the download from a new point in the stream.</p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_SHARE_WRITE</strong></dt> <dt>0x00000400</dt> </dl> </td><td> <p>Another thread or process can open this byte stream for writing. If this flag is present, the length of thebyte stream could change while it is being read. </p> <p>This flag can affect the behavior of byte-stream handlers. For more information, see <see cref="SharpDX.MediaFoundation.ByteStreamAttributeKeys.HandlerAcceptsShareWrite"/>.</p> <strong>Note</strong>??Requires Windows?7 or later. ? </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_DOES_NOT_USE_NETWORK</strong></dt> <dt>0x00000800</dt> </dl> </td><td> <p>The byte stream is not currentlyusing the network to receive the content.  Networking hardwaremay enter a power saving state when this bit is set.</p> <strong>Note</strong>??Requires Windows?8 or later. ? </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::GetCapabilities']/*"/>	
        /// <msdn-id>ms698962</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::GetCapabilities([Out] unsigned int* pdwCapabilities)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::GetCapabilities</unmanaged-short>	
        internal void GetCapabilities_(out int dwCapabilitiesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwCapabilitiesRef_ = &dwCapabilitiesRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwCapabilitiesRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Retrieves the length of the stream. </p>	
        /// </summary>	
        /// <param name="qwLengthRef"><dd> <p> Receives the length of the stream, in bytes. If the length is unknown, this value is -1. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::GetLength']/*"/>	
        /// <msdn-id>ms698941</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::GetLength([Out] unsigned longlong* pqwLength)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::GetLength</unmanaged-short>	
        internal void GetLength_(out long qwLengthRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* qwLengthRef_ = &qwLengthRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, qwLengthRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the length of the stream.</p>	
        /// </summary>	
        /// <param name="qwLength"><dd> <p> Length of the stream in bytes. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::SetLength']/*"/>	
        /// <msdn-id>ms697225</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::SetLength([In] unsigned longlong qwLength)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::SetLength</unmanaged-short>	
        internal void SetLength_(long qwLength)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, qwLength, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Retrieves the current read or write position in the stream. </p>	
        /// </summary>	
        /// <param name="qwPositionRef"><dd> <p> Receives the current position, in bytes. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The methods that update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, <strong>SetCurrentPosition</strong>, and <strong>Seek</strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::GetCurrentPosition']/*"/>	
        /// <msdn-id>ms704059</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::GetCurrentPosition([Out] unsigned longlong* pqwPosition)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::GetCurrentPosition</unmanaged-short>	
        internal void GetCurrentPosition_(out long qwPositionRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* qwPositionRef_ = &qwPositionRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, qwPositionRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the current read or write position.</p>	
        /// </summary>	
        /// <param name="qwPosition"><dd> <p>New position in the stream, as a byte offset from the start of the stream.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> Invalid argument. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If the new position is larger than the length of the stream, the method returns E_INVALIDARG. </p><p><strong> Implementation notes:</strong> This method should update the current position in the stream by setting the current position to the value passed in to the <em>qwPosition</em> parameter. Other methods that can update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, and <strong>Seek</strong>.	
        /// </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::SetCurrentPosition']/*"/>	
        /// <msdn-id>ms695238</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::SetCurrentPosition([In] unsigned longlong qwPosition)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::SetCurrentPosition</unmanaged-short>	
        internal void SetCurrentPosition_(long qwPosition)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, qwPosition, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Queries whether the current position has reached the end of the stream.</p>	
        /// </summary>	
        /// <param name="fEndOfStreamRef"><dd> <p> Receives the value <strong>TRUE</strong> if the end of the stream has been reached, or <strong><see cref="SharpDX.Result.False"/></strong> otherwise. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::IsEndOfStream']/*"/>	
        /// <msdn-id>ms697369</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::IsEndOfStream([Out] BOOL* pfEndOfStream)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::IsEndOfStream</unmanaged-short>	
        internal void IsEndOfStream_(out SharpDX.Mathematics.Interop.RawBool fEndOfStreamRef)
        {
            unsafe
            {
                fEndOfStreamRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fEndOfStreamRef_ = &fEndOfStreamRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fEndOfStreamRef_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Reads data from the stream. </p>	
        /// </summary>	
        /// <param name="bRef"><dd> <p> Pointer to a buffer that receives the data. The caller must allocate the buffer. </p> </dd></param>	
        /// <param name="cb"><dd> <p> Size of the buffer in bytes. </p> </dd></param>	
        /// <param name="cbReadRef"><dd> <p> Receives the number of bytes that are copied into the buffer. This parameter cannot be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This method reads at most <em>cb</em> bytes from the current position in the stream and copies them into the buffer provided by the caller. The number of bytes that were read is returned in the <em>pcbRead</em> parameter. The method does not return an error code on reaching the end of the file, so the application should check the value in <em>pcbRead</em> after the method returns. </p><p> This method is synchronous. It blocks until the read operation completes. </p><p><strong> Implementation notes:</strong> This method should update the current position in the stream by adding the number of bytes that were read, which is specified by the value returned in the <em>pcbRead</em> parameter,  to the current position. Other methods that can update the current position are <strong>Read</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, <strong>Seek</strong>, and <strong>SetCurrentPosition</strong>. 	
        /// </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::Read']/*"/>	
        /// <msdn-id>ms698913</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::Read([In] void* pb,[In] unsigned int cb,[Out] unsigned int* pcbRead)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::Read</unmanaged-short>	
        internal void Read_(System.IntPtr bRef, int cb, out int cbReadRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cbReadRef_ = &cbReadRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)bRef, cb, cbReadRef_, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Begins an asynchronous read operation from the stream. </p>	
        /// </summary>	
        /// <param name="bRef"><dd> <p> Pointer to a buffer that receives the data. The caller must allocate the buffer. </p> </dd></param>	
        /// <param name="cb"><dd> <p> Size of the buffer in bytes. </p> </dd></param>	
        /// <param name="callbackRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> When all of the data has been read into the buffer, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, the application should call <strong><see cref="SharpDX.MediaFoundation.IByteStream.EndRead"/></strong> to complete the asynchronous request. </p><p> Do not read from, write to, free, or reallocate the buffer while an asynchronous read is pending. </p><p><strong> Implementation notes:</strong> This method should update the current position in the stream by adding the number of bytes that will be read, which is specified by the value returned in the <em>pcbRead</em> parameter,  to the current position. Other methods that can update the current position are <strong>BeginRead</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, <strong>Seek</strong>, and <strong>SetCurrentPosition</strong>. 	
        /// </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::BeginRead']/*"/>	
        /// <msdn-id>ms704810</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::BeginRead([In] void* pb,[In] unsigned int cb,[In] IMFAsyncCallback* pCallback,[In] void* punkState)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::BeginRead</unmanaged-short>	
        internal void BeginRead__(System.IntPtr bRef, int cb, System.IntPtr callbackRef, System.IntPtr unkStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)bRef, cb, (void*)callbackRef, (void*)unkStateRef, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Completes an asynchronous read operation. </p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method. </p> </dd></param>	
        /// <param name="cbReadRef"><dd> <p> Receives the number of bytes that were read. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Call this method after the <strong><see cref="SharpDX.MediaFoundation.IByteStream.BeginRead_"/></strong> method completes asynchronously. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::EndRead']/*"/>	
        /// <msdn-id>ms704042</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::EndRead([In] IMFAsyncResult* pResult,[Out] unsigned int* pcbRead)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::EndRead</unmanaged-short>	
        internal void EndRead_(SharpDX.MediaFoundation.AsyncResult resultRef, out int cbReadRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cbReadRef_ = &cbReadRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), cbReadRef_, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Writes data to the stream.</p>	
        /// </summary>	
        /// <param name="bRef"><dd> <p> Pointer to a buffer that contains the data to write. </p> </dd></param>	
        /// <param name="cb"><dd> <p> Size of the buffer in bytes. </p> </dd></param>	
        /// <param name="cbWrittenRef"><dd> <p> Receives the number of bytes that are written. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This method writes the contents of the <em>pb</em> buffer to the stream, starting at the current stream position. The number of bytes that were written is returned in the <em>pcbWritten</em> parameter. </p><p> This method is synchronous. It blocks until the write operation completes. </p><p><strong>Implementation notes:</strong> This method should update the current position in the stream by adding the number of bytes that were written to the stream, which is specified by the value returned in the <em>pcbWritten</em>, to the current position offset. </p><p> Other methods that can update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>BeginWrite</strong>, <strong>Seek</strong>, and <strong>SetCurrentPosition</strong>.	
        /// </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::Write']/*"/>	
        /// <msdn-id>ms703843</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::Write([In] const void* pb,[In] unsigned int cb,[Out] unsigned int* pcbWritten)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::Write</unmanaged-short>	
        internal void Write_(System.IntPtr bRef, int cb, out int cbWrittenRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cbWrittenRef_ = &cbWrittenRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)bRef, cb, cbWrittenRef_, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Begins an asynchronous write operation to the stream. </p>	
        /// </summary>	
        /// <param name="bRef"><dd> <p> Pointer to a buffer containing the data to write. </p> </dd></param>	
        /// <param name="cb"><dd> <p> Size of the buffer in bytes. </p> </dd></param>	
        /// <param name="callbackRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> When all of the data has been written to the stream, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, the application should call <strong><see cref="SharpDX.MediaFoundation.IByteStream.EndWrite"/></strong> to complete the asynchronous request. </p><p> Do not reallocate, free, or write to the buffer while an asynchronous write is still pending. </p><p><strong>Implementation notes:</strong> This method should update the current position in the stream by adding the number of bytes that will be written to the stream, which is specified by the value returned in the <em>pcbWritten</em>, to the current position. Other methods that can update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>Write</strong>, <strong>Seek</strong>, and <strong>SetCurrentPosition</strong>.	
        /// </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::BeginWrite']/*"/>	
        /// <msdn-id>ms694005</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::BeginWrite([In] const void* pb,[In] unsigned int cb,[In] IMFAsyncCallback* pCallback,[In] void* punkState)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::BeginWrite</unmanaged-short>	
        internal void BeginWrite__(System.IntPtr bRef, int cb, System.IntPtr callbackRef, System.IntPtr unkStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)bRef, cb, (void*)callbackRef, (void*)unkStateRef, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Completes an asynchronous write operation.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.</p> </dd></param>	
        /// <param name="cbWrittenRef"><dd> <p> Receives the number of bytes that were written. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Call this method when the <strong><see cref="SharpDX.MediaFoundation.IByteStream.BeginWrite_"/></strong> method completes asynchronously. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::EndWrite']/*"/>	
        /// <msdn-id>ms703863</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::EndWrite([In] IMFAsyncResult* pResult,[Out] unsigned int* pcbWritten)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::EndWrite</unmanaged-short>	
        internal void EndWrite_(SharpDX.MediaFoundation.AsyncResult resultRef, out int cbWrittenRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cbWrittenRef_ = &cbWrittenRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), cbWrittenRef_, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Moves the current position in the stream by a specified offset.</p>	
        /// </summary>	
        /// <param name="seekOrigin"><dd> <p> Specifies the origin of the seek as a member of the <strong><see cref="SharpDX.MediaFoundation.ByteStreamSeekOrigin"/></strong> enumeration. The offset is calculated relative to this position. </p> </dd></param>	
        /// <param name="llSeekOffset"><dd> <p> Specifies the new position, as a byte offset from the seek origin. </p> </dd></param>	
        /// <param name="dwSeekFlags"><dd> <p> Specifies zero or more flags. The following flags are defined. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_SEEK_FLAG_CANCEL_PENDING_IO</strong></dt> </dl> </td><td> <p> All pending I/O requests are canceled after the seek request completes successfully. </p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="qwCurrentPositionRef"><dd> <p> Receives the new position after the seek. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul><p><strong> Implementation notes:</strong> This method should update the current position in the stream by adding the <em>qwSeekOffset</em> to the seek <em>SeekOrigin</em> position. This should be the same value passed back in the <em>pqwCurrentPosition</em> parameter. 	
        /// Other methods that can update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, and <strong>SetCurrentPosition</strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::Seek']/*"/>	
        /// <msdn-id>ms697053</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::Seek([In] MFBYTESTREAM_SEEK_ORIGIN SeekOrigin,[In] longlong llSeekOffset,[In] unsigned int dwSeekFlags,[Out] unsigned longlong* pqwCurrentPosition)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::Seek</unmanaged-short>	
        internal void Seek_(SharpDX.MediaFoundation.ByteStreamSeekOrigin seekOrigin, long llSeekOffset, int dwSeekFlags, out long qwCurrentPositionRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* qwCurrentPositionRef_ = &qwCurrentPositionRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)seekOrigin), llSeekOffset, dwSeekFlags, qwCurrentPositionRef_, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Clears any internal buffers used by the stream. If you are writing to the stream, the buffered data is written to the underlying file or device. </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> If the byte stream is read-only, this method has no effect.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::Flush']/*"/>	
        /// <msdn-id>ms694833</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::Flush()</unmanaged>	
        /// <unmanaged-short>IMFByteStream::Flush</unmanaged-short>	
        internal void Flush_()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Closes the stream and releases any resources associated with the stream, such as sockets or file handles. This method also cancels any pending asynchronous I/O requests. </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::Close']/*"/>	
        /// <msdn-id>ms703909</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::Close()</unmanaged>	
        /// <unmanaged-short>IMFByteStream::Close</unmanaged-short>	
        internal void Close_()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[17]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Controls how a byte stream buffers data from a network. </p><p>To get a reference to this interface, call <strong>QueryInterface</strong> on the byte stream object.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p> If a byte stream implements this interface, a media source can use it to control how the byte stream buffers data. This interface is designed for byte streams that read data from a network. </p><p> A byte stream that implements this interface should also implement the <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator"/></strong> interface. When the byte stream starts buffering, it sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.BufferingStarted"/> event. When it stops buffering, it sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.BufferingStopped"/> event. </p><p> The byte stream must send a matching <see cref="SharpDX.MediaFoundation.MediaEventTypes.BufferingStopped"/> event for every <see cref="SharpDX.MediaFoundation.MediaEventTypes.BufferingStarted"/> event. The byte stream must not send <see cref="SharpDX.MediaFoundation.MediaEventTypes.BufferingStarted"/> events unless the media source has enabled buffering by calling <strong>EnableBuffering</strong> with the value <strong>TRUE</strong>. </p><p> After the byte stream sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.BufferingStarted"/> event, it should send <see cref="SharpDX.MediaFoundation.MediaEventTypes.BufferingStopped"/> if any of the following occur: </p><ul> <li> The byte stream finishes buffering data. </li> <li> The byte stream reaches the end of the stream. </li> <li> The media source calls <strong>EnableBuffering</strong> with the value <strong><see cref="SharpDX.Result.False"/></strong>. </li> <li> The media source calls <strong>StopBuffering</strong>. </li> </ul><p> The byte stream should not send any more buffering events after it reaches the end of the file. </p><p> If buffering is disabled, the byte stream does not send any buffering events. Internally, however, it might still buffer data while it waits for I/O requests to complete. Therefore, <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> methods might take an indefinite length of time to complete. </p><p> If the byte stream is buffering data internally and the media source calls <strong>EnableBuffering</strong> with the value <strong>TRUE</strong>, the byte stream can send <see cref="SharpDX.MediaFoundation.MediaEventTypes.BufferingStarted"/> immediately. </p><p> After the presentation has started, the media source should forward and <see cref="SharpDX.MediaFoundation.MediaEventTypes.BufferingStarted"/> and <see cref="SharpDX.MediaFoundation.MediaEventTypes.BufferingStopped"/> events that it receives while started. The Media Session will pause the presentation clock while buffering is progress and restart the presentation clock when buffering completes. The media source should only forward these events while the presentation is playing. The purpose of sending these events to the Media Session is to pause the presentation time while the source buffers data. </p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamBuffering']/*"/>	
    /// <msdn-id>aa372548</msdn-id>	
    /// <unmanaged>IMFByteStreamBuffering</unmanaged>	
    /// <unmanaged-short>IMFByteStreamBuffering</unmanaged-short>	
    [Guid("6d66d782-1d4f-4db7-8c63-cb8c77f1ef5e")]
    public partial class ByteStreamBuffering : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ByteStreamBuffering"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ByteStreamBuffering(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ByteStreamBuffering"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ByteStreamBuffering(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ByteStreamBuffering(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Sets the buffering parameters.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamBuffering::SetBufferingParams']/*"/>	
        /// <msdn-id>aa366520</msdn-id>	
        /// <unmanaged>SetBufferingParams</unmanaged>	
        /// <unmanaged-short>SetBufferingParams</unmanaged-short>	
        /// <unmanaged>HRESULT IMFByteStreamBuffering::SetBufferingParams([In] MFBYTESTREAM_BUFFERING_PARAMS* pParams)</unmanaged>
        public SharpDX.MediaFoundation.ByteStreamBufferingParameters BufferingParams
        {
            set { SetBufferingParams(ref value); }
        }

        /// <summary>	
        /// <p> </p><p>Sets the buffering parameters.</p>	
        /// </summary>	
        /// <param name="paramsRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.MediaFoundation.ByteStreamBufferingParameters"/></strong> structure that contains the buffering parameters. The byte stream uses this information to calculate how much data to buffer from the network.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamBuffering::SetBufferingParams']/*"/>	
        /// <msdn-id>aa366520</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStreamBuffering::SetBufferingParams([In] MFBYTESTREAM_BUFFERING_PARAMS* pParams)</unmanaged>	
        /// <unmanaged-short>IMFByteStreamBuffering::SetBufferingParams</unmanaged-short>	
        internal void SetBufferingParams(ref SharpDX.MediaFoundation.ByteStreamBufferingParameters paramsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* paramsRef_ = &paramsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, paramsRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Enables or disables buffering.</p>	
        /// </summary>	
        /// <param name="fEnable"><dd> <p>Specifies whether the byte stream buffers data. If <strong>TRUE</strong>, buffering is enabled. If <strong><see cref="SharpDX.Result.False"/></strong>, buffering is disabled.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Before calling this method, call <strong><see cref="SharpDX.MediaFoundation.ByteStreamBuffering.SetBufferingParams"/></strong> to set the buffering parameters on the byte stream.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamBuffering::EnableBuffering']/*"/>	
        /// <msdn-id>aa369933</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStreamBuffering::EnableBuffering([In] BOOL fEnable)</unmanaged>	
        /// <unmanaged-short>IMFByteStreamBuffering::EnableBuffering</unmanaged-short>	
        public void EnableBuffering(SharpDX.Mathematics.Interop.RawBool fEnable)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint6(_nativePointer, fEnable, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Stops any buffering that is in progress.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The byte stream successfully stopped buffering.</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p>No buffering was in progress.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the byte stream is currently buffering data, it stops and sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.BufferingStopped"/> event. If the byte stream is not currently buffering, this method has no effect.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamBuffering::StopBuffering']/*"/>	
        /// <msdn-id>aa375256</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStreamBuffering::StopBuffering()</unmanaged>	
        /// <unmanaged-short>IMFByteStreamBuffering::StopBuffering</unmanaged-short>	
        public void StopBuffering()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Controls how a network byte stream transfers data to a local cache. Optionally, this interface is exposed by byte streams that read data from a network, for example, through HTTP. </p><p>To get a reference to this interface, call <strong>QueryInterface</strong> on the byte stream object.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamCacheControl']/*"/>	
    /// <msdn-id>dd368785</msdn-id>	
    /// <unmanaged>IMFByteStreamCacheControl</unmanaged>	
    /// <unmanaged-short>IMFByteStreamCacheControl</unmanaged-short>	
    [Guid("F5042EA4-7A96-4a75-AA7B-2BE1EF7F88D5")]
    public partial class ByteStreamCacheControl : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ByteStreamCacheControl"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ByteStreamCacheControl(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ByteStreamCacheControl"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ByteStreamCacheControl(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ByteStreamCacheControl(nativePointer);
        }


        /// <summary>	
        /// <p>Stops the background transfer of data to the local cache.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The byte stream resumes transferring data to the cache if the application does one of the following:</p><ul> <li>Reads data from the byte stream.</li> <li>Calls the byte stream's <strong><see cref="SharpDX.MediaFoundation.ByteStreamBuffering.EnableBuffering"/></strong> method.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamCacheControl::StopBackgroundTransfer']/*"/>	
        /// <msdn-id>dd368786</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStreamCacheControl::StopBackgroundTransfer()</unmanaged>	
        /// <unmanaged-short>IMFByteStreamCacheControl::StopBackgroundTransfer</unmanaged-short>	
        public void StopBackgroundTransfer()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Controls how a network byte stream transfers data to a local cache. This interface extends the <strong><see cref="SharpDX.MediaFoundation.ByteStreamCacheControl"/></strong> interface.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Byte streams object in Microsoft Media Foundation can optionally implement this interface. To get a reference to this interface, call <strong>QueryInterface</strong> on the byte stream object. </p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamCacheControl2']/*"/>	
    /// <msdn-id>hh447830</msdn-id>	
    /// <unmanaged>IMFByteStreamCacheControl2</unmanaged>	
    /// <unmanaged-short>IMFByteStreamCacheControl2</unmanaged-short>	
    [Guid("71CE469C-F34B-49EA-A56B-2D2A10E51149")]
    public partial class ByteStreamCacheControl2 : SharpDX.MediaFoundation.ByteStreamCacheControl
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ByteStreamCacheControl2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ByteStreamCacheControl2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ByteStreamCacheControl2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ByteStreamCacheControl2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ByteStreamCacheControl2(nativePointer);
        }


        /// <summary>	
        /// <p>Limits the cache size.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamCacheControl2::SetCacheLimit']/*"/>	
        /// <msdn-id>hh447833</msdn-id>	
        /// <unmanaged>SetCacheLimit</unmanaged>	
        /// <unmanaged-short>SetCacheLimit</unmanaged-short>	
        /// <unmanaged>HRESULT IMFByteStreamCacheControl2::SetCacheLimit([In] unsigned longlong qwBytes)</unmanaged>
        public long CacheLimit
        {
            set { SetCacheLimit(value); }
        }

        /// <summary>	
        /// <p>Queries whether background transfer is active.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Background transfer might stop because the cache limit was reached (see <strong><see cref="SharpDX.MediaFoundation.ByteStreamCacheControl2.SetCacheLimit"/></strong>) or because the <strong><see cref="SharpDX.MediaFoundation.ByteStreamCacheControl.StopBackgroundTransfer"/></strong> method was called.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamCacheControl2::IsBackgroundTransferActive']/*"/>	
        /// <msdn-id>hh447832</msdn-id>	
        /// <unmanaged>IsBackgroundTransferActive</unmanaged>	
        /// <unmanaged-short>IsBackgroundTransferActive</unmanaged-short>	
        /// <unmanaged>HRESULT IMFByteStreamCacheControl2::IsBackgroundTransferActive([Out] BOOL* pfActive)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsBackgroundTransferActive
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; IsBackgroundTransferActive_(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets the ranges of bytes that are currently stored in the cache.</p>	
        /// </summary>	
        /// <param name="cRangesRef"><dd> <p>Receives the number of ranges returned in the <em>ppRanges</em> array.</p> </dd></param>	
        /// <param name="rangesOut"><dd> <p>Receives an array of <strong><see cref="SharpDX.MediaFoundation.ByteStreamCacheRange"/></strong> structures. Each structure specifies a range of bytes stored in the cache. The caller must free the array by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamCacheControl2::GetByteRanges']/*"/>	
        /// <msdn-id>hh447831</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStreamCacheControl2::GetByteRanges([Out] unsigned int* pcRanges,[Buffer, Optional] MF_BYTE_STREAM_CACHE_RANGE** ppRanges)</unmanaged>	
        /// <unmanaged-short>IMFByteStreamCacheControl2::GetByteRanges</unmanaged-short>	
        public void GetByteRanges(out int cRangesRef, SharpDX.MediaFoundation.ByteStreamCacheRange[] rangesOut)
        {
            unsafe
            {
                SharpDX.MediaFoundation.ByteStreamCacheRange[] rangesOut__ = rangesOut;
                SharpDX.Result __result__;
                fixed (void* cRangesRef_ = &cRangesRef)
                fixed (void* rangesOut_ = rangesOut__)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cRangesRef_, rangesOut_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Limits the cache size.</p>	
        /// </summary>	
        /// <param name="qwBytes"><dd> <p>The maximum number of bytes to store in the cache, or <strong>ULONGLONG_MAX </strong> for no limit.  The default value is no limit.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamCacheControl2::SetCacheLimit']/*"/>	
        /// <msdn-id>hh447833</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStreamCacheControl2::SetCacheLimit([In] unsigned longlong qwBytes)</unmanaged>	
        /// <unmanaged-short>IMFByteStreamCacheControl2::SetCacheLimit</unmanaged-short>	
        internal void SetCacheLimit(long qwBytes)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, qwBytes, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries whether background transfer is active.</p>	
        /// </summary>	
        /// <param name="fActiveRef"><dd> <p>Receives the value <strong>TRUE</strong> if background transfer is currently active, or <strong><see cref="SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Background transfer might stop because the cache limit was reached (see <strong><see cref="SharpDX.MediaFoundation.ByteStreamCacheControl2.SetCacheLimit"/></strong>) or because the <strong><see cref="SharpDX.MediaFoundation.ByteStreamCacheControl.StopBackgroundTransfer"/></strong> method was called.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamCacheControl2::IsBackgroundTransferActive']/*"/>	
        /// <msdn-id>hh447832</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStreamCacheControl2::IsBackgroundTransferActive([Out] BOOL* pfActive)</unmanaged>	
        /// <unmanaged-short>IMFByteStreamCacheControl2::IsBackgroundTransferActive</unmanaged-short>	
        internal void IsBackgroundTransferActive_(out SharpDX.Mathematics.Interop.RawBool fActiveRef)
        {
            unsafe
            {
                fActiveRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fActiveRef_ = &fActiveRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fActiveRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Creates a media source from a byte stream. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Applications do not use this interface directly. This interface is exposed by byte-stream handlers, which are used by the source resolver. When the byte-stream handler is given a byte stream, it parses the stream and creates a media source. Byte-stream handlers are registered by file name extension or MIME type.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamHandler']/*"/>	
    /// <msdn-id>ms699886</msdn-id>	
    /// <unmanaged>IMFByteStreamHandler</unmanaged>	
    /// <unmanaged-short>IMFByteStreamHandler</unmanaged-short>	
    [Guid("BB420AA4-765B-4a1f-91FE-D6A8A143924C")]
    public partial class ByteStreamHandler : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ByteStreamHandler"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ByteStreamHandler(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ByteStreamHandler"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ByteStreamHandler(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ByteStreamHandler(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the maximum number of bytes needed to create the media source or determine that the byte stream handler cannot parse this stream.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamHandler::GetMaxNumberOfBytesRequiredForResolution']/*"/>	
        /// <msdn-id>ms704770</msdn-id>	
        /// <unmanaged>GetMaxNumberOfBytesRequiredForResolution</unmanaged>	
        /// <unmanaged-short>GetMaxNumberOfBytesRequiredForResolution</unmanaged-short>	
        /// <unmanaged>HRESULT IMFByteStreamHandler::GetMaxNumberOfBytesRequiredForResolution([Out] unsigned longlong* pqwBytes)</unmanaged>
        public long MaxNumberOfBytesRequiredForResolution
        {
            get { long __output__; GetMaxNumberOfBytesRequiredForResolution(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Begins an asynchronous request to create a media source from a byte stream.</p>	
        /// </summary>	
        /// <param name="byteStreamRef"><dd> <p>Pointer to the byte stream's <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface.</p> </dd></param>	
        /// <param name="wszURLRef"><dd> <p>String that contains the original URL of the byte stream. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="dwFlags"><dd> <p>Bitwise OR of zero or more flags. See <strong>Source Resolver Flags</strong>.</p> </dd></param>	
        /// <param name="propsRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a property store. The byte-stream handler can use this property store to configure the object. This parameter can be <strong><c>null</c></strong>. For more information, see Configuring a Media Source.</p> </dd></param>	
        /// <param name="iUnknownCancelCookieOut"><dd> <p>Receives an <strong><see cref="SharpDX.ComObject"/></strong> reference or the value <strong><c>null</c></strong>. If the value is not <strong><c>null</c></strong>, you can cancel the asynchronous operation by passing this reference to the <strong><see cref="SharpDX.MediaFoundation.ByteStreamHandler.CancelObjectCreation"/></strong> method. The caller must release the interface. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.CannotParseByteStream"/></strong></dt> </dl> </td><td> <p>Unable to parse the byte stream.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The <em>dwFlags</em> parameter must contain the <see cref="SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/> flag and should not contain the <see cref="SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/> flag.</p><p>The byte-stream handler is responsible for parsing the stream and validating the contents. If the stream is not valid or the byte stream handler cannot parse the stream, the handler should return a failure code. The byte stream is not guaranteed to match the type of stream that the byte handler is designed to parse.</p><p>If the <em>pwszURL</em> parameter is not <strong><c>null</c></strong>, the byte-stream handler might use the URL during the resolution process. (For example, it might use the file name extension, if present.) Also, the byte stream might contain the <strong><see cref="SharpDX.MediaFoundation.ByteStreamAttributeKeys.ContentType"/></strong> attribute, specifying the MIME type.</p><p>When the operation completes, the byte-stream handler calls the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method. The <strong>Invoke</strong> method should call <strong><see cref="SharpDX.MediaFoundation.ByteStreamHandler.EndCreateObject"/></strong> to get a reference to the media source.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamHandler::BeginCreateObject']/*"/>	
        /// <msdn-id>ms696214</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStreamHandler::BeginCreateObject([In] IMFByteStream* pByteStream,[In] const wchar_t* pwszURL,[In] unsigned int dwFlags,[In] IPropertyStore* pProps,[Out, Optional] IUnknown** ppIUnknownCancelCookie,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>	
        /// <unmanaged-short>IMFByteStreamHandler::BeginCreateObject</unmanaged-short>	
        internal void BeginCreateObject__(System.IntPtr byteStreamRef, string wszURLRef, int dwFlags, SharpDX.ComObject propsRef, out SharpDX.ComObject iUnknownCancelCookieOut, System.IntPtr callbackRef, SharpDX.ComObject unkStateRef)
        {
            unsafe
            {
                IntPtr iUnknownCancelCookieOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* wszURLRef_ = wszURLRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)byteStreamRef, (void*)wszURLRef_, dwFlags, (void*)((propsRef == null) ? IntPtr.Zero : propsRef.NativePointer), &iUnknownCancelCookieOut_, (void*)callbackRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                iUnknownCancelCookieOut = (iUnknownCancelCookieOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(iUnknownCancelCookieOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Completes an asynchronous request to create a media source.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>Invoke</strong> method.</p> </dd></param>	
        /// <param name="objectTypeRef"><dd> <p>Receives a member of the <strong><see cref="SharpDX.MediaFoundation.ObjectType"/></strong> enumeration, specifying the type of object that was created.</p> </dd></param>	
        /// <param name="objectOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of the media source. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_ABORT</strong></dt> </dl> </td><td> <p>The operation was canceled. See <strong><see cref="SharpDX.MediaFoundation.ByteStreamHandler.CancelObjectCreation"/></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.CannotParseByteStream"/></strong></dt> </dl> </td><td> <p>Unable to parse the byte stream.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method from inside the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamHandler::EndCreateObject']/*"/>	
        /// <msdn-id>ms700217</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStreamHandler::EndCreateObject([In] IMFAsyncResult* pResult,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>	
        /// <unmanaged-short>IMFByteStreamHandler::EndCreateObject</unmanaged-short>	
        public void EndCreateObject(SharpDX.MediaFoundation.AsyncResult resultRef, out SharpDX.MediaFoundation.ObjectType objectTypeRef, out SharpDX.ComObject objectOut)
        {
            unsafe
            {
                IntPtr objectOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* objectTypeRef_ = &objectTypeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), objectTypeRef_, &objectOut_, ((void**)(*(void**)_nativePointer))[4]);
                objectOut = (objectOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(objectOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Cancels the current request to create a media source.</p>	
        /// </summary>	
        /// <param name="iUnknownCancelCookieRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface that was returned in the <em>ppIUnknownCancelCookie</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.ByteStreamHandler.BeginCreateObject__"/></strong> method.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You can use this method to cancel a previous call to <strong>BeginCreateObject</strong>. Because that method is asynchronous, however, it might be completed before the operation can be canceled. Therefore, your callback might still be invoked after you call this method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamHandler::CancelObjectCreation']/*"/>	
        /// <msdn-id>ms701576</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStreamHandler::CancelObjectCreation([In] IUnknown* pIUnknownCancelCookie)</unmanaged>	
        /// <unmanaged-short>IMFByteStreamHandler::CancelObjectCreation</unmanaged-short>	
        public void CancelObjectCreation(SharpDX.ComObject iUnknownCancelCookieRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iUnknownCancelCookieRef == null) ? IntPtr.Zero : iUnknownCancelCookieRef.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the maximum number of bytes needed to create the media source or determine that the byte stream handler cannot parse this stream.</p>	
        /// </summary>	
        /// <param name="qwBytesRef"><dd> <p>Receives the maximum number of bytes that are required.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamHandler::GetMaxNumberOfBytesRequiredForResolution']/*"/>	
        /// <msdn-id>ms704770</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStreamHandler::GetMaxNumberOfBytesRequiredForResolution([Out] unsigned longlong* pqwBytes)</unmanaged>	
        /// <unmanaged-short>IMFByteStreamHandler::GetMaxNumberOfBytesRequiredForResolution</unmanaged-short>	
        internal void GetMaxNumberOfBytesRequiredForResolution(out long qwBytesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* qwBytesRef_ = &qwBytesRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, qwBytesRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Creates a proxy to a byte stream. The proxy enables a media source to read from a byte stream in another process.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamProxyClassFactory']/*"/>	
    /// <msdn-id>hh447835</msdn-id>	
    /// <unmanaged>IMFByteStreamProxyClassFactory</unmanaged>	
    /// <unmanaged-short>IMFByteStreamProxyClassFactory</unmanaged-short>	
    [Guid("a6b43f84-5c0a-42e8-a44d-b1857a76992f")]
    public partial class ByteStreamProxyClassFactory : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ByteStreamProxyClassFactory"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ByteStreamProxyClassFactory(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ByteStreamProxyClassFactory"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ByteStreamProxyClassFactory(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ByteStreamProxyClassFactory(nativePointer);
        }


        /// <summary>	
        /// <p>Creates a proxy to a byte stream. The proxy enables a media source to read from a byte stream in another process.</p>	
        /// </summary>	
        /// <param name="byteStreamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of the byte stream to proxy.</p> </dd></param>	
        /// <param name="attributesRef"><dd> <p>Reserved. Set to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="riid"><dd> <p>The interface identifer (IID) of the interface being requested.</p> </dd></param>	
        /// <param name="vObjectOut"><dd> <p>Receives a reference to the interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamProxyClassFactory::CreateByteStreamProxy']/*"/>	
        /// <msdn-id>hh447835</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStreamProxyClassFactory::CreateByteStreamProxy([In, Optional] IMFByteStream* pByteStream,[In, Optional] IMFAttributes* pAttributes,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>	
        /// <unmanaged-short>IMFByteStreamProxyClassFactory::CreateByteStreamProxy</unmanaged-short>	
        internal void CreateByteStreamProxy_(System.IntPtr byteStreamRef, SharpDX.MediaFoundation.MediaAttributes attributesRef, System.Guid riid, out System.IntPtr vObjectOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vObjectOut_ = &vObjectOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)byteStreamRef, (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), &riid, vObjectOut_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Seeks a byte stream by time position.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A byte stream can implement this interface if it supports time-based seeking. For example, a byte stream that reads data from a server  might implement the interface. Typically, a local file-based byte stream would not implement it.</p><p>To get a reference to this interface, call <strong>QueryInterface</strong> on the byte stream object.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamTimeSeek']/*"/>	
    /// <msdn-id>hh447836</msdn-id>	
    /// <unmanaged>IMFByteStreamTimeSeek</unmanaged>	
    /// <unmanaged-short>IMFByteStreamTimeSeek</unmanaged-short>	
    [Guid("64976BFA-FB61-4041-9069-8C9A5F659BEB")]
    public partial class ByteStreamTimeSeek : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ByteStreamTimeSeek"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ByteStreamTimeSeek(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ByteStreamTimeSeek"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ByteStreamTimeSeek(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ByteStreamTimeSeek(nativePointer);
        }


        /// <summary>	
        /// <p>Queries whether the byte stream supports time-based seeking.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamTimeSeek::IsTimeSeekSupported']/*"/>	
        /// <msdn-id>hh447838</msdn-id>	
        /// <unmanaged>IsTimeSeekSupported</unmanaged>	
        /// <unmanaged-short>IsTimeSeekSupported</unmanaged-short>	
        /// <unmanaged>HRESULT IMFByteStreamTimeSeek::IsTimeSeekSupported([Out] BOOL* pfTimeSeekIsSupported)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsTimeSeekSupported
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; IsTimeSeekSupported_(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Queries whether the byte stream supports time-based seeking.</p>	
        /// </summary>	
        /// <param name="fTimeSeekIsSupportedRef"><dd> <p>Receives the value <strong>TRUE</strong> if the byte stream supports time-based seeking, or <strong><see cref="SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamTimeSeek::IsTimeSeekSupported']/*"/>	
        /// <msdn-id>hh447838</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStreamTimeSeek::IsTimeSeekSupported([Out] BOOL* pfTimeSeekIsSupported)</unmanaged>	
        /// <unmanaged-short>IMFByteStreamTimeSeek::IsTimeSeekSupported</unmanaged-short>	
        internal void IsTimeSeekSupported_(out SharpDX.Mathematics.Interop.RawBool fTimeSeekIsSupportedRef)
        {
            unsafe
            {
                fTimeSeekIsSupportedRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fTimeSeekIsSupportedRef_ = &fTimeSeekIsSupportedRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fTimeSeekIsSupportedRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Seeks to a new position in the byte stream.</p>	
        /// </summary>	
        /// <param name="qwTimePosition"><dd> <p>The new position, in 100-nanosecond units.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If the byte stream reads from a server, it might cache the seek request until the next read request. Therefore, the byte stream might not send a request to the server immediately.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamTimeSeek::TimeSeek']/*"/>	
        /// <msdn-id>hh447839</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStreamTimeSeek::TimeSeek([In] unsigned longlong qwTimePosition)</unmanaged>	
        /// <unmanaged-short>IMFByteStreamTimeSeek::TimeSeek</unmanaged-short>	
        public void TimeSeek(long qwTimePosition)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, qwTimePosition, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the result of a time-based seek.</p>	
        /// </summary>	
        /// <param name="qwStartTimeRef"><dd> <p>Receives the new position after the seek, in 100-nanosecond units.</p> </dd></param>	
        /// <param name="qwStopTimeRef"><dd> <p>Receives the stop time, in 100-nanosecond units. If the stop time is unknown, the value is zero.</p> </dd></param>	
        /// <param name="qwDurationRef"><dd> <p>Receives the total duration of the file, in 100-nanosecond units. If the duration is unknown, the value is ?1.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The byte stream does not support time-based seeking, or no data is available.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method returns the server response from a previous time-based seek. </p><strong>Note</strong>??This method normally cannot be invoked until some data is read from the byte stream, because the <strong><see cref="SharpDX.MediaFoundation.ByteStreamTimeSeek.TimeSeek"/></strong> method does not send a server request immediately.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStreamTimeSeek::GetTimeSeekResult']/*"/>	
        /// <msdn-id>hh447837</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStreamTimeSeek::GetTimeSeekResult([Out] unsigned longlong* pqwStartTime,[Out] unsigned longlong* pqwStopTime,[Out] unsigned longlong* pqwDuration)</unmanaged>	
        /// <unmanaged-short>IMFByteStreamTimeSeek::GetTimeSeekResult</unmanaged-short>	
        public void GetTimeSeekResult(out long qwStartTimeRef, out long qwStopTimeRef, out long qwDurationRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* qwStartTimeRef_ = &qwStartTimeRef)
                fixed (void* qwStopTimeRef_ = &qwStopTimeRef)
                fixed (void* qwDurationRef_ = &qwDurationRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, qwStartTimeRef_, qwStopTimeRef_, qwDurationRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Controls one or more capture devices. The capture engine implements this interface. To get a reference to this interface, call either <strong>MFCreateCaptureEngine</strong> or <strong><see cref="SharpDX.MediaFoundation.CaptureEngineClassFactory.CreateInstance"/></strong>.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><strong><see cref="SharpDX.MediaFoundation.CaptureEngine"/></strong> only supports one pass CBR encoding.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngine']/*"/>	
    /// <msdn-id>hh447846</msdn-id>	
    /// <unmanaged>IMFCaptureEngine</unmanaged>	
    /// <unmanaged-short>IMFCaptureEngine</unmanaged-short>	
    [Guid("a6bba433-176b-48b2-b375-53aa03473207")]
    public partial class CaptureEngine : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.CaptureEngine"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CaptureEngine(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.CaptureEngine"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.CaptureEngine(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.CaptureEngine(nativePointer);
        }


        /// <summary>Constant ClsidMFCaptureEngine.</summary>
        /// <unmanaged>CLSID_MFCaptureEngine</unmanaged>
        internal System.Guid ClsidMFCaptureEngine = new System.Guid("efce38d3-8914-4674-a7df-ae1b3d654b8a");

        /// <summary>	
        /// <p>Gets a reference to the capture source object. Use the capture source to configure the capture devices.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngine::GetSource']/*"/>	
        /// <msdn-id>hh447854</msdn-id>	
        /// <unmanaged>GetSource</unmanaged>	
        /// <unmanaged-short>GetSource</unmanaged-short>	
        /// <unmanaged>HRESULT IMFCaptureEngine::GetSource([Out] IMFCaptureSource** ppSource)</unmanaged>
        public SharpDX.MediaFoundation.CaptureSource Source
        {
            get { SharpDX.MediaFoundation.CaptureSource __output__; GetSource(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Initializes the capture engine.</p>	
        /// </summary>	
        /// <param name="eventCallbackRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.CaptureEngineOnEventCallback"/></strong> interface. The caller must implement this interface. The capture engine uses this interface to send asynchronous events to the caller.</p> </dd></param>	
        /// <param name="attributesRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. This parameter can be <strong><c>null</c></strong>. </p> <p>You can use this parameter to configure the capture engine. Call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAttributes"/></strong> to create an attribute store, and then set any of the following attributes.</p> <ul> <li> <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.D3DManager"/> </li> <li> <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.DisableDXVA"/> </li> <li> <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.DisableHardwareTransforms"/> </li> <li> <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.EncoderTransformFieldOfUseUnlockAttribute"/> </li> <li> <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.EventGeneratorGuid"/> </li> <li> <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.EventStreamIndex"/> </li> <li> <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.MediaSourceConfig"/> </li> <li> <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.RecordSinkAudioMaxProcessedSamples"/> </li> <li> <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.RecordSinkAudioMaxUnprocessedSamples"/> </li> <li> <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.RecordSinkVideoMaxProcessedSamples"/> </li> <li> <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.RecordSinkVideoMaxUnprocessedSamples"/> </li> <li> <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.UseAudioDeviceOnly"/> </li> <li> <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.UseVideoDeviceOnly"/> </li> </ul> </dd></param>	
        /// <param name="audioSourceRef"><dd> <p>An <strong><see cref="SharpDX.ComObject"/></strong> reference that specifies an audio-capture device. This parameter can be <strong><c>null</c></strong>.</p> <p>If you set the <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.UseVideoDeviceOnly"/> attribute to <strong>TRUE</strong> in <em>pAttributes</em>, the capture engine does not use an audio device, and the <em>pAudioSource</em> parameter is ignored.</p> <p>Otherwise, if <em>pAudioSource</em> is <strong><c>null</c></strong>, the capture engine selects the microphone that is built into the video camera specified by <em>pVideoSource</em>. If the video camera does not have a microphone, the capture engine enumerates the audio-capture devices on the system and selects the first one.</p> <p>To override the default audio device, set <em>pAudioSource</em> to an <strong><see cref="SharpDX.MediaFoundation.MediaSource"/></strong> or <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> reference for the device. For more information, see Audio/Video Capture in Media Foundation.</p> </dd></param>	
        /// <param name="videoSourceRef"><dd> <p>An <strong><see cref="SharpDX.ComObject"/></strong> reference that specifies a video-capture device. This parameter can be <strong><c>null</c></strong>.</p> <p>If you set the <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.UseAudioDeviceOnly"/> attribute to <strong>TRUE</strong> in <em>pAttributes</em>, the capture engine does not use a video device, and the <em>pVideoSource</em> parameter is ignored.</p> <p>Otherwise, if <em>pVideoSource</em> is <strong><c>null</c></strong>, the capture engine enumerates the video-capture devices on the system and selects the first one.</p> <p>To override the default video device, set <em>pVideoSource</em> to an <strong><see cref="SharpDX.MediaFoundation.MediaSource"/></strong> or <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> reference for the device. For more information, see Enumerating Video Capture Devices.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The <strong>Initialize</strong> method was already called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoCaptureDevicesAvailable"/></strong></dt> </dl> </td><td> <p>No capture devices are available.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You must call this method once before using the capture engine. Calling the method a second time returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong>.</p><p>This method is asynchronous. If the method returns a success code, the caller will receive an <strong>MF_CAPTURE_ENGINE_INITIALIZED</strong> event through the <strong><see cref="SharpDX.MediaFoundation.CaptureEngineOnEventCallback.OnEvent"/></strong> method. The operation can fail asynchronously after the method succeeds. If so, the error code is conveyed through the <strong>OnEvent</strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngine::Initialize']/*"/>	
        /// <msdn-id>hh447855</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureEngine::Initialize([In] IMFCaptureEngineOnEventCallback* pEventCallback,[In, Optional] IMFAttributes* pAttributes,[In, Optional] IUnknown* pAudioSource,[In, Optional] IUnknown* pVideoSource)</unmanaged>	
        /// <unmanaged-short>IMFCaptureEngine::Initialize</unmanaged-short>	
        internal void Initialize_(System.IntPtr eventCallbackRef, SharpDX.MediaFoundation.MediaAttributes attributesRef, SharpDX.ComObject audioSourceRef, SharpDX.ComObject videoSourceRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)eventCallbackRef, (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), (void*)((audioSourceRef == null) ? IntPtr.Zero : audioSourceRef.NativePointer), (void*)((videoSourceRef == null) ? IntPtr.Zero : videoSourceRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Starts preview.</p>	
        /// </summary>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The preview sink was not initialized.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Before calling this method, configure the preview sink by calling <strong><see cref="SharpDX.MediaFoundation.CaptureSink.AddStream"/></strong>. To get a reference to the preview sink, call <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.GetSink"/></strong>. </p><p>This method is asynchronous. If the method returns a success code, the caller will receive an <strong>MF_CAPTURE_ENGINE_PREVIEW_STARTED</strong> event through the <strong><see cref="SharpDX.MediaFoundation.CaptureEngineOnEventCallback.OnEvent"/></strong> method. The operation can fail asynchronously after the method succeeds. If so, the error code is conveyed through the <strong>OnEvent</strong> method.</p><p>After the preview sink is configured, you can stop and start preview by calling <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.StopPreview"/></strong> and <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.StartPreview"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngine::StartPreview']/*"/>	
        /// <msdn-id>hh447856</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureEngine::StartPreview()</unmanaged>	
        /// <unmanaged-short>IMFCaptureEngine::StartPreview</unmanaged-short>	
        public void StartPreview()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Stops preview.</p>	
        /// </summary>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The capture engine is not currently previewing.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is asynchronous. If the method returns a success code, the caller will receive an <strong>MF_CAPTURE_ENGINE_PREVIEW_STOPPED</strong> event through the <strong><see cref="SharpDX.MediaFoundation.CaptureEngineOnEventCallback.OnEvent"/></strong> method. The operation can fail asynchronously after the method succeeds. If so, the error code is conveyed through the <strong>OnEvent</strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngine::StopPreview']/*"/>	
        /// <msdn-id>hh447858</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureEngine::StopPreview()</unmanaged>	
        /// <unmanaged-short>IMFCaptureEngine::StopPreview</unmanaged-short>	
        public void StopPreview()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Starts recording audio and/or video to a file.</p>	
        /// </summary>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The recording sink was not initialized.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Before calling this method, configure the recording sink by calling <strong><see cref="SharpDX.MediaFoundation.CaptureSink.AddStream"/></strong>. To get a reference to the recording sink, call <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.GetSink"/></strong>.</p><p>This method is asynchronous. If the method returns a success code, the caller will receive an <strong>MF_CAPTURE_ENGINE_RECORD_STARTED</strong> event through the <strong><see cref="SharpDX.MediaFoundation.CaptureEngineOnEventCallback.OnEvent"/></strong> method. The operation can fail asynchronously after the method succeeds. If so, the error code is conveyed through the <strong>OnEvent</strong> method.</p><p>To stop recording, call <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.StopRecord"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngine::StartRecord']/*"/>	
        /// <msdn-id>hh447857</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureEngine::StartRecord()</unmanaged>	
        /// <unmanaged-short>IMFCaptureEngine::StartRecord</unmanaged-short>	
        public void StartRecord()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Stops recording.</p>	
        /// </summary>	
        /// <param name="bFinalize"><dd> <p>A Boolean value that specifies whether to finalize the output file. To create a valid output file, specify <strong>TRUE</strong>. Specify <strong><see cref="SharpDX.Result.False"/></strong> only if you want to interrupt the recording and discard the output file. If the value is <strong><see cref="SharpDX.Result.False"/></strong>, the operation completes more quickly, but the file will not be playable. </p> </dd></param>	
        /// <param name="bFlushUnprocessedSamples"><dd> <p>A Boolean value that specifies if the unprocessed samples waiting to be encoded should be flushed.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method is asynchronous. If the method returns a success code, the caller will receive an <strong>MF_CAPTURE_ENGINE_RECORD_STOPPED</strong> event through the <strong><see cref="SharpDX.MediaFoundation.CaptureEngineOnEventCallback.OnEvent"/></strong> method. The operation can fail asynchronously after the method succeeds. If so, the error code is conveyed through the <strong>OnEvent</strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngine::StopRecord']/*"/>	
        /// <msdn-id>hh447859</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureEngine::StopRecord([In] BOOL bFinalize,[In] BOOL bFlushUnprocessedSamples)</unmanaged>	
        /// <unmanaged-short>IMFCaptureEngine::StopRecord</unmanaged-short>	
        public void StopRecord(SharpDX.Mathematics.Interop.RawBool bFinalize, SharpDX.Mathematics.Interop.RawBool bFlushUnprocessedSamples)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint122(_nativePointer, bFinalize, bFlushUnprocessedSamples, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Captures a still image from the video stream.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Before calling this method, configure the photo sink by calling <strong><see cref="SharpDX.MediaFoundation.CaptureSink.AddStream"/></strong>. To get a reference to the photo sink, call <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.GetSink"/></strong>. </p><p>This method is asynchronous. If the method returns a success code, the caller will receive an <strong>MF_CAPTURE_ENGINE_PHOTO_TAKEN</strong> event through the <strong><see cref="SharpDX.MediaFoundation.CaptureEngineOnEventCallback.OnEvent"/></strong> method. The operation can fail asynchronously after the method succeeds. If so, the error code is conveyed through the <strong>OnEvent</strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngine::TakePhoto']/*"/>	
        /// <msdn-id>hh447860</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureEngine::TakePhoto()</unmanaged>	
        /// <unmanaged-short>IMFCaptureEngine::TakePhoto</unmanaged-short>	
        public void TakePhoto()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a reference to one of the capture sink objects. You can use the capture sinks to configure preview, recording, or still-image capture.</p>	
        /// </summary>	
        /// <param name="mfCaptureEngineSinkType"><dd> <p>An <strong><see cref="SharpDX.MediaFoundation.CaptureEngineSinkType"/></strong> value that specifies the capture sink to retrieve.</p> </dd></param>	
        /// <param name="sinkOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.CaptureSink"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngine::GetSink']/*"/>	
        /// <msdn-id>hh447853</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureEngine::GetSink([In] MF_CAPTURE_ENGINE_SINK_TYPE mfCaptureEngineSinkType,[Out] IMFCaptureSink** ppSink)</unmanaged>	
        /// <unmanaged-short>IMFCaptureEngine::GetSink</unmanaged-short>	
        public void GetSink(SharpDX.MediaFoundation.CaptureEngineSinkType mfCaptureEngineSinkType, out SharpDX.MediaFoundation.CaptureSink sinkOut)
        {
            unsafe
            {
                IntPtr sinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)mfCaptureEngineSinkType), &sinkOut_, ((void**)(*(void**)_nativePointer))[9]);
                sinkOut = (sinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.CaptureSink(sinkOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a reference to the capture source object. Use the capture source to configure the capture devices.</p>	
        /// </summary>	
        /// <param name="sourceOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.CaptureSource"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngine::GetSource']/*"/>	
        /// <msdn-id>hh447854</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureEngine::GetSource([Out] IMFCaptureSource** ppSource)</unmanaged>	
        /// <unmanaged-short>IMFCaptureEngine::GetSource</unmanaged-short>	
        internal void GetSource(out SharpDX.MediaFoundation.CaptureSource sourceOut)
        {
            unsafe
            {
                IntPtr sourceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &sourceOut_, ((void**)(*(void**)_nativePointer))[10]);
                sourceOut = (sourceOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.CaptureSource(sourceOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Creates an instance of the capture engine.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To get a reference to this interface, call the CoCreateInstance function and specify the CLSID equal to <strong><see cref="SharpDX.MediaFoundation.CaptureEngineClassFactory.ClsidMFCaptureEngineClassFactory"/></strong>. </p><p>Calling the <strong>MFCreateCaptureEngine</strong> function is equivalent to calling <strong><see cref="SharpDX.MediaFoundation.CaptureEngineClassFactory.CreateInstance"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngineClassFactory']/*"/>	
    /// <msdn-id>hh447847</msdn-id>	
    /// <unmanaged>IMFCaptureEngineClassFactory</unmanaged>	
    /// <unmanaged-short>IMFCaptureEngineClassFactory</unmanaged-short>	
    [Guid("8f02d140-56fc-4302-a705-3a97c78be779")]
    public partial class CaptureEngineClassFactory : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.CaptureEngineClassFactory"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CaptureEngineClassFactory(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.CaptureEngineClassFactory"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.CaptureEngineClassFactory(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.CaptureEngineClassFactory(nativePointer);
        }


        /// <summary>Constant ClsidMFCaptureEngineClassFactory.</summary>
        /// <unmanaged>CLSID_MFCaptureEngineClassFactory</unmanaged>
        internal System.Guid ClsidMFCaptureEngineClassFactory = new System.Guid("efce38d3-8914-4674-a7df-ae1b3d654b8a");

        /// <summary>	
        /// <p>Creates an instance of the capture engine.</p>	
        /// </summary>	
        /// <param name="clsid"><dd> <p>The CLSID of the object to create. Currently, this parameter must equal <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.ClsidMFCaptureEngine"/></strong>.</p> </dd></param>	
        /// <param name="riid"><dd> <p>The IID of the requested interface. The capture engine supports the <strong><see cref="SharpDX.MediaFoundation.CaptureEngine"/></strong> interface.</p> </dd></param>	
        /// <param name="vObjectOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Before calling this method, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngineClassFactory::CreateInstance']/*"/>	
        /// <msdn-id>hh447848</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureEngineClassFactory::CreateInstance([In] const GUID&amp; clsid,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>	
        /// <unmanaged-short>IMFCaptureEngineClassFactory::CreateInstance</unmanaged-short>	
        internal void CreateInstance(System.Guid clsid, System.Guid riid, out System.IntPtr vObjectOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vObjectOut_ = &vObjectOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &clsid, &riid, vObjectOut_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Callback interface for receiving events from the capture engine.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To set the callback interface on the capture engine, call the <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.Initialize_"/></strong> method.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngineOnEventCallback']/*"/>	
    /// <msdn-id>hh447849</msdn-id>	
    /// <unmanaged>IMFCaptureEngineOnEventCallback</unmanaged>	
    /// <unmanaged-short>IMFCaptureEngineOnEventCallback</unmanaged-short>	
    [Guid("aeda51c0-9025-4983-9012-de597b88b089")]
    internal partial interface CaptureEngineOnEventCallback : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p>Called by the capture engine to notify the application of a capture event.</p>	
        /// </summary>	
        /// <param name="eventRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaEvent"/></strong> interface. Use this interface to get information about the event, as described in Remarks.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To get the type of event, call <strong><see cref="SharpDX.MediaFoundation.MediaEvent.GetExtendedType"/></strong>. This method returns one of the following GUIDs.</p><table> <tr><th><see cref="System.Guid"/></th><th>Description</th></tr> <tr><td><strong>MF_CAPTURE_ENGINE_ALL_EFFECTS_REMOVED</strong></td><td>The <strong><see cref="SharpDX.MediaFoundation.CaptureSource.RemoveAllEffects"/></strong> method completed.</td></tr> <tr><td><strong>MF_CAPTURE_ENGINE_CAMERA_STREAM_BLOCKED</strong></td><td>Video capture has been blocked by the driver.</td></tr> <tr><td><strong>MF_CAPTURE_ENGINE_CAMERA_STREAM_UNBLOCKED</strong></td><td>Video capture has been restored by the driver after having been blocked.</td></tr> <tr><td><strong>MF_CAPTURE_ENGINE_EFFECT_ADDED</strong></td><td>The <strong><see cref="SharpDX.MediaFoundation.CaptureSource.AddEffect"/></strong> method completed.</td></tr> <tr><td><strong>MF_CAPTURE_ENGINE_EFFECT_REMOVED</strong></td><td>The <strong><see cref="SharpDX.MediaFoundation.CaptureSource.RemoveEffect"/></strong> method completed.</td></tr> <tr><td><strong>MF_CAPTURE_ENGINE_ERROR</strong></td><td>An error occurred during capture.</td></tr> <tr><td><strong>MF_CAPTURE_ENGINE_INITIALIZED</strong></td><td>The <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.Initialize_"/></strong> method completed.</td></tr> <tr><td><strong>MF_CAPTURE_ENGINE_PHOTO_TAKEN</strong></td><td>The <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.TakePhoto"/></strong> method completed.</td></tr> <tr><td><strong>MF_CAPTURE_ENGINE_PREVIEW_STARTED</strong></td><td>The <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.StartPreview"/></strong> method completed.</td></tr> <tr><td><strong>MF_CAPTURE_ENGINE_PREVIEW_STOPPED</strong></td><td>The <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.StopPreview"/></strong> method completed.</td></tr> <tr><td><strong>MF_CAPTURE_ENGINE_RECORD_STARTED</strong></td><td>The <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.StartRecord"/></strong> method completed.</td></tr> <tr><td><strong>MF_CAPTURE_ENGINE_RECORD_STOPPED</strong></td><td>The <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.StopRecord"/></strong> method completed.</td></tr> <tr><td><strong>MF_CAPTURE_SINK_PREPARED</strong></td><td>The <strong><see cref="SharpDX.MediaFoundation.CaptureSink.Prepare"/></strong> method completed.</td></tr> <tr><td><strong>MF_CAPTURE_SOURCE_CURRENT_DEVICE_MEDIA_TYPE_SET</strong></td><td>The <strong><see cref="SharpDX.MediaFoundation.CaptureSource.SetCurrentDeviceMediaType"/></strong> method completed.</td></tr> </table><p>?</p><p>This method may be called from a worker thread. The implementation should be thread-safe.</p><p>To get the status code for the event, call <strong><see cref="SharpDX.MediaFoundation.MediaEvent.GetStatus"/></strong>. If the status code is an error code, it indicates that the requested operation failed.</p><p>In addition, the event object specified by <em>pEvent</em> might contain any of the following attributes.</p><ul> <li> <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.EventGeneratorGuid"/> </li> <li> <see cref="SharpDX.MediaFoundation.CaptureEngineAttributeKeys.EventStreamIndex"/> </li> </ul><p>To get event attributes, use the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface, which <strong><see cref="SharpDX.MediaFoundation.MediaEvent"/></strong> inherits.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngineOnEventCallback::OnEvent']/*"/>	
        /// <msdn-id>hh447850</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureEngineOnEventCallback::OnEvent([In] IMFMediaEvent* pEvent)</unmanaged>	
        /// <unmanaged-short>IMFCaptureEngineOnEventCallback::OnEvent</unmanaged-short>	
        /* public void OnEvent(SharpDX.MediaFoundation.MediaEvent eventRef) */
    }
    /// <summary>	
    /// <p>Callback interface to receive data from the capture engine.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To set the callback interface, call one of the following methods.</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.CapturePhotoSink.SetSampleCallback_"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.CapturePreviewSink.SetSampleCallback_"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.CaptureRecordSink.SetSampleCallback_"/></strong> </li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngineOnSampleCallback']/*"/>	
    /// <msdn-id>hh447851</msdn-id>	
    /// <unmanaged>IMFCaptureEngineOnSampleCallback</unmanaged>	
    /// <unmanaged-short>IMFCaptureEngineOnSampleCallback</unmanaged-short>	
    [Guid("52150b82-ab39-4467-980f-e48bf0822ecd")]
    public partial interface CaptureEngineOnSampleCallback : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p>Called when the capture sink receives a sample.</p>	
        /// </summary>	
        /// <param name="sampleRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface. Use this interface to get the time stamp, duration, and stream data. For more information, see Media Samples. This parameter can be <strong><c>null</c></strong>, so make sure to check for a <strong><c>null</c></strong> value before you dereference the reference.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngineOnSampleCallback::OnSample']/*"/>	
        /// <msdn-id>hh447852</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureEngineOnSampleCallback::OnSample([In, Optional] IMFSample* pSample)</unmanaged>	
        /// <unmanaged-short>IMFCaptureEngineOnSampleCallback::OnSample</unmanaged-short>	
        /* public void OnSample(SharpDX.MediaFoundation.Sample sampleRef) */
    }
    /// <summary>	
    /// <p>Extensions for the <strong><see cref="SharpDX.MediaFoundation.CaptureEngineOnSampleCallback"/></strong> callback interface that is used to receive data from the capture engine.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngineOnSampleCallback2']/*"/>	
    /// <msdn-id>dn280677</msdn-id>	
    /// <unmanaged>IMFCaptureEngineOnSampleCallback2</unmanaged>	
    /// <unmanaged-short>IMFCaptureEngineOnSampleCallback2</unmanaged-short>	
    [Guid("e37ceed7-340f-4514-9f4d-9c2ae026100b")]
    public partial interface CaptureEngineOnSampleCallback2 : SharpDX.MediaFoundation.CaptureEngineOnSampleCallback
    {


        /// <summary>	
        /// <p>Called by the capture sink when the format of the sample is changed.</p>	
        /// </summary>	
        /// <param name="eventRef"><dd> <p>The new media type.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The return value is ignored.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureEngineOnSampleCallback2::OnSynchronizedEvent']/*"/>	
        /// <msdn-id>dn280678</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureEngineOnSampleCallback2::OnSynchronizedEvent([In] IMFMediaEvent* pEvent)</unmanaged>	
        /// <unmanaged-short>IMFCaptureEngineOnSampleCallback2::OnSynchronizedEvent</unmanaged-short>	
        /* public void OnSynchronizedEvent(SharpDX.MediaFoundation.MediaEvent eventRef) */
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePhotoConfirmation']/*"/>	
    /// <unmanaged>IMFCapturePhotoConfirmation</unmanaged>	
    /// <unmanaged-short>IMFCapturePhotoConfirmation</unmanaged-short>	
    [Guid("19f68549-ca8a-4706-a4ef-481dbc95e12c")]
    public partial class CapturePhotoConfirmation : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.CapturePhotoConfirmation"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CapturePhotoConfirmation(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.CapturePhotoConfirmation"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.CapturePhotoConfirmation(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.CapturePhotoConfirmation(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePhotoConfirmation::GetPixelFormat']/*"/>	
        /// <unmanaged>GetPixelFormat / SetPixelFormat</unmanaged>	
        /// <unmanaged-short>GetPixelFormat</unmanaged-short>	
        /// <unmanaged>HRESULT IMFCapturePhotoConfirmation::GetPixelFormat([Out] GUID* subtype)</unmanaged>
        public System.Guid PixelFormat
        {
            get { System.Guid __output__; GetPixelFormat(out __output__); return __output__; }
            set { SetPixelFormat(value); }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="notificationCallbackRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePhotoConfirmation::SetPhotoConfirmationCallback']/*"/>	
        /// <unmanaged>HRESULT IMFCapturePhotoConfirmation::SetPhotoConfirmationCallback([In] IMFAsyncCallback* pNotificationCallback)</unmanaged>	
        /// <unmanaged-short>IMFCapturePhotoConfirmation::SetPhotoConfirmationCallback</unmanaged-short>	
        internal void SetPhotoConfirmationCallback_(System.IntPtr notificationCallbackRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)notificationCallbackRef, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="subtype">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePhotoConfirmation::SetPixelFormat']/*"/>	
        /// <unmanaged>HRESULT IMFCapturePhotoConfirmation::SetPixelFormat([In] GUID subtype)</unmanaged>	
        /// <unmanaged-short>IMFCapturePhotoConfirmation::SetPixelFormat</unmanaged-short>	
        internal void SetPixelFormat(System.Guid subtype)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, subtype, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="subtype">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePhotoConfirmation::GetPixelFormat']/*"/>	
        /// <unmanaged>HRESULT IMFCapturePhotoConfirmation::GetPixelFormat([Out] GUID* subtype)</unmanaged>	
        /// <unmanaged-short>IMFCapturePhotoConfirmation::GetPixelFormat</unmanaged-short>	
        internal void GetPixelFormat(out System.Guid subtype)
        {
            unsafe
            {
                subtype = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* subtype_ = &subtype)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, subtype_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Controls the photo sink. The photo sink captures still images from the video stream.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The photo sink can deliver samples to one of the following destinations:</p><ul> <li>Byte stream.</li> <li>Output file.</li> <li>Application-provided callback interface.</li> </ul><p>The application must specify a single destination. Multiple destinations are not supported.</p><p>To capture an image, call <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.TakePhoto"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePhotoSink']/*"/>	
    /// <msdn-id>hh447861</msdn-id>	
    /// <unmanaged>IMFCapturePhotoSink</unmanaged>	
    /// <unmanaged-short>IMFCapturePhotoSink</unmanaged-short>	
    [Guid("d2d43cc8-48bb-4aa7-95db-10c06977e777")]
    public partial class CapturePhotoSink : SharpDX.MediaFoundation.CaptureSink
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.CapturePhotoSink"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CapturePhotoSink(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.CapturePhotoSink"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.CapturePhotoSink(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.CapturePhotoSink(nativePointer);
        }


        /// <summary>	
        /// <p>Specifies the name of the output file for the still image.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Calling this method overrides any previous call to <strong><see cref="SharpDX.MediaFoundation.CapturePhotoSink.SetOutputByteStream_"/></strong> or <strong><see cref="SharpDX.MediaFoundation.CapturePhotoSink.SetSampleCallback_"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePhotoSink::SetOutputFileName']/*"/>	
        /// <msdn-id>hh447863</msdn-id>	
        /// <unmanaged>SetOutputFileName</unmanaged>	
        /// <unmanaged-short>SetOutputFileName</unmanaged-short>	
        /// <unmanaged>HRESULT IMFCapturePhotoSink::SetOutputFileName([In] const wchar_t* fileName)</unmanaged>
        public string OutputFileName
        {
            set { SetOutputFileName(value); }
        }

        /// <summary>	
        /// <p>Specifies the name of the output file for the still image.</p>	
        /// </summary>	
        /// <param name="fileName"><dd> <p>A null-terminated string that contains the URL of the output file. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Calling this method overrides any previous call to <strong><see cref="SharpDX.MediaFoundation.CapturePhotoSink.SetOutputByteStream_"/></strong> or <strong><see cref="SharpDX.MediaFoundation.CapturePhotoSink.SetSampleCallback_"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePhotoSink::SetOutputFileName']/*"/>	
        /// <msdn-id>hh447863</msdn-id>	
        /// <unmanaged>HRESULT IMFCapturePhotoSink::SetOutputFileName([In] const wchar_t* fileName)</unmanaged>	
        /// <unmanaged-short>IMFCapturePhotoSink::SetOutputFileName</unmanaged-short>	
        internal void SetOutputFileName(string fileName)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* fileName_ = fileName)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)fileName_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets a callback to receive the still-image data.</p>	
        /// </summary>	
        /// <param name="callbackRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.CaptureEngineOnSampleCallback"/></strong> interface. The caller must implement this interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Calling this method overrides any previous call to <strong><see cref="SharpDX.MediaFoundation.CapturePhotoSink.SetOutputByteStream_"/></strong> or  <strong><see cref="SharpDX.MediaFoundation.CapturePhotoSink.SetOutputFileName"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePhotoSink::SetSampleCallback']/*"/>	
        /// <msdn-id>hh447864</msdn-id>	
        /// <unmanaged>HRESULT IMFCapturePhotoSink::SetSampleCallback([In] IMFCaptureEngineOnSampleCallback* pCallback)</unmanaged>	
        /// <unmanaged-short>IMFCapturePhotoSink::SetSampleCallback</unmanaged-short>	
        internal void SetSampleCallback_(System.IntPtr callbackRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)callbackRef, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Specifies a byte stream that will receive the still image data.</p>	
        /// </summary>	
        /// <param name="byteStreamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. The byte stream must be writable.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Calling this method overrides any previous call to <strong><see cref="SharpDX.MediaFoundation.CapturePhotoSink.SetOutputFileName"/></strong> or <strong><see cref="SharpDX.MediaFoundation.CapturePhotoSink.SetSampleCallback_"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePhotoSink::SetOutputByteStream']/*"/>	
        /// <msdn-id>hh447862</msdn-id>	
        /// <unmanaged>HRESULT IMFCapturePhotoSink::SetOutputByteStream([In] IMFByteStream* pByteStream)</unmanaged>	
        /// <unmanaged-short>IMFCapturePhotoSink::SetOutputByteStream</unmanaged-short>	
        internal void SetOutputByteStream_(System.IntPtr byteStreamRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)byteStreamRef, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Controls the preview sink. The preview sink enables the application to preview audio and video from the camera.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To start preview, call <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.StartPreview"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePreviewSink']/*"/>	
    /// <msdn-id>hh447865</msdn-id>	
    /// <unmanaged>IMFCapturePreviewSink</unmanaged>	
    /// <unmanaged-short>IMFCapturePreviewSink</unmanaged-short>	
    [Guid("77346cfd-5b49-4d73-ace0-5b52a859f2e0")]
    public partial class CapturePreviewSink : SharpDX.MediaFoundation.CaptureSink
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.CapturePreviewSink"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CapturePreviewSink(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.CapturePreviewSink"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.CapturePreviewSink(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.CapturePreviewSink(nativePointer);
        }


        /// <summary>	
        /// <p>Specifies a window for preview.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Calling this method overrides any previous call to <strong><see cref="SharpDX.MediaFoundation.CapturePreviewSink.SetSampleCallback_"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePreviewSink::SetRenderHandle']/*"/>	
        /// <msdn-id>hh447870</msdn-id>	
        /// <unmanaged>SetRenderHandle</unmanaged>	
        /// <unmanaged-short>SetRenderHandle</unmanaged-short>	
        /// <unmanaged>HRESULT IMFCapturePreviewSink::SetRenderHandle([In] void* handle)</unmanaged>
        public System.IntPtr RenderHandle
        {
            set { SetRenderHandle(value); }
        }

        /// <summary>	
        /// <p>Specifies a Microsoft DirectComposition visual for preview.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePreviewSink::SetRenderSurface']/*"/>	
        /// <msdn-id>hh447871</msdn-id>	
        /// <unmanaged>SetRenderSurface</unmanaged>	
        /// <unmanaged-short>SetRenderSurface</unmanaged-short>	
        /// <unmanaged>HRESULT IMFCapturePreviewSink::SetRenderSurface([In] IUnknown* pSurface)</unmanaged>
        public SharpDX.ComObject RenderSurface
        {
            set { SetRenderSurface(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the current mirroring state of the video preview stream.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePreviewSink::GetMirrorState']/*"/>	
        /// <msdn-id>hh447866</msdn-id>	
        /// <unmanaged>GetMirrorState / SetMirrorState</unmanaged>	
        /// <unmanaged-short>GetMirrorState</unmanaged-short>	
        /// <unmanaged>HRESULT IMFCapturePreviewSink::GetMirrorState([Out] BOOL* pfMirrorState)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool MirrorState
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; GetMirrorState(out __output__); return __output__; }
            set { SetMirrorState(value); }
        }

        /// <summary>	
        /// <p>Sets a custom media sink for preview.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method overrides the default selection of the media sink for preview.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePreviewSink::SetCustomSink']/*"/>	
        /// <msdn-id>hh447868</msdn-id>	
        /// <unmanaged>SetCustomSink</unmanaged>	
        /// <unmanaged-short>SetCustomSink</unmanaged-short>	
        /// <unmanaged>HRESULT IMFCapturePreviewSink::SetCustomSink([In] IMFMediaSink* pMediaSink)</unmanaged>
        public SharpDX.MediaFoundation.MediaSink CustomSink
        {
            set { SetCustomSink(value); }
        }

        /// <summary>	
        /// <p>Specifies a window for preview.</p>	
        /// </summary>	
        /// <param name="handle"><dd> <p>A handle to the window. The preview sink draws the video frames inside this window.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Calling this method overrides any previous call to <strong><see cref="SharpDX.MediaFoundation.CapturePreviewSink.SetSampleCallback_"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePreviewSink::SetRenderHandle']/*"/>	
        /// <msdn-id>hh447870</msdn-id>	
        /// <unmanaged>HRESULT IMFCapturePreviewSink::SetRenderHandle([In] void* handle)</unmanaged>	
        /// <unmanaged-short>IMFCapturePreviewSink::SetRenderHandle</unmanaged-short>	
        internal void SetRenderHandle(System.IntPtr handle)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)handle, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Specifies a Microsoft DirectComposition visual for preview.</p>	
        /// </summary>	
        /// <param name="surfaceRef"><dd> <p>A reference to a DirectComposition visual that implements the <strong><see cref="SharpDX.DirectComposition.Visual"/></strong> interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePreviewSink::SetRenderSurface']/*"/>	
        /// <msdn-id>hh447871</msdn-id>	
        /// <unmanaged>HRESULT IMFCapturePreviewSink::SetRenderSurface([In] IUnknown* pSurface)</unmanaged>	
        /// <unmanaged-short>IMFCapturePreviewSink::SetRenderSurface</unmanaged-short>	
        internal void SetRenderSurface(SharpDX.ComObject surfaceRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((surfaceRef == null) ? IntPtr.Zero : surfaceRef.NativePointer), ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Updates the video frame.  Call this method when the preview window receives a <strong>WM_PAINT</strong> or <strong>WM_SIZE</strong> message.</p>	
        /// </summary>	
        /// <param name="srcRef">No documentation.</param>	
        /// <param name="dstRef">No documentation.</param>	
        /// <param name="borderClrRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePreviewSink::UpdateVideo']/*"/>	
        /// <msdn-id>hh447874</msdn-id>	
        /// <unmanaged>HRESULT IMFCapturePreviewSink::UpdateVideo([In, Optional] const MFVideoNormalizedRect* pSrc,[In, Optional] const RECT* pDst,[In, Optional] const COLORREF* pBorderClr)</unmanaged>	
        /// <unmanaged-short>IMFCapturePreviewSink::UpdateVideo</unmanaged-short>	
        public void UpdateVideo(SharpDX.MediaFoundation.VideoNormalizedRect? srcRef, SharpDX.Mathematics.Interop.RawRectangle? dstRef, int? borderClrRef)
        {
            unsafe
            {
                SharpDX.MediaFoundation.VideoNormalizedRect srcRef_;
                if (srcRef.HasValue)
                    srcRef_ = srcRef.Value;
                SharpDX.Mathematics.Interop.RawRectangle dstRef_;
                if (dstRef.HasValue)
                    dstRef_ = dstRef.Value;
                int borderClrRef_;
                if (borderClrRef.HasValue)
                    borderClrRef_ = borderClrRef.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (srcRef.HasValue) ? &srcRef_ : (void*)IntPtr.Zero, (dstRef.HasValue) ? &dstRef_ : (void*)IntPtr.Zero, (borderClrRef.HasValue) ? &borderClrRef_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets a callback to receive the preview data for one stream.</p>	
        /// </summary>	
        /// <param name="dwStreamSinkIndex"><dd> <p>The zero-based index of the stream. The index is returned in the <em>pdwSinkStreamIndex</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.CaptureSink.AddStream"/></strong> method.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.CaptureEngineOnSampleCallback"/></strong> interface. The caller must implement this interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Calling this method overrides any previous call to <strong><see cref="SharpDX.MediaFoundation.CapturePreviewSink.SetRenderHandle"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePreviewSink::SetSampleCallback']/*"/>	
        /// <msdn-id>hh447873</msdn-id>	
        /// <unmanaged>HRESULT IMFCapturePreviewSink::SetSampleCallback([In] unsigned int dwStreamSinkIndex,[In] IMFCaptureEngineOnSampleCallback* pCallback)</unmanaged>	
        /// <unmanaged-short>IMFCapturePreviewSink::SetSampleCallback</unmanaged-short>	
        internal void SetSampleCallback_(int dwStreamSinkIndex, System.IntPtr callbackRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamSinkIndex, (void*)callbackRef, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the current mirroring state of the video preview stream.</p>	
        /// </summary>	
        /// <param name="fMirrorStateRef"><dd> <p>Receives the value <strong>TRUE</strong> if mirroring is enabled, or <strong><see cref="SharpDX.Result.False"/></strong> if mirroring is disabled.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePreviewSink::GetMirrorState']/*"/>	
        /// <msdn-id>hh447866</msdn-id>	
        /// <unmanaged>HRESULT IMFCapturePreviewSink::GetMirrorState([Out] BOOL* pfMirrorState)</unmanaged>	
        /// <unmanaged-short>IMFCapturePreviewSink::GetMirrorState</unmanaged-short>	
        internal void GetMirrorState(out SharpDX.Mathematics.Interop.RawBool fMirrorStateRef)
        {
            unsafe
            {
                fMirrorStateRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fMirrorStateRef_ = &fMirrorStateRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fMirrorStateRef_, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Enables or disables mirroring of the video preview stream.</p>	
        /// </summary>	
        /// <param name="fMirrorState"><dd> <p>If   <strong>TRUE</strong>, mirroring is enabled. If <strong><see cref="SharpDX.Result.False"/></strong>, mirror is disabled.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePreviewSink::SetMirrorState']/*"/>	
        /// <msdn-id>hh447869</msdn-id>	
        /// <unmanaged>HRESULT IMFCapturePreviewSink::SetMirrorState([In] BOOL fMirrorState)</unmanaged>	
        /// <unmanaged-short>IMFCapturePreviewSink::SetMirrorState</unmanaged-short>	
        internal void SetMirrorState(SharpDX.Mathematics.Interop.RawBool fMirrorState)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint6(_nativePointer, fMirrorState, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the rotation of the video preview stream.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of the stream. You must specify a video stream.</p> </dd></param>	
        /// <param name="dwRotationValueRef"><dd> <p>Receives the image rotation, in degrees.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePreviewSink::GetRotation']/*"/>	
        /// <msdn-id>hh447867</msdn-id>	
        /// <unmanaged>HRESULT IMFCapturePreviewSink::GetRotation([In] unsigned int dwStreamIndex,[Out] unsigned int* pdwRotationValue)</unmanaged>	
        /// <unmanaged-short>IMFCapturePreviewSink::GetRotation</unmanaged-short>	
        public void GetRotation(int dwStreamIndex, out int dwRotationValueRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwRotationValueRef_ = &dwRotationValueRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, dwRotationValueRef_, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Rotates the video preview stream.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of the stream to rotate. You must specify a video stream.</p> </dd></param>	
        /// <param name="dwRotationValue"><dd> <p>The amount to rotate the video, in degrees. Valid values are 0, 90, 180, and 270. The value zero restores the video to its original orientation.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePreviewSink::SetRotation']/*"/>	
        /// <msdn-id>hh447872</msdn-id>	
        /// <unmanaged>HRESULT IMFCapturePreviewSink::SetRotation([In] unsigned int dwStreamIndex,[In] unsigned int dwRotationValue)</unmanaged>	
        /// <unmanaged-short>IMFCapturePreviewSink::SetRotation</unmanaged-short>	
        public void SetRotation(int dwStreamIndex, int dwRotationValue)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, dwRotationValue, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets a custom media sink for preview.</p>	
        /// </summary>	
        /// <param name="mediaSinkRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaSink"/></strong> interface of the media sink.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method overrides the default selection of the media sink for preview.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCapturePreviewSink::SetCustomSink']/*"/>	
        /// <msdn-id>hh447868</msdn-id>	
        /// <unmanaged>HRESULT IMFCapturePreviewSink::SetCustomSink([In] IMFMediaSink* pMediaSink)</unmanaged>	
        /// <unmanaged-short>IMFCapturePreviewSink::SetCustomSink</unmanaged-short>	
        internal void SetCustomSink(SharpDX.MediaFoundation.MediaSink mediaSinkRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((mediaSinkRef == null) ? IntPtr.Zero : mediaSinkRef.NativePointer), ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Controls the recording sink. The recording sink creates compressed audio/video files or compressed audio/video streams.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The recording sink can deliver samples to one of the following destinations:</p><ul> <li>Byte stream.</li> <li>Output file.</li> <li>Application-provided callback interface.</li> </ul><p>The application must specify a single destination. Multiple destinations are not supported. (However, if a callback is used, you can provide a separate callback for each stream.)</p><p>If the destination is a byte stream or an output file, the application specifies a container type, such as MP4 or ASF. The capture engine then multiplexes the audio and video to produce the format defined by the container type. If the destination is a callback interface, however, the capture engine does not multiplex or otherwise interleave the samples. The callback option gives you the most control over the recorded output, but requires more work by the application.</p><p>To start the recording, call <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.StartRecord"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureRecordSink']/*"/>	
    /// <msdn-id>hh447875</msdn-id>	
    /// <unmanaged>IMFCaptureRecordSink</unmanaged>	
    /// <unmanaged-short>IMFCaptureRecordSink</unmanaged-short>	
    [Guid("3323b55a-f92a-4fe2-8edc-e9bfc0634d77")]
    public partial class CaptureRecordSink : SharpDX.MediaFoundation.CaptureSink
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.CaptureRecordSink"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CaptureRecordSink(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.CaptureRecordSink"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.CaptureRecordSink(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.CaptureRecordSink(nativePointer);
        }


        /// <summary>	
        /// <p>Specifies the name of the output file for the recording.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The capture engine uses the file name extension to select the container type for the output file. For example, if the file name extension is ."mp4", the capture engine creates an MP4 file.</p><p>Calling this method overrides any previous call to <strong><see cref="SharpDX.MediaFoundation.CaptureRecordSink.SetOutputByteStream_"/></strong> or <strong><see cref="SharpDX.MediaFoundation.CaptureRecordSink.SetSampleCallback_"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureRecordSink::SetOutputFileName']/*"/>	
        /// <msdn-id>hh447879</msdn-id>	
        /// <unmanaged>SetOutputFileName</unmanaged>	
        /// <unmanaged-short>SetOutputFileName</unmanaged-short>	
        /// <unmanaged>HRESULT IMFCaptureRecordSink::SetOutputFileName([In] const wchar_t* fileName)</unmanaged>
        public string OutputFileName
        {
            set { SetOutputFileName(value); }
        }

        /// <summary>	
        /// <p>Sets a custom media sink for recording.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method overrides the default selection of the media sink for recording.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureRecordSink::SetCustomSink']/*"/>	
        /// <msdn-id>hh447877</msdn-id>	
        /// <unmanaged>SetCustomSink</unmanaged>	
        /// <unmanaged-short>SetCustomSink</unmanaged-short>	
        /// <unmanaged>HRESULT IMFCaptureRecordSink::SetCustomSink([In] IMFMediaSink* pMediaSink)</unmanaged>
        public SharpDX.MediaFoundation.MediaSink CustomSink
        {
            set { SetCustomSink(value); }
        }

        /// <summary>	
        /// <p>Specifies a byte stream that will receive the data for the recording.</p>	
        /// </summary>	
        /// <param name="byteStreamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. The byte stream must be writable.</p> </dd></param>	
        /// <param name="guidContainerType"><dd> <p>A <see cref="System.Guid"/> that specifies the file container type. Possible values are documented in the <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeContainertype"/> attribute.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Calling this method overrides any previous call to <strong><see cref="SharpDX.MediaFoundation.CaptureRecordSink.SetOutputFileName"/></strong> or <strong><see cref="SharpDX.MediaFoundation.CaptureRecordSink.SetSampleCallback_"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureRecordSink::SetOutputByteStream']/*"/>	
        /// <msdn-id>hh447878</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureRecordSink::SetOutputByteStream([In] IMFByteStream* pByteStream,[In] const GUID&amp; guidContainerType)</unmanaged>	
        /// <unmanaged-short>IMFCaptureRecordSink::SetOutputByteStream</unmanaged-short>	
        internal void SetOutputByteStream_(System.IntPtr byteStreamRef, System.Guid guidContainerType)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)byteStreamRef, &guidContainerType, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Specifies the name of the output file for the recording.</p>	
        /// </summary>	
        /// <param name="fileName"><dd> <p>A null-terminated string that contains the URL of the output file. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The capture engine uses the file name extension to select the container type for the output file. For example, if the file name extension is ."mp4", the capture engine creates an MP4 file.</p><p>Calling this method overrides any previous call to <strong><see cref="SharpDX.MediaFoundation.CaptureRecordSink.SetOutputByteStream_"/></strong> or <strong><see cref="SharpDX.MediaFoundation.CaptureRecordSink.SetSampleCallback_"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureRecordSink::SetOutputFileName']/*"/>	
        /// <msdn-id>hh447879</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureRecordSink::SetOutputFileName([In] const wchar_t* fileName)</unmanaged>	
        /// <unmanaged-short>IMFCaptureRecordSink::SetOutputFileName</unmanaged-short>	
        internal void SetOutputFileName(string fileName)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* fileName_ = fileName)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)fileName_, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets a callback to receive the recording data for one stream.</p>	
        /// </summary>	
        /// <param name="dwStreamSinkIndex"><dd> <p>The zero-based index of the stream. The index is returned in the <em>pdwSinkStreamIndex</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.CaptureSink.AddStream"/></strong> method.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.CaptureEngineOnSampleCallback"/></strong> interface. The caller must implement this interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Calling this method overrides any previous call to <strong><see cref="SharpDX.MediaFoundation.CaptureRecordSink.SetOutputByteStream_"/></strong> or  <strong><see cref="SharpDX.MediaFoundation.CaptureRecordSink.SetOutputFileName"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureRecordSink::SetSampleCallback']/*"/>	
        /// <msdn-id>hh447881</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureRecordSink::SetSampleCallback([In] unsigned int dwStreamSinkIndex,[In] IMFCaptureEngineOnSampleCallback* pCallback)</unmanaged>	
        /// <unmanaged-short>IMFCaptureRecordSink::SetSampleCallback</unmanaged-short>	
        internal void SetSampleCallback_(int dwStreamSinkIndex, System.IntPtr callbackRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamSinkIndex, (void*)callbackRef, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets a custom media sink for recording.</p>	
        /// </summary>	
        /// <param name="mediaSinkRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaSink"/></strong> interface of the media sink.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method overrides the default selection of the media sink for recording.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureRecordSink::SetCustomSink']/*"/>	
        /// <msdn-id>hh447877</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureRecordSink::SetCustomSink([In] IMFMediaSink* pMediaSink)</unmanaged>	
        /// <unmanaged-short>IMFCaptureRecordSink::SetCustomSink</unmanaged-short>	
        internal void SetCustomSink(SharpDX.MediaFoundation.MediaSink mediaSinkRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((mediaSinkRef == null) ? IntPtr.Zero : mediaSinkRef.NativePointer), ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the rotation that is currently being applied to the recorded video stream.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of the stream. You must specify a video stream.</p> </dd></param>	
        /// <param name="dwRotationValueRef"><dd> <p>Receives the image rotation, in degrees.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureRecordSink::GetRotation']/*"/>	
        /// <msdn-id>hh447876</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureRecordSink::GetRotation([In] unsigned int dwStreamIndex,[Out] unsigned int* pdwRotationValue)</unmanaged>	
        /// <unmanaged-short>IMFCaptureRecordSink::GetRotation</unmanaged-short>	
        public void GetRotation(int dwStreamIndex, out int dwRotationValueRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwRotationValueRef_ = &dwRotationValueRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, dwRotationValueRef_, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Rotates the recorded video stream.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of the stream to rotate. You must specify a video stream.</p> </dd></param>	
        /// <param name="dwRotationValue"><dd> <p>The amount to rotate the video, in degrees. Valid values are 0, 90, 180, and 270. The value zero restores the video to its original orientation.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureRecordSink::SetRotation']/*"/>	
        /// <msdn-id>hh447880</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureRecordSink::SetRotation([In] unsigned int dwStreamIndex,[In] unsigned int dwRotationValue)</unmanaged>	
        /// <unmanaged-short>IMFCaptureRecordSink::SetRotation</unmanaged-short>	
        public void SetRotation(int dwStreamIndex, int dwRotationValue)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, dwRotationValue, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Controls a capture sink, which is an object that receives one or more streams from a capture device.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The capture engine creates the following capture sinks.</p><ul> <li>Photo sink. Encodes still image files.</li> <li>Preview sink. Previews live audio or video.</li> <li>Recording sink. Creates compressed audio/video files or compressed audio/video streams.</li> </ul><p>To get a reference to a capture sink, call <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.GetSink"/></strong>. Each capture sink implements an interface that derives from <strong><see cref="SharpDX.MediaFoundation.CaptureSink"/></strong>. Call <strong>QueryInterface</strong> to get a reference to the derived interface.</p><table> <tr><th>Sink</th><th>Interface</th></tr> <tr><td>Photo sink</td><td> <strong><see cref="SharpDX.MediaFoundation.CapturePhotoSink"/></strong> </td></tr> <tr><td>Preview sink</td><td> <strong><see cref="SharpDX.MediaFoundation.CapturePreviewSink"/></strong> </td></tr> <tr><td>Recording sink</td><td> <strong><see cref="SharpDX.MediaFoundation.CaptureRecordSink"/></strong> </td></tr> </table><p>?</p><p>Applications cannot directly create the capture sinks.</p><p>If an image stream native media type is set to JPEG, the photo sink should be configured with a format identical to native source format. JPEG native type is passthrough only.</p><p>If an image stream native type is set to JPEG, to add an effect, change the native type on the image stream to an uncompressed video media type (such as NV12 or RGB32) and then add the effect.</p><p>If the native type is H.264 for the record stream, the record sink should be configured with the same media type. H.264 native type is passthrough only and cannot be decoded.</p><p>Record streams that expose H.264 do not  expose any other type. H.264 record streams cannot be used in conjunction with effects. To add effects, instead connect the preview stream to the recordsink using <strong>AddStream</strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSink']/*"/>	
    /// <msdn-id>hh447882</msdn-id>	
    /// <unmanaged>IMFCaptureSink</unmanaged>	
    /// <unmanaged-short>IMFCaptureSink</unmanaged-short>	
    [Guid("72d6135b-35e9-412c-b926-fd5265f2a885")]
    public partial class CaptureSink : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.CaptureSink"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CaptureSink(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.CaptureSink"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.CaptureSink(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.CaptureSink(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the output format for a stream on this capture sink.</p>	
        /// </summary>	
        /// <param name="dwSinkStreamIndex"><dd> <p>The zero-based index of the stream to query. The index is returned in the <em>pdwSinkStreamIndex</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.CaptureSink.AddStream"/></strong> method.</p> </dd></param>	
        /// <param name="mediaTypeOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the reference.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The <em>dwSinkStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSink::GetOutputMediaType']/*"/>	
        /// <msdn-id>hh447884</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSink::GetOutputMediaType([In] unsigned int dwSinkStreamIndex,[Out, Optional] IMFMediaType** ppMediaType)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSink::GetOutputMediaType</unmanaged-short>	
        public void GetOutputMediaType(int dwSinkStreamIndex, out SharpDX.MediaFoundation.MediaType mediaTypeOut)
        {
            unsafe
            {
                IntPtr mediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwSinkStreamIndex, &mediaTypeOut_, ((void**)(*(void**)_nativePointer))[3]);
                mediaTypeOut = (mediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(mediaTypeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries the underlying Sink Writer object for an interface.</p>	
        /// </summary>	
        /// <param name="dwSinkStreamIndex">No documentation.</param>	
        /// <param name="rguidService">No documentation.</param>	
        /// <param name="riid">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSink::GetService']/*"/>	
        /// <msdn-id>hh447885</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSink::GetService([In] unsigned int dwSinkStreamIndex,[In] const GUID&amp; rguidService,[In] const GUID&amp; riid,[Out, Optional] IUnknown** ppUnknown)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSink::GetService</unmanaged-short>	
        public SharpDX.ComObject GetService(int dwSinkStreamIndex, System.Guid rguidService, System.Guid riid)
        {
            unsafe
            {
                SharpDX.ComObject unknownOut;
                IntPtr unknownOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwSinkStreamIndex, &rguidService, &riid, &unknownOut_, ((void**)(*(void**)_nativePointer))[4]);
                unknownOut = (unknownOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(unknownOut_);
                __result__.CheckError();
                return unknownOut;
            }
        }

        /// <summary>	
        /// <p>Connects a stream from the capture source to this capture sink.</p>	
        /// </summary>	
        /// <param name="dwSourceStreamIndex"><dd> <p>The source stream to connect. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream. To get the number of streams, call <strong><see cref="SharpDX.MediaFoundation.CaptureSource.GetDeviceStreamCount"/></strong>.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</strong></strong></dt> <dt>0xFFFFFFFB</dt> </dl> </td><td> <p>The first image stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="mediaTypeRef"><dd> <p>An <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> reference that specifies the desired format of the output stream. The details of the format will depend on the capture sink.</p> <ul> <li>Photo sink: A still image format compatible with Windows Imaging Component (WIC).</li> <li>Preview sink: An uncompressed audio or video format.</li> <li>Record sink: The audio or video format that will be written to the output file.</li> </ul> </dd></param>	
        /// <param name="attributesRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. For compressed streams, you can use this parameter to configure the encoder. This parameter can also be <strong><c>null</c></strong>. For the preview sink, set this parameter to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="dwSinkStreamIndexRef"><dd> <p>Receives the index of the new stream on the capture sink. Note that this index will not necessarily match the value of <em>dwSourceStreamIndex</em>. </p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidMediaType"/></strong></dt> </dl> </td><td> <p>The format specified in <em>pMediaType</em> is not valid for this capture sink.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The <em>dwSourceStreamIndex</em> parameter is invalid, or the specified source stream was already connected to this sink.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSink::AddStream']/*"/>	
        /// <msdn-id>hh447883</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSink::AddStream([In] unsigned int dwSourceStreamIndex,[In] IMFMediaType* pMediaType,[In, Optional] IMFAttributes* pAttributes,[Out, Optional] unsigned int* pdwSinkStreamIndex)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSink::AddStream</unmanaged-short>	
        public void AddStream(int dwSourceStreamIndex, SharpDX.MediaFoundation.MediaType mediaTypeRef, SharpDX.MediaFoundation.MediaAttributes attributesRef, out int dwSinkStreamIndexRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwSinkStreamIndexRef_ = &dwSinkStreamIndexRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwSourceStreamIndex, (void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), dwSinkStreamIndexRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Prepares the capture sink by loading any required pipeline components, such as encoders, video processors, and media sinks.</p>	
        /// </summary>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid request.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Calling this method is optional. This method gives the application an opportunity to configure the pipeline components before they are used. The method is asynchronous. If the method returns a success code, the caller will receive an <strong>MF_CAPTURE_SINK_PREPARED</strong> event through the <strong><see cref="SharpDX.MediaFoundation.CaptureEngineOnEventCallback.OnEvent"/></strong> method.  After this event is received, call <strong><see cref="SharpDX.MediaFoundation.CaptureSink.GetService"/></strong> to configure individual components.</p><p>Before calling this method, configure the capture sink by adding at least one stream. To add a stream, call <strong><see cref="SharpDX.MediaFoundation.CaptureSink.AddStream"/></strong>.</p><p>The <strong>Prepare</strong> method fails if the capture sink is currently in use. For example, calling <strong>Prepare</strong> on the preview sink fails if the capture engine is currently previewing.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSink::Prepare']/*"/>	
        /// <msdn-id>hh447886</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSink::Prepare()</unmanaged>	
        /// <unmanaged-short>IMFCaptureSink::Prepare</unmanaged-short>	
        public void Prepare()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Removes all streams from the capture sink.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>You can use this method to reconfigure the sink.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSink::RemoveAllStreams']/*"/>	
        /// <msdn-id>hh447887</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSink::RemoveAllStreams()</unmanaged>	
        /// <unmanaged-short>IMFCaptureSink::RemoveAllStreams</unmanaged-short>	
        public void RemoveAllStreams()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Extends the <strong><see cref="SharpDX.MediaFoundation.CaptureSink"/></strong> interface to provide  functionality for dynamically setting the output media type of the record sink or preview sink.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSink2']/*"/>	
    /// <msdn-id>dn280679</msdn-id>	
    /// <unmanaged>IMFCaptureSink2</unmanaged>	
    /// <unmanaged-short>IMFCaptureSink2</unmanaged-short>	
    [Guid("f9e4219e-6197-4b5e-b888-bee310ab2c59")]
    public partial class CaptureSink2 : SharpDX.MediaFoundation.CaptureSink
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.CaptureSink2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CaptureSink2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.CaptureSink2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.CaptureSink2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.CaptureSink2(nativePointer);
        }


        /// <summary>	
        /// <p>Dynamically sets the output media type of the record sink or preview sink.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The stream index to change the output media type on.</p> </dd></param>	
        /// <param name="mediaTypeRef"><dd> <p>The new output media type.</p> </dd></param>	
        /// <param name="encodingAttributesRef"><dd> <p>The new encoder attributes. This can be  <strong>null</strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded</p> </td></tr> <tr><td> <dl> <dt><strong>MF_E_INVALID_MEDIATYPE</strong></dt> </dl> </td><td> <p>The sink does not support the media type.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This is an asynchronous call.  Listen to the MF_CAPTURE_ENGINE_OUTPUT_MEDIA_TYPE_SET event	
        /// to be notified when the output media type has been set.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSink2::SetOutputMediaType']/*"/>	
        /// <msdn-id>dn280680</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSink2::SetOutputMediaType([In] unsigned int dwStreamIndex,[In] IMFMediaType* pMediaType,[In, Optional] IMFAttributes* pEncodingAttributes)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSink2::SetOutputMediaType</unmanaged-short>	
        public void SetOutputMediaType(int dwStreamIndex, SharpDX.MediaFoundation.MediaType mediaTypeRef, SharpDX.MediaFoundation.MediaAttributes encodingAttributesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, (void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), (void*)((encodingAttributesRef == null) ? IntPtr.Zero : encodingAttributesRef.NativePointer), ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Controls the capture source object. The capture source manages the audio and video capture devices.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To get a reference to the capture source, call <strong><see cref="SharpDX.MediaFoundation.CaptureEngine.GetSource"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSource']/*"/>	
    /// <msdn-id>hh447889</msdn-id>	
    /// <unmanaged>IMFCaptureSource</unmanaged>	
    /// <unmanaged-short>IMFCaptureSource</unmanaged-short>	
    [Guid("439a42a8-0d2c-4505-be83-f79b2a05d5c4")]
    public partial class CaptureSource : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.CaptureSource"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CaptureSource(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.CaptureSource"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.CaptureSource(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.CaptureSource(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the number of device streams.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSource::GetDeviceStreamCount']/*"/>	
        /// <msdn-id>hh447894</msdn-id>	
        /// <unmanaged>GetDeviceStreamCount</unmanaged>	
        /// <unmanaged-short>GetDeviceStreamCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFCaptureSource::GetDeviceStreamCount([Out] unsigned int* pdwStreamCount)</unmanaged>
        public int DeviceStreamCount
        {
            get { int __output__; GetDeviceStreamCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets the current capture device's <strong><see cref="SharpDX.MediaFoundation.MediaSource"/></strong> object reference.</p>	
        /// </summary>	
        /// <param name="mfCaptureEngineDeviceType">No documentation.</param>	
        /// <param name="mediaSourceOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSource::GetCaptureDeviceSource']/*"/>	
        /// <msdn-id>jj159896</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSource::GetCaptureDeviceSource([In] MF_CAPTURE_ENGINE_DEVICE_TYPE mfCaptureEngineDeviceType,[Out, Optional] IMFMediaSource** ppMediaSource)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSource::GetCaptureDeviceSource</unmanaged-short>	
        public void GetCaptureDeviceSource(SharpDX.MediaFoundation.CaptureEngineDeviceType mfCaptureEngineDeviceType, out SharpDX.MediaFoundation.MediaSource mediaSourceOut)
        {
            unsafe
            {
                IntPtr mediaSourceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)mfCaptureEngineDeviceType), &mediaSourceOut_, ((void**)(*(void**)_nativePointer))[3]);
                mediaSourceOut = (mediaSourceOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSource(mediaSourceOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the current capture device's <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> object reference.</p>	
        /// </summary>	
        /// <param name="mfCaptureEngineDeviceType">No documentation.</param>	
        /// <param name="activateOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSource::GetCaptureDeviceActivate']/*"/>	
        /// <msdn-id>jj159895</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSource::GetCaptureDeviceActivate([In] MF_CAPTURE_ENGINE_DEVICE_TYPE mfCaptureEngineDeviceType,[Out, Optional] IMFActivate** ppActivate)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSource::GetCaptureDeviceActivate</unmanaged-short>	
        public void GetCaptureDeviceActivate(SharpDX.MediaFoundation.CaptureEngineDeviceType mfCaptureEngineDeviceType, out SharpDX.MediaFoundation.Activate activateOut)
        {
            unsafe
            {
                IntPtr activateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)mfCaptureEngineDeviceType), &activateOut_, ((void**)(*(void**)_nativePointer))[4]);
                activateOut = (activateOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Activate(activateOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a reference to the underlying Source Reader object.</p>	
        /// </summary>	
        /// <param name="rguidService">No documentation.</param>	
        /// <param name="riid">No documentation.</param>	
        /// <param name="unknownOut">No documentation.</param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The capture source was not initialized. Possibly there is no capture device on the system.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSource::GetService']/*"/>	
        /// <msdn-id>hh447896</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSource::GetService([In] const GUID&amp; rguidService,[In] const GUID&amp; riid,[Out, Optional] IUnknown** ppUnknown)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSource::GetService</unmanaged-short>	
        public void GetService(System.Guid rguidService, System.Guid riid, out SharpDX.ComObject unknownOut)
        {
            unsafe
            {
                IntPtr unknownOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &rguidService, &riid, &unknownOut_, ((void**)(*(void**)_nativePointer))[5]);
                unknownOut = (unknownOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(unknownOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Adds an effect to a capture stream.</p>	
        /// </summary>	
        /// <param name="dwSourceStreamIndex"><dd> <p>The capture stream. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.  To get the number of streams, call <strong><see cref="SharpDX.MediaFoundation.CaptureSource.GetDeviceStreamCount"/></strong>.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</strong></strong></dt> <dt>0xFFFFFFFB</dt> </dl> </td><td> <p>The first image stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="unknownRef"><dd> <p>A reference to one of the following: </p> <ul> <li>A Media Foundation transform (MFT) that exposes the <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> interface.</li> <li>An MFT activation object that exposes the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface.</li> </ul> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidMediaType"/></strong></dt> </dl> </td><td> <p>No compatible media type could be found.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The <em>dwSourceStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The effect must be implemented as a Media Foundation Transform (MFT). The <em>pUnknown</em> parameter can point to an instance of the MFT, or to an activation object for the MFT. For more information, see Activation Objects.</p><p>The effect is applied to the stream before the data reaches the capture sinks. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSource::AddEffect']/*"/>	
        /// <msdn-id>hh447890</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSource::AddEffect([In] unsigned int dwSourceStreamIndex,[In] IUnknown* pUnknown)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSource::AddEffect</unmanaged-short>	
        public void AddEffect(int dwSourceStreamIndex, SharpDX.ComObject unknownRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwSourceStreamIndex, (void*)((unknownRef == null) ? IntPtr.Zero : unknownRef.NativePointer), ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Removes an effect from a capture stream.</p>	
        /// </summary>	
        /// <param name="dwSourceStreamIndex"><dd> <p>The capture stream. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.  To get the number of streams, call <strong><see cref="SharpDX.MediaFoundation.CaptureSource.GetDeviceStreamCount"/></strong>.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</strong></strong></dt> <dt>0xFFFFFFFB</dt> </dl> </td><td> <p>The first image stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="unknownRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of the effect object. </p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid request. Possibly the specified effect could not be found.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The <em>dwSourceStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method removes an effect that was previously added using the <strong><see cref="SharpDX.MediaFoundation.CaptureSource.AddEffect"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSource::RemoveEffect']/*"/>	
        /// <msdn-id>hh447898</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSource::RemoveEffect([In] unsigned int dwSourceStreamIndex,[In] IUnknown* pUnknown)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSource::RemoveEffect</unmanaged-short>	
        public void RemoveEffect(int dwSourceStreamIndex, SharpDX.ComObject unknownRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwSourceStreamIndex, (void*)((unknownRef == null) ? IntPtr.Zero : unknownRef.NativePointer), ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Removes all effects from a capture stream.</p>	
        /// </summary>	
        /// <param name="dwSourceStreamIndex"><dd> <p>The capture stream. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream. To get the number of streams, call <strong><see cref="SharpDX.MediaFoundation.CaptureSource.GetDeviceStreamCount"/></strong>.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</strong></strong></dt> <dt>0xFFFFFFFB</dt> </dl> </td><td> <p>The first image stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The <em>dwSourceStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSource::RemoveAllEffects']/*"/>	
        /// <msdn-id>hh447897</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSource::RemoveAllEffects([In] unsigned int dwSourceStreamIndex)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSource::RemoveAllEffects</unmanaged-short>	
        public void RemoveAllEffects(int dwSourceStreamIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwSourceStreamIndex, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a format that is supported by one of the capture streams.</p>	
        /// </summary>	
        /// <param name="dwSourceStreamIndex"><dd> <p>The stream to query. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream. To get the number of streams, call <strong><see cref="SharpDX.MediaFoundation.CaptureSource.GetDeviceStreamCount"/></strong>.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</strong></strong></dt> <dt>0xFFFFFFFB</dt> </dl> </td><td> <p>The first image stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="dwMediaTypeIndex"><dd> <p>The zero-based index of the media type to retrieve.</p> </dd></param>	
        /// <param name="mediaTypeOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The <em>dwSourceStreamIndex</em> parameter is invalid.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoMoreTypes"/></strong></dt> </dl> </td><td> <p>The <em>dwMediaTypeIndex</em> parameter is out of range. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To enumerate all of the available formats on a stream, call this method in a loop while incrementing <em>dwMediaTypeIndex</em>, until the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.NoMoreTypes"/></strong>.</p><p>Some cameras might support a range of frame rates. The minimum and maximum frame rates are stored in the <see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.FrameRateRangeMin"/> and <see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.FrameRateRangeMax"/> attributes on the media type.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSource::GetAvailableDeviceMediaType']/*"/>	
        /// <msdn-id>hh447891</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSource::GetAvailableDeviceMediaType([In] unsigned int dwSourceStreamIndex,[In] unsigned int dwMediaTypeIndex,[Out, Optional] IMFMediaType** ppMediaType)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSource::GetAvailableDeviceMediaType</unmanaged-short>	
        public void GetAvailableDeviceMediaType(int dwSourceStreamIndex, int dwMediaTypeIndex, out SharpDX.MediaFoundation.MediaType mediaTypeOut)
        {
            unsafe
            {
                IntPtr mediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwSourceStreamIndex, dwMediaTypeIndex, &mediaTypeOut_, ((void**)(*(void**)_nativePointer))[9]);
                mediaTypeOut = (mediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(mediaTypeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the output format for a capture stream.</p>	
        /// </summary>	
        /// <param name="dwSourceStreamIndex"><dd> <p>The capture stream to set. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream. To get the number of streams, call <strong><see cref="SharpDX.MediaFoundation.CaptureSource.GetDeviceStreamCount"/></strong>.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</strong></strong></dt> <dt>0xFFFFFFFB</dt> </dl> </td><td> <p>The first image stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="mediaTypeRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The <em>dwSourceStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method sets the native output type on the capture device. The device must support the specified format. To get the list of available formats, call <strong><see cref="SharpDX.MediaFoundation.CaptureSource.GetAvailableDeviceMediaType"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSource::SetCurrentDeviceMediaType']/*"/>	
        /// <msdn-id>hh447899</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSource::SetCurrentDeviceMediaType([In] unsigned int dwSourceStreamIndex,[In] IMFMediaType* pMediaType)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSource::SetCurrentDeviceMediaType</unmanaged-short>	
        public void SetCurrentDeviceMediaType(int dwSourceStreamIndex, SharpDX.MediaFoundation.MediaType mediaTypeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwSourceStreamIndex, (void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the current media type for a capture stream.</p>	
        /// </summary>	
        /// <param name="dwSourceStreamIndex"><dd> <p>Specifies which stream to query. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.  To get the number of streams, call <strong><see cref="SharpDX.MediaFoundation.CaptureSource.GetDeviceStreamCount"/></strong>.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</strong></strong></dt> <dt>0xFFFFFFFB</dt> </dl> </td><td> <p>The first image stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="mediaTypeOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The <em>dwSourceStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSource::GetCurrentDeviceMediaType']/*"/>	
        /// <msdn-id>hh447893</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSource::GetCurrentDeviceMediaType([In] unsigned int dwSourceStreamIndex,[Out] IMFMediaType** ppMediaType)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSource::GetCurrentDeviceMediaType</unmanaged-short>	
        public void GetCurrentDeviceMediaType(int dwSourceStreamIndex, out SharpDX.MediaFoundation.MediaType mediaTypeOut)
        {
            unsafe
            {
                IntPtr mediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwSourceStreamIndex, &mediaTypeOut_, ((void**)(*(void**)_nativePointer))[11]);
                mediaTypeOut = (mediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(mediaTypeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the number of device streams.</p>	
        /// </summary>	
        /// <param name="dwStreamCountRef"><dd> <p>Receives the number of device streams.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSource::GetDeviceStreamCount']/*"/>	
        /// <msdn-id>hh447894</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSource::GetDeviceStreamCount([Out] unsigned int* pdwStreamCount)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSource::GetDeviceStreamCount</unmanaged-short>	
        internal void GetDeviceStreamCount(out int dwStreamCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwStreamCountRef_ = &dwStreamCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamCountRef_, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the stream category for the specified source stream index.</p>	
        /// </summary>	
        /// <param name="dwSourceStreamIndex"><dd> <p>The index of the source stream.</p> </dd></param>	
        /// <param name="streamCategoryRef"><dd> <p>Receives the <see cref="SharpDX.MediaFoundation.CaptureEngineStreamCategory"/> of the specified source stream.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSource::GetDeviceStreamCategory']/*"/>	
        /// <msdn-id>jj159897</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSource::GetDeviceStreamCategory([In] unsigned int dwSourceStreamIndex,[Out] MF_CAPTURE_ENGINE_STREAM_CATEGORY* pStreamCategory)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSource::GetDeviceStreamCategory</unmanaged-short>	
        public void GetDeviceStreamCategory(int dwSourceStreamIndex, out SharpDX.MediaFoundation.CaptureEngineStreamCategory streamCategoryRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* streamCategoryRef_ = &streamCategoryRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwSourceStreamIndex, streamCategoryRef_, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the current mirroring state of the video preview stream.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of the stream.</p> </dd></param>	
        /// <param name="fMirrorStateRef"><dd> <p>Receives the value <strong>TRUE</strong> if mirroring is enabled, or <strong><see cref="SharpDX.Result.False"/></strong> if mirroring is disabled.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSource::GetMirrorState']/*"/>	
        /// <msdn-id>hh447895</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSource::GetMirrorState([In] unsigned int dwStreamIndex,[Out] BOOL* pfMirrorState)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSource::GetMirrorState</unmanaged-short>	
        public void GetMirrorState(int dwStreamIndex, out SharpDX.Mathematics.Interop.RawBool fMirrorStateRef)
        {
            unsafe
            {
                fMirrorStateRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fMirrorStateRef_ = &fMirrorStateRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, fMirrorStateRef_, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Enables or disables mirroring of the video preview stream.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of the stream.</p> </dd></param>	
        /// <param name="fMirrorState"><dd> <p>If   <strong>TRUE</strong>,    mirroring is enabled; if  <strong><see cref="SharpDX.Result.False"/></strong>, mirroring is  disabled.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>The device stream does not have mirroring capability.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The source is not initialized.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSource::SetMirrorState']/*"/>	
        /// <msdn-id>hh447900</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSource::SetMirrorState([In] unsigned int dwStreamIndex,[In] BOOL fMirrorState)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSource::SetMirrorState</unmanaged-short>	
        public void SetMirrorState(int dwStreamIndex, SharpDX.Mathematics.Interop.RawBool fMirrorState)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint19(_nativePointer, dwStreamIndex, fMirrorState, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the actual device stream index translated from a friendly stream name.</p>	
        /// </summary>	
        /// <param name="uifriendlyName"><dd> <p>The friendly name.  Can be one of the following:</p> <ul> <li>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</li> <li>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</li> <li>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</li> <li>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_VIDEO_STREAM_FOR_RECORD</li> <li>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_VIDEO_STREAM_FOR_PREVIEW</li> <li>MF_CAPTURE_ENGINE_FIRST_SOURCE_INDEPENDENT_PHOTO_STREAM</li> </ul> </dd></param>	
        /// <param name="dwActualStreamIndexRef"><dd> <p>Receives the value of the stream index that corresponds to the friendly name.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCaptureSource::GetStreamIndexFromFriendlyName']/*"/>	
        /// <msdn-id>jj128307</msdn-id>	
        /// <unmanaged>HRESULT IMFCaptureSource::GetStreamIndexFromFriendlyName([In] unsigned int uifriendlyName,[Out] unsigned int* pdwActualStreamIndex)</unmanaged>	
        /// <unmanaged-short>IMFCaptureSource::GetStreamIndexFromFriendlyName</unmanaged-short>	
        public void GetStreamIndexFromFriendlyName(int uifriendlyName, out int dwActualStreamIndexRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwActualStreamIndexRef_ = &dwActualStreamIndexRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, uifriendlyName, dwActualStreamIndexRef_, ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Used to enable the client to notify the Content Decryption Module (CDM) when global resources should be brought into a consistent state prior to suspending.	
    /// </p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCdmSuspendNotify']/*"/>	
    /// <msdn-id>dn280681</msdn-id>	
    /// <unmanaged>IMFCdmSuspendNotify</unmanaged>	
    /// <unmanaged-short>IMFCdmSuspendNotify</unmanaged-short>	
    [Guid("7a5645d2-43bd-47fd-87b7-dcd24cc7d692")]
    public partial class CdmSuspendNotify : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.CdmSuspendNotify"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CdmSuspendNotify(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.CdmSuspendNotify"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.CdmSuspendNotify(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.CdmSuspendNotify(nativePointer);
        }


        /// <summary>	
        /// <p>Indicates that the suspend process is starting and  resources should be brought into a consistent state.  </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCdmSuspendNotify::Begin']/*"/>	
        /// <msdn-id>dn280682</msdn-id>	
        /// <unmanaged>HRESULT IMFCdmSuspendNotify::Begin()</unmanaged>	
        /// <unmanaged-short>IMFCdmSuspendNotify::Begin</unmanaged-short>	
        public void Begin()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>The actual suspend is about to occur and no more calls will be made into the Content Decryption Module (CDM).</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCdmSuspendNotify::End']/*"/>	
        /// <msdn-id>dn280683</msdn-id>	
        /// <unmanaged>HRESULT IMFCdmSuspendNotify::End()</unmanaged>	
        /// <unmanaged-short>IMFCdmSuspendNotify::End</unmanaged-short>	
        public void End()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides timing information from a clock in Microsoft Media Foundation.</p><p>Clocks and some media sinks expose this interface through <strong>QueryInterface</strong>.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.MediaFoundation.Clock"/></strong> interface applies to any kind of clock. The presentation clock exposes the <strong><see cref="SharpDX.MediaFoundation.PresentationClock"/></strong> interface in addition to <strong><see cref="SharpDX.MediaFoundation.Clock"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClock']/*"/>	
    /// <msdn-id>ms696248</msdn-id>	
    /// <unmanaged>IMFClock</unmanaged>	
    /// <unmanaged-short>IMFClock</unmanaged-short>	
    [Guid("2eb1e945-18b8-4139-9b1a-d5d584818530")]
    public partial class Clock : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.Clock"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Clock(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.Clock"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.Clock(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.Clock(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the characteristics of the clock.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClock::GetClockCharacteristics']/*"/>	
        /// <msdn-id>ms697050</msdn-id>	
        /// <unmanaged>GetClockCharacteristics</unmanaged>	
        /// <unmanaged-short>GetClockCharacteristics</unmanaged-short>	
        /// <unmanaged>HRESULT IMFClock::GetClockCharacteristics([Out] unsigned int* pdwCharacteristics)</unmanaged>
        public int ClockCharacteristics
        {
            get { int __output__; GetClockCharacteristics(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the clock's continuity key. (Not supported.)</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Continuity keys are currently not supported in Media Foundation. Clocks must return the value zero in the <em>pdwContinuityKey</em> parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClock::GetContinuityKey']/*"/>	
        /// <msdn-id>ms700188</msdn-id>	
        /// <unmanaged>GetContinuityKey</unmanaged>	
        /// <unmanaged-short>GetContinuityKey</unmanaged-short>	
        /// <unmanaged>HRESULT IMFClock::GetContinuityKey([Out] unsigned int* pdwContinuityKey)</unmanaged>
        public int ContinuityKey
        {
            get { int __output__; GetContinuityKey(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the properties of the clock.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClock::GetProperties']/*"/>	
        /// <msdn-id>ms701613</msdn-id>	
        /// <unmanaged>GetProperties</unmanaged>	
        /// <unmanaged-short>GetProperties</unmanaged-short>	
        /// <unmanaged>HRESULT IMFClock::GetProperties([Out] MFCLOCK_PROPERTIES* pClockProperties)</unmanaged>
        public SharpDX.MediaFoundation.ClockProperties Properties
        {
            get { SharpDX.MediaFoundation.ClockProperties __output__; GetProperties(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the characteristics of the clock.</p>	
        /// </summary>	
        /// <param name="dwCharacteristicsRef"><dd> <p>Receives a bitwise OR of values from the <strong><see cref="SharpDX.MediaFoundation.ClockCharacteristicsFlags"/></strong> enumeration indicating the characteristics of the clock.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClock::GetClockCharacteristics']/*"/>	
        /// <msdn-id>ms697050</msdn-id>	
        /// <unmanaged>HRESULT IMFClock::GetClockCharacteristics([Out] unsigned int* pdwCharacteristics)</unmanaged>	
        /// <unmanaged-short>IMFClock::GetClockCharacteristics</unmanaged-short>	
        internal void GetClockCharacteristics(out int dwCharacteristicsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwCharacteristicsRef_ = &dwCharacteristicsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwCharacteristicsRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Retrieves the last clock time that was correlated with system time. </p>	
        /// </summary>	
        /// <param name="dwReserved"><dd> <p> Reserved, must be zero. </p> </dd></param>	
        /// <param name="llClockTimeRef"><dd> <p> Receives the last known clock time, in units of the clock's frequency. </p> </dd></param>	
        /// <param name="hnsSystemTimeRef"><dd> <p> Receives the system time that corresponds to the clock time returned in <em>pllClockTime</em>, in 100-nanosecond units. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ClockNoTimeSource"/></strong></dt> </dl> </td><td> <p> The clock does not have a time source. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>At some fixed interval, a clock correlates its internal clock ticks with the system time. (The system time is the time returned by the high-resolution performance counter.) This method returns:</p><ul> <li> The most recent clock time that was correlated with system time. </li> <li> The system time when the correlation was performed. </li> </ul><p> The clock time is returned in the <em>pllClockTime</em> parameter and is expressed in units of the clock's frequency. If the clock's <strong><see cref="SharpDX.MediaFoundation.Clock.GetClockCharacteristics"/></strong> method returns the <strong><see cref="SharpDX.MediaFoundation.ClockCharacteristicsFlags.Frequency10mhz"/></strong> flag, the clock's frequency is 10 MHz (each clock tick is 100 nanoseconds). Otherwise, you can get the clock's frequency by calling <strong><see cref="SharpDX.MediaFoundation.Clock.GetProperties"/></strong>. The frequency is given in the <strong>qwClockFrequency</strong> member of the <strong><see cref="SharpDX.MediaFoundation.ClockProperties"/></strong> structure returned by that method. </p><p> The system time is returned in the <em>phnsSystemTime</em> parameter, and is always expressed in 100-nanosecond units. </p><p> To find out how often the clock correlates its clock time with the system time, call <strong>GetProperties</strong>. The correlation interval is given in the <strong>qwCorrelationRate</strong> member of the <strong><see cref="SharpDX.MediaFoundation.ClockProperties"/></strong> structure. If <strong>qwCorrelationRate</strong> is zero, it means the clock performs the correlation whenever <strong>GetCorrelatedTime</strong> is called. Otherwise, you can calculate the current clock time by extrapolating from the last correlated time. </p><p> Some clocks support rate changes through the <strong><see cref="SharpDX.MediaFoundation.RateControl"/></strong> interface. If so, the clock time advances at a speed of frequency ? current rate. If a clock does not expose the <strong><see cref="SharpDX.MediaFoundation.RateControl"/></strong> interface, the rate is always 1.0. </p><p>For the presentation clock, the clock time is the presentation time, and is always relative to the starting time specified in <strong><see cref="SharpDX.MediaFoundation.PresentationClock.Start"/></strong>. You can also get the presentation time by calling <strong><see cref="SharpDX.MediaFoundation.PresentationClock.GetTime"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClock::GetCorrelatedTime']/*"/>	
        /// <msdn-id>ms694122</msdn-id>	
        /// <unmanaged>HRESULT IMFClock::GetCorrelatedTime([In] unsigned int dwReserved,[Out] longlong* pllClockTime,[Out] longlong* phnsSystemTime)</unmanaged>	
        /// <unmanaged-short>IMFClock::GetCorrelatedTime</unmanaged-short>	
        public void GetCorrelatedTime(int dwReserved, out long llClockTimeRef, out long hnsSystemTimeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* llClockTimeRef_ = &llClockTimeRef)
                fixed (void* hnsSystemTimeRef_ = &hnsSystemTimeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwReserved, llClockTimeRef_, hnsSystemTimeRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the clock's continuity key. (Not supported.)</p>	
        /// </summary>	
        /// <param name="dwContinuityKeyRef"><dd> <p>Receives the continuity key.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Continuity keys are currently not supported in Media Foundation. Clocks must return the value zero in the <em>pdwContinuityKey</em> parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClock::GetContinuityKey']/*"/>	
        /// <msdn-id>ms700188</msdn-id>	
        /// <unmanaged>HRESULT IMFClock::GetContinuityKey([Out] unsigned int* pdwContinuityKey)</unmanaged>	
        /// <unmanaged-short>IMFClock::GetContinuityKey</unmanaged-short>	
        internal void GetContinuityKey(out int dwContinuityKeyRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwContinuityKeyRef_ = &dwContinuityKeyRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwContinuityKeyRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the current state of the clock.</p>	
        /// </summary>	
        /// <param name="dwReserved"><dd> <p>Reserved, must be zero.</p> </dd></param>	
        /// <param name="eClockStateRef"><dd> <p>Receives the clock state, as a member of the <strong><see cref="SharpDX.MediaFoundation.ClockState"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClock::GetState']/*"/>	
        /// <msdn-id>ms700206</msdn-id>	
        /// <unmanaged>HRESULT IMFClock::GetState([In] unsigned int dwReserved,[Out] MFCLOCK_STATE* peClockState)</unmanaged>	
        /// <unmanaged-short>IMFClock::GetState</unmanaged-short>	
        public void GetState(int dwReserved, out SharpDX.MediaFoundation.ClockState eClockStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* eClockStateRef_ = &eClockStateRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwReserved, eClockStateRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the properties of the clock.</p>	
        /// </summary>	
        /// <param name="clockPropertiesRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.MediaFoundation.ClockProperties"/></strong> structure that receives the properties.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClock::GetProperties']/*"/>	
        /// <msdn-id>ms701613</msdn-id>	
        /// <unmanaged>HRESULT IMFClock::GetProperties([Out] MFCLOCK_PROPERTIES* pClockProperties)</unmanaged>	
        /// <unmanaged-short>IMFClock::GetProperties</unmanaged-short>	
        internal void GetProperties(out SharpDX.MediaFoundation.ClockProperties clockPropertiesRef)
        {
            unsafe
            {
                clockPropertiesRef = new SharpDX.MediaFoundation.ClockProperties();
                SharpDX.Result __result__;
                fixed (void* clockPropertiesRef_ = &clockPropertiesRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, clockPropertiesRef_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Creates a media source or a byte stream from a URL. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Applications do not use this interface. This interface is exposed by scheme handlers, which are used by the source resolver. A scheme handler is designed to parse one type of URL scheme. When the scheme handler is given a URL, it parses the resource that is located at that URL and creates either a media source or a byte stream.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClockConsumer']/*"/>	
    /// <msdn-id>ms701638</msdn-id>	
    /// <unmanaged>IMFClockConsumer</unmanaged>	
    /// <unmanaged-short>IMFClockConsumer</unmanaged-short>	
    [Guid("6ef2a662-47c0-4666-b13d-cbb717f2fa2c")]
    public partial class ClockConsumer : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ClockConsumer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ClockConsumer(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ClockConsumer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ClockConsumer(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ClockConsumer(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClockConsumer::GetPresentationClock']/*"/>	
        /// <unmanaged>GetPresentationClock / SetPresentationClock</unmanaged>	
        /// <unmanaged-short>GetPresentationClock</unmanaged-short>	
        /// <unmanaged>HRESULT IMFClockConsumer::GetPresentationClock([Out] IMFPresentationClock** ppPresentationClock)</unmanaged>
        public SharpDX.MediaFoundation.PresentationClock PresentationClock
        {
            get { SharpDX.MediaFoundation.PresentationClock __output__; GetPresentationClock(out __output__); return __output__; }
            set { SetPresentationClock(value); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called by the media pipeline to provide the app with an instance of <strong><see cref="SharpDX.MediaFoundation.PresentationClock"/></strong>.</p>	
        /// </summary>	
        /// <param name="presentationClockRef">No documentation.</param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClockConsumer::SetPresentationClock']/*"/>	
        /// <msdn-id>mt797926</msdn-id>	
        /// <unmanaged>HRESULT IMFClockConsumer::SetPresentationClock([In, Optional] IMFPresentationClock* pPresentationClock)</unmanaged>	
        /// <unmanaged-short>IMFClockConsumer::SetPresentationClock</unmanaged-short>	
        internal void SetPresentationClock(SharpDX.MediaFoundation.PresentationClock presentationClockRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((presentationClockRef == null) ? IntPtr.Zero : presentationClockRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="presentationClockOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClockConsumer::GetPresentationClock']/*"/>	
        /// <unmanaged>HRESULT IMFClockConsumer::GetPresentationClock([Out] IMFPresentationClock** ppPresentationClock)</unmanaged>	
        /// <unmanaged-short>IMFClockConsumer::GetPresentationClock</unmanaged-short>	
        internal void GetPresentationClock(out SharpDX.MediaFoundation.PresentationClock presentationClockOut)
        {
            unsafe
            {
                IntPtr presentationClockOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &presentationClockOut_, ((void**)(*(void**)_nativePointer))[4]);
                presentationClockOut = (presentationClockOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PresentationClock(presentationClockOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Receives state-change notifications from the presentation clock. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To receive state-change notifications from the presentation clock, implement this interface and call <strong><see cref="SharpDX.MediaFoundation.PresentationClock.AddClockStateSink_"/></strong> on the presentation clock.</p><p>This interface must be implemented by:</p><ul> <li> <p>Presentation time sources. The presentation clock uses this interface to request change states from the time source.</p> </li> <li> <p>Media sinks. Media sinks use this interface to get notifications when the presentation clock changes.</p> </li> </ul><p>Other objects that need to be notified can implement this interface.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClockStateSink']/*"/>	
    /// <msdn-id>ms701593</msdn-id>	
    /// <unmanaged>IMFClockStateSink</unmanaged>	
    /// <unmanaged-short>IMFClockStateSink</unmanaged-short>	
    [Guid("F6696E82-74F7-4f3d-A178-8A5E09C3659F")]
    public partial interface ClockStateSink : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p> Called when the presentation clock starts. </p>	
        /// </summary>	
        /// <param name="hnsSystemTime"><dd> <p> The system time when the clock started, in 100-nanosecond units. </p> </dd></param>	
        /// <param name="llClockStartOffset"><dd> <p> The new starting time for the clock, in 100-nanosecond units. This parameter can also equal <strong>PRESENTATION_CURRENT_POSITION</strong>, indicating the clock has started or restarted from its current position. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method is called whe the presentation clock's <strong><see cref="SharpDX.MediaFoundation.PresentationClock.Start"/></strong> method is called, with the following exception: If the clock is paused and <strong>Start</strong> is called with the value <strong>PRESENTATION_CURRENT_POSITION</strong>, <strong><see cref="SharpDX.MediaFoundation.ClockStateSink.OnClockRestart"/></strong> is called instead of <strong>OnClockStart</strong>.</p><p>The clock notifies the presentation time source by calling the time source's <strong>OnClockStart</strong> method. This call occurs synchronously within the <strong>Start</strong> method. If the time source returns an error from <strong>OnClockStart</strong>, the presentation clock's <strong>Start</strong> method returns an error and the state change does not take place.</p><p>For any object that is not the presentation time source, the <strong>OnClockStart</strong> method is called asynchronously, after the state change is completed. In that case, the return value from this method is ignored.</p><p>The value given in <em>llClockStartOffset</em> is the presentation time when the clock starts, so it is relative to the start of the presentation. Media sinks should not render any data with a presentation time earlier than <em>llClockStartOffSet</em>. If a sample straddles the offset?that is, if the offset falls between the sample's start and stop times?the sink should either trim the sample so that only data after <em>llClockStartOffset</em> is rendered, or else simply drop the sample.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClockStateSink::OnClockStart']/*"/>	
        /// <msdn-id>ms694879</msdn-id>	
        /// <unmanaged>HRESULT IMFClockStateSink::OnClockStart([In] longlong hnsSystemTime,[In] longlong llClockStartOffset)</unmanaged>	
        /// <unmanaged-short>IMFClockStateSink::OnClockStart</unmanaged-short>	
        /* public void OnClockStart(long hnsSystemTime, long llClockStartOffset) */

        /// <summary>	
        /// <p> Called when the presentation clock stops. </p>	
        /// </summary>	
        /// <param name="hnsSystemTime"><dd> <p> The system time when the clock stopped, in 100-nanosecond units. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.SinkAlreadystopped"/></strong></dt> </dl> </td><td> <p>Deprecated. Do not use this error code.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> When the presentation clock's <strong><see cref="SharpDX.MediaFoundation.PresentationClock.Stop"/></strong> method is called, the clock notifies the presentation time source by calling the presentation time source's <strong>OnClockStop</strong> method. This call occurs synchronously within the <strong>Stop</strong> method. If the time source returns an error from <strong>OnClockStop</strong>, the presentation clock's <strong>Stop</strong> method returns an error and the state change does not take place. </p><p> For any object that is not the presentation time source, the <strong>OnClockStop</strong> method is called asynchronously, after the state change is completed. </p><p>If an object is already stopped, it should return <strong><see cref="SharpDX.Result.Ok"/></strong> from <strong>OnClockStop</strong>. It should not return an error code. </p><strong>Note</strong>??Although the header file mferror.h defines an error code named <strong><see cref="SharpDX.MediaFoundation.ResultCode.SinkAlreadystopped"/></strong>, it should not be returned in this situation.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClockStateSink::OnClockStop']/*"/>	
        /// <msdn-id>ms697009</msdn-id>	
        /// <unmanaged>HRESULT IMFClockStateSink::OnClockStop([In] longlong hnsSystemTime)</unmanaged>	
        /// <unmanaged-short>IMFClockStateSink::OnClockStop</unmanaged-short>	
        /* public void OnClockStop(long hnsSystemTime) */

        /// <summary>	
        /// <p> Called when the presentation clock pauses. </p>	
        /// </summary>	
        /// <param name="hnsSystemTime"><dd> <p> The system time when the clock was paused, in 100-nanosecond units. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>When the presentation clock's <strong><see cref="SharpDX.MediaFoundation.PresentationClock.Pause"/></strong> method is called, the clock notifies the presentation time source by calling the time source's <strong>OnClockPause</strong> method. This call occurs synchronously within the <strong>Pause</strong> method. If the time source returns an error from <strong>OnClockPause</strong>, the presentation clock's <strong>Pause</strong> method returns an error and the state change does not take place.</p><p>For any object that is not the presentation time source, the <strong>OnClockPause</strong> method is called asynchronously, after the state change is completed. In that case, the return value from this method is ignored.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClockStateSink::OnClockPause']/*"/>	
        /// <msdn-id>ms703882</msdn-id>	
        /// <unmanaged>HRESULT IMFClockStateSink::OnClockPause([In] longlong hnsSystemTime)</unmanaged>	
        /// <unmanaged-short>IMFClockStateSink::OnClockPause</unmanaged-short>	
        /* public void OnClockPause(long hnsSystemTime) */

        /// <summary>	
        /// <p> Called when the presentation clock restarts from the same position while paused. </p>	
        /// </summary>	
        /// <param name="hnsSystemTime"><dd> <p> The system time when the clock restarted, in 100-nanosecond units. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This method is called if the presentation clock is paused and the <strong><see cref="SharpDX.MediaFoundation.PresentationClock.Start"/></strong> method is called with the value <strong>PRESENTATION_CURRENT_POSITION</strong>. </p><p> The clock notifies the presentation time source by calling the time source's <strong>OnClockRestart</strong> method. This call occurs synchronously within the <strong>Start</strong> method. If the time source returns an error from <strong>OnClockRestart</strong>, the presentation clock's <strong>Start</strong> method returns an error and the state change does not take place. </p><p> For any object that is not the presentation time source, the <strong>OnClockRestart</strong> method is called asynchronously, after the state change is completed. In that case, the return value from this method is ignored. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClockStateSink::OnClockRestart']/*"/>	
        /// <msdn-id>ms697215</msdn-id>	
        /// <unmanaged>HRESULT IMFClockStateSink::OnClockRestart([In] longlong hnsSystemTime)</unmanaged>	
        /// <unmanaged-short>IMFClockStateSink::OnClockRestart</unmanaged-short>	
        /* public void OnClockRestart(long hnsSystemTime) */

        /// <summary>	
        /// <p>Called when the rate changes on the presentation clock. </p>	
        /// </summary>	
        /// <param name="hnsSystemTime"><dd> <p> The system time when the rate was set, in 100-nanosecond units. </p> </dd></param>	
        /// <param name="flRate"><dd> <p> The new rate, as a multiplier of the normal playback rate. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> When the presentation clock's <strong><see cref="SharpDX.MediaFoundation.RateControl.SetRate"/></strong> method is called, the clock notifies the presentation time source by calling the time source's <strong>OnClockSetRate</strong> method. This call occurs synchronously within the <strong>SetRate</strong> method. If the time source returns an error from <strong>OnClockSetRate</strong>, the presentation clock's <strong>SetRate</strong> method returns an error and the state change does not take place. </p><p> For any object that is not the presentation time source, the <strong>OnClockSetRate</strong> method is called asynchronously, after the state change is completed. In that case, the return value from this method is ignored. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFClockStateSink::OnClockSetRate']/*"/>	
        /// <msdn-id>ms702979</msdn-id>	
        /// <unmanaged>HRESULT IMFClockStateSink::OnClockSetRate([In] longlong hnsSystemTime,[In] float flRate)</unmanaged>	
        /// <unmanaged-short>IMFClockStateSink::OnClockSetRate</unmanaged-short>	
        /* public void OnClockSetRate(long hnsSystemTime, float flRate) */
    }
    /// <summary>	
    /// Defines size, enumerators, and synchronization methods for all nongeneric collections. <p></p>Namespace: System.CollectionsAssembly: mscorlib (in mscorlib.dll)&lt;ComVisibleAttribute(True)&gt; _	
    /// Public Interface ICollection Inherits IEnumerableDim instance As ICollection	
    /// [ComVisibleAttribute(true)] 	
    /// public interface ICollection : IEnumerable[ComVisibleAttribute(true)] 	
    /// public interface class ICollection : IEnumerable/** @attribute ComVisibleAttribute(true) */ 	
    /// public interface ICollection extends IEnumerableComVisibleAttribute(true) 	
    /// public interface ICollection extends IEnumerableNot applicable. <p>The ICollection interface is the base interface for classes in the System.Collections namespace.</p> <p>The ICollection interface extends IEnumerable; IDictionary and IList are more specialized interfaces that extend ICollection. An IDictionary implementation is a collection of key/value pairs, like the Hashtable class. An IList implementation is a collection of values and its members can be accessed by index, like the ArrayList class.</p> <p>Some collections that limit access to their elements, such as the Queue class and the Stack class, directly implement the ICollection interface.</p> <p>If neither the IDictionary interface nor the IList interface meet the requirements of the required collection, derive the new collection class from the ICollection interface instead for more flexibility.</p> <p>For the generic version of this interface, see System.Collections.Generic.ICollection.</p> <p>Windows 98, Windows Server 2000 SP4, Windows CE, Windows Millennium Edition, Windows Mobile for Pocket PC, Windows Mobile for Smartphone, Windows Server 2003, Windows XP Media Center Edition, Windows XP Professional x64 Edition, Windows XP SP2, Windows XP Starter Edition</p><p></p><p></p> The Microsoft .NET Framework 3.0 is supported on Windows Vista, Microsoft Windows XP SP2, and Windows Server 2003 SP1. .NET FrameworkSupported in: 3.0, 2.0, 1.1, 1.0.NET Compact FrameworkSupported in: 2.0, 1.0XNA FrameworkSupported in: 1.0ReferenceICollection MembersSystem.Collections NamespaceIDictionaryIListSystem.Collections.Generic.ICollection	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCollection']/*"/>	
    /// <msdn-id>system.collections.icollection</msdn-id>	
    /// <unmanaged>IMFCollection</unmanaged>	
    /// <unmanaged-short>IMFCollection</unmanaged-short>	
    [Guid("5BC8A76B-869A-46a3-9B03-FA218A66AEBE")]
    public partial class Collection : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.Collection"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Collection(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.Collection"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.Collection(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.Collection(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the number of objects in the collection.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCollection::GetElementCount']/*"/>	
        /// <msdn-id>ms697034</msdn-id>	
        /// <unmanaged>GetElementCount</unmanaged>	
        /// <unmanaged-short>GetElementCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFCollection::GetElementCount([Out] unsigned int* pcElements)</unmanaged>
        public int ElementCount
        {
            get { int __output__; GetElementCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of objects in the collection.</p>	
        /// </summary>	
        /// <param name="cElementsRef"><dd> <p>Receives the number of objects in the collection.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCollection::GetElementCount']/*"/>	
        /// <msdn-id>ms697034</msdn-id>	
        /// <unmanaged>HRESULT IMFCollection::GetElementCount([Out] unsigned int* pcElements)</unmanaged>	
        /// <unmanaged-short>IMFCollection::GetElementCount</unmanaged-short>	
        internal void GetElementCount(out int cElementsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cElementsRef_ = &cElementsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cElementsRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves an object in the collection.</p>	
        /// </summary>	
        /// <param name="dwElementIndex"><dd> <p> Zero-based index of the object to retrieve. Objects are indexed in the order in which they were added to the collection. </p> </dd></param>	
        /// <returns><dd> <p> Receives a reference to the object's <strong><see cref="SharpDX.ComObject"/></strong> interface. The caller must release the interface. The retrieved reference value might be <strong><c>null</c></strong>. </p> </dd></returns>	
        /// <remarks>	
        /// <p> This method does not remove the object from the collection. To remove an object, call <strong><see cref="SharpDX.MediaFoundation.Collection.RemoveElement"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCollection::GetElement']/*"/>	
        /// <msdn-id>ms701793</msdn-id>	
        /// <unmanaged>HRESULT IMFCollection::GetElement([In] unsigned int dwElementIndex,[Out] IUnknown** ppUnkElement)</unmanaged>	
        /// <unmanaged-short>IMFCollection::GetElement</unmanaged-short>	
        public SharpDX.ComObject GetElement(int dwElementIndex)
        {
            unsafe
            {
                SharpDX.ComObject unkElementOut;
                IntPtr unkElementOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwElementIndex, &unkElementOut_, ((void**)(*(void**)_nativePointer))[4]);
                unkElementOut = (unkElementOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(unkElementOut_);
                __result__.CheckError();
                return unkElementOut;
            }
        }

        /// <summary>	
        /// <p> </p><p>Adds an object to the collection.</p>	
        /// </summary>	
        /// <param name="unkElementRef"><dd> <p>Pointer to the object's <strong><see cref="SharpDX.ComObject"/></strong> interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If <em>pUnkElement</em> is <strong><c>null</c></strong>, a <strong><c>null</c></strong> reference is added to the collection.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCollection::AddElement']/*"/>	
        /// <msdn-id>ms695202</msdn-id>	
        /// <unmanaged>HRESULT IMFCollection::AddElement([In, Optional] IUnknown* pUnkElement)</unmanaged>	
        /// <unmanaged-short>IMFCollection::AddElement</unmanaged-short>	
        public void AddElement(SharpDX.ComObject unkElementRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((unkElementRef == null) ? IntPtr.Zero : unkElementRef.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Removes an object from the collection.</p>	
        /// </summary>	
        /// <param name="dwElementIndex"><dd> <p>Zero-based index of the object to remove. Objects are indexed in the order in which they were added to the collection.</p> </dd></param>	
        /// <param name="unkElementOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of the object. The caller must release the interface. This parameter cannot be <strong><c>null</c></strong>, but the retrieved reference value might be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCollection::RemoveElement']/*"/>	
        /// <msdn-id>ms697010</msdn-id>	
        /// <unmanaged>HRESULT IMFCollection::RemoveElement([In] unsigned int dwElementIndex,[Out] IUnknown** ppUnkElement)</unmanaged>	
        /// <unmanaged-short>IMFCollection::RemoveElement</unmanaged-short>	
        public void RemoveElement(int dwElementIndex, out SharpDX.ComObject unkElementOut)
        {
            unsafe
            {
                IntPtr unkElementOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwElementIndex, &unkElementOut_, ((void**)(*(void**)_nativePointer))[6]);
                unkElementOut = (unkElementOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(unkElementOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Adds an object at the specified index in the collection.</p>	
        /// </summary>	
        /// <param name="dwIndex"><dd> <p>The zero-based index where the object will be added to the collection.</p> </dd></param>	
        /// <param name="unknownRef"><dd> <p>The object to insert.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCollection::InsertElementAt']/*"/>	
        /// <msdn-id>ms703963</msdn-id>	
        /// <unmanaged>HRESULT IMFCollection::InsertElementAt([In] unsigned int dwIndex,[In, Optional] IUnknown* pUnknown)</unmanaged>	
        /// <unmanaged-short>IMFCollection::InsertElementAt</unmanaged-short>	
        public void InsertElementAt(int dwIndex, SharpDX.ComObject unknownRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwIndex, (void*)((unknownRef == null) ? IntPtr.Zero : unknownRef.NativePointer), ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Removes all items from the collection.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFCollection::RemoveAllElements']/*"/>	
        /// <msdn-id>ms700194</msdn-id>	
        /// <unmanaged>HRESULT IMFCollection::RemoveAllElements()</unmanaged>	
        /// <unmanaged-short>IMFCollection::RemoveAllElements</unmanaged-short>	
        public void RemoveAllElements()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Allows a decryptor to manage hardware keys and decrypt hardware samples.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentDecryptorContext']/*"/>	
    /// <msdn-id>mt219182</msdn-id>	
    /// <unmanaged>IMFContentDecryptorContext</unmanaged>	
    /// <unmanaged-short>IMFContentDecryptorContext</unmanaged-short>	
    [Guid("7EC4B1BD-43FB-4763-85D2-64FCB5C5F4CB")]
    public partial class ContentDecryptorContext : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ContentDecryptorContext"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ContentDecryptorContext(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ContentDecryptorContext"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ContentDecryptorContext(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ContentDecryptorContext(nativePointer);
        }


        /// <summary>	
        /// <p> Allows the display driver to return IHV-specific information used when initializing a new hardware key. </p>	
        /// </summary>	
        /// <param name="inputPrivateDataByteCount"><dd> <p>The number of bytes in the buffer that <em>InputPrivateData</em> specifies.</p> </dd></param>	
        /// <param name="inputPrivateData"><dd> <p>The contents of this parameter are defined by the implementation of    the protection system that runs in the security processor. The contents may contain data about license or stream properties.</p> </dd></param>	
        /// <param name="outputPrivateData"><dd> <p>The return data is also defined by the implementation of the protection system implementation    that runs in the security processor.  The contents may contain data associated with the underlying hardware key.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentDecryptorContext::InitializeHardwareKey']/*"/>	
        /// <msdn-id>mt219183</msdn-id>	
        /// <unmanaged>HRESULT IMFContentDecryptorContext::InitializeHardwareKey([In] unsigned int InputPrivateDataByteCount,[In, Buffer, Optional] const void* InputPrivateData,[Out] unsigned longlong* OutputPrivateData)</unmanaged>	
        /// <unmanaged-short>IMFContentDecryptorContext::InitializeHardwareKey</unmanaged-short>	
        public void InitializeHardwareKey(int inputPrivateDataByteCount, System.IntPtr inputPrivateData, out long outputPrivateData)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* outputPrivateData_ = &outputPrivateData)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, inputPrivateDataByteCount, (void*)inputPrivateData, outputPrivateData_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Implements one step that must be performed for the user to access media content. For example, the steps might be individualization followed by license acquisition. Each of these steps would be encapsulated by a content enabler object that exposes the <strong><see cref="SharpDX.MediaFoundation.ContentEnabler"/></strong> interface.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentEnabler']/*"/>	
    /// <msdn-id>ms697004</msdn-id>	
    /// <unmanaged>IMFContentEnabler</unmanaged>	
    /// <unmanaged-short>IMFContentEnabler</unmanaged-short>	
    [Guid("D3C4EF59-49CE-4381-9071-D5BCD044C770")]
    public partial class ContentEnabler : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ContentEnabler"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ContentEnabler(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ContentEnabler"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ContentEnabler(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ContentEnabler(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the type of operation that this content enabler performs.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The following GUIDs are defined for the <em>pType</em> parameter.</p><table> <tr><th>Value</th><th>Description</th></tr> <tr><td>MFENABLETYPE_MF_RebootRequired</td><td>The user must reboot his or her computer.</td></tr> <tr><td>MFENABLETYPE_MF_UpdateRevocationInformation</td><td>Update revocation information.</td></tr> <tr><td>MFENABLETYPE_MF_UpdateUntrustedComponent</td><td>Update untrusted components.</td></tr> <tr><td>MFENABLETYPE_WMDRMV1_LicenseAcquisition</td><td>License acquisition for Windows Media Digital Rights Management (DRM) version 1.</td></tr> <tr><td>MFENABLETYPE_WMDRMV7_Individualization</td><td>Individualization.</td></tr> <tr><td>MFENABLETYPE_WMDRMV7_LicenseAcquisition</td><td>License acquisition for Windows Media DRM version 7 or later.</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentEnabler::GetEnableType']/*"/>	
        /// <msdn-id>bb970471</msdn-id>	
        /// <unmanaged>GetEnableType</unmanaged>	
        /// <unmanaged-short>GetEnableType</unmanaged-short>	
        /// <unmanaged>HRESULT IMFContentEnabler::GetEnableType([Out] GUID* pType)</unmanaged>
        public System.Guid EnableType
        {
            get { System.Guid __output__; GetEnableType(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Queries whether the content enabler can perform all of its actions automatically.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If this method returns <strong>TRUE</strong> in the <em>pfAutomatic</em> parameter, call the <strong><see cref="SharpDX.MediaFoundation.ContentEnabler.AutomaticEnable"/></strong> method to perform the enabling action.</p><p>If this method returns <strong><see cref="SharpDX.Result.False"/></strong> in the <em>pfAutomatic</em> parameter, the application must use manual enabling. To do so, call <strong><see cref="SharpDX.MediaFoundation.ContentEnabler.GetEnableURL"/></strong> and <strong><see cref="SharpDX.MediaFoundation.ContentEnabler.GetEnableData"/></strong> to get the URL and data needed for manual enabling.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentEnabler::IsAutomaticSupported']/*"/>	
        /// <msdn-id>bb970334</msdn-id>	
        /// <unmanaged>IsAutomaticSupported</unmanaged>	
        /// <unmanaged-short>IsAutomaticSupported</unmanaged-short>	
        /// <unmanaged>HRESULT IMFContentEnabler::IsAutomaticSupported([Out] BOOL* pfAutomatic)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsAutomaticSupported
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; IsAutomaticSupported_(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the type of operation that this content enabler performs.</p>	
        /// </summary>	
        /// <param name="typeRef"><dd> <p>Receives a <see cref="System.Guid"/> that identifies the type of operation. An application can tailor its user interface (UI) strings for known operation types. See Remarks.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The following GUIDs are defined for the <em>pType</em> parameter.</p><table> <tr><th>Value</th><th>Description</th></tr> <tr><td>MFENABLETYPE_MF_RebootRequired</td><td>The user must reboot his or her computer.</td></tr> <tr><td>MFENABLETYPE_MF_UpdateRevocationInformation</td><td>Update revocation information.</td></tr> <tr><td>MFENABLETYPE_MF_UpdateUntrustedComponent</td><td>Update untrusted components.</td></tr> <tr><td>MFENABLETYPE_WMDRMV1_LicenseAcquisition</td><td>License acquisition for Windows Media Digital Rights Management (DRM) version 1.</td></tr> <tr><td>MFENABLETYPE_WMDRMV7_Individualization</td><td>Individualization.</td></tr> <tr><td>MFENABLETYPE_WMDRMV7_LicenseAcquisition</td><td>License acquisition for Windows Media DRM version 7 or later.</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentEnabler::GetEnableType']/*"/>	
        /// <msdn-id>bb970471</msdn-id>	
        /// <unmanaged>HRESULT IMFContentEnabler::GetEnableType([Out] GUID* pType)</unmanaged>	
        /// <unmanaged-short>IMFContentEnabler::GetEnableType</unmanaged-short>	
        internal void GetEnableType(out System.Guid typeRef)
        {
            unsafe
            {
                typeRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* typeRef_ = &typeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, typeRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a URL for performing a manual content enabling action.</p>	
        /// </summary>	
        /// <param name="wszURLOut"><dd> <p>Receives a reference to a buffer that contains the URL. The caller must release the memory for the buffer by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <param name="cchURLRef"><dd> <p>Receives the number of characters returned in <em>ppwszURL</em>, including the terminating <c>null</c> character.</p> </dd></param>	
        /// <param name="trustStatusRef"><dd> <p>Receives a member of the <strong><see cref="SharpDX.MediaFoundation.UrlTrustStatus"/></strong> enumeration indicating whether the URL is trusted.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotAvailable"/></strong></dt> </dl> </td><td> <p>No URL is available.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the enabling action can be performed by navigating to a URL, this method returns the URL. If no such URL exists, the method returns a failure code.</p><p>The purpose of the URL depends on the content enabler type, which is obtained by calling <strong><see cref="SharpDX.MediaFoundation.ContentEnabler.GetEnableType"/></strong>.</p><table> <tr><th>Enable type</th><th>Purpose of URL</th></tr> <tr><td>Individualization</td><td>Not applicable.</td></tr> <tr><td>License acquisition</td><td>URL to obtain the license. Call <strong><see cref="SharpDX.MediaFoundation.ContentEnabler.GetEnableData"/></strong> and submit the data to the URL as an HTTP POST request. To receive notification when the license is acquired, call <strong><see cref="SharpDX.MediaFoundation.ContentEnabler.MonitorEnable"/></strong>.</td></tr> <tr><td>Revocation</td><td>URL to a webpage where the user can download and install an updated component.</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentEnabler::GetEnableURL']/*"/>	
        /// <msdn-id>bb970345</msdn-id>	
        /// <unmanaged>HRESULT IMFContentEnabler::GetEnableURL([Buffer, Optional] wchar_t** ppwszURL,[Out] unsigned int* pcchURL,[InOut, Optional] MF_URL_TRUST_STATUS* pTrustStatus)</unmanaged>	
        /// <unmanaged-short>IMFContentEnabler::GetEnableURL</unmanaged-short>	
        public void GetEnableURL(string wszURLOut, out int cchURLRef, System.IntPtr trustStatusRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* wszURLOut_ = wszURLOut)
                fixed (void* cchURLRef_ = &cchURLRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)wszURLOut_, cchURLRef_, (void*)trustStatusRef, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the data for a manual content enabling action.</p>	
        /// </summary>	
        /// <param name="bDataOut"><dd> <p>Receives a reference to a buffer that contains the data. The caller must free the buffer by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <param name="cbDataRef"><dd> <p>Receives the size of the <em>ppbData</em> buffer.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotAvailable"/></strong></dt> </dl> </td><td> <p>No data is available.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The purpose of the data depends on the content enabler type, which is obtained by calling <strong><see cref="SharpDX.MediaFoundation.ContentEnabler.GetEnableType"/></strong>.</p><table> <tr><th>Enable type</th><th>Purpose of data</th></tr> <tr><td>Individualization</td><td>Not applicable.</td></tr> <tr><td>License acquisition</td><td>HTTP POST data.</td></tr> <tr><td>Revocation</td><td> <strong><see cref="SharpDX.MediaFoundation.RrComponents"/></strong> structure.</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentEnabler::GetEnableData']/*"/>	
        /// <msdn-id>bb970525</msdn-id>	
        /// <unmanaged>HRESULT IMFContentEnabler::GetEnableData([Buffer, Optional] unsigned char** ppbData,[Out] unsigned int* pcbData)</unmanaged>	
        /// <unmanaged-short>IMFContentEnabler::GetEnableData</unmanaged-short>	
        public void GetEnableData(byte[] bDataOut, out int cbDataRef)
        {
            unsafe
            {
                byte[] bDataOut__ = bDataOut;
                SharpDX.Result __result__;
                fixed (void* bDataOut_ = bDataOut__)
                fixed (void* cbDataRef_ = &cbDataRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bDataOut_, cbDataRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Queries whether the content enabler can perform all of its actions automatically.</p>	
        /// </summary>	
        /// <param name="fAutomaticRef"><dd> <p>Receives a Boolean value. If <strong>TRUE</strong>, the content enabler can perform the enabing action automatically.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If this method returns <strong>TRUE</strong> in the <em>pfAutomatic</em> parameter, call the <strong><see cref="SharpDX.MediaFoundation.ContentEnabler.AutomaticEnable"/></strong> method to perform the enabling action.</p><p>If this method returns <strong><see cref="SharpDX.Result.False"/></strong> in the <em>pfAutomatic</em> parameter, the application must use manual enabling. To do so, call <strong><see cref="SharpDX.MediaFoundation.ContentEnabler.GetEnableURL"/></strong> and <strong><see cref="SharpDX.MediaFoundation.ContentEnabler.GetEnableData"/></strong> to get the URL and data needed for manual enabling.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentEnabler::IsAutomaticSupported']/*"/>	
        /// <msdn-id>bb970334</msdn-id>	
        /// <unmanaged>HRESULT IMFContentEnabler::IsAutomaticSupported([Out] BOOL* pfAutomatic)</unmanaged>	
        /// <unmanaged-short>IMFContentEnabler::IsAutomaticSupported</unmanaged-short>	
        internal void IsAutomaticSupported_(out SharpDX.Mathematics.Interop.RawBool fAutomaticRef)
        {
            unsafe
            {
                fAutomaticRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fAutomaticRef_ = &fAutomaticRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fAutomaticRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Performs a content enabling action without any user interaction.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is asynchronous. When the operation is complete, the content enabler sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.EnablerCompleted"/> event. While the operation is in progress, the content enabler might send <see cref="SharpDX.MediaFoundation.MediaEventTypes.EnablerProgress"/> events.</p><p>To find out whether the content enabler supports this method, call <strong><see cref="SharpDX.MediaFoundation.ContentEnabler.IsAutomaticSupported_"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentEnabler::AutomaticEnable']/*"/>	
        /// <msdn-id>ms699012</msdn-id>	
        /// <unmanaged>HRESULT IMFContentEnabler::AutomaticEnable()</unmanaged>	
        /// <unmanaged-short>IMFContentEnabler::AutomaticEnable</unmanaged-short>	
        public void AutomaticEnable()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Requests notification when the enabling action is completed.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p>The method succeeded and no action was required.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If you use a manual enabling action, call this method to be notified when the operation completes. If this method returns <see cref="SharpDX.Result.Ok"/>, the content enabler will send an <see cref="SharpDX.MediaFoundation.MediaEventTypes.EnablerCompleted"/> event when the operation is completed. If the application cancels the operatation before completing it, call <strong><see cref="SharpDX.MediaFoundation.ContentEnabler.Cancel"/></strong>.</p><p>You do not have to call <strong>MonitorEnable</strong> when you use automatic enabling by calling <strong><see cref="SharpDX.MediaFoundation.ContentEnabler.AutomaticEnable"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentEnabler::MonitorEnable']/*"/>	
        /// <msdn-id>ms698997</msdn-id>	
        /// <unmanaged>HRESULT IMFContentEnabler::MonitorEnable()</unmanaged>	
        /// <unmanaged-short>IMFContentEnabler::MonitorEnable</unmanaged-short>	
        public void MonitorEnable()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Cancels a pending content enabling action.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The content enabler sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.EnablerCompleted"/> event with a status code of E_CANCEL.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentEnabler::Cancel']/*"/>	
        /// <msdn-id>ms704633</msdn-id>	
        /// <unmanaged>HRESULT IMFContentEnabler::Cancel()</unmanaged>	
        /// <unmanaged-short>IMFContentEnabler::Cancel</unmanaged-short>	
        public void Cancel()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Gets the required number of bytes that need to be prepended to    the  input and output buffers when you call the security processor through the <strong>InvokeFunction</strong> method.   When you specify this number of bytes, the Media Foundation transform (MFT) decryptor can allocate the total amount of bytes and can avoid making copies of the data when the decrytor moves the data to the security processor.  </p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentProtectionDevice']/*"/>	
    /// <msdn-id>mt219185</msdn-id>	
    /// <unmanaged>IMFContentProtectionDevice</unmanaged>	
    /// <unmanaged-short>IMFContentProtectionDevice</unmanaged-short>	
    [Guid("E6257174-A060-4C9A-A088-3B1B471CAD28")]
    public partial class ContentProtectionDevice : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ContentProtectionDevice"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ContentProtectionDevice(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ContentProtectionDevice"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ContentProtectionDevice(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ContentProtectionDevice(nativePointer);
        }


        /// <summary>	
        /// <p>Calls into the implementation of the protection system in the security processor. </p>	
        /// </summary>	
        /// <param name="functionId"><dd> <p>The identifier of the function that you want to run. This identifier is defined by the implementation of the protection system.</p> </dd></param>	
        /// <param name="inputBufferByteCount"><dd> <p>The number of bytes of in the buffer that <em>InputBuffer</em> specifies, including private data.</p> </dd></param>	
        /// <param name="inputBuffer"><dd> <p>A reference to the data that you want to provide as input.</p> </dd></param>	
        /// <param name="outputBufferByteCount"><dd> <p>Pointer to a value that specifies the length in bytes of the data that the function wrote to the buffer that <em>OutputBuffer</em> specifies, including the private data.    </p> </dd></param>	
        /// <param name="outputBuffer"><dd> <p>Pointer to the buffer where you want the function to write its output.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentProtectionDevice::InvokeFunction']/*"/>	
        /// <msdn-id>mt219186</msdn-id>	
        /// <unmanaged>HRESULT IMFContentProtectionDevice::InvokeFunction([In] unsigned int FunctionId,[In] unsigned int InputBufferByteCount,[In, Buffer] const unsigned char* InputBuffer,[InOut] unsigned int* OutputBufferByteCount,[Out, Buffer] unsigned char* OutputBuffer)</unmanaged>	
        /// <unmanaged-short>IMFContentProtectionDevice::InvokeFunction</unmanaged-short>	
        public void InvokeFunction(int functionId, int inputBufferByteCount, byte[] inputBuffer, ref int outputBufferByteCount, byte[] outputBuffer)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* inputBuffer_ = inputBuffer)
                fixed (void* outputBufferByteCount_ = &outputBufferByteCount)
                fixed (void* outputBuffer_ = outputBuffer)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, functionId, inputBufferByteCount, inputBuffer_, outputBufferByteCount_, outputBuffer_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the required number of bytes that need to be prepended to    the  input and output buffers when you call the security processor through the <strong>InvokeFunction</strong> method.   When you specify this number of bytes, the Media Foundation transform (MFT) decryptor can allocate the total amount of bytes and can avoid making copies of the data when the decrytor moves the data to the security processor.  </p>	
        /// </summary>	
        /// <param name="privateInputByteCount">No documentation.</param>	
        /// <param name="privateOutputByteCount">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentProtectionDevice::GetPrivateDataByteCount']/*"/>	
        /// <msdn-id>mt219185</msdn-id>	
        /// <unmanaged>HRESULT IMFContentProtectionDevice::GetPrivateDataByteCount([Out] unsigned int* PrivateInputByteCount,[Out] unsigned int* PrivateOutputByteCount)</unmanaged>	
        /// <unmanaged-short>IMFContentProtectionDevice::GetPrivateDataByteCount</unmanaged-short>	
        public void GetPrivateDataByteCount(out int privateInputByteCount, out int privateOutputByteCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* privateInputByteCount_ = &privateInputByteCount)
                fixed (void* privateOutputByteCount_ = &privateOutputByteCount)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, privateInputByteCount_, privateOutputByteCount_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables playback of protected content by providing the application with a reference to a content enabler object.</p><p>Applications that play protected content should implement this interface.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A <em>content enabler</em> is an object that performs some action that is required to play a piece of protected content. For example, the action might be obtaining a DRM license. Content enablers expose the <strong><see cref="SharpDX.MediaFoundation.ContentEnabler"/></strong> interface, which defines a generic mechanism for content enabler. Content enablers are created inside the protected media path (PMP) process. However, they must be invoked from the application process. Therefore, the <strong><see cref="SharpDX.MediaFoundation.ContentProtectionManager"/></strong> interface provides a way for the PMP Media Session to notify the application.</p><p>To use this interface, do the following:</p><ol> <li> <p>Implement the interface in your application.</p> </li> <li> <p>Create an attribute store by calling <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAttributes"/></strong>.</p> </li> <li> <p>Set the <strong><see cref="SharpDX.MediaFoundation.MediaSessionAttributeKeys.ContentProtectionManager"/></strong> attribute on the attribute store. The attribute value is a reference to your <strong><see cref="SharpDX.MediaFoundation.ContentProtectionManager"/></strong> implementation.</p> </li> <li> <p>Call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreatePMPMediaSession"/></strong> and pass the attribute store in the <em>pConfiguration</em> parameter.</p> </li> </ol><p>If the content requires a content enabler, the application's <strong>BeginEnableContent</strong> method is called. Usually this method called during the <strong><see cref="SharpDX.MediaFoundation.MediaSession.SetTopology"/></strong> operation, before the Media Session raises the <see cref="SharpDX.MediaFoundation.MediaEventTypes.SessionTopologySet"/> event. The application might receive multiple <strong>BeginEnableContent</strong> calls for a single piece of content. The <see cref="SharpDX.MediaFoundation.MediaEventTypes.SessionTopologySet"/> event signals that the content-enabling process is complete for the current topology. The <strong>BeginEnableContent</strong> method can also be called outside of the <strong>SetTopology</strong> operation, but less commonly.</p><p>Many content enablers send machine-specific data to the network, which can have privacy implications. One of the purposes of the <strong><see cref="SharpDX.MediaFoundation.ContentProtectionManager"/></strong> interface is to give applications an opportunity to display information to the user and enable to user to opt in or out of the process.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentProtectionManager']/*"/>	
    /// <msdn-id>ms694217</msdn-id>	
    /// <unmanaged>IMFContentProtectionManager</unmanaged>	
    /// <unmanaged-short>IMFContentProtectionManager</unmanaged-short>	
    [Guid("ACF92459-6A61-42bd-B57C-B43E51203CB0")]
    public partial class ContentProtectionManager : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ContentProtectionManager"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ContentProtectionManager(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ContentProtectionManager"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ContentProtectionManager(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ContentProtectionManager(nativePointer);
        }


        /// <summary>	
        /// <p>Begins an asynchronous request to perform a content enabling action.</p><p>This method requests the application to perform a specific step needed to acquire rights to the content, using a content enabler object.</p>	
        /// </summary>	
        /// <param name="enablerActivateRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface of a content enabler object. To create the content enabler, call <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> and request the <strong><see cref="SharpDX.MediaFoundation.ContentEnabler"/></strong> interface. The application should use the methods in <strong><see cref="SharpDX.MediaFoundation.ContentEnabler"/></strong> to complete the content enabling action. </p> </dd></param>	
        /// <param name="topoRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.Topology"/></strong> interface of the pending topology. </p> </dd></param>	
        /// <param name="callbackRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. When the operation is complete, the application should call <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> on the callback. </p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p> Reserved. Currently this parameter is always <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Do not block within this callback method. Instead, perform the content enabling action asynchronously on another thread. When the operation is finished, notify the protected media path (PMP) through the <em>pCallback</em> parameter.</p><p>If you return a success code from this method, you must call <strong>Invoke</strong> on the callback. Conversely, if you return an error code from this method, you must not call <strong>Invoke</strong>. If the operation fails after the method returns a success code, use status code on the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> object to report the error.</p><p>After the callback is invoked, the PMP will call the application's <strong><see cref="SharpDX.MediaFoundation.ContentProtectionManager.EndEnableContent"/></strong> method to complete the asynchronous call.</p><p>This method is not necessarily called every time the application plays protected content. Generally, the method will not be called if the user has a valid, up-to-date license for the content. Internally, the input trust authority (ITA) determines whether <strong>BeginEnableContent</strong> is called, based on the content provider's DRM policy. For more information, see Protected Media Path.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentProtectionManager::BeginEnableContent']/*"/>	
        /// <msdn-id>ms696203</msdn-id>	
        /// <unmanaged>HRESULT IMFContentProtectionManager::BeginEnableContent([In] IMFActivate* pEnablerActivate,[In] IMFTopology* pTopo,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>	
        /// <unmanaged-short>IMFContentProtectionManager::BeginEnableContent</unmanaged-short>	
        internal void BeginEnableContent_(SharpDX.MediaFoundation.Activate enablerActivateRef, SharpDX.MediaFoundation.Topology topoRef, System.IntPtr callbackRef, SharpDX.ComObject unkStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((enablerActivateRef == null) ? IntPtr.Zero : enablerActivateRef.NativePointer), (void*)((topoRef == null) ? IntPtr.Zero : topoRef.NativePointer), (void*)callbackRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Ends an asynchronous request to perform a content enabling action. This method is called by the protected media path (PMP) to complete an asynchronous call to <strong><see cref="SharpDX.MediaFoundation.ContentProtectionManager.BeginEnableContent_"/></strong>.</p>	
        /// </summary>	
        /// <param name="resultRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When the <strong>BeginEnableContent</strong> method completes asynchronously, the application notifies the PMP by invoking the asynchronous callback. The PMP calls <strong>EndEnableContent</strong> on the application to get the result code. This method is called on the application's thread from inside the callback method. Therefore, it must not block the thread that invoked the callback.</p><p>The application must return the success or failure code of the asynchronous processing that followed the call to <strong>BeginEnableContent</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFContentProtectionManager::EndEnableContent']/*"/>	
        /// <msdn-id>ms694267</msdn-id>	
        /// <unmanaged>HRESULT IMFContentProtectionManager::EndEnableContent([In] IMFAsyncResult* pResult)</unmanaged>	
        /// <unmanaged-short>IMFContentProtectionManager::EndEnableContent</unmanaged-short>	
        public void EndEnableContent(SharpDX.MediaFoundation.AsyncResult resultRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables the presenter for the enhanced video renderer (EVR) to request a specific frame from the video mixer.</p><p>The sample objects created by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateVideoSampleFromSurface"/></strong> function implement this interface. To retrieve a reference to this interface, call <strong>QueryInterface</strong> on the sample.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDesiredSample']/*"/>	
    /// <msdn-id>ms696237</msdn-id>	
    /// <unmanaged>IMFDesiredSample</unmanaged>	
    /// <unmanaged-short>IMFDesiredSample</unmanaged-short>	
    [Guid("56C294D0-753E-4260-8D61-A3D8820B1D54")]
    public partial class DesiredSample : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.DesiredSample"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DesiredSample(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.DesiredSample"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.DesiredSample(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.DesiredSample(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Called by the mixer to get the time and duration of the sample requested by the presenter.</p>	
        /// </summary>	
        /// <param name="hnsSampleTimeRef"><dd> <p>Receives the desired sample time that should be mixed.</p> </dd></param>	
        /// <param name="hnsSampleDurationRef"><dd> <p>Receives the sample duration that should be mixed.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotAvailable"/></strong></dt> </dl> </td><td> <p>No time stamp was set for this sample. See <strong><see cref="SharpDX.MediaFoundation.DesiredSample.Clear"/></strong>.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDesiredSample::GetDesiredSampleTimeAndDuration']/*"/>	
        /// <msdn-id>ms694058</msdn-id>	
        /// <unmanaged>HRESULT IMFDesiredSample::GetDesiredSampleTimeAndDuration([Out] longlong* phnsSampleTime,[Out] longlong* phnsSampleDuration)</unmanaged>	
        /// <unmanaged-short>IMFDesiredSample::GetDesiredSampleTimeAndDuration</unmanaged-short>	
        public void GetDesiredSampleTimeAndDuration(out long hnsSampleTimeRef, out long hnsSampleDurationRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* hnsSampleTimeRef_ = &hnsSampleTimeRef)
                fixed (void* hnsSampleDurationRef_ = &hnsSampleDurationRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, hnsSampleTimeRef_, hnsSampleDurationRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Called by the presenter to set the time and duration of the sample that it requests from the mixer.</p>	
        /// </summary>	
        /// <param name="hnsSampleTime"><dd> <p>The time of the requested sample.</p> </dd></param>	
        /// <param name="hnsSampleDuration"><dd> <p>The duration of the requested sample.</p> </dd></param>	
        /// <remarks>	
        /// <p>This value should be set prior to passing the buffer to the mixer for a Mix operation. The mixer sets the actual start and duration times on the sample before sending it back.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDesiredSample::SetDesiredSampleTimeAndDuration']/*"/>	
        /// <msdn-id>ms694296</msdn-id>	
        /// <unmanaged>void IMFDesiredSample::SetDesiredSampleTimeAndDuration([In] longlong hnsSampleTime,[In] longlong hnsSampleDuration)</unmanaged>	
        /// <unmanaged-short>IMFDesiredSample::SetDesiredSampleTimeAndDuration</unmanaged-short>	
        public void SetDesiredSampleTimeAndDuration(long hnsSampleTime, long hnsSampleDuration)
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, hnsSampleTime, hnsSampleDuration, ((void**)(*(void**)_nativePointer))[4]);
            }
        }

        /// <summary>	
        /// <p> </p><p>Clears the time stamps previously set by a call to <strong><see cref="SharpDX.MediaFoundation.DesiredSample.SetDesiredSampleTimeAndDuration"/></strong>.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>After this method is called, the <strong><see cref="SharpDX.MediaFoundation.DesiredSample.GetDesiredSampleTimeAndDuration"/></strong> method returns <see cref="SharpDX.MediaFoundation.ResultCode.NotAvailable"/>.</p><p>This method also clears the time stamp and duration and removes all attributes from the sample.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDesiredSample::Clear']/*"/>	
        /// <msdn-id>ms703903</msdn-id>	
        /// <unmanaged>void IMFDesiredSample::Clear()</unmanaged>	
        /// <unmanaged-short>IMFDesiredSample::Clear</unmanaged-short>	
        public void Clear()
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
            }
        }
    }
    /// <summary>	
    /// <p> </p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform']/*"/>	
    /// <msdn-id>ms696268</msdn-id>	
    /// <unmanaged>IMFDeviceTransform</unmanaged>	
    /// <unmanaged-short>IMFDeviceTransform</unmanaged-short>	
    [Guid("D818FBD8-FC46-42F2-87AC-1EA2D1F9BF32")]
    public partial class DeviceTransform : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.DeviceTransform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DeviceTransform(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.DeviceTransform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.DeviceTransform(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.DeviceTransform(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="attributesRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::InitializeTransform']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::InitializeTransform([In] IMFAttributes* pAttributes)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::InitializeTransform</unmanaged-short>	
        public void InitializeTransform(SharpDX.MediaFoundation.MediaAttributes attributesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwInputStreamID">No documentation.</param>	
        /// <param name="dwTypeIndex">No documentation.</param>	
        /// <param name="mediaTypeRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::GetInputAvailableType']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::GetInputAvailableType([In] unsigned int dwInputStreamID,[In] unsigned int dwTypeIndex,[Out] IMFMediaType** pMediaType)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::GetInputAvailableType</unmanaged-short>	
        public void GetInputAvailableType(int dwInputStreamID, int dwTypeIndex, out SharpDX.MediaFoundation.MediaType mediaTypeRef)
        {
            unsafe
            {
                IntPtr mediaTypeRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamID, dwTypeIndex, &mediaTypeRef_, ((void**)(*(void**)_nativePointer))[4]);
                mediaTypeRef = (mediaTypeRef_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(mediaTypeRef_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwInputStreamID">No documentation.</param>	
        /// <param name="mediaTypeRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::GetInputCurrentType']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::GetInputCurrentType([In] unsigned int dwInputStreamID,[Out] IMFMediaType** pMediaType)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::GetInputCurrentType</unmanaged-short>	
        public void GetInputCurrentType(int dwInputStreamID, out SharpDX.MediaFoundation.MediaType mediaTypeRef)
        {
            unsafe
            {
                IntPtr mediaTypeRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamID, &mediaTypeRef_, ((void**)(*(void**)_nativePointer))[5]);
                mediaTypeRef = (mediaTypeRef_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(mediaTypeRef_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwInputStreamID">No documentation.</param>	
        /// <param name="attributesOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::GetInputStreamAttributes']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::GetInputStreamAttributes([In] unsigned int dwInputStreamID,[Out] IMFAttributes** ppAttributes)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::GetInputStreamAttributes</unmanaged-short>	
        public void GetInputStreamAttributes(int dwInputStreamID, out SharpDX.MediaFoundation.MediaAttributes attributesOut)
        {
            unsafe
            {
                IntPtr attributesOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamID, &attributesOut_, ((void**)(*(void**)_nativePointer))[6]);
                attributesOut = (attributesOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(attributesOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwOutputStreamID">No documentation.</param>	
        /// <param name="dwTypeIndex">No documentation.</param>	
        /// <param name="mediaTypeRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::GetOutputAvailableType']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::GetOutputAvailableType([In] unsigned int dwOutputStreamID,[In] unsigned int dwTypeIndex,[Out] IMFMediaType** pMediaType)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::GetOutputAvailableType</unmanaged-short>	
        public void GetOutputAvailableType(int dwOutputStreamID, int dwTypeIndex, out SharpDX.MediaFoundation.MediaType mediaTypeRef)
        {
            unsafe
            {
                IntPtr mediaTypeRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputStreamID, dwTypeIndex, &mediaTypeRef_, ((void**)(*(void**)_nativePointer))[7]);
                mediaTypeRef = (mediaTypeRef_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(mediaTypeRef_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwOutputStreamID">No documentation.</param>	
        /// <param name="mediaTypeRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::GetOutputCurrentType']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::GetOutputCurrentType([In] unsigned int dwOutputStreamID,[Out] IMFMediaType** pMediaType)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::GetOutputCurrentType</unmanaged-short>	
        public void GetOutputCurrentType(int dwOutputStreamID, out SharpDX.MediaFoundation.MediaType mediaTypeRef)
        {
            unsafe
            {
                IntPtr mediaTypeRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputStreamID, &mediaTypeRef_, ((void**)(*(void**)_nativePointer))[8]);
                mediaTypeRef = (mediaTypeRef_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(mediaTypeRef_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwOutputStreamID">No documentation.</param>	
        /// <param name="attributesOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::GetOutputStreamAttributes']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::GetOutputStreamAttributes([In] unsigned int dwOutputStreamID,[Out] IMFAttributes** ppAttributes)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::GetOutputStreamAttributes</unmanaged-short>	
        public void GetOutputStreamAttributes(int dwOutputStreamID, out SharpDX.MediaFoundation.MediaAttributes attributesOut)
        {
            unsafe
            {
                IntPtr attributesOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputStreamID, &attributesOut_, ((void**)(*(void**)_nativePointer))[9]);
                attributesOut = (attributesOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(attributesOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="cInputStreamsRef">No documentation.</param>	
        /// <param name="cOutputStreamsRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::GetStreamCount']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::GetStreamCount([Out] unsigned int* pcInputStreams,[Out] unsigned int* pcOutputStreams)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::GetStreamCount</unmanaged-short>	
        public void GetStreamCount(out int cInputStreamsRef, out int cOutputStreamsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cInputStreamsRef_ = &cInputStreamsRef)
                fixed (void* cOutputStreamsRef_ = &cOutputStreamsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cInputStreamsRef_, cOutputStreamsRef_, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwInputIDArraySize">No documentation.</param>	
        /// <param name="dwInputStreamIdsRef">No documentation.</param>	
        /// <param name="dwOutputIDArraySize">No documentation.</param>	
        /// <param name="dwOutputStreamIdsRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::GetStreamIDs']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::GetStreamIDs([In] unsigned int dwInputIDArraySize,[Out] unsigned int* pdwInputStreamIds,[In] unsigned int dwOutputIDArraySize,[Out] unsigned int* pdwOutputStreamIds)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::GetStreamIDs</unmanaged-short>	
        public void GetStreamIDs(int dwInputIDArraySize, out int dwInputStreamIdsRef, int dwOutputIDArraySize, out int dwOutputStreamIdsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwInputStreamIdsRef_ = &dwInputStreamIdsRef)
                fixed (void* dwOutputStreamIdsRef_ = &dwOutputStreamIdsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputIDArraySize, dwInputStreamIdsRef_, dwOutputIDArraySize, dwOutputStreamIdsRef_, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwInputStreamID">No documentation.</param>	
        /// <param name="eventRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::ProcessEvent']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::ProcessEvent([In] unsigned int dwInputStreamID,[In] IMFMediaEvent* pEvent)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::ProcessEvent</unmanaged-short>	
        public void ProcessEvent(int dwInputStreamID, SharpDX.MediaFoundation.MediaEvent eventRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamID, (void*)((eventRef == null) ? IntPtr.Zero : eventRef.NativePointer), ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwInputStreamID">No documentation.</param>	
        /// <param name="sampleRef">No documentation.</param>	
        /// <param name="dwFlags">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::ProcessInput']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::ProcessInput([In] unsigned int dwInputStreamID,[In] IMFSample* pSample,[In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::ProcessInput</unmanaged-short>	
        public void ProcessInput(int dwInputStreamID, SharpDX.MediaFoundation.Sample sampleRef, int dwFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamID, (void*)((sampleRef == null) ? IntPtr.Zero : sampleRef.NativePointer), dwFlags, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="eMessage">No documentation.</param>	
        /// <param name="ulParam">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::ProcessMessage']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::ProcessMessage([In] MFT_MESSAGE_TYPE eMessage,[In] ULONG_PTR ulParam)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::ProcessMessage</unmanaged-short>	
        public void ProcessMessage(SharpDX.MediaFoundation.TMessageType eMessage, System.IntPtr ulParam)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)eMessage), (void*)ulParam, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwFlags">No documentation.</param>	
        /// <param name="cOutputBufferCount">No documentation.</param>	
        /// <param name="outputSampleRef">No documentation.</param>	
        /// <param name="dwStatusRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::ProcessOutput']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::ProcessOutput([In] unsigned int dwFlags,[In] unsigned int cOutputBufferCount,[InOut] MFT_OUTPUT_DATA_BUFFER* pOutputSample,[Out] unsigned int* pdwStatus)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::ProcessOutput</unmanaged-short>	
        public void ProcessOutput(int dwFlags, int cOutputBufferCount, ref SharpDX.MediaFoundation.TOutputDataBuffer outputSampleRef, out int dwStatusRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* outputSampleRef_ = &outputSampleRef)
                fixed (void* dwStatusRef_ = &dwStatusRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwFlags, cOutputBufferCount, outputSampleRef_, dwStatusRef_, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>The <strong>SetInputStreamState</strong> method sets the Device MFT input stream state and media type.</p>	
        /// </summary>	
        /// <param name="dwStreamID"><dd> <p>Stream ID of the input stream where the state and media type needs to be changed.</p> </dd></param>	
        /// <param name="mediaTypeRef"><dd> <p>Preferred media type for the input stream is passed in through this parameter. Device MFT should change the media type only if the incoming media type is different from the current media type.</p> </dd></param>	
        /// <param name="value"><dd> <p>Specifies the  <strong>DeviceStreamState</strong> which the input stream should transition to.</p> </dd></param>	
        /// <param name="dwFlags"><dd> <p>When  <strong><see cref="SharpDX.Result.Ok"/></strong> is returned, perform the state change operation. Otherwise, this contains an error that occurred while setting the media type on the devproxy  output pin. In this case, propagate the error appropriately.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include but not limited to values given in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Initialization succeeded</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>Device MFT could not  support the request at this time.</p> </td></tr> <tr><td> <dl> <dt><strong>MF_E_INVAILIDSTREAMNUMBER</strong></dt> </dl> </td><td> <p>An invalid stream ID was passed.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamState"/></strong></dt> </dl> </td><td> <p>The requested stream transition is not possible.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface function helps to transition the input stream to a specified state with a specified media type set on the input stream. This will be used by device transform  manager (DTM) when the Device MFT requests a specific input stream?s state and media type to be changed. Device MFT would need to request such a change when one of the Device MFT's output changes.</p><p>As an  example, consider a Device MFT that has two input streams and three output streams. Let  Output 1 and Output 2 source from Input 1 and  stream at 720p. Now, if   Output 2?s media type changes to 1080p, Device MFT has to change Input 1's media type to 1080p. To achieve this, Device MFT should request DTM to call this method using the <see cref="SharpDX.MediaFoundation.MediaEventTypes.TransformInputStreamStateChanged"/> message.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::SetInputStreamState']/*"/>	
        /// <msdn-id>mt797683</msdn-id>	
        /// <unmanaged>HRESULT IMFDeviceTransform::SetInputStreamState([In] unsigned int dwStreamID,[In] IMFMediaType* pMediaType,[In] DeviceStreamState value,[In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::SetInputStreamState</unmanaged-short>	
        public void SetInputStreamState(int dwStreamID, SharpDX.MediaFoundation.MediaType mediaTypeRef, SharpDX.MediaFoundation.DeviceStreamState value, int dwFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamID, (void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), unchecked((int)value), dwFlags, ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwStreamID">No documentation.</param>	
        /// <param name="value">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::GetInputStreamState']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::GetInputStreamState([In] unsigned int dwStreamID,[Out] DeviceStreamState* value)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::GetInputStreamState</unmanaged-short>	
        public void GetInputStreamState(int dwStreamID, out SharpDX.MediaFoundation.DeviceStreamState value)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* value_ = &value)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamID, value_, ((void**)(*(void**)_nativePointer))[17]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>The <strong>SetOutputStreamState</strong> method sets the Device MFT output stream state and media type.</p>	
        /// </summary>	
        /// <param name="dwStreamID"><dd> <p>Stream ID of the input stream where the state and media type needs to be changed.</p> </dd></param>	
        /// <param name="mediaTypeRef"><dd> <p>Preferred media type for the input stream is passed in through this parameter. Device MFT should change the media type only if the incoming media type is different from the current media type.</p> </dd></param>	
        /// <param name="value"><dd> <p>Specifies the  <strong>DeviceStreamState</strong> which the input stream should transition to.</p> </dd></param>	
        /// <param name="dwFlags"><dd> <p>Must be zero.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include but not limited to values given in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Transitioning the stream state succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>Device MFT could not  support the request at this time.</p> </td></tr> <tr><td> <dl> <dt><strong>MF_E_INVAILIDSTREAMNUMBER</strong></dt> </dl> </td><td> <p>An invalid stream ID was passed.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamState"/></strong></dt> </dl> </td><td> <p>The requested stream transition is not possible.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface method helps to transition the output stream to a specified state with specified media type set on the output stream. This will be used by the DTM when the Device Source requests a specific output stream?s state and media type to be changed. Device MFT should change the specified output stream?s media type and state to the requested media type.</p><p>If the incoming media type and stream state are same as the current media type and stream state the method return <strong><see cref="SharpDX.Result.Ok"/></strong>.</p><p>If the incoming media type and current media type of the stream are the same, Device MFT must change the stream?s state to the requested value and return the appropriate <strong><see cref="SharpDX.Result"/></strong>.</p><p>When a change in the output stream?s media type requires a corresponding change in the input then Device MFT must post the <see cref="SharpDX.MediaFoundation.MediaEventTypes.TransformInputStreamStateChanged"/> event  to DTM to change the relevant input stream. The call must return only after changing the input stream?s media type and the appropriate <strong><see cref="SharpDX.Result"/></strong>.</p><p>As an  example, consider a Device MFT that has two input streams and three output streams. Let  Output 1 and Output 2 source from Input 1 and  stream at 720p. Now, let us say Output 2?s media type changes to 1080p. To satisfy this request, Device MFT must  change the Input 1 media type to 1080p, by posting <see cref="SharpDX.MediaFoundation.MediaEventTypes.TransformInputStreamStateChanged"/> event to the DTM. DTM would call <strong>SetInputStreamState</strong> to change the input stream? media type and state. After this call, the <strong>SetOutputStreamState</strong> must return.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::SetOutputStreamState']/*"/>	
        /// <msdn-id>mt797684</msdn-id>	
        /// <unmanaged>HRESULT IMFDeviceTransform::SetOutputStreamState([In] unsigned int dwStreamID,[In] IMFMediaType* pMediaType,[In] DeviceStreamState value,[In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::SetOutputStreamState</unmanaged-short>	
        public void SetOutputStreamState(int dwStreamID, SharpDX.MediaFoundation.MediaType mediaTypeRef, SharpDX.MediaFoundation.DeviceStreamState value, int dwFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamID, (void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), unchecked((int)value), dwFlags, ((void**)(*(void**)_nativePointer))[18]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwStreamID">No documentation.</param>	
        /// <param name="value">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::GetOutputStreamState']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::GetOutputStreamState([In] unsigned int dwStreamID,[Out] DeviceStreamState* value)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::GetOutputStreamState</unmanaged-short>	
        public void GetOutputStreamState(int dwStreamID, out SharpDX.MediaFoundation.DeviceStreamState value)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* value_ = &value)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamID, value_, ((void**)(*(void**)_nativePointer))[19]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwStreamID">No documentation.</param>	
        /// <param name="value">No documentation.</param>	
        /// <param name="mediaTypeOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::GetInputStreamPreferredState']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::GetInputStreamPreferredState([In] unsigned int dwStreamID,[Out] DeviceStreamState* value,[Out] IMFMediaType** ppMediaType)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::GetInputStreamPreferredState</unmanaged-short>	
        public void GetInputStreamPreferredState(int dwStreamID, out SharpDX.MediaFoundation.DeviceStreamState value, out SharpDX.MediaFoundation.MediaType mediaTypeOut)
        {
            unsafe
            {
                IntPtr mediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* value_ = &value)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamID, value_, &mediaTypeOut_, ((void**)(*(void**)_nativePointer))[20]);
                mediaTypeOut = (mediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(mediaTypeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwStreamIndex">No documentation.</param>	
        /// <param name="dwFlags">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::FlushInputStream']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::FlushInputStream([In] unsigned int dwStreamIndex,[In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::FlushInputStream</unmanaged-short>	
        public void FlushInputStream(int dwStreamIndex, int dwFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, dwFlags, ((void**)(*(void**)_nativePointer))[21]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwStreamIndex">No documentation.</param>	
        /// <param name="dwFlags">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDeviceTransform::FlushOutputStream']/*"/>	
        /// <unmanaged>HRESULT IMFDeviceTransform::FlushOutputStream([In] unsigned int dwStreamIndex,[In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IMFDeviceTransform::FlushOutputStream</unmanaged-short>	
        public void FlushOutputStream(int dwStreamIndex, int dwFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, dwFlags, ((void**)(*(void**)_nativePointer))[22]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Initializes the Digital Living Network Alliance (DLNA) media sink. </p><p>The DLNA media sink exposes this interface. To get a reference to this interface, call <strong>CoCreateInstance</strong>. The CLSID is <strong>CLSID_MPEG2DLNASink</strong>.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDLNASinkInit']/*"/>	
    /// <msdn-id>dd368787</msdn-id>	
    /// <unmanaged>IMFDLNASinkInit</unmanaged>	
    /// <unmanaged-short>IMFDLNASinkInit</unmanaged-short>	
    [Guid("0c012799-1b61-4c10-bda9-04445be5f561")]
    public partial class DLNASinkInit : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.DLNASinkInit"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DLNASinkInit(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.DLNASinkInit"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.DLNASinkInit(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.DLNASinkInit(nativePointer);
        }


        /// <summary>	
        /// <p>Initializes the Digital Living Network Alliance (DLNA) media sink.</p>	
        /// </summary>	
        /// <param name="byteStreamRef"><dd> <p>Pointer to a byte stream. The DLNA media sink writes data to this byte stream. The byte stream must be writable.</p> </dd></param>	
        /// <param name="fPal"><dd> <p>If <strong>TRUE</strong>, the DLNA media sink accepts PAL video formats. Otherwise, it accepts NTSC video  formats.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.AlreadyInitializeD"/></strong></strong></dt> </dl> </td><td> <p>The method was already called.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The media sink's <strong><see cref="SharpDX.MediaFoundation.MediaSink.Shutdown"/></strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDLNASinkInit::Initialize']/*"/>	
        /// <msdn-id>dd368788</msdn-id>	
        /// <unmanaged>HRESULT IMFDLNASinkInit::Initialize([In] IMFByteStream* pByteStream,[In] BOOL fPal)</unmanaged>	
        /// <unmanaged-short>IMFDLNASinkInit::Initialize</unmanaged-short>	
        internal void Initialize_(System.IntPtr byteStreamRef, SharpDX.Mathematics.Interop.RawBool fPal)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint15(_nativePointer, (void*)byteStreamRef, fPal, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Configures Windows Media Digital Rights Management (DRM) for Network Devices on a network sink.</p><p> The Advanced Systems Format (ASF) streaming media sink exposes this interface. To get a reference to the <strong><see cref="SharpDX.MediaFoundation.DRMNetHelper"/></strong> interface, perform the following tasks.</p><ol> <li>Get the activation object for the ASF streaming media sink by calling <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateASFStreamingMediaSinkActivate"/></strong>.</li> <li>Create the media sink by calling  the activation object <strong>ActivateObject</strong> method.</li> <li>Get an <strong><see cref="SharpDX.MediaFoundation.DRMNetHelper"/></strong> reference by calling <strong>QueryInterface</strong> on the media sink.</li> </ol><p>For more information, see Remarks.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To stream protected content over a network, the <em>ASF streaming media sink</em> provides an output trust authority (OTA) that supports  Windows Media DRM for Network Devices and implements the <strong><see cref="SharpDX.MediaFoundation.DRMNetHelper"/></strong> interface. For this OTA,  encryption occurs on each frame before multiplexing. The license request and response process takes place in the media sink.</p><p>The application gets a reference to <strong><see cref="SharpDX.MediaFoundation.DRMNetHelper"/></strong> and uses the methods to handle the license request and response. The application is also responsible for sending the license to the client.</p><p>To stream the content, the application does the following:</p><ol> <li>Provide the HTTP byte stream to which the media sink writes the streamed content. <p>To stream DRM-protected content over a network from a server to a client, an application must use the Microsoft Media Foundation Protected Media Path (PMP). The media sink and the application-provided HTTP byte stream exist in  mfpmp.exe. Therefore, the byte stream must expose the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface so that it can be created out-of-process.</p><strong>Note</strong>??This might affect how the code is packaged. The DLL that contains the HTTP byte stream and other dependent DLLs must be signed for the Protected Environment (PE-signed).   ? </li> <li>Set the <strong>MFPKEY_ASFMEDIASINK_DRMACTION</strong> property to <strong><see cref="SharpDX.MediaFoundation.SinkWmdrmaction.Transcrypt"/></strong>. The media sink's property store is available to the application through the ASF ContentInfo. To get the property store, call <strong><see cref="SharpDX.MediaFoundation.ASFContentInfo.GetEncodingConfigurationPropertyStore"/></strong>.</li> <li>Get a reference to the <strong><see cref="SharpDX.MediaFoundation.DRMNetHelper"/></strong> interface by querying the media sink.</li> <li>To make a license request, call <strong><see cref="SharpDX.MediaFoundation.DRMNetHelper.ProcessLicenseRequest"/></strong>. This method calls into the OTA implementation and retrieves the license.<p>When the clock starts for the first time or restarts , the encrypter that is used for encrypting samples is retrieved, and   the license response is cached.</p> </li> <li>To get the cached license response, call <strong><see cref="SharpDX.MediaFoundation.DRMNetHelper.GetChainedLicenseResponse"/></strong>.</li> </ol>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDRMNetHelper']/*"/>	
    /// <msdn-id>dd368789</msdn-id>	
    /// <unmanaged>IMFDRMNetHelper</unmanaged>	
    /// <unmanaged-short>IMFDRMNetHelper</unmanaged-short>	
    [Guid("3D1FF0EA-679A-4190-8D46-7FA69E8C7E15")]
    public partial class DRMNetHelper : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.DRMNetHelper"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DRMNetHelper(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.DRMNetHelper"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.DRMNetHelper(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.DRMNetHelper(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the license response for the specified request.</p>	
        /// </summary>	
        /// <param name="licenseRequestRef"><dd> <p>Pointer to a byte array that contains the license request.</p> </dd></param>	
        /// <param name="cbLicenseRequest"><dd> <p>Size, in bytes, of the license request.</p> </dd></param>	
        /// <param name="licenseResponseOut"><dd> <p>Receives a reference to a byte array that contains the license response. The caller must free the array by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <param name="cbLicenseResponseRef"><dd> <p>Receives the size, in bytes, of the license response.</p> </dd></param>	
        /// <param name="bstrKIDRef"><dd> <p>Receives the key identifier. The caller must release the string by calling <strong>SysFreeString</strong>.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink was shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDRMNetHelper::ProcessLicenseRequest']/*"/>	
        /// <msdn-id>dd368791</msdn-id>	
        /// <unmanaged>HRESULT IMFDRMNetHelper::ProcessLicenseRequest([In, Buffer] unsigned char* pLicenseRequest,[In] unsigned int cbLicenseRequest,[Buffer, Optional] unsigned char** ppLicenseResponse,[Out] unsigned int* pcbLicenseResponse,[Out] wchar_t** pbstrKID)</unmanaged>	
        /// <unmanaged-short>IMFDRMNetHelper::ProcessLicenseRequest</unmanaged-short>	
        public void ProcessLicenseRequest(byte[] licenseRequestRef, int cbLicenseRequest, byte[] licenseResponseOut, out int cbLicenseResponseRef, System.IntPtr bstrKIDRef)
        {
            unsafe
            {
                byte[] licenseResponseOut__ = licenseResponseOut;
                SharpDX.Result __result__;
                fixed (void* licenseRequestRef_ = licenseRequestRef)
                fixed (void* licenseResponseOut_ = licenseResponseOut__)
                fixed (void* cbLicenseResponseRef_ = &cbLicenseResponseRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, licenseRequestRef_, cbLicenseRequest, licenseResponseOut_, cbLicenseResponseRef_, (void*)bstrKIDRef, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Not implemented in this release.</p>	
        /// </summary>	
        /// <param name="licenseResponseOut"><dd> <p>Receives a reference to a byte array that contains the license response. The caller must free the array by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <param name="cbLicenseResponseRef"><dd> <p>Receives the size, in bytes, of the license response.</p> </dd></param>	
        /// <returns><p>The method returns <strong>E_NOTIMPL</strong>.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDRMNetHelper::GetChainedLicenseResponse']/*"/>	
        /// <msdn-id>dd368790</msdn-id>	
        /// <unmanaged>HRESULT IMFDRMNetHelper::GetChainedLicenseResponse([Buffer, Optional] unsigned char** ppLicenseResponse,[Out] unsigned int* pcbLicenseResponse)</unmanaged>	
        /// <unmanaged-short>IMFDRMNetHelper::GetChainedLicenseResponse</unmanaged-short>	
        public void GetChainedLicenseResponse(byte[] licenseResponseOut, out int cbLicenseResponseRef)
        {
            unsafe
            {
                byte[] licenseResponseOut__ = licenseResponseOut;
                SharpDX.Result __result__;
                fixed (void* licenseResponseOut_ = licenseResponseOut__)
                fixed (void* cbLicenseResponseRef_ = &cbLicenseResponseRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, licenseResponseOut_, cbLicenseResponseRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a buffer that contains a Microsoft DirectX Graphics Infrastructure (DXGI) surface.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To create a DXGI media buffer, first create the DXGI surface. Then call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDXGISurfaceBuffer"/></strong>. </p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIBuffer']/*"/>	
    /// <msdn-id>hh447901</msdn-id>	
    /// <unmanaged>IMFDXGIBuffer</unmanaged>	
    /// <unmanaged-short>IMFDXGIBuffer</unmanaged-short>	
    [Guid("e7174cfa-1c9e-48b1-8866-626226bfc258")]
    public partial class DXGIBuffer : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.DXGIBuffer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DXGIBuffer(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.DXGIBuffer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.DXGIBuffer(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.DXGIBuffer(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the index of the subresource that is associated with this media buffer.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The subresource index is specified when you create the media buffer object. See <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDXGISurfaceBuffer"/></strong>.</p><p>For more information about texture subresources, see <strong><see cref="SharpDX.Direct3D11.Device.CreateTexture2D"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIBuffer::GetSubresourceIndex']/*"/>	
        /// <msdn-id>hh447903</msdn-id>	
        /// <unmanaged>GetSubresourceIndex</unmanaged>	
        /// <unmanaged-short>GetSubresourceIndex</unmanaged-short>	
        /// <unmanaged>HRESULT IMFDXGIBuffer::GetSubresourceIndex([Out] unsigned int* puSubresource)</unmanaged>
        public int SubresourceIndex
        {
            get { int __output__; GetSubresourceIndex(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Queries the Microsoft DirectX Graphics Infrastructure (DXGI) surface for an interface.</p>	
        /// </summary>	
        /// <param name="riid"><dd> <p>The interface identifer (IID) of the interface being requested.</p> </dd></param>	
        /// <param name="vObjectOut"><dd> <p>Receives a reference to the interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong> E_NOINTERFACE</strong></dt> </dl> </td><td> <p>The object does not support the specified interface.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid request.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You can use this method to get a reference to the <strong><see cref="SharpDX.Direct3D11.Texture2D"/></strong> interface of the surface. If the buffer is locked, the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIBuffer::GetResource']/*"/>	
        /// <msdn-id>hh447902</msdn-id>	
        /// <unmanaged>HRESULT IMFDXGIBuffer::GetResource([In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>	
        /// <unmanaged-short>IMFDXGIBuffer::GetResource</unmanaged-short>	
        public void GetResource(System.Guid riid, out System.IntPtr vObjectOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vObjectOut_ = &vObjectOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &riid, vObjectOut_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the index of the subresource that is associated with this media buffer.</p>	
        /// </summary>	
        /// <param name="uSubresourceRef"><dd> <p>Receives the zero-based index of the subresource.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The subresource index is specified when you create the media buffer object. See <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDXGISurfaceBuffer"/></strong>.</p><p>For more information about texture subresources, see <strong><see cref="SharpDX.Direct3D11.Device.CreateTexture2D"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIBuffer::GetSubresourceIndex']/*"/>	
        /// <msdn-id>hh447903</msdn-id>	
        /// <unmanaged>HRESULT IMFDXGIBuffer::GetSubresourceIndex([Out] unsigned int* puSubresource)</unmanaged>	
        /// <unmanaged-short>IMFDXGIBuffer::GetSubresourceIndex</unmanaged-short>	
        internal void GetSubresourceIndex(out int uSubresourceRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* uSubresourceRef_ = &uSubresourceRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, uSubresourceRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets an <strong><see cref="SharpDX.ComObject"/></strong> reference that was previously stored in the media buffer object.</p>	
        /// </summary>	
        /// <param name="guid">No documentation.</param>	
        /// <param name="riid">No documentation.</param>	
        /// <param name="vObjectOut">No documentation.</param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong> E_NOINTERFACE</strong></dt> </dl> </td><td> <p>The object does not support the specified interface.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotFound"/></strong></dt> </dl> </td><td> <p>The specified key was not found.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIBuffer::GetUnknown']/*"/>	
        /// <msdn-id>hh447904</msdn-id>	
        /// <unmanaged>HRESULT IMFDXGIBuffer::GetUnknown([In] const GUID&amp; guid,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>	
        /// <unmanaged-short>IMFDXGIBuffer::GetUnknown</unmanaged-short>	
        public void GetUnknown(System.Guid guid, System.Guid riid, out System.IntPtr vObjectOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vObjectOut_ = &vObjectOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guid, &riid, vObjectOut_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Stores an arbitrary <strong><see cref="SharpDX.ComObject"/></strong> reference in the media buffer object.</p>	
        /// </summary>	
        /// <param name="guid">No documentation.</param>	
        /// <param name="unkDataRef">No documentation.</param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Win32.ErrorCode.ObjectAlreadyExists"/></strong></dt> </dl> </td><td> <p>An item already exists with this key.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To retrieve the reference from the object, call <strong><see cref="SharpDX.MediaFoundation.DXGIBuffer.GetUnknown"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIBuffer::SetUnknown']/*"/>	
        /// <msdn-id>hh447905</msdn-id>	
        /// <unmanaged>HRESULT IMFDXGIBuffer::SetUnknown([In] const GUID&amp; guid,[In, Optional] IUnknown* pUnkData)</unmanaged>	
        /// <unmanaged-short>IMFDXGIBuffer::SetUnknown</unmanaged-short>	
        public void SetUnknown(System.Guid guid, SharpDX.ComObject unkDataRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guid, (void*)((unkDataRef == null) ? IntPtr.Zero : unkDataRef.NativePointer), ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables two threads to share the same Microsoft Direct3D?11 device.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is exposed by the Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager. To create the DXGI Device Manager, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDXGIDeviceManager"/></strong> function.</p><p>When you create an <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> with <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDXGIDeviceManager"/></strong>, a Direct3D?11 device is not associated with the device manager. To associate a Direct3D?11 device with the device manager, call <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.ResetDevice"/></strong>, passing in the reference to the Direct3D?11 device. To create a Direct3D?11 device, call <strong><see cref="SharpDX.Direct3D11.D3D11.CreateDevice"/></strong>. The device should be created with the <strong><see cref="SharpDX.Direct3D11.DeviceCreationFlags.VideoSupport"/></strong> device creation flag which is defined in the <strong><see cref="SharpDX.Direct3D11.DeviceCreationFlags"/></strong> enumeration.</p><p>For Microsoft Direct3D?9 devices, use the <strong>IDirect3DDeviceManager9</strong> interface.</p><p>Windows Store apps must use <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> and Direct3D 11 Video APIs. </p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIDeviceManager']/*"/>	
    /// <msdn-id>hh447906</msdn-id>	
    /// <unmanaged>IMFDXGIDeviceManager</unmanaged>	
    /// <unmanaged-short>IMFDXGIDeviceManager</unmanaged-short>	
    [Guid("eb533d5d-2db6-40f8-97a9-494692014f07")]
    public partial class DXGIDeviceManager : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DXGIDeviceManager(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.DXGIDeviceManager(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.DXGIDeviceManager(nativePointer);
        }


        /// <summary>	
        /// <p>Enables two threads to share the same Microsoft Direct3D?11 device.</p>	
        /// </summary>	
        /// <param name="hDevice">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <remarks>	
        /// <p>This interface is exposed by the Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager. To create the DXGI Device Manager, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDXGIDeviceManager"/></strong> function.</p><p>When you create an <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> with <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDXGIDeviceManager"/></strong>, a Direct3D?11 device is not associated with the device manager. To associate a Direct3D?11 device with the device manager, call <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.ResetDevice"/></strong>, passing in the reference to the Direct3D?11 device. To create a Direct3D?11 device, call <strong><see cref="SharpDX.Direct3D11.D3D11.CreateDevice"/></strong>. The device should be created with the <strong><see cref="SharpDX.Direct3D11.DeviceCreationFlags.VideoSupport"/></strong> device creation flag which is defined in the <strong><see cref="SharpDX.Direct3D11.DeviceCreationFlags"/></strong> enumeration.</p><p>For Microsoft Direct3D?9 devices, use the <strong>IDirect3DDeviceManager9</strong> interface.</p><p>Windows Store apps must use <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> and Direct3D 11 Video APIs. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIDeviceManager::CloseDeviceHandle']/*"/>	
        /// <msdn-id>hh447906</msdn-id>	
        /// <unmanaged>HRESULT IMFDXGIDeviceManager::CloseDeviceHandle([In] void* hDevice)</unmanaged>	
        /// <unmanaged-short>IMFDXGIDeviceManager::CloseDeviceHandle</unmanaged-short>	
        public void CloseDeviceHandle(System.IntPtr hDevice)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)hDevice, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries the Microsoft Direct3D device for an interface.</p>	
        /// </summary>	
        /// <param name="hDevice"><dd> <p>A handle to the Direct3D device. To get the device handle, call <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.OpenDeviceHandle"/></strong>.</p> </dd></param>	
        /// <param name="riid"><dd> <p>The interface identifier (IID) of the requested interface. The Direct3D device supports the following interfaces:</p> <ul> <li> <strong><see cref="SharpDX.Direct3D11.Device"/></strong>. To get a reference to the Direct3D11 device, use <strong>IID_ID3D11Device</strong> as the <em>riid</em>.</li> <li> <strong><see cref="SharpDX.Direct3D11.VideoDevice"/></strong>. To get a reference to the Direct3D11 video device, use <strong>IID_ID3D11VideoDevice</strong> as the <em>riid</em>.</li> </ul> </dd></param>	
        /// <returns><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></returns>	
        /// <remarks>	
        /// <p>If the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.DxgiNewVideoDevice"/></strong>, call <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.CloseDeviceHandle"/></strong> to close the handle and then call <strong>OpenDeviceHandle</strong> again to get a new handle. The  <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.ResetDevice"/></strong> method invalidates all open device handles.</p><p>For more info see, Supporting Direct3D 11 Video Decoding in Media Foundation.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIDeviceManager::GetVideoService']/*"/>	
        /// <msdn-id>hh447908</msdn-id>	
        /// <unmanaged>HRESULT IMFDXGIDeviceManager::GetVideoService([In] void* hDevice,[In] const GUID&amp; riid,[Out] void** ppService)</unmanaged>	
        /// <unmanaged-short>IMFDXGIDeviceManager::GetVideoService</unmanaged-short>	
        public System.IntPtr GetVideoService(System.IntPtr hDevice, System.Guid riid)
        {
            unsafe
            {
                System.IntPtr serviceOut;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)hDevice, &riid, &serviceOut, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
                return serviceOut;
            }
        }

        /// <summary>	
        /// <p>Gives the caller exclusive access to the Microsoft Direct3D device.</p>	
        /// </summary>	
        /// <param name="hDevice"><dd> <p>A handle to the Direct3D device. To get the device handle, call <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.OpenDeviceHandle"/></strong>.</p> </dd></param>	
        /// <param name="riid"><dd> <p>The interface identifier (IID) of the requested interface. The Direct3D device will support the following interfaces:</p> <ul> <li> <strong><see cref="SharpDX.Direct3D11.Device"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D11.VideoContext"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D11.VideoDevice"/></strong> </li> </ul> </dd></param>	
        /// <param name="fBlock"><dd> <p>Specifies whether to wait for the device lock. If the device is already locked and this parameter is <strong>TRUE</strong>, the method blocks until the device is unlocked. Otherwise, if the device is locked and this parameter is <strong><see cref="SharpDX.Result.False"/></strong>, the method returns immediately with the error code <strong>DXVA2_E_VIDEO_DEVICE_LOCKED</strong>.</p> </dd></param>	
        /// <returns><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></returns>	
        /// <remarks>	
        /// <p>When you are done using the Direct3D device, call <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.UnlockDevice"/></strong> to unlock the device.</p><p>If the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.DxgiNewVideoDevice"/></strong>, call <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.CloseDeviceHandle"/></strong> to close the handle and then call <strong>OpenDeviceHandle</strong> again to get a new handle. The  <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.ResetDevice"/></strong> method invalidates all open device handles.</p><p>If <em>fBlock</em> is <strong>TRUE</strong>, this method can potentially deadlock. For example, it will deadlock if a thread calls <strong>LockDevice</strong> and then waits on another thread that calls <strong>LockDevice</strong>. It will also deadlock if a thread calls <strong>LockDevice</strong> twice without calling <strong>UnlockDevice</strong> in between.  </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIDeviceManager::LockDevice']/*"/>	
        /// <msdn-id>hh447909</msdn-id>	
        /// <unmanaged>HRESULT IMFDXGIDeviceManager::LockDevice([In] void* hDevice,[In] const GUID&amp; riid,[Out] void** ppUnkDevice,[In] BOOL fBlock)</unmanaged>	
        /// <unmanaged-short>IMFDXGIDeviceManager::LockDevice</unmanaged-short>	
        public System.IntPtr LockDevice(System.IntPtr hDevice, System.Guid riid, SharpDX.Mathematics.Interop.RawBool fBlock)
        {
            unsafe
            {
                System.IntPtr unkDeviceOut;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint89(_nativePointer, (void*)hDevice, &riid, &unkDeviceOut, fBlock, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
                return unkDeviceOut;
            }
        }

        /// <summary>	
        /// <p>Gets a handle to the Microsoft Direct3D device. </p>	
        /// </summary>	
        /// <returns><dd> <p>Receives the device handle.</p> </dd></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIDeviceManager::OpenDeviceHandle']/*"/>	
        /// <msdn-id>hh447910</msdn-id>	
        /// <unmanaged>HRESULT IMFDXGIDeviceManager::OpenDeviceHandle([Out] void** phDevice)</unmanaged>	
        /// <unmanaged-short>IMFDXGIDeviceManager::OpenDeviceHandle</unmanaged-short>	
        public System.IntPtr OpenDeviceHandle()
        {
            unsafe
            {
                System.IntPtr hDeviceRef;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &hDeviceRef, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
                return hDeviceRef;
            }
        }

        /// <summary>	
        /// <p>Enables two threads to share the same Microsoft Direct3D?11 device.</p>	
        /// </summary>	
        /// <param name="unkDeviceRef">No documentation.</param>	
        /// <param name="resetToken">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <remarks>	
        /// <p>This interface is exposed by the Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager. To create the DXGI Device Manager, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDXGIDeviceManager"/></strong> function.</p><p>When you create an <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> with <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDXGIDeviceManager"/></strong>, a Direct3D?11 device is not associated with the device manager. To associate a Direct3D?11 device with the device manager, call <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.ResetDevice"/></strong>, passing in the reference to the Direct3D?11 device. To create a Direct3D?11 device, call <strong><see cref="SharpDX.Direct3D11.D3D11.CreateDevice"/></strong>. The device should be created with the <strong><see cref="SharpDX.Direct3D11.DeviceCreationFlags.VideoSupport"/></strong> device creation flag which is defined in the <strong><see cref="SharpDX.Direct3D11.DeviceCreationFlags"/></strong> enumeration.</p><p>For Microsoft Direct3D?9 devices, use the <strong>IDirect3DDeviceManager9</strong> interface.</p><p>Windows Store apps must use <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> and Direct3D 11 Video APIs. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIDeviceManager::ResetDevice']/*"/>	
        /// <msdn-id>hh447906</msdn-id>	
        /// <unmanaged>HRESULT IMFDXGIDeviceManager::ResetDevice([In] IUnknown* pUnkDevice,[In] unsigned int resetToken)</unmanaged>	
        /// <unmanaged-short>IMFDXGIDeviceManager::ResetDevice</unmanaged-short>	
        internal void ResetDevice(SharpDX.ComObject unkDeviceRef, int resetToken)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((unkDeviceRef == null) ? IntPtr.Zero : unkDeviceRef.NativePointer), resetToken, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Tests whether a Microsoft Direct3D device handle is valid.</p>	
        /// </summary>	
        /// <param name="hDevice"><dd> <p>A handle to the Direct3D device. To get the device handle, call <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.OpenDeviceHandle"/></strong>.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong>E_HANDLE</strong></dt> </dl> </td><td> <p>The specified handle is not a Direct3D device handle.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.DxgiNewVideoDevice"/></strong></dt> </dl> </td><td> <p>The device handle is invalid. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.DxgiNewVideoDevice"/></strong>, call <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.CloseDeviceHandle"/></strong> to close the handle and then call <strong>OpenDeviceHandle</strong> again to get a new handle. The  <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.ResetDevice"/></strong> method invalidates all open device handles.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIDeviceManager::TestDevice']/*"/>	
        /// <msdn-id>hh447912</msdn-id>	
        /// <unmanaged>HRESULT IMFDXGIDeviceManager::TestDevice([In] void* hDevice)</unmanaged>	
        /// <unmanaged-short>IMFDXGIDeviceManager::TestDevice</unmanaged-short>	
        public void TestDevice(System.IntPtr hDevice)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)hDevice, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Unlocks the Microsoft Direct3D device.</p>	
        /// </summary>	
        /// <param name="hDevice"><dd> <p>A handle to the Direct3D device. To get the device handle, call <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.OpenDeviceHandle"/></strong>.</p> </dd></param>	
        /// <param name="fSaveState"><dd> <p>Reserved.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Call this method to release the device after calling <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager.LockDevice"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIDeviceManager::UnlockDevice']/*"/>	
        /// <msdn-id>hh447913</msdn-id>	
        /// <unmanaged>HRESULT IMFDXGIDeviceManager::UnlockDevice([In] void* hDevice,[In] BOOL fSaveState)</unmanaged>	
        /// <unmanaged-short>IMFDXGIDeviceManager::UnlockDevice</unmanaged-short>	
        internal void UnlockDevice(System.IntPtr hDevice, SharpDX.Mathematics.Interop.RawBool fSaveState)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint15(_nativePointer, (void*)hDevice, fSaveState, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides functionality for getting the <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> from the Microsoft Media Foundation video rendering sink.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIDeviceManagerSource']/*"/>	
    /// <msdn-id>dn280687</msdn-id>	
    /// <unmanaged>IMFDXGIDeviceManagerSource</unmanaged>	
    /// <unmanaged-short>IMFDXGIDeviceManagerSource</unmanaged-short>	
    [Guid("20bc074b-7a8d-4609-8c3b-64a0a3b5d7ce")]
    public partial class DXGIDeviceManagerSource : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.DXGIDeviceManagerSource"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DXGIDeviceManagerSource(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.DXGIDeviceManagerSource"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.DXGIDeviceManagerSource(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.DXGIDeviceManagerSource(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> from the Microsoft Media Foundation video rendering sink.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIDeviceManagerSource::GetManager']/*"/>	
        /// <msdn-id>dn280688</msdn-id>	
        /// <unmanaged>GetManager</unmanaged>	
        /// <unmanaged-short>GetManager</unmanaged-short>	
        /// <unmanaged>HRESULT IMFDXGIDeviceManagerSource::GetManager([Out] IMFDXGIDeviceManager** ppManager)</unmanaged>
        public SharpDX.MediaFoundation.DXGIDeviceManager Manager
        {
            get { SharpDX.MediaFoundation.DXGIDeviceManager __output__; GetManager(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets the <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> from the Microsoft Media Foundation video rendering sink.</p>	
        /// </summary>	
        /// <param name="managerOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFDXGIDeviceManagerSource::GetManager']/*"/>	
        /// <msdn-id>dn280688</msdn-id>	
        /// <unmanaged>HRESULT IMFDXGIDeviceManagerSource::GetManager([Out] IMFDXGIDeviceManager** ppManager)</unmanaged>	
        /// <unmanaged-short>IMFDXGIDeviceManagerSource::GetManager</unmanaged-short>	
        internal void GetManager(out SharpDX.MediaFoundation.DXGIDeviceManager managerOut)
        {
            unsafe
            {
                IntPtr managerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &managerOut_, ((void**)(*(void**)_nativePointer))[3]);
                managerOut = (managerOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.DXGIDeviceManager(managerOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFExtendedDRMTypeSupport']/*"/>	
    /// <unmanaged>IMFExtendedDRMTypeSupport</unmanaged>	
    /// <unmanaged-short>IMFExtendedDRMTypeSupport</unmanaged-short>	
    [Guid("332EC562-3758-468D-A784-E38F23552128")]
    public partial class ExtendedDRMTypeSupport : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ExtendedDRMTypeSupport"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ExtendedDRMTypeSupport(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ExtendedDRMTypeSupport"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ExtendedDRMTypeSupport(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ExtendedDRMTypeSupport(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="type">No documentation.</param>	
        /// <param name="keySystem">No documentation.</param>	
        /// <param name="answerRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFExtendedDRMTypeSupport::IsTypeSupportedEx']/*"/>	
        /// <unmanaged>HRESULT IMFExtendedDRMTypeSupport::IsTypeSupportedEx([In, Optional] wchar_t* type,[In] wchar_t* keySystem,[Out] MF_MEDIA_ENGINE_CANPLAY* pAnswer)</unmanaged>	
        /// <unmanaged-short>IMFExtendedDRMTypeSupport::IsTypeSupportedEx</unmanaged-short>	
        public void IsTypeSupportedEx(string type, string keySystem, out SharpDX.MediaFoundation.MediaEngineCanPlay answerRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* type_ = type)
                fixed (char* keySystem_ = keySystem)
                fixed (void* answerRef_ = &answerRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)type_, (void*)keySystem_, answerRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables an application to use a Media Foundation transform (MFT) that has restrictions on its use.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If you register an MFT that requires unlocking, include the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Fieldofuse"/></strong> flag when you call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegister"/></strong> function.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFFieldOfUseMFTUnlock']/*"/>	
    /// <msdn-id>dd368792</msdn-id>	
    /// <unmanaged>IMFFieldOfUseMFTUnlock</unmanaged>	
    /// <unmanaged-short>IMFFieldOfUseMFTUnlock</unmanaged-short>	
    [Guid("508E71D3-EC66-4fc3-8775-B4B9ED6BA847")]
    public partial class FieldOfUseMFTUnlock : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.FieldOfUseMFTUnlock"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FieldOfUseMFTUnlock(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.FieldOfUseMFTUnlock"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.FieldOfUseMFTUnlock(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.FieldOfUseMFTUnlock(nativePointer);
        }


        /// <summary>	
        /// <p>Unlocks a Media Foundation transform (MFT) so that the application can use it.</p>	
        /// </summary>	
        /// <param name="unkMFTRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of the MFT.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method authenticates the caller, using a private communication channel between the MFT and the object that implements the <strong><see cref="SharpDX.MediaFoundation.FieldOfUseMFTUnlock"/></strong> interface. The details of the communication depend entirely on the implementation.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFFieldOfUseMFTUnlock::Unlock']/*"/>	
        /// <msdn-id>dd368793</msdn-id>	
        /// <unmanaged>HRESULT IMFFieldOfUseMFTUnlock::Unlock([In, Optional] IUnknown* pUnkMFT)</unmanaged>	
        /// <unmanaged-short>IMFFieldOfUseMFTUnlock::Unlock</unmanaged-short>	
        public void Unlock(SharpDX.ComObject unkMFTRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((unkMFTRef == null) ? IntPtr.Zero : unkMFTRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Retrieves the number of input pins on the EVR filter. The EVR filter always has at least one input pin, which corresponds to the reference stream.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEVRFilterConfig']/*"/>	
    /// <msdn-id>ms701550</msdn-id>	
    /// <unmanaged>IEVRFilterConfig</unmanaged>	
    /// <unmanaged-short>IEVRFilterConfig</unmanaged-short>	
    [Guid("83E91E85-82C1-4ea7-801D-85DC50B75086")]
    public partial class FilterConfig : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.FilterConfig"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FilterConfig(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.FilterConfig"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.FilterConfig(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.FilterConfig(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the number of input pins on the EVR filter. The EVR filter always has at least one input pin, which corresponds to the reference stream.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEVRFilterConfig::GetNumberOfStreams']/*"/>	
        /// <msdn-id>ms701550</msdn-id>	
        /// <unmanaged>GetNumberOfStreams / SetNumberOfStreams</unmanaged>	
        /// <unmanaged-short>GetNumberOfStreams</unmanaged-short>	
        /// <unmanaged>HRESULT IEVRFilterConfig::GetNumberOfStreams([Out] unsigned int* pdwMaxStreams)</unmanaged>
        public int NumberOfStreams
        {
            get { int __output__; GetNumberOfStreams(out __output__); return __output__; }
            set { SetNumberOfStreams(value); }
        }

        /// <summary>	
        /// <p> </p><p>Sets the number of input pins on the EVR filter.</p>	
        /// </summary>	
        /// <param name="dwMaxStreams"><dd> <p>Specifies the total number of input pins on the EVR filter. This value includes the input pin for the reference stream, which is created by default. For example, to mix one substream plus the reference stream, set this parameter to 2.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid number of streams. The minimum is one, and the maximum is 16.</p> </td></tr> <tr><td> <dl> <dt><strong>VFW_E_WRONG_STATE</strong></dt> </dl> </td><td> <p>This method has already been called, or at least one pin is already connected.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>After this method has been called, it cannot be called a second time on the same instance of the EVR filter. Also, the method fails if any input pins are connected.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEVRFilterConfig::SetNumberOfStreams']/*"/>	
        /// <msdn-id>ms698968</msdn-id>	
        /// <unmanaged>HRESULT IEVRFilterConfig::SetNumberOfStreams([In] unsigned int dwMaxStreams)</unmanaged>	
        /// <unmanaged-short>IEVRFilterConfig::SetNumberOfStreams</unmanaged-short>	
        internal void SetNumberOfStreams(int dwMaxStreams)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwMaxStreams, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of input pins on the EVR filter. The EVR filter always has at least one input pin, which corresponds to the reference stream.</p>	
        /// </summary>	
        /// <param name="dwMaxStreamsRef"><dd> <p>Receives the number of streams.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEVRFilterConfig::GetNumberOfStreams']/*"/>	
        /// <msdn-id>ms701550</msdn-id>	
        /// <unmanaged>HRESULT IEVRFilterConfig::GetNumberOfStreams([Out] unsigned int* pdwMaxStreams)</unmanaged>	
        /// <unmanaged-short>IEVRFilterConfig::GetNumberOfStreams</unmanaged-short>	
        internal void GetNumberOfStreams(out int dwMaxStreamsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwMaxStreamsRef_ = &dwMaxStreamsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwMaxStreamsRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Configures the DirectShow <strong>Enhanced Video Renderer</strong> (EVR) filter.  To get a reference to this interface, call <strong>QueryInterface</strong> on the  EVR filter.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEVRFilterConfigEx']/*"/>	
    /// <msdn-id>dd373924</msdn-id>	
    /// <unmanaged>IEVRFilterConfigEx</unmanaged>	
    /// <unmanaged-short>IEVRFilterConfigEx</unmanaged-short>	
    [Guid("aea36028-796d-454f-beee-b48071e24304")]
    public partial class FilterConfigEx : SharpDX.MediaFoundation.FilterConfig
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.FilterConfigEx"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FilterConfigEx(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.FilterConfigEx"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.FilterConfigEx(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.FilterConfigEx(nativePointer);
        }


        /// <summary>	
        /// <p>Gets or sets the configuration parameters for the Microsoft DirectShow <strong>Enhanced Video Renderer Filter</strong> filter.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEVRFilterConfigEx::GetConfigPrefs']/*"/>	
        /// <msdn-id>dd373925</msdn-id>	
        /// <unmanaged>GetConfigPrefs / SetConfigPrefs</unmanaged>	
        /// <unmanaged-short>GetConfigPrefs</unmanaged-short>	
        /// <unmanaged>HRESULT IEVRFilterConfigEx::GetConfigPrefs([Out] unsigned int* pdwConfigFlags)</unmanaged>
        public int ConfigPrefs
        {
            get { int __output__; GetConfigPrefs(out __output__); return __output__; }
            set { SetConfigPrefs(value); }
        }

        /// <summary>	
        /// <p>Sets the configuration parameters for the Microsoft DirectShow <strong>Enhanced Video Renderer Filter</strong> (EVR).</p>	
        /// </summary>	
        /// <param name="dwConfigFlags">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEVRFilterConfigEx::SetConfigPrefs']/*"/>	
        /// <msdn-id>dd373926</msdn-id>	
        /// <unmanaged>HRESULT IEVRFilterConfigEx::SetConfigPrefs([In] unsigned int dwConfigFlags)</unmanaged>	
        /// <unmanaged-short>IEVRFilterConfigEx::SetConfigPrefs</unmanaged-short>	
        internal void SetConfigPrefs(int dwConfigFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwConfigFlags, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the configuration parameters for the Microsoft DirectShow <strong>Enhanced Video Renderer Filter</strong> filter.</p>	
        /// </summary>	
        /// <param name="dwConfigFlagsRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEVRFilterConfigEx::GetConfigPrefs']/*"/>	
        /// <msdn-id>dd373925</msdn-id>	
        /// <unmanaged>HRESULT IEVRFilterConfigEx::GetConfigPrefs([Out] unsigned int* pdwConfigFlags)</unmanaged>	
        /// <unmanaged-short>IEVRFilterConfigEx::GetConfigPrefs</unmanaged-short>	
        internal void GetConfigPrefs(out int dwConfigFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwConfigFlagsRef_ = &dwConfigFlagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwConfigFlagsRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Optionally supported by media sinks to perform required tasks before shutdown. This interface is typically exposed by archive sinks?that is, media sinks that write to a file. It is used to perform tasks such as flushing data to disk or updating a file header.</p><p>To get a reference to this interface, call <strong>QueryInterface</strong> on the media sink.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If a media sink exposes this interface, the Media Session will call <strong>BeginFinalize</strong> on the sink before the session closes.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFFinalizableMediaSink']/*"/>	
    /// <msdn-id>ms704715</msdn-id>	
    /// <unmanaged>IMFFinalizableMediaSink</unmanaged>	
    /// <unmanaged-short>IMFFinalizableMediaSink</unmanaged-short>	
    [Guid("EAECB74A-9A50-42ce-9541-6A7F57AA4AD7")]
    public partial class FinalizableMediaSink : SharpDX.MediaFoundation.MediaSink
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.FinalizableMediaSink"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FinalizableMediaSink(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.FinalizableMediaSink"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.FinalizableMediaSink(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.FinalizableMediaSink(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Notifies the media sink to asynchronously take any steps it needs to finish its tasks.</p>	
        /// </summary>	
        /// <param name="callbackRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of an asynchronous object. The caller must implement this interface.</p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Many archive media sinks have steps they need to do at the end of archiving to complete their file operations, such as updating the header (for some formats) or flushing all pending writes to disk. In some cases, this may include expensive operations such as indexing the content. <strong>BeginFinalize</strong> is an asynchronous way to initiate final tasks.</p><p>When the finalize operation is complete, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, the application should call <strong><see cref="SharpDX.MediaFoundation.FinalizableMediaSink.EndFinalize"/></strong> to complete the asynchronous request.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFFinalizableMediaSink::BeginFinalize']/*"/>	
        /// <msdn-id>ms705643</msdn-id>	
        /// <unmanaged>HRESULT IMFFinalizableMediaSink::BeginFinalize([In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>	
        /// <unmanaged-short>IMFFinalizableMediaSink::BeginFinalize</unmanaged-short>	
        internal void BeginFinalize_(System.IntPtr callbackRef, SharpDX.ComObject unkStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)callbackRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Completes an asynchronous finalize operation.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method after the <strong><see cref="SharpDX.MediaFoundation.FinalizableMediaSink.BeginFinalize_"/></strong> method completes asynchronously.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFFinalizableMediaSink::EndFinalize']/*"/>	
        /// <msdn-id>ms694891</msdn-id>	
        /// <unmanaged>HRESULT IMFFinalizableMediaSink::EndFinalize([In] IMFAsyncResult* pResult)</unmanaged>	
        /// <unmanaged-short>IMFFinalizableMediaSink::EndFinalize</unmanaged-short>	
        public void EndFinalize(SharpDX.MediaFoundation.AsyncResult resultRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHDCPStatus']/*"/>	
    /// <unmanaged>IMFHDCPStatus</unmanaged>	
    /// <unmanaged-short>IMFHDCPStatus</unmanaged-short>	
    [Guid("DE400F54-5BF1-40CF-8964-0BEA136B1E3D")]
    public partial class HDCPStatus : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.HDCPStatus"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public HDCPStatus(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.HDCPStatus"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.HDCPStatus(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.HDCPStatus(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="statusRef">No documentation.</param>	
        /// <param name="fStatusRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHDCPStatus::Query']/*"/>	
        /// <unmanaged>HRESULT IMFHDCPStatus::Query([InOut] MF_HDCP_STATUS* pStatus,[InOut] BOOL* pfStatus)</unmanaged>	
        /// <unmanaged-short>IMFHDCPStatus::Query</unmanaged-short>	
        public void Query(ref SharpDX.MediaFoundation.HdcpStatus statusRef, ref SharpDX.Mathematics.Interop.RawBool fStatusRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* statusRef_ = &statusRef)
                fixed (void* fStatusRef_ = &fStatusRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, statusRef_, fStatusRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="status">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHDCPStatus::Set']/*"/>	
        /// <unmanaged>HRESULT IMFHDCPStatus::Set([In] MF_HDCP_STATUS status)</unmanaged>	
        /// <unmanaged-short>IMFHDCPStatus::Set</unmanaged-short>	
        public void Set(SharpDX.MediaFoundation.HdcpStatus status)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)status), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Implemented by the Microsoft Media Foundation sink writer object.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To create the sink writer, call one of the following functions:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSinkWriterFromMediaSink"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSinkWriterFromURL"/></strong> </li> </ul><p>Alternatively, use the <strong><see cref="SharpDX.MediaFoundation.ReadWriteClassFactory"/></strong> interface.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p><p>In Windows?8, this interface is extended with <strong><see cref="SharpDX.MediaFoundation.SinkWriterEx"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest']/*"/>	
    /// <msdn-id>dd374642</msdn-id>	
    /// <unmanaged>IMFHttpDownloadRequest</unmanaged>	
    /// <unmanaged-short>IMFHttpDownloadRequest</unmanaged-short>	
    [Guid("F779FDDF-26E7-4270-8A8B-B983D1859DE0")]
    public partial class HttpDownloadRequest : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.HttpDownloadRequest"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public HttpDownloadRequest(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.HttpDownloadRequest"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.HttpDownloadRequest(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.HttpDownloadRequest(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::GetHttpStatus']/*"/>	
        /// <unmanaged>GetHttpStatus</unmanaged>	
        /// <unmanaged-short>GetHttpStatus</unmanaged-short>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::GetHttpStatus([Out] unsigned int* pdwHttpStatus)</unmanaged>
        public int HttpStatus
        {
            get { int __output__; GetHttpStatus(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::GetAtEndOfPayload']/*"/>	
        /// <unmanaged>GetAtEndOfPayload</unmanaged>	
        /// <unmanaged-short>GetAtEndOfPayload</unmanaged-short>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::GetAtEndOfPayload([Out] BOOL* pfAtEndOfPayload)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool AtEndOfPayload
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; GetAtEndOfPayload(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::GetTotalLength']/*"/>	
        /// <unmanaged>GetTotalLength</unmanaged>	
        /// <unmanaged-short>GetTotalLength</unmanaged-short>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::GetTotalLength([Out] unsigned longlong* pqwTotalLength)</unmanaged>
        public long TotalLength
        {
            get { long __output__; GetTotalLength(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::GetRangeEndOffset']/*"/>	
        /// <unmanaged>GetRangeEndOffset</unmanaged>	
        /// <unmanaged-short>GetRangeEndOffset</unmanaged-short>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::GetRangeEndOffset([Out] unsigned longlong* pqwRangeEnd)</unmanaged>
        public long RangeEndOffset
        {
            get { long __output__; GetRangeEndOffset(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="szHeader">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::AddHeader']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::AddHeader([In] const wchar_t* szHeader)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadRequest::AddHeader</unmanaged-short>	
        public void AddHeader(string szHeader)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* szHeader_ = szHeader)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szHeader_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="bPayloadRef">No documentation.</param>	
        /// <param name="cbPayload">No documentation.</param>	
        /// <param name="callbackRef">No documentation.</param>	
        /// <param name="unkStateRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::BeginSendRequest']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::BeginSendRequest([In, Buffer, Optional] const unsigned char* pbPayload,[In] unsigned int cbPayload,[In] IMFAsyncCallback* pCallback,[In, Optional] IUnknown* punkState)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadRequest::BeginSendRequest</unmanaged-short>	
        internal void BeginSendRequest_(byte[] bPayloadRef, int cbPayload, System.IntPtr callbackRef, SharpDX.ComObject unkStateRef)
        {
            unsafe
            {
                byte[] bPayloadRef__ = bPayloadRef;
                SharpDX.Result __result__;
                fixed (void* bPayloadRef_ = bPayloadRef__)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bPayloadRef_, cbPayload, (void*)callbackRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="resultRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::EndSendRequest']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::EndSendRequest([In] IMFAsyncResult* pResult)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadRequest::EndSendRequest</unmanaged-short>	
        public void EndSendRequest(SharpDX.MediaFoundation.AsyncResult resultRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="callbackRef">No documentation.</param>	
        /// <param name="unkStateRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::BeginReceiveResponse']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::BeginReceiveResponse([In] IMFAsyncCallback* pCallback,[In, Optional] IUnknown* punkState)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadRequest::BeginReceiveResponse</unmanaged-short>	
        internal void BeginReceiveResponse_(System.IntPtr callbackRef, SharpDX.ComObject unkStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)callbackRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="resultRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::EndReceiveResponse']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::EndReceiveResponse([In] IMFAsyncResult* pResult)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadRequest::EndReceiveResponse</unmanaged-short>	
        public void EndReceiveResponse(SharpDX.MediaFoundation.AsyncResult resultRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="bRef">No documentation.</param>	
        /// <param name="cb">No documentation.</param>	
        /// <param name="callbackRef">No documentation.</param>	
        /// <param name="unkStateRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::BeginReadPayload']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::BeginReadPayload([Out, Buffer] unsigned char* pb,[In] unsigned int cb,[In] IMFAsyncCallback* pCallback,[In, Optional] IUnknown* punkState)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadRequest::BeginReadPayload</unmanaged-short>	
        internal void BeginReadPayload_(byte[] bRef, int cb, System.IntPtr callbackRef, SharpDX.ComObject unkStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* bRef_ = bRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bRef_, cb, (void*)callbackRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="resultRef">No documentation.</param>	
        /// <param name="qwOffsetRef">No documentation.</param>	
        /// <param name="cbReadRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::EndReadPayload']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::EndReadPayload([In] IMFAsyncResult* pResult,[Out] unsigned longlong* pqwOffset,[Out] unsigned int* pcbRead)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadRequest::EndReadPayload</unmanaged-short>	
        public void EndReadPayload(SharpDX.MediaFoundation.AsyncResult resultRef, out long qwOffsetRef, out int cbReadRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* qwOffsetRef_ = &qwOffsetRef)
                fixed (void* cbReadRef_ = &cbReadRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), qwOffsetRef_, cbReadRef_, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="szHeaderName">No documentation.</param>	
        /// <param name="dwIndex">No documentation.</param>	
        /// <param name="szHeaderValueOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::QueryHeader']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::QueryHeader([In] const wchar_t* szHeaderName,[In] unsigned int dwIndex,[Out] wchar_t** ppszHeaderValue)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadRequest::QueryHeader</unmanaged-short>	
        public void QueryHeader(string szHeaderName, int dwIndex, System.IntPtr szHeaderValueOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* szHeaderName_ = szHeaderName)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szHeaderName_, dwIndex, (void*)szHeaderValueOut, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="szURLOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::GetURL']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::GetURL([Out] wchar_t** ppszURL)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadRequest::GetURL</unmanaged-short>	
        public void GetURL(System.IntPtr szURLOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szURLOut, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="fNullSourceOriginRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::HasNullSourceOrigin']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::HasNullSourceOrigin([Out] BOOL* pfNullSourceOrigin)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadRequest::HasNullSourceOrigin</unmanaged-short>	
        public void HasNullSourceOrigin(out SharpDX.Mathematics.Interop.RawBool fNullSourceOriginRef)
        {
            unsafe
            {
                fNullSourceOriginRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fNullSourceOriginRef_ = &fNullSourceOriginRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fNullSourceOriginRef_, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="qwStartTimeRef">No documentation.</param>	
        /// <param name="qwStopTimeRef">No documentation.</param>	
        /// <param name="qwDurationRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::GetTimeSeekResult']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::GetTimeSeekResult([Out] unsigned longlong* pqwStartTime,[Out] unsigned longlong* pqwStopTime,[Out] unsigned longlong* pqwDuration)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadRequest::GetTimeSeekResult</unmanaged-short>	
        public void GetTimeSeekResult(out long qwStartTimeRef, out long qwStopTimeRef, out long qwDurationRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* qwStartTimeRef_ = &qwStartTimeRef)
                fixed (void* qwStopTimeRef_ = &qwStopTimeRef)
                fixed (void* qwDurationRef_ = &qwDurationRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, qwStartTimeRef_, qwStopTimeRef_, qwDurationRef_, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwHttpStatusRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::GetHttpStatus']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::GetHttpStatus([Out] unsigned int* pdwHttpStatus)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadRequest::GetHttpStatus</unmanaged-short>	
        internal void GetHttpStatus(out int dwHttpStatusRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwHttpStatusRef_ = &dwHttpStatusRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwHttpStatusRef_, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="fAtEndOfPayloadRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::GetAtEndOfPayload']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::GetAtEndOfPayload([Out] BOOL* pfAtEndOfPayload)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadRequest::GetAtEndOfPayload</unmanaged-short>	
        internal void GetAtEndOfPayload(out SharpDX.Mathematics.Interop.RawBool fAtEndOfPayloadRef)
        {
            unsafe
            {
                fAtEndOfPayloadRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fAtEndOfPayloadRef_ = &fAtEndOfPayloadRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fAtEndOfPayloadRef_, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="qwTotalLengthRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::GetTotalLength']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::GetTotalLength([Out] unsigned longlong* pqwTotalLength)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadRequest::GetTotalLength</unmanaged-short>	
        internal void GetTotalLength(out long qwTotalLengthRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* qwTotalLengthRef_ = &qwTotalLengthRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, qwTotalLengthRef_, ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="qwRangeEndRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::GetRangeEndOffset']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::GetRangeEndOffset([Out] unsigned longlong* pqwRangeEnd)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadRequest::GetRangeEndOffset</unmanaged-short>	
        internal void GetRangeEndOffset(out long qwRangeEndRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* qwRangeEndRef_ = &qwRangeEndRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, qwRangeEndRef_, ((void**)(*(void**)_nativePointer))[17]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadRequest::Close']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadRequest::Close()</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadRequest::Close</unmanaged-short>	
        public void Close()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[18]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables a media source in the application process to create objects in the protected media path (PMP) process.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is used when a media source resides in the application process but the Media Session resides in a PMP process. The media source can use this interface to create objects in the PMP process. For example, to play DRM-protected content, the media source typically must create an input trust authority (ITA) in the PMP process. </p><p>To use this interface, the media source implements the <strong><see cref="SharpDX.MediaFoundation.PMPClient"/></strong> interface. The PMP Media Session calls <strong><see cref="SharpDX.MediaFoundation.PMPClient.SetPMPHost"/></strong> on the media source, passing in a reference to the <strong><see cref="SharpDX.MediaFoundation.PMPHost"/></strong> interface.</p><p>You can also get a reference to this interface by calling <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> on the PMP Media Session, using the service identifier <strong>MF_PMP_SERVICE</strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadSession']/*"/>	
    /// <msdn-id>ms705635</msdn-id>	
    /// <unmanaged>IMFHttpDownloadSession</unmanaged>	
    /// <unmanaged-short>IMFHttpDownloadSession</unmanaged-short>	
    [Guid("71FA9A2C-53CE-4662-A132-1A7E8CBF62DB")]
    public partial class HttpDownloadSession : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.HttpDownloadSession"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public HttpDownloadSession(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.HttpDownloadSession"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.HttpDownloadSession(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.HttpDownloadSession(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="szServerName">No documentation.</param>	
        /// <param name="nPort">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadSession::SetServer']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadSession::SetServer([In] const wchar_t* szServerName,[In] unsigned int nPort)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadSession::SetServer</unmanaged-short>	
        public void SetServer(string szServerName, int nPort)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* szServerName_ = szServerName)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szServerName_, nPort, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="szObjectName">No documentation.</param>	
        /// <param name="fBypassProxyCache">No documentation.</param>	
        /// <param name="fSecure">No documentation.</param>	
        /// <param name="szVerb">No documentation.</param>	
        /// <param name="szReferrer">No documentation.</param>	
        /// <param name="requestOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadSession::CreateRequest']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadSession::CreateRequest([In] const wchar_t* szObjectName,[In] BOOL fBypassProxyCache,[In] BOOL fSecure,[In, Optional] const wchar_t* szVerb,[In, Optional] const wchar_t* szReferrer,[Out] IMFHttpDownloadRequest** ppRequest)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadSession::CreateRequest</unmanaged-short>	
        public void CreateRequest(string szObjectName, SharpDX.Mathematics.Interop.RawBool fBypassProxyCache, SharpDX.Mathematics.Interop.RawBool fSecure, string szVerb, string szReferrer, out SharpDX.MediaFoundation.HttpDownloadRequest requestOut)
        {
            unsafe
            {
                IntPtr requestOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* szObjectName_ = szObjectName)
                fixed (char* szVerb_ = szVerb)
                fixed (char* szReferrer_ = szReferrer)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint77(_nativePointer, (void*)szObjectName_, fBypassProxyCache, fSecure, (void*)szVerb_, (void*)szReferrer_, &requestOut_, ((void**)(*(void**)_nativePointer))[4]);
                requestOut = (requestOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.HttpDownloadRequest(requestOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadSession::Close']/*"/>	
        /// <unmanaged>HRESULT IMFHttpDownloadSession::Close()</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadSession::Close</unmanaged-short>	
        public void Close()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications implement this interface in order to provide custom a custom HTTP or HTTPS download implementation. Use the <strong><see cref="SharpDX.MediaFoundation.SourceResolver"/></strong> interface to register the provider. For more information, see Using the Source Resolver. Once registered, the Microsoft Media Foundation will invoke the <strong>CreateHttpDownloadSession</strong> method of the provider  implementation to open HTTP or HTTPS URLs instead of using the default implementation.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadSessionProvider']/*"/>	
    /// <msdn-id>mt781238</msdn-id>	
    /// <unmanaged>IMFHttpDownloadSessionProvider</unmanaged>	
    /// <unmanaged-short>IMFHttpDownloadSessionProvider</unmanaged-short>	
    [Guid("1B4CF4B9-3A16-4115-839D-03CC5C99DF01")]
    public partial class HttpDownloadSessionProvider : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.HttpDownloadSessionProvider"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public HttpDownloadSessionProvider(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.HttpDownloadSessionProvider"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.HttpDownloadSessionProvider(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.HttpDownloadSessionProvider(nativePointer);
        }


        /// <summary>	
        /// <p>Applications implement this interface in order to provide custom a custom HTTP or HTTPS download implementation. Use the <strong><see cref="SharpDX.MediaFoundation.SourceResolver"/></strong> interface to register the provider. For more information, see Using the Source Resolver. Once registered, the Microsoft Media Foundation will invoke the <strong>CreateHttpDownloadSession</strong> method of the provider  implementation to open HTTP or HTTPS URLs instead of using the default implementation.</p>	
        /// </summary>	
        /// <param name="wszScheme">No documentation.</param>	
        /// <param name="downloadSessionOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFHttpDownloadSessionProvider::CreateHttpDownloadSession']/*"/>	
        /// <msdn-id>mt781238</msdn-id>	
        /// <unmanaged>HRESULT IMFHttpDownloadSessionProvider::CreateHttpDownloadSession([In] const wchar_t* wszScheme,[Out] IMFHttpDownloadSession** ppDownloadSession)</unmanaged>	
        /// <unmanaged-short>IMFHttpDownloadSessionProvider::CreateHttpDownloadSession</unmanaged-short>	
        public void CreateHttpDownloadSession(string wszScheme, out SharpDX.MediaFoundation.HttpDownloadSession downloadSessionOut)
        {
            unsafe
            {
                IntPtr downloadSessionOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* wszScheme_ = wszScheme)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)wszScheme_, &downloadSessionOut_, ((void**)(*(void**)_nativePointer))[3]);
                downloadSessionOut = (downloadSessionOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.HttpDownloadSession(downloadSessionOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Callback interface to notify the application when an asynchronous method completes. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p> For more information about asynchronous methods in Microsoft Media Foundation, see Asynchronous Callback Methods. </p><p>This interface is also used to perform  a work item in a Media Foundation work-queue. For more information, see Work Queues. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAsyncCallback']/*"/>	
    /// <msdn-id>ms699856</msdn-id>	
    /// <unmanaged>IMFAsyncCallback</unmanaged>	
    /// <unmanaged-short>IMFAsyncCallback</unmanaged-short>	
    [Guid("a27003cf-2354-4f2a-8d6a-ab7cff15437e")]
    public partial interface IAsyncCallback : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p> </p><p>Provides configuration information to the dispatching thread for a callback.</p>	
        /// </summary>	
        /// <param name="dwFlagsRef"><dd> <p>Receives a flag indicating the behavior of the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method. The following values are defined. The default value is zero.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>Zero</strong></dt> </dl> </td><td> <p>The callback does not take a long time to complete, but has no specific restrictions on what system calls it makes. The callback generally takes less than 30 milliseconds to complete.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.AsyncCallbackFlags.FastIoProcessing"/></strong></strong></dt> </dl> </td><td> <p>The callback does very minimal processing. It takes less than 1 millisecond to complete.</p> <p>The callback must be invoked from one of the following work queues:</p> <ul> <li><strong><see cref="SharpDX.MediaFoundation.WorkQueueType.Io"/></strong></li> <li><strong><see cref="SharpDX.MediaFoundation.WorkQueueType.Timer"/></strong></li> </ul> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.AsyncCallbackFlags.Signal"/></strong></strong></dt> </dl> </td><td> <p>Implies <strong><see cref="SharpDX.MediaFoundation.AsyncCallbackFlags.FastIoProcessing"/></strong>, with the additional restriction that the callback does no processing (less than 50 microseconds), and the only system call it makes is <strong>SetEvent</strong>.</p> <p>The callback must be invoked from one of the following work queues:</p> <ul> <li><strong><see cref="SharpDX.MediaFoundation.WorkQueueType.Io"/></strong></li> <li><strong><see cref="SharpDX.MediaFoundation.WorkQueueType.Timer"/></strong></li> </ul> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.AsyncCallbackFlags.Blocking"/></strong></strong></dt> </dl> </td><td> <p>Blocking callback.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.AsyncCallbackFlags.Reply"/></strong></strong></dt> </dl> </td><td> <p>Reply callback.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="dwQueueRef"><dd> <p> Receives the identifier of the work queue on which the callback is dispatched.  </p> <p>This value can specify one of the standard Media Foundation work queues, or a work queue created by the application. For list of standard Media Foundation work queues, see <strong>Work Queue Identifiers</strong>. To create a new work queue, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue"/></strong>. The default value is <strong><see cref="SharpDX.MediaFoundation.WorkQueueType.Standard"/></strong>.</p> <p>If the work queue is not compatible with the value returned in <em>pdwFlags</em>, the Media Foundation platform returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidWorkqueue"/></strong> when it tries to dispatch the callback. (See <strong><see cref="SharpDX.MediaFoundation.MediaFactory.PutWorkItem"/></strong>.)</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_NOTIMPL</strong></strong></dt> </dl> </td><td> <p> Not implemented. Assume the default behavior. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> The <strong>GetParameters</strong> method returns information about the callback so that the dispatching thread can optimize the process that it uses to invoke the callback. </p><p> If the method returns a value other than zero in the <em>pdwFlags</em> parameter, your <strong>Invoke</strong> method must meet the requirements described here. Otherwise, the callback might delay the pipeline.</p><p> If you want default values for both parameters, return <strong>E_NOTIMPL</strong>. The default values are given in the parameter descriptions on this page.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAsyncCallback::GetParameters']/*"/>	
        /// <msdn-id>bb970381</msdn-id>	
        /// <unmanaged>HRESULT IMFAsyncCallback::GetParameters([Out] MFASYNC_CALLBACK_FLAGS* pdwFlags,[Out] unsigned int* pdwQueue)</unmanaged>	
        /// <unmanaged-short>IMFAsyncCallback::GetParameters</unmanaged-short>	
        /* public void GetParameters(out SharpDX.MediaFoundation.AsyncCallbackFlags dwFlagsRef, out int dwQueueRef) */

        /// <summary>	
        /// <p> </p><p>Called when an asynchronous operation is completed.</p>	
        /// </summary>	
        /// <param name="asyncResultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass this reference to the asynchronous <strong>End...</strong> method to complete the asynchronous call.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Within your implementation of <strong>Invoke</strong>, call the corresponding <strong>End...</strong> method.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAsyncCallback::Invoke']/*"/>	
        /// <msdn-id>bb970360</msdn-id>	
        /// <unmanaged>HRESULT IMFAsyncCallback::Invoke([In, Optional] IMFAsyncResult* pAsyncResult)</unmanaged>	
        /// <unmanaged-short>IMFAsyncCallback::Invoke</unmanaged-short>	
        /* public void Invoke(SharpDX.MediaFoundation.AsyncResult asyncResultRef) */
    }
    /// <summary>	
    /// <p>Provides logging information about the parent object the async callback is associated with.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><strong><see cref="SharpDX.MediaFoundation.IAsyncCallbackLogging"/></strong> is primarily used for async callbacks to return an ID of the parent object that they are associated with.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAsyncCallbackLogging']/*"/>	
    /// <msdn-id>jj128304</msdn-id>	
    /// <unmanaged>IMFAsyncCallbackLogging</unmanaged>	
    /// <unmanaged-short>IMFAsyncCallbackLogging</unmanaged-short>	
    [Guid("c7a4dca1-f5f0-47b6-b92b-bf0106d25791")]
    public partial interface IAsyncCallbackLogging : SharpDX.MediaFoundation.IAsyncCallback
    {


        /// <summary>	
        /// <p>Gets the reference to the parent object the async callback is associated with. </p>	
        /// </summary>	
        /// <returns><p>void reference to the object.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAsyncCallbackLogging::GetObjectPointer']/*"/>	
        /// <msdn-id>jj128305</msdn-id>	
        /// <unmanaged>void* IMFAsyncCallbackLogging::GetObjectPointer()</unmanaged>	
        /// <unmanaged-short>IMFAsyncCallbackLogging::GetObjectPointer</unmanaged-short>	
        /* internal System.IntPtr GetObjectPointer() */

        /// <summary>	
        /// <p>Gets the tag of the parent object the async callback is associated object.</p>	
        /// </summary>	
        /// <returns><p>The tag of the object.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAsyncCallbackLogging::GetObjectTag']/*"/>	
        /// <msdn-id>jj128306</msdn-id>	
        /// <unmanaged>unsigned int IMFAsyncCallbackLogging::GetObjectTag()</unmanaged>	
        /// <unmanaged-short>IMFAsyncCallbackLogging::GetObjectTag</unmanaged-short>	
        /* internal int GetObjectTag() */
    }
    /// <summary>	
    /// <p><em>Media sources</em> are objects that generate media data in the Media Foundation pipeline. This section describes the media source APIs in detail. Read this section if you are implementing a custom media source, or using a media source outside of the Media Foundation pipeline.</p><p>If your application uses the control layer, it needs to use only a limited subset of the media source APIs. For information, see the topic Using Media Sources with the Media Session.</p><p> </p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IAudioSourceProvider']/*"/>	
    /// <msdn-id>ms697527</msdn-id>	
    /// <unmanaged>IAudioSourceProvider</unmanaged>	
    /// <unmanaged-short>IAudioSourceProvider</unmanaged-short>	
    [Guid("EBBAF249-AFC2-4582-91C6-B60DF2E84954")]
    public partial class IAudioSourceProvider : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.IAudioSourceProvider"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public IAudioSourceProvider(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.IAudioSourceProvider"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.IAudioSourceProvider(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.IAudioSourceProvider(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwSampleCount">No documentation.</param>	
        /// <param name="dwChannelCountRef">No documentation.</param>	
        /// <param name="interleavedAudioDataRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IAudioSourceProvider::ProvideInput']/*"/>	
        /// <unmanaged>HRESULT IAudioSourceProvider::ProvideInput([In] unsigned int dwSampleCount,[InOut] unsigned int* pdwChannelCount,[Out, Buffer, Optional] float* pInterleavedAudioData)</unmanaged>	
        /// <unmanaged-short>IAudioSourceProvider::ProvideInput</unmanaged-short>	
        public void ProvideInput(int dwSampleCount, ref int dwChannelCountRef, float[] interleavedAudioDataRef)
        {
            unsafe
            {
                float[] interleavedAudioDataRef__ = interleavedAudioDataRef;
                SharpDX.Result __result__;
                fixed (void* dwChannelCountRef_ = &dwChannelCountRef)
                fixed (void* interleavedAudioDataRef_ = interleavedAudioDataRef__)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwSampleCount, dwChannelCountRef_, interleavedAudioDataRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a byte stream from some data source, which might be a local file, a network file, or some other source. The <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface supports the typical stream operations, such as reading, writing, and seeking. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p> The following functions return <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> references for local files: </p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.BeginCreateFile"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateFile"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateTempFile"/></strong> </li> </ul><p> A byte stream for a media souce can be opened with read access. A byte stream for an archive media sink should be opened with both read and write access. (Read access may be required, because the archive sink might need to read portions of the file as it writes.) </p><p>Some implementations of this interface also expose one or more of the following interfaces:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.ByteStreamBuffering"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.ByteStreamCacheControl"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.ServiceProvider"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator"/></strong> </li> </ul><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream']/*"/>	
    /// <msdn-id>ms698720</msdn-id>	
    /// <unmanaged>IMFByteStream</unmanaged>	
    /// <unmanaged-short>IMFByteStream</unmanaged-short>	
    [Guid("ad4c1b00-4bf7-422f-9175-756693d9130d")]
    public partial interface IByteStream : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p> Retrieves the characteristics of the byte stream. </p>	
        /// </summary>	
        /// <param name="dwCapabilitiesRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags. The following flags are defined.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_READABLE</strong></dt> <dt>0x00000001</dt> </dl> </td><td> <p> The byte stream can be read. </p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_WRITABLE</strong></dt> <dt>0x00000002</dt> </dl> </td><td> <p> The byte stream can be written to. </p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_SEEKABLE</strong></dt> <dt>0x00000004</dt> </dl> </td><td> <p> The byte stream can be seeked. </p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_REMOTE</strong></dt> <dt>0x00000008</dt> </dl> </td><td> <p> The byte stream is from a remote source, such as a network. </p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_DIRECTORY</strong></dt> <dt>0x00000080</dt> </dl> </td><td> <p> The byte stream represents a file directory. </p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_HAS_SLOW_SEEK</strong></dt> <dt>0x00000100</dt> </dl> </td><td> <p> Seeking within this stream might be slow. For example, the byte stream might download from a network.</p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_PARTIALLY_DOWNLOADED</strong></dt> <dt>0x00000200</dt> </dl> </td><td> <p>The byte stream is currently downloading data to a local cache. Read operations on the byte stream might take longer until the data is completely downloaded.</p> <p>This flag is cleared after all of the data has been downloaded.</p> <p>If the <strong>MFBYTESTREAM_HAS_SLOW_SEEK</strong> flag is also set, it means the byte stream must download the entire file sequentially. Otherwise, the byte stream can respond to seek requests by restarting the download from a new point in the stream.</p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_SHARE_WRITE</strong></dt> <dt>0x00000400</dt> </dl> </td><td> <p>Another thread or process can open this byte stream for writing. If this flag is present, the length of thebyte stream could change while it is being read. </p> <p>This flag can affect the behavior of byte-stream handlers. For more information, see <see cref="SharpDX.MediaFoundation.ByteStreamAttributeKeys.HandlerAcceptsShareWrite"/>.</p> <strong>Note</strong>??Requires Windows?7 or later. ? </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_DOES_NOT_USE_NETWORK</strong></dt> <dt>0x00000800</dt> </dl> </td><td> <p>The byte stream is not currentlyusing the network to receive the content.  Networking hardwaremay enter a power saving state when this bit is set.</p> <strong>Note</strong>??Requires Windows?8 or later. ? </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::GetCapabilities']/*"/>	
        /// <msdn-id>ms698962</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::GetCapabilities([Out] unsigned int* pdwCapabilities)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::GetCapabilities</unmanaged-short>	
        /* public void GetCapabilities(out int dwCapabilitiesRef) */

        /// <summary>	
        /// <p> Retrieves the length of the stream. </p>	
        /// </summary>	
        /// <param name="qwLengthRef"><dd> <p> Receives the length of the stream, in bytes. If the length is unknown, this value is -1. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::GetLength']/*"/>	
        /// <msdn-id>ms698941</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::GetLength([Out] unsigned longlong* pqwLength)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::GetLength</unmanaged-short>	
        /* public void GetLength(out long qwLengthRef) */

        /// <summary>	
        /// <p> </p><p>Sets the length of the stream.</p>	
        /// </summary>	
        /// <param name="qwLength"><dd> <p> Length of the stream in bytes. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::SetLength']/*"/>	
        /// <msdn-id>ms697225</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::SetLength([In] unsigned longlong qwLength)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::SetLength</unmanaged-short>	
        /* public void SetLength(long qwLength) */

        /// <summary>	
        /// <p> Retrieves the current read or write position in the stream. </p>	
        /// </summary>	
        /// <param name="qwPositionRef"><dd> <p> Receives the current position, in bytes. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The methods that update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, <strong>SetCurrentPosition</strong>, and <strong>Seek</strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::GetCurrentPosition']/*"/>	
        /// <msdn-id>ms704059</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::GetCurrentPosition([Out] unsigned longlong* pqwPosition)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::GetCurrentPosition</unmanaged-short>	
        /* public void GetCurrentPosition(out long qwPositionRef) */

        /// <summary>	
        /// <p> </p><p>Sets the current read or write position.</p>	
        /// </summary>	
        /// <param name="qwPosition"><dd> <p>New position in the stream, as a byte offset from the start of the stream.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> Invalid argument. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If the new position is larger than the length of the stream, the method returns E_INVALIDARG. </p><p><strong> Implementation notes:</strong> This method should update the current position in the stream by setting the current position to the value passed in to the <em>qwPosition</em> parameter. Other methods that can update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, and <strong>Seek</strong>.	
        /// </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::SetCurrentPosition']/*"/>	
        /// <msdn-id>ms695238</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::SetCurrentPosition([In] unsigned longlong qwPosition)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::SetCurrentPosition</unmanaged-short>	
        /* public void SetCurrentPosition(long qwPosition) */

        /// <summary>	
        /// <p> </p><p>Queries whether the current position has reached the end of the stream.</p>	
        /// </summary>	
        /// <param name="fEndOfStreamRef"><dd> <p> Receives the value <strong>TRUE</strong> if the end of the stream has been reached, or <strong><see cref="SharpDX.Result.False"/></strong> otherwise. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::IsEndOfStream']/*"/>	
        /// <msdn-id>ms697369</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::IsEndOfStream([Out] BOOL* pfEndOfStream)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::IsEndOfStream</unmanaged-short>	
        /* public void IsEndOfStream(out SharpDX.Mathematics.Interop.RawBool fEndOfStreamRef) */

        /// <summary>	
        /// <p> Reads data from the stream. </p>	
        /// </summary>	
        /// <param name="bRef"><dd> <p> Pointer to a buffer that receives the data. The caller must allocate the buffer. </p> </dd></param>	
        /// <param name="cb"><dd> <p> Size of the buffer in bytes. </p> </dd></param>	
        /// <param name="cbReadRef"><dd> <p> Receives the number of bytes that are copied into the buffer. This parameter cannot be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This method reads at most <em>cb</em> bytes from the current position in the stream and copies them into the buffer provided by the caller. The number of bytes that were read is returned in the <em>pcbRead</em> parameter. The method does not return an error code on reaching the end of the file, so the application should check the value in <em>pcbRead</em> after the method returns. </p><p> This method is synchronous. It blocks until the read operation completes. </p><p><strong> Implementation notes:</strong> This method should update the current position in the stream by adding the number of bytes that were read, which is specified by the value returned in the <em>pcbRead</em> parameter,  to the current position. Other methods that can update the current position are <strong>Read</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, <strong>Seek</strong>, and <strong>SetCurrentPosition</strong>. 	
        /// </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::Read']/*"/>	
        /// <msdn-id>ms698913</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::Read([In] void* pb,[In] unsigned int cb,[Out] unsigned int* pcbRead)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::Read</unmanaged-short>	
        /* public void Read(System.IntPtr bRef, int cb, out int cbReadRef) */

        /// <summary>	
        /// <p> Begins an asynchronous read operation from the stream. </p>	
        /// </summary>	
        /// <param name="bRef"><dd> <p> Pointer to a buffer that receives the data. The caller must allocate the buffer. </p> </dd></param>	
        /// <param name="cb"><dd> <p> Size of the buffer in bytes. </p> </dd></param>	
        /// <param name="callbackRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> When all of the data has been read into the buffer, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, the application should call <strong><see cref="SharpDX.MediaFoundation.IByteStream.EndRead"/></strong> to complete the asynchronous request. </p><p> Do not read from, write to, free, or reallocate the buffer while an asynchronous read is pending. </p><p><strong> Implementation notes:</strong> This method should update the current position in the stream by adding the number of bytes that will be read, which is specified by the value returned in the <em>pcbRead</em> parameter,  to the current position. Other methods that can update the current position are <strong>BeginRead</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, <strong>Seek</strong>, and <strong>SetCurrentPosition</strong>. 	
        /// </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::BeginRead']/*"/>	
        /// <msdn-id>ms704810</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::BeginRead([In] void* pb,[In] unsigned int cb,[In] IMFAsyncCallback* pCallback,[In] void* punkState)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::BeginRead</unmanaged-short>	
        /* internal void BeginRead_(System.IntPtr bRef, int cb, System.IntPtr callbackRef, System.IntPtr unkStateRef) */

        /// <summary>	
        /// <p> Completes an asynchronous read operation. </p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method. </p> </dd></param>	
        /// <param name="cbReadRef"><dd> <p> Receives the number of bytes that were read. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Call this method after the <strong><see cref="SharpDX.MediaFoundation.IByteStream.BeginRead_"/></strong> method completes asynchronously. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::EndRead']/*"/>	
        /// <msdn-id>ms704042</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::EndRead([In] IMFAsyncResult* pResult,[Out] unsigned int* pcbRead)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::EndRead</unmanaged-short>	
        /* public void EndRead(SharpDX.MediaFoundation.AsyncResult resultRef, out int cbReadRef) */

        /// <summary>	
        /// <p> </p><p>Writes data to the stream.</p>	
        /// </summary>	
        /// <param name="bRef"><dd> <p> Pointer to a buffer that contains the data to write. </p> </dd></param>	
        /// <param name="cb"><dd> <p> Size of the buffer in bytes. </p> </dd></param>	
        /// <param name="cbWrittenRef"><dd> <p> Receives the number of bytes that are written. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This method writes the contents of the <em>pb</em> buffer to the stream, starting at the current stream position. The number of bytes that were written is returned in the <em>pcbWritten</em> parameter. </p><p> This method is synchronous. It blocks until the write operation completes. </p><p><strong>Implementation notes:</strong> This method should update the current position in the stream by adding the number of bytes that were written to the stream, which is specified by the value returned in the <em>pcbWritten</em>, to the current position offset. </p><p> Other methods that can update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>BeginWrite</strong>, <strong>Seek</strong>, and <strong>SetCurrentPosition</strong>.	
        /// </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::Write']/*"/>	
        /// <msdn-id>ms703843</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::Write([In] const void* pb,[In] unsigned int cb,[Out] unsigned int* pcbWritten)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::Write</unmanaged-short>	
        /* public void Write(System.IntPtr bRef, int cb, out int cbWrittenRef) */

        /// <summary>	
        /// <p> Begins an asynchronous write operation to the stream. </p>	
        /// </summary>	
        /// <param name="bRef"><dd> <p> Pointer to a buffer containing the data to write. </p> </dd></param>	
        /// <param name="cb"><dd> <p> Size of the buffer in bytes. </p> </dd></param>	
        /// <param name="callbackRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> When all of the data has been written to the stream, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, the application should call <strong><see cref="SharpDX.MediaFoundation.IByteStream.EndWrite"/></strong> to complete the asynchronous request. </p><p> Do not reallocate, free, or write to the buffer while an asynchronous write is still pending. </p><p><strong>Implementation notes:</strong> This method should update the current position in the stream by adding the number of bytes that will be written to the stream, which is specified by the value returned in the <em>pcbWritten</em>, to the current position. Other methods that can update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>Write</strong>, <strong>Seek</strong>, and <strong>SetCurrentPosition</strong>.	
        /// </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::BeginWrite']/*"/>	
        /// <msdn-id>ms694005</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::BeginWrite([In] const void* pb,[In] unsigned int cb,[In] IMFAsyncCallback* pCallback,[In] void* punkState)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::BeginWrite</unmanaged-short>	
        /* internal void BeginWrite_(System.IntPtr bRef, int cb, System.IntPtr callbackRef, System.IntPtr unkStateRef) */

        /// <summary>	
        /// <p> </p><p>Completes an asynchronous write operation.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.</p> </dd></param>	
        /// <param name="cbWrittenRef"><dd> <p> Receives the number of bytes that were written. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Call this method when the <strong><see cref="SharpDX.MediaFoundation.IByteStream.BeginWrite_"/></strong> method completes asynchronously. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::EndWrite']/*"/>	
        /// <msdn-id>ms703863</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::EndWrite([In] IMFAsyncResult* pResult,[Out] unsigned int* pcbWritten)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::EndWrite</unmanaged-short>	
        /* public void EndWrite(SharpDX.MediaFoundation.AsyncResult resultRef, out int cbWrittenRef) */

        /// <summary>	
        /// <p> </p><p>Moves the current position in the stream by a specified offset.</p>	
        /// </summary>	
        /// <param name="seekOrigin"><dd> <p> Specifies the origin of the seek as a member of the <strong><see cref="SharpDX.MediaFoundation.ByteStreamSeekOrigin"/></strong> enumeration. The offset is calculated relative to this position. </p> </dd></param>	
        /// <param name="llSeekOffset"><dd> <p> Specifies the new position, as a byte offset from the seek origin. </p> </dd></param>	
        /// <param name="dwSeekFlags"><dd> <p> Specifies zero or more flags. The following flags are defined. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_SEEK_FLAG_CANCEL_PENDING_IO</strong></dt> </dl> </td><td> <p> All pending I/O requests are canceled after the seek request completes successfully. </p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="qwCurrentPositionRef"><dd> <p> Receives the new position after the seek. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul><p><strong> Implementation notes:</strong> This method should update the current position in the stream by adding the <em>qwSeekOffset</em> to the seek <em>SeekOrigin</em> position. This should be the same value passed back in the <em>pqwCurrentPosition</em> parameter. 	
        /// Other methods that can update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, and <strong>SetCurrentPosition</strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::Seek']/*"/>	
        /// <msdn-id>ms697053</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::Seek([In] MFBYTESTREAM_SEEK_ORIGIN SeekOrigin,[In] longlong llSeekOffset,[In] unsigned int dwSeekFlags,[Out] unsigned longlong* pqwCurrentPosition)</unmanaged>	
        /// <unmanaged-short>IMFByteStream::Seek</unmanaged-short>	
        /* public void Seek(SharpDX.MediaFoundation.ByteStreamSeekOrigin seekOrigin, long llSeekOffset, int dwSeekFlags, out long qwCurrentPositionRef) */

        /// <summary>	
        /// <p> Clears any internal buffers used by the stream. If you are writing to the stream, the buffered data is written to the underlying file or device. </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> If the byte stream is read-only, this method has no effect.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::Flush']/*"/>	
        /// <msdn-id>ms694833</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::Flush()</unmanaged>	
        /// <unmanaged-short>IMFByteStream::Flush</unmanaged-short>	
        /* public void Flush() */

        /// <summary>	
        /// <p> Closes the stream and releases any resources associated with the stream, such as sockets or file handles. This method also cancels any pending asynchronous I/O requests. </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFByteStream::Close']/*"/>	
        /// <msdn-id>ms703909</msdn-id>	
        /// <unmanaged>HRESULT IMFByteStream::Close()</unmanaged>	
        /// <unmanaged-short>IMFByteStream::Close</unmanaged-short>	
        /* public void Close() */
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDMOQualityControl']/*"/>	
    /// <unmanaged>IDMOQualityControl</unmanaged>	
    /// <unmanaged-short>IDMOQualityControl</unmanaged-short>	
    [Guid("65abea96-cf36-453f-af8a-705e98f16260")]
    public partial class IDMOQualityControl : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.IDMOQualityControl"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public IDMOQualityControl(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.IDMOQualityControl"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.IDMOQualityControl(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.IDMOQualityControl(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDMOQualityControl::SetNow']/*"/>	
        /// <unmanaged>SetNow</unmanaged>	
        /// <unmanaged-short>SetNow</unmanaged-short>	
        /// <unmanaged>HRESULT IDMOQualityControl::SetNow([In] longlong rtNow)</unmanaged>
        public long Now
        {
            set { SetNow(value); }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDMOQualityControl::GetStatus']/*"/>	
        /// <unmanaged>GetStatus / SetStatus</unmanaged>	
        /// <unmanaged-short>GetStatus</unmanaged-short>	
        /// <unmanaged>HRESULT IDMOQualityControl::GetStatus([Out] unsigned int* pdwFlags)</unmanaged>
        public int Status
        {
            get { int __output__; GetStatus(out __output__); return __output__; }
            set { SetStatus(value); }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="rtNow">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDMOQualityControl::SetNow']/*"/>	
        /// <unmanaged>HRESULT IDMOQualityControl::SetNow([In] longlong rtNow)</unmanaged>	
        /// <unmanaged-short>IDMOQualityControl::SetNow</unmanaged-short>	
        internal void SetNow(long rtNow)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, rtNow, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwFlags">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDMOQualityControl::SetStatus']/*"/>	
        /// <unmanaged>HRESULT IDMOQualityControl::SetStatus([In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IDMOQualityControl::SetStatus</unmanaged-short>	
        internal void SetStatus(int dwFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwFlags, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwFlagsRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDMOQualityControl::GetStatus']/*"/>	
        /// <unmanaged>HRESULT IDMOQualityControl::GetStatus([Out] unsigned int* pdwFlags)</unmanaged>	
        /// <unmanaged-short>IDMOQualityControl::GetStatus</unmanaged-short>	
        internal void GetStatus(out int dwFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwFlagsRef_ = &dwFlagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwFlagsRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDMOVideoOutputOptimizations']/*"/>	
    /// <unmanaged>IDMOVideoOutputOptimizations</unmanaged>	
    /// <unmanaged-short>IDMOVideoOutputOptimizations</unmanaged-short>	
    [Guid("be8f4f4e-5b16-4d29-b350-7f6b5d9298ac")]
    public partial class IDMOVideoOutputOptimizations : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.IDMOVideoOutputOptimizations"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public IDMOVideoOutputOptimizations(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.IDMOVideoOutputOptimizations"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.IDMOVideoOutputOptimizations(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.IDMOVideoOutputOptimizations(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="ulOutputStreamIndex">No documentation.</param>	
        /// <param name="dwRequestedCapabilitiesRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDMOVideoOutputOptimizations::QueryOperationModePreferences']/*"/>	
        /// <unmanaged>HRESULT IDMOVideoOutputOptimizations::QueryOperationModePreferences([In] unsigned int ulOutputStreamIndex,[Out] unsigned int* pdwRequestedCapabilities)</unmanaged>	
        /// <unmanaged-short>IDMOVideoOutputOptimizations::QueryOperationModePreferences</unmanaged-short>	
        public void QueryOperationModePreferences(int ulOutputStreamIndex, out int dwRequestedCapabilitiesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwRequestedCapabilitiesRef_ = &dwRequestedCapabilitiesRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ulOutputStreamIndex, dwRequestedCapabilitiesRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="ulOutputStreamIndex">No documentation.</param>	
        /// <param name="dwEnabledFeatures">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDMOVideoOutputOptimizations::SetOperationMode']/*"/>	
        /// <unmanaged>HRESULT IDMOVideoOutputOptimizations::SetOperationMode([In] unsigned int ulOutputStreamIndex,[In] unsigned int dwEnabledFeatures)</unmanaged>	
        /// <unmanaged-short>IDMOVideoOutputOptimizations::SetOperationMode</unmanaged-short>	
        public void SetOperationMode(int ulOutputStreamIndex, int dwEnabledFeatures)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ulOutputStreamIndex, dwEnabledFeatures, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>The <code>GetCurrentOperationMode</code> method retrieves the optimization features in effect.</p>	
        /// </summary>	
        /// <param name="ulOutputStreamIndex"><dd> <p>Zero-based index of an output stream on the DMO.</p> </dd></param>	
        /// <param name="dwEnabledFeaturesRef"><dd> <p>Pointer to a variable that receives the current features. The returned value is a bitwise combination of zero or more flags from the <strong>DMO_VIDEO_OUTPUT_STREAM_FLAGS</strong> enumeration.</p> </dd></param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDMOVideoOutputOptimizations::GetCurrentOperationMode']/*"/>	
        /// <msdn-id>dd406844</msdn-id>	
        /// <unmanaged>HRESULT IDMOVideoOutputOptimizations::GetCurrentOperationMode([In] unsigned int ulOutputStreamIndex,[Out] unsigned int* pdwEnabledFeatures)</unmanaged>	
        /// <unmanaged-short>IDMOVideoOutputOptimizations::GetCurrentOperationMode</unmanaged-short>	
        public void GetCurrentOperationMode(int ulOutputStreamIndex, out int dwEnabledFeaturesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwEnabledFeaturesRef_ = &dwEnabledFeaturesRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ulOutputStreamIndex, dwEnabledFeaturesRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>The <code>GetCurrentSampleRequirements</code> method retrieves the optimization features required to process the next sample, given the features already agreed to by the application.</p>	
        /// </summary>	
        /// <param name="ulOutputStreamIndex"><dd> <p>Zero-based index of an output stream on the DMO.</p> </dd></param>	
        /// <param name="dwRequestedFeaturesRef"><dd> <p>Pointer to a variable that receives the required features. The returned value is a bitwise combination of zero or more flags from the <strong>DMO_VIDEO_OUTPUT_STREAM_FLAGS</strong> enumeration.</p> </dd></param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>After an application calls the <strong><see cref="SharpDX.MediaFoundation.IDMOVideoOutputOptimizations.SetOperationMode"/></strong> method, it must provide all the features it has agreed to. However, the DMO might not require every feature on every sample. This method enables the DMO to waive an agreed-upon feature for one sample.</p><p>Before processing a sample, the application can call this method. If the DMO does not require a given feature in order to process the next sample, it omits the corresponding flag from the <em>pdwRequestedFeatures</em> parameter. For the next sample only, the application can ignore the feature. The results of this method are valid only for the next call to the <strong><see cref="SharpDX.MediaFoundation.IMediaObject.ProcessOutput"/></strong> method.</p><p>The DMO will return only the flags that were agreed to in the <strong>SetOperationMode</strong> method. In other words, you cannot dynamically enable new features with this method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDMOVideoOutputOptimizations::GetCurrentSampleRequirements']/*"/>	
        /// <msdn-id>dd406845</msdn-id>	
        /// <unmanaged>HRESULT IDMOVideoOutputOptimizations::GetCurrentSampleRequirements([In] unsigned int ulOutputStreamIndex,[Out] unsigned int* pdwRequestedFeatures)</unmanaged>	
        /// <unmanaged-short>IDMOVideoOutputOptimizations::GetCurrentSampleRequirements</unmanaged-short>	
        public void GetCurrentSampleRequirements(int ulOutputStreamIndex, out int dwRequestedFeaturesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwRequestedFeaturesRef_ = &dwRequestedFeaturesRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ulOutputStreamIndex, dwRequestedFeaturesRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEnumDMO']/*"/>	
    /// <unmanaged>IEnumDMO</unmanaged>	
    /// <unmanaged-short>IEnumDMO</unmanaged-short>	
    [Guid("2c3cd98a-2bfa-4a53-9c27-5249ba64ba0f")]
    public partial class IEnumDMO : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.IEnumDMO"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public IEnumDMO(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.IEnumDMO"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.IEnumDMO(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.IEnumDMO(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>The <code>Next</code> method retrieves a specified number of items in the enumeration sequence.</p>	
        /// </summary>	
        /// <param name="cItemsToFetch"><dd> <p>Number of items to retrieve.</p> </dd></param>	
        /// <param name="cLSIDRef"><dd> <p>Array of size <em>cItemsToFetch</em> that is filled with the CLSIDs of the enumerated DMOs.</p> </dd></param>	
        /// <param name="names"><dd> <p>Array of size <em>cItemsToFetch</em> that is filled with the friendly names of the enumerated DMOs.</p> </dd></param>	
        /// <param name="cItemsFetchedRef"><dd> <p>Pointer to a variable that receives the actual number of items retrieved. Can be <strong><c>null</c></strong> if <em>cItemsToFetch</em> equals 1.</p> </dd></param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p>Insufficient memory.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument.</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p>Retrieved fewer items than requested.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Retrieved the requested number of items.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the method succeeds, the arrays given by the <em>pCLSID</em> and <em>Names</em> parameters are filled with CLSIDs and wide-character strings. The value of *<em>pcItemsFetched</em> specifies the number of items returned in these arrays.</p><p>The method returns <see cref="SharpDX.Result.Ok"/> if it retrieves the requested number of items (in other words, if *<em>pcItemsFetched</em> equals <em>cItemsToFetch</em>). Otherwise, it returns S_FALSE or an error code.</p><p>The caller must free the memory allocated for each string returned in the <em>Names</em> parameter, using the <strong>CoTaskMemFree</strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEnumDMO::Next']/*"/>	
        /// <msdn-id>dd376587</msdn-id>	
        /// <unmanaged>HRESULT IEnumDMO::Next([In] unsigned int cItemsToFetch,[Out, Buffer] GUID* pCLSID,[Out, Buffer] wchar_t** Names,[Out] unsigned int* pcItemsFetched)</unmanaged>	
        /// <unmanaged-short>IEnumDMO::Next</unmanaged-short>	
        public void Next(int cItemsToFetch, System.Guid[] cLSIDRef, System.IntPtr names, out int cItemsFetchedRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cLSIDRef_ = cLSIDRef)
                fixed (void* cItemsFetchedRef_ = &cItemsFetchedRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cItemsToFetch, cLSIDRef_, (void*)names, cItemsFetchedRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="cItemsToSkip">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEnumDMO::Skip']/*"/>	
        /// <unmanaged>HRESULT IEnumDMO::Skip([In] unsigned int cItemsToSkip)</unmanaged>	
        /// <unmanaged-short>IEnumDMO::Skip</unmanaged-short>	
        public void Skip(int cItemsToSkip)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cItemsToSkip, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>The <code>Reset</code> method resets the enumeration sequence to the beginning.</p>	
        /// </summary>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/>.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEnumDMO::Reset']/*"/>	
        /// <msdn-id>dd376588</msdn-id>	
        /// <unmanaged>HRESULT IEnumDMO::Reset()</unmanaged>	
        /// <unmanaged-short>IEnumDMO::Reset</unmanaged-short>	
        public void Reset()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="enumOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEnumDMO::Clone']/*"/>	
        /// <unmanaged>HRESULT IEnumDMO::Clone([Out] IEnumDMO** ppEnum)</unmanaged>	
        /// <unmanaged-short>IEnumDMO::Clone</unmanaged-short>	
        public void Clone(out SharpDX.MediaFoundation.IEnumDMO enumOut)
        {
            unsafe
            {
                IntPtr enumOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &enumOut_, ((void**)(*(void**)_nativePointer))[6]);
                enumOut = (enumOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.IEnumDMO(enumOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>The <code><see cref="SharpDX.MediaFoundation.IMediaBuffer"/></code> interface provides methods for manipulating a data buffer. Buffers passed to the <strong><see cref="SharpDX.MediaFoundation.IMediaObject.ProcessInput"/></strong> and <strong>ProcessOutput</strong> methods must implement this interface.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaBuffer']/*"/>	
    /// <msdn-id>dd390166</msdn-id>	
    /// <unmanaged>IMediaBuffer</unmanaged>	
    /// <unmanaged-short>IMediaBuffer</unmanaged-short>	
    [Guid("59eff8b9-938c-4a26-82f2-95cb84cdc837")]
    public partial class IMediaBuffer : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.IMediaBuffer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public IMediaBuffer(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.IMediaBuffer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.IMediaBuffer(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.IMediaBuffer(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaBuffer::SetLength']/*"/>	
        /// <unmanaged>SetLength</unmanaged>	
        /// <unmanaged-short>SetLength</unmanaged-short>	
        /// <unmanaged>HRESULT IMediaBuffer::SetLength([In] unsigned int cbLength)</unmanaged>
        public int Length
        {
            set { SetLength(value); }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaBuffer::GetMaxLength']/*"/>	
        /// <unmanaged>GetMaxLength</unmanaged>	
        /// <unmanaged-short>GetMaxLength</unmanaged-short>	
        /// <unmanaged>HRESULT IMediaBuffer::GetMaxLength([Out] unsigned int* pcbMaxLength)</unmanaged>
        public int MaxLength
        {
            get { int __output__; GetMaxLength(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="cbLength">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaBuffer::SetLength']/*"/>	
        /// <unmanaged>HRESULT IMediaBuffer::SetLength([In] unsigned int cbLength)</unmanaged>	
        /// <unmanaged-short>IMediaBuffer::SetLength</unmanaged-short>	
        internal void SetLength(int cbLength)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cbLength, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="cbMaxLengthRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaBuffer::GetMaxLength']/*"/>	
        /// <unmanaged>HRESULT IMediaBuffer::GetMaxLength([Out] unsigned int* pcbMaxLength)</unmanaged>	
        /// <unmanaged-short>IMediaBuffer::GetMaxLength</unmanaged-short>	
        internal void GetMaxLength(out int cbMaxLengthRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cbMaxLengthRef_ = &cbMaxLengthRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cbMaxLengthRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="bufferOut">No documentation.</param>	
        /// <param name="cbLengthRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaBuffer::GetBufferAndLength']/*"/>	
        /// <unmanaged>HRESULT IMediaBuffer::GetBufferAndLength([Out, Buffer, Optional] unsigned char** ppBuffer,[Out, Optional] unsigned int* pcbLength)</unmanaged>	
        /// <unmanaged-short>IMediaBuffer::GetBufferAndLength</unmanaged-short>	
        public void GetBufferAndLength(byte[] bufferOut, out int cbLengthRef)
        {
            unsafe
            {
                byte[] bufferOut__ = bufferOut;
                SharpDX.Result __result__;
                fixed (void* bufferOut_ = bufferOut__)
                fixed (void* cbLengthRef_ = &cbLengthRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bufferOut_, cbLengthRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>The <code><see cref="SharpDX.MediaFoundation.IMediaObject"/></code> interface provides methods for manipulating a Microsoft DirectX Media Object (DMO).</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject']/*"/>	
    /// <msdn-id>dd406926</msdn-id>	
    /// <unmanaged>IMediaObject</unmanaged>	
    /// <unmanaged-short>IMediaObject</unmanaged-short>	
    [Guid("d8ad0f58-5494-4102-97c5-ec798e59bcf4")]
    public partial class IMediaObject : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.IMediaObject"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public IMediaObject(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.IMediaObject"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.IMediaObject(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.IMediaObject(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="cInputStreamsRef">No documentation.</param>	
        /// <param name="cOutputStreamsRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::GetStreamCount']/*"/>	
        /// <unmanaged>HRESULT IMediaObject::GetStreamCount([Out] unsigned int* pcInputStreams,[Out] unsigned int* pcOutputStreams)</unmanaged>	
        /// <unmanaged-short>IMediaObject::GetStreamCount</unmanaged-short>	
        public void GetStreamCount(out int cInputStreamsRef, out int cOutputStreamsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cInputStreamsRef_ = &cInputStreamsRef)
                fixed (void* cOutputStreamsRef_ = &cOutputStreamsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cInputStreamsRef_, cOutputStreamsRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwInputStreamIndex">No documentation.</param>	
        /// <param name="dwFlagsRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::GetInputStreamInfo']/*"/>	
        /// <unmanaged>HRESULT IMediaObject::GetInputStreamInfo([In] unsigned int dwInputStreamIndex,[Out] unsigned int* pdwFlags)</unmanaged>	
        /// <unmanaged-short>IMediaObject::GetInputStreamInfo</unmanaged-short>	
        public void GetInputStreamInfo(int dwInputStreamIndex, out int dwFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwFlagsRef_ = &dwFlagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamIndex, dwFlagsRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>The <code>GetOutputStreamInfo</code> method retrieves information about an output stream; for example, whether the stream is discardable, and whether it uses a fixed sample size. This information never changes.</p>	
        /// </summary>	
        /// <param name="dwOutputStreamIndex"><dd> <p>Zero-based index of an output stream on the DMO.</p> </dd></param>	
        /// <param name="dwFlagsRef"><dd> <p>Pointer to a variable that receives a bitwise combination of zero or more <strong>DMO_OUTPUT_STREAM_INFO_FLAGS</strong> flags.</p> </dd></param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::GetOutputStreamInfo']/*"/>	
        /// <msdn-id>dd406955</msdn-id>	
        /// <unmanaged>HRESULT IMediaObject::GetOutputStreamInfo([In] unsigned int dwOutputStreamIndex,[Out] unsigned int* pdwFlags)</unmanaged>	
        /// <unmanaged-short>IMediaObject::GetOutputStreamInfo</unmanaged-short>	
        public void GetOutputStreamInfo(int dwOutputStreamIndex, out int dwFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwFlagsRef_ = &dwFlagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputStreamIndex, dwFlagsRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>The <code>GetInputType</code> method retrieves a preferred media type for a specified input stream.</p>	
        /// </summary>	
        /// <param name="dwInputStreamIndex"><dd> <p>Zero-based index of an input stream on the DMO.</p> </dd></param>	
        /// <param name="dwTypeIndex"><dd> <p>Zero-based index on the set of acceptable media types.</p> </dd></param>	
        /// <param name="mtRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.MediaFoundation.DmoMediaType"/></strong> structure allocated by the caller, or <strong><c>null</c></strong>. If this parameter is non-<strong><c>null</c></strong>, the method fills the structure with the media type. You can use the value <strong><c>null</c></strong> to test whether the type index is in range, by checking the return code.</p> </dd></param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index.</p> </td></tr> <tr><td> <dl> <dt><strong>DMO_E_NO_MORE_ITEMS</strong></dt> </dl> </td><td> <p>Type index is out of range.</p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p>Insufficient memory.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method to enumerate an input stream's preferred media types. The DMO assigns each media type an index value in order of preference. The most preferred type has an index of zero. To enumerate all the types, make successive calls while incrementing the type index until the method returns DMO_E_NO_MORE_ITEMS. The DMO is not guaranteed to enumerate every media type that it supports.</p><p>The format block in the returned type might be <strong><c>null</c></strong>. If so, the format type is GUID_NULL. Check the format type before dereferencing the format block.</p><p>If the method succeeds, call <strong>MoFreeMediaType</strong> to free the format block. (This function is also safe to call when the format block is <strong><c>null</c></strong>.)</p><p>To set the media type, call the <strong><see cref="SharpDX.MediaFoundation.IMediaObject.SetInputType"/></strong> method. Setting the media type on one stream can change another stream's preferred types. In fact, a stream might not have a preferred type until the type is set on another stream. For example, a decoder might not have a preferred output type until the input type is set. However, the DMO is not required to update its preferred types dynamically in this fashion. Thus, the types returned by this method are not guaranteed to be valid; they might fail when used in the <strong>SetInputType</strong> method.</p><p>To test whether a particular media type is acceptable, call <strong>SetInputType</strong> with the <see cref="SharpDX.MediaFoundation.DmoSetTypeFlags.DmoSetTypefTestOnly"/> flag.</p><p>To test whether the <em>dwTypeIndex</em> parameter is in range, set <em>pmt</em> to <strong><c>null</c></strong>. The method returns <see cref="SharpDX.Result.Ok"/> if the index is in range, or DMO_E_NO_MORE_ITEMS if the index is out of range.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::GetInputType']/*"/>	
        /// <msdn-id>dd406952</msdn-id>	
        /// <unmanaged>HRESULT IMediaObject::GetInputType([In] unsigned int dwInputStreamIndex,[In] unsigned int dwTypeIndex,[Out, Optional] DMO_MEDIA_TYPE* pmt)</unmanaged>	
        /// <unmanaged-short>IMediaObject::GetInputType</unmanaged-short>	
        public void GetInputType(int dwInputStreamIndex, int dwTypeIndex, out SharpDX.MediaFoundation.DmoMediaType mtRef)
        {
            unsafe
            {
                mtRef = new SharpDX.MediaFoundation.DmoMediaType();
                SharpDX.Result __result__;
                fixed (void* mtRef_ = &mtRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamIndex, dwTypeIndex, mtRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwOutputStreamIndex">No documentation.</param>	
        /// <param name="dwTypeIndex">No documentation.</param>	
        /// <param name="mtRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::GetOutputType']/*"/>	
        /// <unmanaged>HRESULT IMediaObject::GetOutputType([In] unsigned int dwOutputStreamIndex,[In] unsigned int dwTypeIndex,[Out, Optional] DMO_MEDIA_TYPE* pmt)</unmanaged>	
        /// <unmanaged-short>IMediaObject::GetOutputType</unmanaged-short>	
        public void GetOutputType(int dwOutputStreamIndex, int dwTypeIndex, out SharpDX.MediaFoundation.DmoMediaType mtRef)
        {
            unsafe
            {
                mtRef = new SharpDX.MediaFoundation.DmoMediaType();
                SharpDX.Result __result__;
                fixed (void* mtRef_ = &mtRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputStreamIndex, dwTypeIndex, mtRef_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>The <code>SetInputType</code> method sets the media type on an input stream, or tests whether a media type is acceptable.</p>	
        /// </summary>	
        /// <param name="dwInputStreamIndex"><dd> <p>Zero-based index of an input stream on the DMO.</p> </dd></param>	
        /// <param name="mtRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.MediaFoundation.DmoMediaType"/></strong> structure that specifies the media type.</p> </dd></param>	
        /// <param name="dwFlags"><dd> <p>Bitwise combination of zero or more flags from the <strong>DMO_SET_TYPE_FLAGS</strong> enumeration.</p> </dd></param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index</p> </td></tr> <tr><td> <dl> <dt><strong>DMO_E_TYPE_NOT_ACCEPTED</strong></dt> </dl> </td><td> <p>Media type was not accepted</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p>Media type is not acceptable</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Media type was set successfully, or is acceptable</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method to test, set, or clear the media type on an input stream:</p><ul> <li>To test the media type without setting it, use the <see cref="SharpDX.MediaFoundation.DmoSetTypeFlags.DmoSetTypefTestOnly"/> flag. If the media type is not acceptable, the method returns S_FALSE.</li> <li>To set the media type, set <em>dwFlags</em> to zero. If the media type is not acceptable, the method returns DMO_E_TYPE_NOT_ACCEPTED.</li> <li>To clear the current media type (if any), use the <see cref="SharpDX.MediaFoundation.DmoSetTypeFlags.DmoSetTypefClear"/> flag and set <em>pmt</em> to <strong><c>null</c></strong>. When the method returns, the stream no longer has a media type. The DMO cannot process samples until the application sets a new media type.</li> </ul><p>The media types that are currently set on other streams can affect whether the media type is acceptable.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::SetInputType']/*"/>	
        /// <msdn-id>dd406962</msdn-id>	
        /// <unmanaged>HRESULT IMediaObject::SetInputType([In] unsigned int dwInputStreamIndex,[In, Optional] const DMO_MEDIA_TYPE* pmt,[In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IMediaObject::SetInputType</unmanaged-short>	
        public void SetInputType(int dwInputStreamIndex, SharpDX.MediaFoundation.DmoMediaType? mtRef, int dwFlags)
        {
            unsafe
            {
                SharpDX.MediaFoundation.DmoMediaType mtRef_;
                if (mtRef.HasValue)
                    mtRef_ = mtRef.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamIndex, (mtRef.HasValue) ? &mtRef_ : (void*)IntPtr.Zero, dwFlags, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwOutputStreamIndex">No documentation.</param>	
        /// <param name="mtRef">No documentation.</param>	
        /// <param name="dwFlags">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::SetOutputType']/*"/>	
        /// <unmanaged>HRESULT IMediaObject::SetOutputType([In] unsigned int dwOutputStreamIndex,[In, Optional] const DMO_MEDIA_TYPE* pmt,[In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IMediaObject::SetOutputType</unmanaged-short>	
        public void SetOutputType(int dwOutputStreamIndex, SharpDX.MediaFoundation.DmoMediaType? mtRef, int dwFlags)
        {
            unsafe
            {
                SharpDX.MediaFoundation.DmoMediaType mtRef_;
                if (mtRef.HasValue)
                    mtRef_ = mtRef.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputStreamIndex, (mtRef.HasValue) ? &mtRef_ : (void*)IntPtr.Zero, dwFlags, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>The <code>GetInputCurrentType</code> method retrieves the media type that was set for an input stream, if any.</p>	
        /// </summary>	
        /// <param name="dwInputStreamIndex"><dd> <p>Zero-based index of an input stream on the DMO.</p> </dd></param>	
        /// <param name="mtRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.MediaFoundation.DmoMediaType"/></strong> structure allocated by the caller. The method fills the structure with the media type.</p> </dd></param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index.</p> </td></tr> <tr><td> <dl> <dt><strong>DMO_E_TYPE_NOT_SET</strong></dt> </dl> </td><td> <p>Media type was not set.</p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p>Insufficient memory.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The caller must set the media type for the stream before calling this method. To set the media type, call the <strong><see cref="SharpDX.MediaFoundation.IMediaObject.SetInputType"/></strong> method.</p><p>If the method succeeds, call <strong>MoFreeMediaType</strong> to free the format block.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::GetInputCurrentType']/*"/>	
        /// <msdn-id>dd406947</msdn-id>	
        /// <unmanaged>HRESULT IMediaObject::GetInputCurrentType([In] unsigned int dwInputStreamIndex,[Out] DMO_MEDIA_TYPE* pmt)</unmanaged>	
        /// <unmanaged-short>IMediaObject::GetInputCurrentType</unmanaged-short>	
        public void GetInputCurrentType(int dwInputStreamIndex, out SharpDX.MediaFoundation.DmoMediaType mtRef)
        {
            unsafe
            {
                mtRef = new SharpDX.MediaFoundation.DmoMediaType();
                SharpDX.Result __result__;
                fixed (void* mtRef_ = &mtRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamIndex, mtRef_, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwOutputStreamIndex">No documentation.</param>	
        /// <param name="mtRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::GetOutputCurrentType']/*"/>	
        /// <unmanaged>HRESULT IMediaObject::GetOutputCurrentType([In] unsigned int dwOutputStreamIndex,[Out] DMO_MEDIA_TYPE* pmt)</unmanaged>	
        /// <unmanaged-short>IMediaObject::GetOutputCurrentType</unmanaged-short>	
        public void GetOutputCurrentType(int dwOutputStreamIndex, out SharpDX.MediaFoundation.DmoMediaType mtRef)
        {
            unsafe
            {
                mtRef = new SharpDX.MediaFoundation.DmoMediaType();
                SharpDX.Result __result__;
                fixed (void* mtRef_ = &mtRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputStreamIndex, mtRef_, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>The <code>GetInputSizeInfo</code> method retrieves the buffer requirements for a specified input stream.</p>	
        /// </summary>	
        /// <param name="dwInputStreamIndex"><dd> <p>Zero-based index of an input stream on the DMO.</p> </dd></param>	
        /// <param name="cbSizeRef"><dd> <p>Pointer to a variable that receives the minimum size of an input buffer for this stream, in bytes.</p> </dd></param>	
        /// <param name="cbMaxLookaheadRef"><dd> <p>Pointer to a variable that receives the maximum amount of data that the DMO will hold for lookahead, in bytes. If the DMO does not perform lookahead on the stream, the value is zero.</p> </dd></param>	
        /// <param name="cbAlignmentRef"><dd> <p>Pointer to a variable that receives the required buffer alignment, in bytes. If the input stream has no alignment requirement, the value is 1.</p> </dd></param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index.</p> </td></tr> <tr><td> <dl> <dt><strong>DMO_E_TYPE_NOT_SET</strong></dt> </dl> </td><td> <p>Media type was not set.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The buffer requirements may depend on the media types of the various streams. Before calling this method, set the media type of each stream by calling the <strong><see cref="SharpDX.MediaFoundation.IMediaObject.SetInputType"/></strong> and <strong><see cref="SharpDX.MediaFoundation.IMediaObject.SetOutputType"/></strong> methods. If the media types have not been set, this method might return an error.</p><p>If the DMO performs lookahead on the input stream, it returns the <see cref="SharpDX.MediaFoundation.DmoInputStreamInformationFlags.DmoInputStreamFHoldsBuffers"/> flag in the <strong><see cref="SharpDX.MediaFoundation.IMediaObject.GetInputStreamInfo"/></strong> method. During processing, the DMO holds up to the number of bytes indicated by the <em>pcbMaxLookahead</em> parameter. The application must allocate enough buffers for the DMO to hold this much data.</p><p>A buffer is <em>aligned</em> if the buffer's start address is a multiple of <em>*pcbAlignment</em>. The alignment must be a power of two. Depending on the microprocessor, reads and writes to an aligned buffer might be faster than to an unaligned buffer. Also, some microprocessors do not support unaligned reads and writes.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::GetInputSizeInfo']/*"/>	
        /// <msdn-id>dd406949</msdn-id>	
        /// <unmanaged>HRESULT IMediaObject::GetInputSizeInfo([In] unsigned int dwInputStreamIndex,[Out] unsigned int* pcbSize,[Out] unsigned int* pcbMaxLookahead,[Out] unsigned int* pcbAlignment)</unmanaged>	
        /// <unmanaged-short>IMediaObject::GetInputSizeInfo</unmanaged-short>	
        public void GetInputSizeInfo(int dwInputStreamIndex, out int cbSizeRef, out int cbMaxLookaheadRef, out int cbAlignmentRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cbSizeRef_ = &cbSizeRef)
                fixed (void* cbMaxLookaheadRef_ = &cbMaxLookaheadRef)
                fixed (void* cbAlignmentRef_ = &cbAlignmentRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamIndex, cbSizeRef_, cbMaxLookaheadRef_, cbAlignmentRef_, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwOutputStreamIndex">No documentation.</param>	
        /// <param name="cbSizeRef">No documentation.</param>	
        /// <param name="cbAlignmentRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::GetOutputSizeInfo']/*"/>	
        /// <unmanaged>HRESULT IMediaObject::GetOutputSizeInfo([In] unsigned int dwOutputStreamIndex,[Out] unsigned int* pcbSize,[Out] unsigned int* pcbAlignment)</unmanaged>	
        /// <unmanaged-short>IMediaObject::GetOutputSizeInfo</unmanaged-short>	
        public void GetOutputSizeInfo(int dwOutputStreamIndex, out int cbSizeRef, out int cbAlignmentRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cbSizeRef_ = &cbSizeRef)
                fixed (void* cbAlignmentRef_ = &cbAlignmentRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputStreamIndex, cbSizeRef_, cbAlignmentRef_, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwInputStreamIndex">No documentation.</param>	
        /// <param name="rtMaxLatencyRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::GetInputMaxLatency']/*"/>	
        /// <unmanaged>HRESULT IMediaObject::GetInputMaxLatency([In] unsigned int dwInputStreamIndex,[Out] longlong* prtMaxLatency)</unmanaged>	
        /// <unmanaged-short>IMediaObject::GetInputMaxLatency</unmanaged-short>	
        public void GetInputMaxLatency(int dwInputStreamIndex, out long rtMaxLatencyRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* rtMaxLatencyRef_ = &rtMaxLatencyRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamIndex, rtMaxLatencyRef_, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwInputStreamIndex">No documentation.</param>	
        /// <param name="rtMaxLatency">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::SetInputMaxLatency']/*"/>	
        /// <unmanaged>HRESULT IMediaObject::SetInputMaxLatency([In] unsigned int dwInputStreamIndex,[In] longlong rtMaxLatency)</unmanaged>	
        /// <unmanaged-short>IMediaObject::SetInputMaxLatency</unmanaged-short>	
        public void SetInputMaxLatency(int dwInputStreamIndex, long rtMaxLatency)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamIndex, rtMaxLatency, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>The <code>Flush</code> method flushes all internally buffered data.</p>	
        /// </summary>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful. Otherwise, returns an <strong><see cref="SharpDX.Result"/></strong> value indicating the cause of the error.</p></returns>	
        /// <remarks>	
        /// <p>The DMO performs the following actions when this method is called:</p><ul> <li>Releases any <strong><see cref="SharpDX.MediaFoundation.IMediaBuffer"/></strong> references it holds.</li> <li>Discards any values that specify the time stamp or sample length for a media buffer.</li> <li>Reinitializes any internal states that depend on the contents of a media sample.</li> </ul><p>Media types, maximum latency, and locked state do not change.</p><p>When the method returns, every input stream accepts data. Output streams cannot produce any data until the application calls the <strong><see cref="SharpDX.MediaFoundation.IMediaObject.ProcessInput"/></strong> method on at least one input stream.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::Flush']/*"/>	
        /// <msdn-id>dd406945</msdn-id>	
        /// <unmanaged>HRESULT IMediaObject::Flush()</unmanaged>	
        /// <unmanaged-short>IMediaObject::Flush</unmanaged-short>	
        public void Flush()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>The <code>Discontinuity</code> method signals a discontinuity on the specified input stream.</p>	
        /// </summary>	
        /// <param name="dwInputStreamIndex"><dd> <p>Zero-based index of an input stream on the DMO.</p> </dd></param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index</p> </td></tr> <tr><td> <dl> <dt><strong>DMO_E_NOTACCEPTING</strong></dt> </dl> </td><td> <p>The DMO is not accepting input.</p> </td></tr> <tr><td> <dl> <dt><strong>DMO_E_TYPE_NOT_SET</strong></dt> </dl> </td><td> <p>The input and output types have not been set.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>A discontinuity represents a break in the input. A discontinuity might occur because no more data is expected, the format is changing, or there is a gap in the data. After a discontinuity, the DMO does not accept further input on that stream until all pending data has been processed. The application should call the <strong><see cref="SharpDX.MediaFoundation.IMediaObject.ProcessOutput"/></strong> method until none of the streams returns the <see cref="SharpDX.MediaFoundation.DmoOutputDataBufferFlags.DmoOutputDataBufferFIncomplete"/> flag.</p><p>This method might fail if it is called before the client sets the input and output types on the DMO.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::Discontinuity']/*"/>	
        /// <msdn-id>dd406944</msdn-id>	
        /// <unmanaged>HRESULT IMediaObject::Discontinuity([In] unsigned int dwInputStreamIndex)</unmanaged>	
        /// <unmanaged-short>IMediaObject::Discontinuity</unmanaged-short>	
        public void Discontinuity(int dwInputStreamIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamIndex, ((void**)(*(void**)_nativePointer))[17]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::AllocateStreamingResources']/*"/>	
        /// <unmanaged>HRESULT IMediaObject::AllocateStreamingResources()</unmanaged>	
        /// <unmanaged-short>IMediaObject::AllocateStreamingResources</unmanaged-short>	
        public void AllocateStreamingResources()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[18]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::FreeStreamingResources']/*"/>	
        /// <unmanaged>HRESULT IMediaObject::FreeStreamingResources()</unmanaged>	
        /// <unmanaged-short>IMediaObject::FreeStreamingResources</unmanaged-short>	
        public void FreeStreamingResources()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[19]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwInputStreamIndex">No documentation.</param>	
        /// <param name="dwFlags">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::GetInputStatus']/*"/>	
        /// <unmanaged>HRESULT IMediaObject::GetInputStatus([In] unsigned int dwInputStreamIndex,[Out] unsigned int* dwFlags)</unmanaged>	
        /// <unmanaged-short>IMediaObject::GetInputStatus</unmanaged-short>	
        public void GetInputStatus(int dwInputStreamIndex, out int dwFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwFlags_ = &dwFlags)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamIndex, dwFlags_, ((void**)(*(void**)_nativePointer))[20]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>The <code>ProcessInput</code> method delivers a buffer to the specified input stream.</p>	
        /// </summary>	
        /// <param name="dwInputStreamIndex"><dd> <p>Zero-based index of an input stream on the DMO.</p> </dd></param>	
        /// <param name="bufferRef"><dd> <p>Pointer to the buffer's <strong><see cref="SharpDX.MediaFoundation.IMediaBuffer"/></strong> interface.</p> </dd></param>	
        /// <param name="dwFlags"><dd> <p>Bitwise combination of zero or more flags from the <strong>DMO_INPUT_DATA_BUFFER_FLAGS</strong> enumeration.</p> </dd></param>	
        /// <param name="rtTimestamp"><dd> <p>Time stamp that specifies the start time of the data in the buffer. If the buffer has a valid time stamp, set the <see cref="SharpDX.MediaFoundation.DmoInputDataBufferFlags.DmoInputDataBufferFTime"/> flag in the <em>dwFlags</em> parameter. Otherwise, the DMO ignores this value.</p> </dd></param>	
        /// <param name="rtTimelength"><dd> <p>Reference time specifying the duration of the data in the buffer. If this value is valid, set the <see cref="SharpDX.MediaFoundation.DmoInputDataBufferFlags.DmoInputDataBufferFTimelength"/> flag in the <em>dwFlags</em> parameter. Otherwise, the DMO ignores this value.</p> </dd></param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index.</p> </td></tr> <tr><td> <dl> <dt><strong>DMO_E_NOTACCEPTING</strong></dt> </dl> </td><td> <p>Data cannot be accepted.</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p>No output to process.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The input buffer specified in the <em>pBuffer</em> parameter is read-only. The DMO will not modify the data in this buffer. All write operations occur on the output buffers, which are given in a separate call to the <strong><see cref="SharpDX.MediaFoundation.IMediaObject.ProcessOutput"/></strong> method.</p><p>If the DMO does not process all the data in the buffer, it keeps a reference count on the buffer. It releases the buffer once it has generated all the output, unless it needs to perform lookahead on the data. (To determine whether a DMO performs lookahead, call the <strong><see cref="SharpDX.MediaFoundation.IMediaObject.GetInputStreamInfo"/></strong> method.)</p><p>If this method returns DMO_E_NOTACCEPTING, call <strong>ProcessOutput</strong> until the input stream can accept more data. To determine whether the stream can accept more data, call the <strong><see cref="SharpDX.MediaFoundation.IMediaObject.GetInputStatus"/></strong> method.</p><p>If the method returns S_FALSE, no output was generated from this input and the application does not need to call <strong>ProcessOutput</strong>. However, a DMO is not required to return S_FALSE in this situation; it might return <see cref="SharpDX.Result.Ok"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::ProcessInput']/*"/>	
        /// <msdn-id>dd406959</msdn-id>	
        /// <unmanaged>HRESULT IMediaObject::ProcessInput([In] unsigned int dwInputStreamIndex,[In] IMediaBuffer* pBuffer,[In] unsigned int dwFlags,[In] longlong rtTimestamp,[In] longlong rtTimelength)</unmanaged>	
        /// <unmanaged-short>IMediaObject::ProcessInput</unmanaged-short>	
        public void ProcessInput(int dwInputStreamIndex, SharpDX.MediaFoundation.IMediaBuffer bufferRef, int dwFlags, long rtTimestamp, long rtTimelength)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamIndex, (void*)((bufferRef == null) ? IntPtr.Zero : bufferRef.NativePointer), dwFlags, rtTimestamp, rtTimelength, ((void**)(*(void**)_nativePointer))[21]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>The <code>ProcessOutput</code> method generates output from the current input data.</p>	
        /// </summary>	
        /// <param name="dwFlags"><dd> <p>Bitwise combination of zero or more flags from the <strong>DMO_PROCESS_OUTPUT_FLAGS</strong> enumeration.</p> </dd></param>	
        /// <param name="cOutputBufferCount"><dd> <p>Number of output buffers.</p> </dd></param>	
        /// <param name="outputBuffersRef"><dd> <p>Pointer to an array of <strong><see cref="SharpDX.MediaFoundation.DmoOutputDataBuffer"/></strong> structures containing the output buffers. Specify the size of the array in the <em>cOutputBufferCount</em> parameter.</p> </dd></param>	
        /// <param name="dwStatusRef"><dd> <p>Pointer to a variable that receives a reserved value (zero). The application should ignore this value.</p> </dd></param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p>Failure</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p>No output was generated</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The <em>pOutputBuffers</em> parameter points to an array of <strong><see cref="SharpDX.MediaFoundation.DmoOutputDataBuffer"/></strong> structures. The application must allocate one structure for each output stream. To determine the number of output streams, call the <strong><see cref="SharpDX.MediaFoundation.IMediaObject.GetStreamCount"/></strong> method. Set the <em>cOutputBufferCount</em> parameter to this number.</p><p>Each <strong><see cref="SharpDX.MediaFoundation.DmoOutputDataBuffer"/></strong> structure contains a reference to a buffer's <strong><see cref="SharpDX.MediaFoundation.IMediaBuffer"/></strong> interface. The application allocates these buffers. The other members of the structure are status fields. The DMO sets these fields if the method succeeds. If the method fails, their values are undefined.</p><p>When the application calls <code>ProcessOutput</code>, the DMO processes as much input data as possible. It writes the output data to the output buffers, starting from the end of the data in each buffer. (To find the end of the data, call the <strong><see cref="SharpDX.MediaFoundation.IMediaBuffer.GetBufferAndLength"/></strong> method.) The DMO never holds a reference count on an output buffer.</p><p>If the DMO fills an entire output buffer and still has input data to process, the DMO returns the <see cref="SharpDX.MediaFoundation.DmoOutputDataBufferFlags.DmoOutputDataBufferFIncomplete"/> flag in the <strong><see cref="SharpDX.MediaFoundation.DmoOutputDataBuffer"/></strong> structure. The application should check for this flag by testing the <strong>dwStatus</strong> member of each structure.</p><p>If the method returns S_FALSE, no output was generated. However, a DMO is not required to return S_FALSE in this situation; it might return <see cref="SharpDX.Result.Ok"/>.</p><p><strong>Discarding data:</strong></p><p>You can discard data from a stream by setting the <see cref="SharpDX.MediaFoundation.DmoProcessOutputFlags.DmoProcessOutputDiscardWhenNoBuffer"/> flag in the <em>dwFlags</em> parameter. For each stream that you want to discard, set the <strong>pBuffer</strong> member of the <strong><see cref="SharpDX.MediaFoundation.DmoOutputDataBuffer"/></strong> structure to <strong><c>null</c></strong>.</p><p>For each stream in which <strong>pBuffer</strong> is <strong><c>null</c></strong>:</p><ul> <li>If the <see cref="SharpDX.MediaFoundation.DmoProcessOutputFlags.DmoProcessOutputDiscardWhenNoBuffer"/> flag is set, and the stream is discardable or optional, the DMO discards the data.</li> <li>If the flag is set but the stream is neither discardable nor optional, the DMO discards the data if possible. It is not guaranteed to discard the data.</li> <li>If the flag is not set, the DMO does not produce output data for that stream, but does not discard the data.</li> </ul><p>To check whether a stream is discardable or optional, call the <strong><see cref="SharpDX.MediaFoundation.IMediaObject.GetOutputStreamInfo"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::ProcessOutput']/*"/>	
        /// <msdn-id>dd406960</msdn-id>	
        /// <unmanaged>HRESULT IMediaObject::ProcessOutput([In] unsigned int dwFlags,[In] unsigned int cOutputBufferCount,[Out, Buffer] DMO_OUTPUT_DATA_BUFFER* pOutputBuffers,[Out] unsigned int* pdwStatus)</unmanaged>	
        /// <unmanaged-short>IMediaObject::ProcessOutput</unmanaged-short>	
        public void ProcessOutput(int dwFlags, int cOutputBufferCount, SharpDX.MediaFoundation.DmoOutputDataBuffer[] outputBuffersRef, out int dwStatusRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* outputBuffersRef_ = outputBuffersRef)
                fixed (void* dwStatusRef_ = &dwStatusRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwFlags, cOutputBufferCount, outputBuffersRef_, dwStatusRef_, ((void**)(*(void**)_nativePointer))[22]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>The <code>Lock</code> method acquires or releases a lock on the DMO. Call this method to keep the DMO serialized when performing multiple operations.</p>	
        /// </summary>	
        /// <param name="bLock"><dd> <p>Value that specifies whether to acquire or release the lock. If the value is non-zero, a lock is acquired. If the value is zero, the lock is released.</p> </dd></param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p>Failure</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method prevents other threads from calling methods on the DMO. If another thread calls a method on the DMO, the thread blocks until the lock is released.</p><p>If you are using the Active Template Library (ATL) to implement a DMO, the name of the Lock method conflicts with the <strong>CComObjectRootEx::Lock</strong> method. To work around this problem, define the preprocessor symbol FIX_LOCK_NAME before including the header file Dmo.h:</p><pre> #define FIX_LOCK_NAME	
        /// #include &lt;dmo.h&gt;	
        /// </pre><p>This directive causes the preprocessor to rename the <strong><see cref="SharpDX.MediaFoundation.IMediaObject"/></strong> method to <em>DMOLock</em>. In your DMO, implement the method as <em>DMOLock</em>. In your implementation, call the ATL <strong>Lock</strong> or <strong>Unlock</strong> method, depending on the value of <em>bLock</em>. Applications can still invoke the method using the name <em>Lock</em> because the vtable order does not change.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObject::Lock']/*"/>	
        /// <msdn-id>dd406958</msdn-id>	
        /// <unmanaged>HRESULT IMediaObject::Lock([In] int bLock)</unmanaged>	
        /// <unmanaged-short>IMediaObject::Lock</unmanaged-short>	
        public void Lock(int bLock)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bLock, ((void**)(*(void**)_nativePointer))[23]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObjectInPlace']/*"/>	
    /// <unmanaged>IMediaObjectInPlace</unmanaged>	
    /// <unmanaged-short>IMediaObjectInPlace</unmanaged-short>	
    [Guid("651b9ad0-0fc7-4aa9-9538-d89931010741")]
    public partial class IMediaObjectInPlace : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.IMediaObjectInPlace"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public IMediaObjectInPlace(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.IMediaObjectInPlace"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.IMediaObjectInPlace(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.IMediaObjectInPlace(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>The <code>GetLatency</code> method retrieves the latency introduced by this DMO.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method returns the average time required to process each buffer. This value usually depends on factors in the run-time environment, such as the processor speed and the CPU load. One possible way to implement this method is for the DMO to keep a running average based on historical data.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObjectInPlace::GetLatency']/*"/>	
        /// <msdn-id>dd406941</msdn-id>	
        /// <unmanaged>GetLatency</unmanaged>	
        /// <unmanaged-short>GetLatency</unmanaged-short>	
        /// <unmanaged>HRESULT IMediaObjectInPlace::GetLatency([Out] longlong* pLatencyTime)</unmanaged>
        public long Latency
        {
            get { long __output__; GetLatency(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="ulSize">No documentation.</param>	
        /// <param name="dataRef">No documentation.</param>	
        /// <param name="refTimeStart">No documentation.</param>	
        /// <param name="dwFlags">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObjectInPlace::Process']/*"/>	
        /// <unmanaged>HRESULT IMediaObjectInPlace::Process([In] unsigned int ulSize,[Out, Buffer] unsigned char* pData,[In] longlong refTimeStart,[In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IMediaObjectInPlace::Process</unmanaged-short>	
        public void Process(int ulSize, byte[] dataRef, long refTimeStart, int dwFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ulSize, dataRef_, refTimeStart, dwFlags, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>The <code>Clone</code> method creates a copy of the DMO in its current state.</p>	
        /// </summary>	
        /// <param name="mediaObjectOut"><dd> <p>Address of a reference to receive the new DMO's <strong><see cref="SharpDX.MediaFoundation.IMediaObjectInPlace"/></strong> interface.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful. Otherwise, returns an <strong><see cref="SharpDX.Result"/></strong> value indicating the cause of the error.</p></returns>	
        /// <remarks>	
        /// <p>If the method succeeds, the <strong><see cref="SharpDX.MediaFoundation.IMediaObjectInPlace"/></strong> interface that it returns has an outstanding reference count. Be sure to release the interface when you are finished using it.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObjectInPlace::Clone']/*"/>	
        /// <msdn-id>dd406940</msdn-id>	
        /// <unmanaged>HRESULT IMediaObjectInPlace::Clone([Out] IMediaObjectInPlace** ppMediaObject)</unmanaged>	
        /// <unmanaged-short>IMediaObjectInPlace::Clone</unmanaged-short>	
        public void Clone(out SharpDX.MediaFoundation.IMediaObjectInPlace mediaObjectOut)
        {
            unsafe
            {
                IntPtr mediaObjectOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &mediaObjectOut_, ((void**)(*(void**)_nativePointer))[4]);
                mediaObjectOut = (mediaObjectOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.IMediaObjectInPlace(mediaObjectOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>The <code>GetLatency</code> method retrieves the latency introduced by this DMO.</p>	
        /// </summary>	
        /// <param name="latencyTimeRef"><dd> <p>Pointer to a variable that receives the latency, in 100-nanosecond units.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful. Otherwise, returns an <strong><see cref="SharpDX.Result"/></strong> value indicating the cause of the error.</p></returns>	
        /// <remarks>	
        /// <p>This method returns the average time required to process each buffer. This value usually depends on factors in the run-time environment, such as the processor speed and the CPU load. One possible way to implement this method is for the DMO to keep a running average based on historical data.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMediaObjectInPlace::GetLatency']/*"/>	
        /// <msdn-id>dd406941</msdn-id>	
        /// <unmanaged>HRESULT IMediaObjectInPlace::GetLatency([Out] longlong* pLatencyTime)</unmanaged>	
        /// <unmanaged-short>IMediaObjectInPlace::GetLatency</unmanaged-short>	
        internal void GetLatency(out long latencyTimeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* latencyTimeRef_ = &latencyTimeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, latencyTimeRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables other components in the protected media path (PMP) to use the input protection system provided by an input trust authorities (ITA). An ITA is a component that implements an input protection system for media content. ITAs expose the <strong><see cref="SharpDX.MediaFoundation.InputTrustAuthority"/></strong> interface.</p><p>An ITA translates policy from the content's native format into a common format that is used by other PMP components. It also provides a decrypter, if one is needed to decrypt the stream.</p><p>The topology contains one ITA instance for every protected stream in the media source. The ITA is obtained from the media source by calling <strong><see cref="SharpDX.MediaFoundation.TrustedInput.GetInputTrustAuthority"/></strong>.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFInputTrustAuthority']/*"/>	
    /// <msdn-id>ms697500</msdn-id>	
    /// <unmanaged>IMFInputTrustAuthority</unmanaged>	
    /// <unmanaged-short>IMFInputTrustAuthority</unmanaged-short>	
    [Guid("D19F8E98-B126-4446-890C-5DCB7AD71453")]
    public partial class InputTrustAuthority : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.InputTrustAuthority"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public InputTrustAuthority(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.InputTrustAuthority"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.InputTrustAuthority(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.InputTrustAuthority(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves a decrypter transform.</p>	
        /// </summary>	
        /// <param name="riid"><dd> <p>Interface identifier (IID) of the interface being requested. Currently this value must be IID_IMFTransform, which requests the <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> interface.</p> </dd></param>	
        /// <param name="vOut"><dd> <p>Receives a reference to the interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOINTERFACE</strong></dt> </dl> </td><td> <p>The decrypter does not support the requested interface.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotProtected"/></strong></dt> </dl> </td><td> <p>This input trust authority (ITA) does not provide a decrypter.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The decrypter should be created in a disabled state, where any calls to <strong><see cref="SharpDX.MediaFoundation.Transform.ProcessOutput"/></strong> automatically fail. After the input trust authority (ITA) has verified that it is running inside the protected media path (PMP), the ITA should enable the decrypter.</p><p>An ITA is not required to provide a decrypter. If the source content is not encrypted, the method should return <see cref="SharpDX.MediaFoundation.ResultCode.NotProtected"/>. The PMP will then proceed without using a decrypter for that stream.</p><p>The ITA must create a new instance of its decrypter for each call to <strong>GetDecrypter</strong>. Do not return multiple references to the same decrypter. They must be separate instances because the Media Session might place them in two different branches of the topology.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFInputTrustAuthority::GetDecrypter']/*"/>	
        /// <msdn-id>bb970385</msdn-id>	
        /// <unmanaged>HRESULT IMFInputTrustAuthority::GetDecrypter([In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>	
        /// <unmanaged-short>IMFInputTrustAuthority::GetDecrypter</unmanaged-short>	
        public void GetDecrypter(System.Guid riid, out System.IntPtr vOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vOut_ = &vOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &riid, vOut_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Requests permission to perform a specified action on the stream.</p>	
        /// </summary>	
        /// <param name="action"><dd> <p>The requested action, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.PolicymanagerAction"/></strong> enumeration.</p> </dd></param>	
        /// <param name="contentEnablerActivateOut"><dd> <p>Receives the value <strong><c>null</c></strong> or a reference to the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface. The <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface is used to create a content enabler object. The caller must release the interface. For more information, see Remarks.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The user has permission to perform this action.</p> </td></tr> <tr><td> <dl> <dt><strong>NS_E_DRM_NEEDS_INDIVIDUALIZATION</strong></dt> </dl> </td><td> <p>The user must individualize the application.</p> </td></tr> <tr><td> <dl> <dt><strong>NS_E_LICENSE_REQUIRED</strong></dt> </dl> </td><td> <p>The user must obtain a license.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method verifies whether the user has permission to perform a specified action on the stream. The ITA does any work needed to verify the user's right to perform the action, such as checking licenses.</p><p>To verify the user's rights, the ITA might need to perform additional steps that require interaction with the user or consent from the user. For example, it might need to acquire a new license or individualize a DRM component. In that case, the ITA creates an activation object for a content enabler and returns the activation object's <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface in the <em>ppContentEnablerActivate</em> parameter. The activation object is responsible for creating a content enabler that exposes the <strong><see cref="SharpDX.MediaFoundation.ContentEnabler"/></strong> interface. The content enabler is used as follows:</p><ol> <li> <p>The Media Session returns the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> reference to the application.</p> </li> <li> <p>The application calls <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> to activate the content enabler.</p> </li> <li> <p>The application calls <strong><see cref="SharpDX.MediaFoundation.ContentEnabler"/></strong> methods to perform whatever actions are needed, such as individualization or obtaining a license. The content enabler object must encapsulate this functionality through the <strong><see cref="SharpDX.MediaFoundation.ContentEnabler"/></strong> interface.</p> </li> <li> <p>The Media Session calls <strong>RequestAccess</strong> again.</p> </li> </ol><p>The return value signals whether the user has permission to perform the action:</p><ul> <li> <p>If the user already has permission to perform the action, the method returns <see cref="SharpDX.Result.Ok"/> and sets *<em>ppContentEnablerActivate</em> to <strong><c>null</c></strong>.</p> </li> <li> <p>If the user does not have permission, the method returns a failure code and sets *<em>ppContentEnablerActivate</em> to <strong><c>null</c></strong>.</p> </li> <li> <p>If the ITA must perform additional steps that require interaction with the user, the method returns a failure code and returns the content enabler's <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> reference in <em>ppContentEnablerActivate</em>.</p> </li> </ul><p>The Media Session will not allow the action unless this method returns <see cref="SharpDX.Result.Ok"/>. However, a return value of <see cref="SharpDX.Result.Ok"/> does not guarantee that the action will be performed, because some other failure might occur after this method is called. When the action is definitely about to happen, the Media Session calls <strong><see cref="SharpDX.MediaFoundation.InputTrustAuthority.BindAccess"/></strong>.</p><p>A stream can go to multiple outputs, so this method might be called multiple times with different actions, once for every output.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFInputTrustAuthority::RequestAccess']/*"/>	
        /// <msdn-id>bb970453</msdn-id>	
        /// <unmanaged>HRESULT IMFInputTrustAuthority::RequestAccess([In] MFPOLICYMANAGER_ACTION Action,[Out] IMFActivate** ppContentEnablerActivate)</unmanaged>	
        /// <unmanaged-short>IMFInputTrustAuthority::RequestAccess</unmanaged-short>	
        public void RequestAccess(SharpDX.MediaFoundation.PolicymanagerAction action, out SharpDX.MediaFoundation.Activate contentEnablerActivateOut)
        {
            unsafe
            {
                IntPtr contentEnablerActivateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)action), &contentEnablerActivateOut_, ((void**)(*(void**)_nativePointer))[4]);
                contentEnablerActivateOut = (contentEnablerActivateOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Activate(contentEnablerActivateOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the policy that defines which output protection systems are allowed for this stream, and the configuration data for each protection system.</p>	
        /// </summary>	
        /// <param name="action"><dd> <p>The action that will be performed on this stream, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.PolicymanagerAction"/></strong> enumeration.</p> </dd></param>	
        /// <param name="policyOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.OutputPolicy"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFInputTrustAuthority::GetPolicy']/*"/>	
        /// <msdn-id>bb970400</msdn-id>	
        /// <unmanaged>HRESULT IMFInputTrustAuthority::GetPolicy([In] MFPOLICYMANAGER_ACTION Action,[Out] IMFOutputPolicy** ppPolicy)</unmanaged>	
        /// <unmanaged-short>IMFInputTrustAuthority::GetPolicy</unmanaged-short>	
        public void GetPolicy(SharpDX.MediaFoundation.PolicymanagerAction action, out SharpDX.MediaFoundation.OutputPolicy policyOut)
        {
            unsafe
            {
                IntPtr policyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)action), &policyOut_, ((void**)(*(void**)_nativePointer))[5]);
                policyOut = (policyOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.OutputPolicy(policyOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Notifies the input trust authority (ITA) that a requested action is about to be performed.</p>	
        /// </summary>	
        /// <param name="paramRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.MediaFoundation.InputTrustauthorityAccessParameters"/></strong> structure that contains parameters for the <strong>BindAccess</strong> action.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Before calling this method, the Media Session calls <strong><see cref="SharpDX.MediaFoundation.InputTrustAuthority.RequestAccess"/></strong> to request an action. The <strong>BindAccess</strong> method notifies the ITA that the action is definitely about to occur, so that the ITA can update its internal state as needed. If the method returns a failure code, the Media Session cancels the action.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFInputTrustAuthority::BindAccess']/*"/>	
        /// <msdn-id>ms701551</msdn-id>	
        /// <unmanaged>HRESULT IMFInputTrustAuthority::BindAccess([In] MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS* pParam)</unmanaged>	
        /// <unmanaged-short>IMFInputTrustAuthority::BindAccess</unmanaged-short>	
        public void BindAccess(ref SharpDX.MediaFoundation.InputTrustauthorityAccessParameters paramRef)
        {
            unsafe
            {
                var paramRef_ = new SharpDX.MediaFoundation.InputTrustauthorityAccessParameters.__Native();
                paramRef.__MarshalTo(ref paramRef_);
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &paramRef_, ((void**)(*(void**)_nativePointer))[6]);
                paramRef.__MarshalFree(ref paramRef_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Notifies the input trust authority (ITA) when the number of output trust authorities (OTAs) that will perform a specified action has changed.</p>	
        /// </summary>	
        /// <param name="paramRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.MediaFoundation.InputTrustauthorityAccessParameters"/></strong> structure that contains parameters for the <strong>UpdateAccess</strong> action.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The ITA can update its internal state if needed. If the method returns a failure code, the Media Session cancels the action.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFInputTrustAuthority::UpdateAccess']/*"/>	
        /// <msdn-id>ms697037</msdn-id>	
        /// <unmanaged>HRESULT IMFInputTrustAuthority::UpdateAccess([In] MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS* pParam)</unmanaged>	
        /// <unmanaged-short>IMFInputTrustAuthority::UpdateAccess</unmanaged-short>	
        public void UpdateAccess(ref SharpDX.MediaFoundation.InputTrustauthorityAccessParameters paramRef)
        {
            unsafe
            {
                var paramRef_ = new SharpDX.MediaFoundation.InputTrustauthorityAccessParameters.__Native();
                paramRef.__MarshalTo(ref paramRef_);
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &paramRef_, ((void**)(*(void**)_nativePointer))[7]);
                paramRef.__MarshalFree(ref paramRef_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Resets the input trust authority (ITA) to its initial state.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When this method is called, the ITA should disable any decrypter that was returned in the <strong><see cref="SharpDX.MediaFoundation.InputTrustAuthority.GetDecrypter"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFInputTrustAuthority::Reset']/*"/>	
        /// <msdn-id>ms703015</msdn-id>	
        /// <unmanaged>HRESULT IMFInputTrustAuthority::Reset()</unmanaged>	
        /// <unmanaged-short>IMFInputTrustAuthority::Reset</unmanaged-short>	
        public void Reset()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Registers Media Foundation transforms (MFTs) in the caller's process.</p><p>The Media Session exposes this interface as a service. To obtain a reference to this interface, call the <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> method on the Media Session with the service identifier <strong>MF_LOCAL_MFT_REGISTRATION_SERVICE</strong>.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface requires the Media Session. If you are not using the Media Session for playback, call one of the following functions instead:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegisterLocal"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegisterLocalByCLSID"/></strong> </li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFLocalMFTRegistration']/*"/>	
    /// <msdn-id>dd374219</msdn-id>	
    /// <unmanaged>IMFLocalMFTRegistration</unmanaged>	
    /// <unmanaged-short>IMFLocalMFTRegistration</unmanaged-short>	
    [Guid("149c4d73-b4be-4f8d-8b87-079e926b6add")]
    public partial class LocalMFTRegistration : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.LocalMFTRegistration"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public LocalMFTRegistration(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.LocalMFTRegistration"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.LocalMFTRegistration(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.LocalMFTRegistration(nativePointer);
        }


        /// <summary>	
        /// <p>Registers one or more Media Foundation transforms (MFTs) in the caller's process.</p>	
        /// </summary>	
        /// <param name="mFTsRef"><dd> <p>A reference to an array of <strong><see cref="SharpDX.MediaFoundation.TRegistrationInformation"/></strong> structures.</p> </dd></param>	
        /// <param name="cMFTs"><dd> <p>The number of elements in the <em>pMFTs</em> array.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method is similar to the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegisterLocalByCLSID"/></strong> function. It registers one or more MFTs in the caller's process. These MFTs can be enumerated by calling the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnumEx"/></strong> function with the <strong><see cref="SharpDX.MediaFoundation.TransformEnumFlag.Localmft"/></strong> flag.</p><p>Unlike <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TRegisterLocalByCLSID"/></strong>, however, this method also makes the MFT available in the Protected Media Path (PMP) process, and is therefore useful if you are using the Media Session inside the PMP. For more information, see the following topics:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreatePMPMediaSession"/></strong> </li> <li> Protected Media Path </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFLocalMFTRegistration::RegisterMFTs']/*"/>	
        /// <msdn-id>dd374223</msdn-id>	
        /// <unmanaged>HRESULT IMFLocalMFTRegistration::RegisterMFTs([In, Buffer] MFT_REGISTRATION_INFO* pMFTs,[In] unsigned int cMFTs)</unmanaged>	
        /// <unmanaged-short>IMFLocalMFTRegistration::RegisterMFTs</unmanaged-short>	
        public void RegisterMFTs(SharpDX.MediaFoundation.TRegistrationInformation[] mFTsRef, int cMFTs)
        {
            unsafe
            {
                SharpDX.MediaFoundation.TRegistrationInformation.__Native[] mFTsRef__ = new SharpDX.MediaFoundation.TRegistrationInformation.__Native[mFTsRef.Length];
                for (int i = 0; i < mFTsRef.Length; i++)
                    mFTsRef[i].__MarshalTo(ref mFTsRef__[i]);
                SharpDX.Result __result__;
                fixed (void* mFTsRef_ = mFTsRef__)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, mFTsRef_, cMFTs, ((void**)(*(void**)_nativePointer))[3]);
                for (int i = 0; i < mFTsRef.Length; i++)
                    mFTsRef[i].__MarshalFree(ref mFTsRef__[i]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides a generic way to store key/value pairs on an object. The keys are <strong><see cref="System.Guid"/></strong>s, and the values can be any of the following data types: <strong>UINT32</strong>, <strong>UINT64</strong>, <strong>double</strong>, <strong><see cref="System.Guid"/></strong>, wide-character string, byte array, or <strong><see cref="SharpDX.ComObject"/></strong> reference. The standard implementation of this interface holds a thread lock while values are added, deleted, or retrieved.</p><p>For a list of predefined attribute <strong><see cref="System.Guid"/></strong>s, see Media Foundation Attributes. Each attribute <strong><see cref="System.Guid"/></strong> has an expected data type. The various "set" methods in <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> do not validate the type against the attribute <strong><see cref="System.Guid"/></strong>. It is the application's responsibility to set the correct type for the attribute.</p><p>To create an empty attribute store, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAttributes"/></strong>.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes']/*"/>	
    /// <msdn-id>ms704598</msdn-id>	
    /// <unmanaged>IMFAttributes</unmanaged>	
    /// <unmanaged-short>IMFAttributes</unmanaged-short>	
    [Guid("2cd2d921-c447-44a7-a13c-4adabfc247e3")]
    public partial class MediaAttributes : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaAttributes"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaAttributes(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaAttributes"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaAttributes(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaAttributes(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the number of attributes that are set on this object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>To enumerate all of the attributes, call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetItemByIndex"/></strong> for each index value.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::GetCount']/*"/>	
        /// <msdn-id>bb970413</msdn-id>	
        /// <unmanaged>GetCount</unmanaged>	
        /// <unmanaged-short>GetCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFAttributes::GetCount([Out] unsigned int* pcItems)</unmanaged>
        public int Count
        {
            get { int __output__; GetCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the value associated with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p> A <see cref="System.Guid"/> that identifies which value to retrieve. </p> </dd></param>	
        /// <param name="valueRef"><dd> <p>A reference to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that receives the value. The method fills the <strong><see cref="SharpDX.Win32.Variant"/></strong> with a copy of the stored value, if the value is found. Call <strong>PropVariantClear</strong> to free the memory allocated by this method. This parameter can be <strong><c>null</c></strong>. If this parameter is <strong><c>null</c></strong>, the method searches for the key and returns <see cref="SharpDX.Result.Ok"/> if the key is found, but does not copy the value.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Attributenotfound"/></strong></dt> </dl> </td><td> <p> The specified key was not found. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::GetItem']/*"/>	
        /// <msdn-id>bb970450</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::GetItem([In] const GUID&amp; guidKey,[In] void* pValue)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::GetItem</unmanaged-short>	
        internal void GetItem(System.Guid guidKey, System.IntPtr valueRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, (void*)valueRef, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the data type of the value associated with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies which value to query.</p> </dd></param>	
        /// <returns><dd> <p>Receives a member of the <strong><see cref="SharpDX.MediaFoundation.AttributeType"/></strong> enumeration.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::GetItemType']/*"/>	
        /// <msdn-id>bb970369</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::GetItemType([In] const GUID&amp; guidKey,[Out] MF_ATTRIBUTE_TYPE* pType)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::GetItemType</unmanaged-short>	
        public SharpDX.MediaFoundation.AttributeType GetItemType(System.Guid guidKey)
        {
            unsafe
            {
                SharpDX.MediaFoundation.AttributeType typeRef;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, &typeRef, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
                return typeRef;
            }
        }

        /// <summary>	
        /// <p> </p><p>Queries whether a stored attribute value equals to a specified <strong><see cref="SharpDX.Win32.Variant"/></strong>.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies which value to query.</p> </dd></param>	
        /// <param name="value"><dd> <p><strong><see cref="SharpDX.Win32.Variant"/></strong> that contains the value to compare.</p> </dd></param>	
        /// <returns><dd> <p>Receives a Boolean value indicating whether the attribute matches the value given in <em>Value</em>. See Remarks. This parameter must not be <strong><c>null</c></strong>. If this parameter is <strong><c>null</c></strong>, an access violation occurs.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The method sets <em>pbResult</em> to <strong><see cref="SharpDX.Result.False"/></strong> for any of the following reasons:</p><ul> <li> <p>No attribute is found whose key matches the one given in <em>guidKey</em>.</p> </li> <li> <p>The attribute's <strong><see cref="SharpDX.Win32.Variant"/></strong> type does not match the type given in <em>Value</em>.</p> </li> <li> <p>The attribute value does not match the value given in <em>Value</em>.</p> </li> <li> <p>The method fails.</p> </li> </ul><p>Otherwise, the method sets <em>pbResult</em> to <strong>TRUE</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::CompareItem']/*"/>	
        /// <msdn-id>bb970566</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::CompareItem([In] const GUID&amp; guidKey,[In] const PROPVARIANT&amp; Value,[Out] BOOL* pbResult)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::CompareItem</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool CompareItem(System.Guid guidKey, SharpDX.Win32.Variant value)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool bResultRef;
                bResultRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, &value, &bResultRef, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
                return bResultRef;
            }
        }

        /// <summary>	
        /// <p> </p><p>Compares the attributes on this object with the attributes on another object.</p>	
        /// </summary>	
        /// <param name="theirsRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the object to compare with this object.</p> </dd></param>	
        /// <param name="matchType"><dd> <p>Member of the <strong><see cref="SharpDX.MediaFoundation.AttributesMatchType"/></strong> enumeration, specifying the type of comparison to make.</p> </dd></param>	
        /// <returns><dd> <p>Receives a Boolean value. The value is <strong>TRUE</strong> if the two sets of attributes match in the way specified by the <em>MatchType</em> parameter. Otherwise, the value is <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></returns>	
        /// <remarks>	
        /// <p>If <em>pThis</em> is the object whose <strong>Compare</strong> method is called, and <em>pTheirs</em> is the object passed in as the <em>pTheirs</em> parameter, the following comparisons are defined by <em>MatchType</em>.</p><table> <tr><th>Match type</th><th>Returns <strong>TRUE</strong> if and only if</th></tr> <tr><td><strong><see cref="SharpDX.MediaFoundation.AttributesMatchType.OurItems"/></strong></td><td>For every attribute in <em>pThis</em>, an attribute with the same key and value exists in <em>pTheirs</em>.</td></tr> <tr><td><strong><see cref="SharpDX.MediaFoundation.AttributesMatchType.TheirItems"/></strong></td><td>For every attribute in <em>pTheirs</em>, an attribute with the same key and value exists in <em>pThis</em>.</td></tr> <tr><td><strong><see cref="SharpDX.MediaFoundation.AttributesMatchType.AllItems"/></strong></td><td>The key/value pairs are identical in both objects.</td></tr> <tr><td><strong><see cref="SharpDX.MediaFoundation.AttributesMatchType.Intersection"/></strong></td><td>Take the intersection of the keys in <em>pThis</em> and the keys in <em>pTheirs</em>. The values associated with those keys are identical in both <em>pThis</em> and <em>pTheirs</em>.</td></tr> <tr><td><strong><see cref="SharpDX.MediaFoundation.AttributesMatchType.Smaller"/></strong></td><td>Take the object with the smallest number of attributes. For every attribute in that object, an attribute with the same key and value exists in the other object.</td></tr> </table><p>?</p><p>The <em>pTheirs</em> and <em>pbResult</em> parameters must not be <strong><c>null</c></strong>. If either parameter is <strong><c>null</c></strong>, an access violation occurs.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::Compare']/*"/>	
        /// <msdn-id>bb970349</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::Compare([In, Optional] IMFAttributes* pTheirs,[In] MF_ATTRIBUTES_MATCH_TYPE MatchType,[Out] BOOL* pbResult)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::Compare</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool Compare(SharpDX.MediaFoundation.MediaAttributes theirsRef, SharpDX.MediaFoundation.AttributesMatchType matchType)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool bResultRef;
                bResultRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((theirsRef == null) ? IntPtr.Zero : theirsRef.NativePointer), unchecked((int)matchType), &bResultRef, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
                return bResultRef;
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a <strong>UINT32</strong> value associated with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong><see cref="SharpDX.MediaFoundation.AttributeType.UInt32"/></strong>.</p> </dd></param>	
        /// <returns><dd> <p>Receives a <strong>UINT32</strong> value. If the key is found and the data type is <strong>UINT32</strong>, the method copies the value into this parameter. Otherwise, the original value of this parameter is not changed.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::GetUINT32']/*"/>	
        /// <msdn-id>bb970551</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::GetUINT32([In] const GUID&amp; guidKey,[Out] unsigned int* punValue)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::GetUINT32</unmanaged-short>	
        internal int GetInt(System.Guid guidKey)
        {
            unsafe
            {
                int unValueRef;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, &unValueRef, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
                return unValueRef;
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a <strong>UINT64</strong> value associated with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong><see cref="SharpDX.MediaFoundation.AttributeType.UInt64"/></strong>.</p> </dd></param>	
        /// <returns><dd> <p>Receives a <strong>UINT64</strong> value. If the key is found and the data type is <strong>UINT64</strong>, the method copies the value into this parameter. Otherwise, the original value of this parameter is not changed.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::GetUINT64']/*"/>	
        /// <msdn-id>bb970569</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::GetUINT64([In] const GUID&amp; guidKey,[Out] unsigned longlong* punValue)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::GetUINT64</unmanaged-short>	
        internal long GetLong(System.Guid guidKey)
        {
            unsafe
            {
                long unValueRef;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, &unValueRef, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
                return unValueRef;
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a <strong>double</strong> value associated with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong><see cref="SharpDX.MediaFoundation.AttributeType.Double"/></strong>.</p> </dd></param>	
        /// <returns><dd> <p>Receives a <strong>double</strong> value. If the key is found and the data type is <strong>double</strong>, the method copies the value into this parameter. Otherwise, the original value of this parameter is not changed.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::GetDouble']/*"/>	
        /// <msdn-id>bb970418</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::GetDouble([In] const GUID&amp; guidKey,[Out] double* pfValue)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::GetDouble</unmanaged-short>	
        internal double GetDouble(System.Guid guidKey)
        {
            unsafe
            {
                double fValueRef;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, &fValueRef, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
                return fValueRef;
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a <see cref="System.Guid"/> value associated with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong><see cref="SharpDX.MediaFoundation.AttributeType.Guid"/></strong>.</p> </dd></param>	
        /// <returns><dd> <p>Receives a <see cref="System.Guid"/> value. If the key is found and the data type is <see cref="System.Guid"/>, the method copies the value into this parameter. Otherwise, the original value of this parameter is not changed.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::GetGUID']/*"/>	
        /// <msdn-id>bb970426</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::GetGUID([In] const GUID&amp; guidKey,[Out] GUID* pguidValue)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::GetGUID</unmanaged-short>	
        internal System.Guid GetGUID(System.Guid guidKey)
        {
            unsafe
            {
                System.Guid guidValueRef;
                guidValueRef = new System.Guid();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, &guidValueRef, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
                return guidValueRef;
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the length of a string value associated with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong><see cref="SharpDX.MediaFoundation.AttributeType.String"/></strong>.</p> </dd></param>	
        /// <returns><dd> <p>If the key is found and the value is a string type, this parameter receives the number of characters in the string, not including the terminating <strong><c>null</c></strong> character. To get the string value, call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetString"/></strong>.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::GetStringLength']/*"/>	
        /// <msdn-id>bb970425</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::GetStringLength([In] const GUID&amp; guidKey,[Out] unsigned int* pcchLength)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::GetStringLength</unmanaged-short>	
        internal int GetStringLength(System.Guid guidKey)
        {
            unsafe
            {
                int cchLengthRef;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, &cchLengthRef, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
                return cchLengthRef;
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a wide-character string associated with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong><see cref="SharpDX.MediaFoundation.AttributeType.String"/></strong>.</p> </dd></param>	
        /// <param name="wszValueRef"><dd> <p>Pointer to a wide-character array allocated by the caller. The array must be large enough to hold the string, including the terminating <strong><c>null</c></strong> character. If the key is found and the value is a string type, the method copies the string into this buffer. To find the length of the string, call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetStringLength"/></strong>.</p> </dd></param>	
        /// <param name="cchBufSize"><dd> <p>The size of the <em>pwszValue</em> array, in characters. This value includes the terminating <c>null</c> character.</p> </dd></param>	
        /// <param name="cchLengthRef"><dd> <p>Receives the number of characters in the string, excluding the terminating <strong><c>null</c></strong> character. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p>The length of the string is too large to fit in a <strong>UINT32</strong> value.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOT_SUFFICIENT_BUFFER</strong></dt> </dl> </td><td> <p>The buffer is not large enough to hold the string.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Attributenotfound"/></strong></dt> </dl> </td><td> <p>The specified key was not found.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidType"/></strong></dt> </dl> </td><td> <p>The attribute value is not a string.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You can also use the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetAllocatedString"/></strong> method, which allocates the buffer to hold the string.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::GetString']/*"/>	
        /// <msdn-id>bb970430</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::GetString([In] const GUID&amp; guidKey,[Out, Buffer] wchar_t* pwszValue,[In] unsigned int cchBufSize,[InOut, Optional] unsigned int* pcchLength)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::GetString</unmanaged-short>	
        internal void GetString(System.Guid guidKey, System.IntPtr wszValueRef, int cchBufSize, System.IntPtr cchLengthRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, (void*)wszValueRef, cchBufSize, (void*)cchLengthRef, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets a wide-character string associated with a key. This method allocates the memory for the string. </p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p>A <see cref="System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong><see cref="SharpDX.MediaFoundation.AttributeType.String"/></strong>. </p> </dd></param>	
        /// <param name="wszValueOut"><dd> <p>If the key is found and the value is a string type, this parameter receives a copy of the string. The caller must free the memory for the string by calling <strong>CoTaskMemFree</strong>. </p> </dd></param>	
        /// <param name="cchLengthRef"><dd> <p> Receives the number of characters in the string, excluding the terminating <strong><c>null</c></strong> character. This parameter must not be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Attributenotfound"/></strong></dt> </dl> </td><td> <p> The specified key was not found. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidType"/></strong></dt> </dl> </td><td> <p> The attribute value is not a string. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To copy a string value into a caller-allocated buffer, use the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetString"/></strong> method.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul><strong>Note</strong>??An earlier version of the documentation incorrectly stated that the <em>pcchLength</em> parameter can be <strong><c>null</c></strong>. Setting this parameter to <strong><c>null</c></strong> might succeed in some cases, but is not guaranteed. The caller must pass a non-<strong><c>null</c></strong> reference for this parameter.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::GetAllocatedString']/*"/>	
        /// <msdn-id>bb970406</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::GetAllocatedString([In] const GUID&amp; guidKey,[Buffer, Optional] wchar_t** ppwszValue,[Out] unsigned int* pcchLength)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::GetAllocatedString</unmanaged-short>	
        internal void GetAllocatedString(System.Guid guidKey, string wszValueOut, out int cchLengthRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* wszValueOut_ = wszValueOut)
                fixed (void* cchLengthRef_ = &cchLengthRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, (void*)wszValueOut_, cchLengthRef_, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the length of a byte array associated with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong><see cref="SharpDX.MediaFoundation.AttributeType.Blob"/></strong>.</p> </dd></param>	
        /// <returns><dd> <p>If the key is found and the value is a byte array, this parameter receives the size of the array, in bytes.</p> </dd></returns>	
        /// <remarks>	
        /// <p>To get the byte array, call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetBlob"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::GetBlobSize']/*"/>	
        /// <msdn-id>bb970459</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::GetBlobSize([In] const GUID&amp; guidKey,[Out] unsigned int* pcbBlobSize)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::GetBlobSize</unmanaged-short>	
        internal int GetBlobSize(System.Guid guidKey)
        {
            unsafe
            {
                int cbBlobSizeRef;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, &cbBlobSizeRef, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
                return cbBlobSizeRef;
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a byte array associated with a key. This method copies the array into a caller-allocated buffer.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong><see cref="SharpDX.MediaFoundation.AttributeType.Blob"/></strong>.</p> </dd></param>	
        /// <param name="bufRef"><dd> <p>Pointer to a buffer allocated by the caller. If the key is found and the value is a byte array, the method copies the array into this buffer. To find the required size of the buffer, call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetBlobSize"/></strong>.</p> </dd></param>	
        /// <param name="cbBufSize"><dd> <p>The size of the <em>pBuf</em> buffer, in bytes.</p> </dd></param>	
        /// <param name="cbBlobSizeRef"><dd> <p>Receives the size of the byte array. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_NOT_SUFFICIENT_BUFFER</strong></strong></dt> </dl> </td><td> <p>The buffer is not large enough to the array.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Attributenotfound"/></strong></strong></dt> </dl> </td><td> <p>The specified key was not found.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidType"/></strong></strong></dt> </dl> </td><td> <p>The attribute value is not a byte array.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You can also use the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetAllocatedBlob"/></strong> method, which allocates the buffer to hold the byte array.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::GetBlob']/*"/>	
        /// <msdn-id>bb970421</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::GetBlob([In] const GUID&amp; guidKey,[In] void* pBuf,[In] unsigned int cbBufSize,[InOut, Optional] unsigned int* pcbBlobSize)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::GetBlob</unmanaged-short>	
        internal void GetBlob(System.Guid guidKey, System.IntPtr bufRef, int cbBufSize, System.IntPtr cbBlobSizeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, (void*)bufRef, cbBufSize, (void*)cbBlobSizeRef, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Provides a generic way to store key/value pairs on an object. The keys are <strong><see cref="System.Guid"/></strong>s, and the values can be any of the following data types: <strong>UINT32</strong>, <strong>UINT64</strong>, <strong>double</strong>, <strong><see cref="System.Guid"/></strong>, wide-character string, byte array, or <strong><see cref="SharpDX.ComObject"/></strong> reference. The standard implementation of this interface holds a thread lock while values are added, deleted, or retrieved.</p><p>For a list of predefined attribute <strong><see cref="System.Guid"/></strong>s, see Media Foundation Attributes. Each attribute <strong><see cref="System.Guid"/></strong> has an expected data type. The various "set" methods in <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> do not validate the type against the attribute <strong><see cref="System.Guid"/></strong>. It is the application's responsibility to set the correct type for the attribute.</p><p>To create an empty attribute store, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAttributes"/></strong>.</p>	
        /// </summary>	
        /// <param name="guidKey">No documentation.</param>	
        /// <param name="bufOut">No documentation.</param>	
        /// <param name="cbSizeRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::GetAllocatedBlob']/*"/>	
        /// <msdn-id>ms704598</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::GetAllocatedBlob([In] const GUID&amp; guidKey,[Buffer, Optional] unsigned char** ppBuf,[Out] unsigned int* pcbSize)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::GetAllocatedBlob</unmanaged-short>	
        internal void GetAllocatedBlob(System.Guid guidKey, byte[] bufOut, out int cbSizeRef)
        {
            unsafe
            {
                byte[] bufOut__ = bufOut;
                SharpDX.Result __result__;
                fixed (void* bufOut_ = bufOut__)
                fixed (void* cbSizeRef_ = &cbSizeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, bufOut_, cbSizeRef_, ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves an interface reference associated with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong><see cref="SharpDX.MediaFoundation.AttributeType.IUnknown"/></strong>.</p> </dd></param>	
        /// <param name="riid"><dd> <p>Interface identifier (IID) of the interface to retrieve.</p> </dd></param>	
        /// <param name="vOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOINTERFACE</strong></dt> </dl> </td><td> <p>The attribute value is an <strong><see cref="SharpDX.ComObject"/></strong> reference but does not support requested interface.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Attributenotfound"/></strong></dt> </dl> </td><td> <p>The specified key was not found.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidType"/></strong></dt> </dl> </td><td> <p>The attribute value is not an <strong><see cref="SharpDX.ComObject"/></strong> reference.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::GetUnknown']/*"/>	
        /// <msdn-id>bb970481</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::GetUnknown([In] const GUID&amp; guidKey,[In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::GetUnknown</unmanaged-short>	
        internal void GetUnknown(System.Guid guidKey, System.Guid riid, out System.IntPtr vOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vOut_ = &vOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, &riid, vOut_, ((void**)(*(void**)_nativePointer))[17]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Adds an attribute value with a specified key. </p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p> A <see cref="System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value. </p> </dd></param>	
        /// <param name="value"><dd> <p> A <strong><see cref="SharpDX.Win32.Variant"/></strong> that contains the attribute value. The method copies the value. The <strong><see cref="SharpDX.Win32.Variant"/></strong> type must be one of the types listed in the <strong><see cref="SharpDX.MediaFoundation.AttributeType"/></strong> enumeration. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p> Insufficient memory. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidType"/></strong></dt> </dl> </td><td> <p> Invalid attribute type. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> This method checks whether the <strong><see cref="SharpDX.Win32.Variant"/></strong> type is one of the attribute types defined in <strong><see cref="SharpDX.MediaFoundation.AttributeType"/></strong>, and fails if an unsupported type is used. However, this method does not check whether the <strong><see cref="SharpDX.Win32.Variant"/></strong> is the correct type for the specified attribute <see cref="System.Guid"/>. (There is no programmatic way to associate attribute GUIDs with property types.) For a list of Media Foundation attributes and their data types, see Media Foundation Attributes. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::SetItem']/*"/>	
        /// <msdn-id>bb970346</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::SetItem([In] const GUID&amp; guidKey,[In] const PROPVARIANT&amp; Value)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::SetItem</unmanaged-short>	
        internal void Set(System.Guid guidKey, SharpDX.Win32.Variant value)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, &value, ((void**)(*(void**)_nativePointer))[18]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Removes a key/value pair from the object's attribute list.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies the value to delete.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the specified key does not exist, the method returns <strong><see cref="SharpDX.Result.Ok"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::DeleteItem']/*"/>	
        /// <msdn-id>bb970486</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::DeleteItem([In] const GUID&amp; guidKey)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::DeleteItem</unmanaged-short>	
        public void DeleteItem(System.Guid guidKey)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, ((void**)(*(void**)_nativePointer))[19]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Removes all key/value pairs from the object's attribute list.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::DeleteAllItems']/*"/>	
        /// <msdn-id>ms700200</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::DeleteAllItems()</unmanaged>	
        /// <unmanaged-short>IMFAttributes::DeleteAllItems</unmanaged-short>	
        public void DeleteAllItems()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[20]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Associates a <strong>UINT32</strong> value with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value.</p> </dd></param>	
        /// <param name="unValue"><dd> <p>New value for this key.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To retrieve the <strong>UINT32</strong> value, call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetInt"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::SetUINT32']/*"/>	
        /// <msdn-id>bb970467</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::SetUINT32([In] const GUID&amp; guidKey,[In] unsigned int unValue)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::SetUINT32</unmanaged-short>	
        internal void Set(System.Guid guidKey, int unValue)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, unValue, ((void**)(*(void**)_nativePointer))[21]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Associates a <strong>UINT64</strong> value with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value.</p> </dd></param>	
        /// <param name="unValue"><dd> <p>New value for this key.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To retrieve the <strong>UINT64</strong> value, call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetLong"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::SetUINT64']/*"/>	
        /// <msdn-id>bb970439</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::SetUINT64([In] const GUID&amp; guidKey,[In] unsigned longlong unValue)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::SetUINT64</unmanaged-short>	
        internal void Set(System.Guid guidKey, long unValue)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, unValue, ((void**)(*(void**)_nativePointer))[22]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Associates a <strong>double</strong> value with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value.</p> </dd></param>	
        /// <param name="fValue"><dd> <p>New value for this key.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To retrieve the double value, call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetDouble"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::SetDouble']/*"/>	
        /// <msdn-id>bb970505</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::SetDouble([In] const GUID&amp; guidKey,[In] double fValue)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::SetDouble</unmanaged-short>	
        internal void Set(System.Guid guidKey, double fValue)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, fValue, ((void**)(*(void**)_nativePointer))[23]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Associates a <see cref="System.Guid"/> value with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value.</p> </dd></param>	
        /// <param name="guidValue"><dd> <p>New value for this key.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p>Insufficient memory.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To retrieve the <see cref="System.Guid"/> value, call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetGUID"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::SetGUID']/*"/>	
        /// <msdn-id>bb970530</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::SetGUID([In] const GUID&amp; guidKey,[In] const GUID&amp; guidValue)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::SetGUID</unmanaged-short>	
        internal void Set(System.Guid guidKey, System.Guid guidValue)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, &guidValue, ((void**)(*(void**)_nativePointer))[24]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Associates a wide-character string with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value.</p> </dd></param>	
        /// <param name="wszValue"><dd> <p>Null-terminated wide-character string to associate with this key. The method stores a copy of the string.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To retrieve the string, call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetString"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetAllocatedString"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::SetString']/*"/>	
        /// <msdn-id>bb970404</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::SetString([In] const GUID&amp; guidKey,[In] const wchar_t* wszValue)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::SetString</unmanaged-short>	
        internal void Set(System.Guid guidKey, string wszValue)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* wszValue_ = wszValue)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, (void*)wszValue_, ((void**)(*(void**)_nativePointer))[25]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Associates a byte array with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value.</p> </dd></param>	
        /// <param name="bufRef"><dd> <p>Pointer to a byte array to associate with this key. The method stores a copy of the array.</p> </dd></param>	
        /// <param name="cbBufSize"><dd> <p>Size of the array, in bytes.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To retrieve the byte array, call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetBlob"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetAllocatedBlob"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::SetBlob']/*"/>	
        /// <msdn-id>bb970395</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::SetBlob([In] const GUID&amp; guidKey,[In] const void* pBuf,[In] unsigned int cbBufSize)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::SetBlob</unmanaged-short>	
        internal void SetBlob(System.Guid guidKey, System.IntPtr bufRef, int cbBufSize)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, (void*)bufRef, cbBufSize, ((void**)(*(void**)_nativePointer))[26]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Associates an <strong><see cref="SharpDX.ComObject"/></strong> reference with a key.</p>	
        /// </summary>	
        /// <param name="guidKey"><dd> <p><see cref="System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value.</p> </dd></param>	
        /// <param name="unknownRef"><dd> <p><strong><see cref="SharpDX.ComObject"/></strong> reference to be associated with this key.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To retrieve the <strong><see cref="SharpDX.ComObject"/></strong> reference, call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetUnknown"/></strong>.</p><p>It is not an error to call <strong>SetUnknown</strong> with <em>pUnknown</em> equal to <strong><c>null</c></strong>. However, <strong>GetUnknown</strong> will return <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidType"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::SetUnknown']/*"/>	
        /// <msdn-id>bb970533</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::SetUnknown([In] const GUID&amp; guidKey,[In, Optional] IUnknown* pUnknown)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::SetUnknown</unmanaged-short>	
        internal void Set(System.Guid guidKey, SharpDX.ComObject unknownRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidKey, (void*)((unknownRef == null) ? IntPtr.Zero : unknownRef.NativePointer), ((void**)(*(void**)_nativePointer))[27]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Locks the attribute store so that no other thread can access it. If the attribute store is already locked by another thread, this method blocks until the other thread unlocks the object. After calling this method, call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.UnlockStore"/></strong> to unlock the object.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method can cause a deadlock if a thread that calls <strong>LockStore</strong> waits on a thread that calls any other <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> methods on the same object.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::LockStore']/*"/>	
        /// <msdn-id>ms698926</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::LockStore()</unmanaged>	
        /// <unmanaged-short>IMFAttributes::LockStore</unmanaged-short>	
        public void LockStore()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[28]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Unlocks the attribute store after a call to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.LockStore"/></strong> method. While the object is unlocked, multiple threads can access the object's attributes.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::UnlockStore']/*"/>	
        /// <msdn-id>ms697545</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::UnlockStore()</unmanaged>	
        /// <unmanaged-short>IMFAttributes::UnlockStore</unmanaged-short>	
        public void UnlockStore()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[29]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of attributes that are set on this object.</p>	
        /// </summary>	
        /// <param name="cItemsRef"><dd> <p>Receives the number of attributes. This parameter must not be <strong><c>null</c></strong>. If this parameter is <strong><c>null</c></strong>, an access violation occurs.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To enumerate all of the attributes, call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetItemByIndex"/></strong> for each index value.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::GetCount']/*"/>	
        /// <msdn-id>bb970413</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::GetCount([Out] unsigned int* pcItems)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::GetCount</unmanaged-short>	
        internal void GetCount(out int cItemsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cItemsRef_ = &cItemsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cItemsRef_, ((void**)(*(void**)_nativePointer))[30]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves an attribute at the specified index.</p>	
        /// </summary>	
        /// <param name="unIndex"><dd> <p>Index of the attribute to retrieve. To get the number of attributes, call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetCount"/></strong>.</p> </dd></param>	
        /// <param name="guidKeyRef"><dd> <p>Receives the <see cref="System.Guid"/> that identifies this attribute.</p> </dd></param>	
        /// <param name="valueRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that receives the value. This parameter can be <strong><c>null</c></strong>. If it is not <strong><c>null</c></strong>, the method fills the <strong><see cref="SharpDX.Win32.Variant"/></strong> with a copy of the attribute value. Call <strong>PropVariantClear</strong> to free the memory allocated by this method.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid index.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To enumerate all of an object's attributes in a thread-safe way, do the following:</p><ol> <li> <p>Call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.LockStore"/></strong> to prevent another thread from adding or deleting attributes.</p> </li> <li> <p>Call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.GetCount"/></strong> to find the number of attributes.</p> </li> <li> <p>Call <strong>GetItemByIndex</strong> to get each attribute by index.</p> </li> <li> <p>Call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.UnlockStore"/></strong> to unlock the attribute store.</p> </li> </ol><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::GetItemByIndex']/*"/>	
        /// <msdn-id>bb970331</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::GetItemByIndex([In] unsigned int unIndex,[Out] GUID* pguidKey,[InOut, Optional] PROPVARIANT* pValue)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::GetItemByIndex</unmanaged-short>	
        internal void GetItemByIndex(int unIndex, out System.Guid guidKeyRef, System.IntPtr valueRef)
        {
            unsafe
            {
                guidKeyRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* guidKeyRef_ = &guidKeyRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unIndex, guidKeyRef_, (void*)valueRef, ((void**)(*(void**)_nativePointer))[31]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Copies all of the attributes from this object into another attribute store. </p>	
        /// </summary>	
        /// <param name="destRef"><dd> <p> A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the attribute store that receives the copy. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This method deletes all of the attributes originally stored in <em>pDest</em>. </p><strong>Note</strong>??<p>When you call <strong>CopyAllItems</strong> on an <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong>, which inherits this method, the sample time, duration, and flags are not copied to the destination sample. You must copy these values to the new sample manually.</p>?<p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFAttributes::CopyAllItems']/*"/>	
        /// <msdn-id>bb970330</msdn-id>	
        /// <unmanaged>HRESULT IMFAttributes::CopyAllItems([In, Optional] IMFAttributes* pDest)</unmanaged>	
        /// <unmanaged-short>IMFAttributes::CopyAllItems</unmanaged-short>	
        public void CopyAllItems(SharpDX.MediaFoundation.MediaAttributes destRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((destRef == null) ? IntPtr.Zero : destRef.NativePointer), ((void**)(*(void**)_nativePointer))[32]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a block of memory that contains media data. Use this interface to access the data in the buffer.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If the buffer contains 2-D image data (such as an uncompressed video frame), you should query the buffer for the <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong> interface. The methods on <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong> are optimized for 2-D data.</p><p>To get a buffer from a media sample, call one of the following <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> methods:</p><ul> <li> <p> <strong><see cref="SharpDX.MediaFoundation.Sample.ConvertToContiguousBuffer"/></strong> </p> </li> <li> <p> <strong><see cref="SharpDX.MediaFoundation.Sample.GetBufferByIndex"/></strong> </p> </li> </ul><p>To create a new buffer object, use one of the following functions.</p><table> <tr><th>Function</th><th>Description</th></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateMemoryBuffer"/></strong> </td><td>Creates a buffer and allocates system memory.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateMediaBufferWrapper"/></strong> </td><td>Creates a media buffer that wraps an existing media buffer.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateDXSurfaceBuffer"/></strong> </td><td>Creates a buffer that manages a DirectX surface.</td></tr> <tr><td> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAlignedMemoryBuffer"/></strong> </td><td>Creates a buffer and allocates system memory with a specified alignment.</td></tr> </table><p>?</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaBuffer']/*"/>	
    /// <msdn-id>ms696261</msdn-id>	
    /// <unmanaged>IMFMediaBuffer</unmanaged>	
    /// <unmanaged-short>IMFMediaBuffer</unmanaged-short>	
    [Guid("045FA593-8799-42b8-BC8D-8968C6453507")]
    public partial class MediaBuffer : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaBuffer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaBuffer(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaBuffer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaBuffer(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaBuffer(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the length of the valid data in the buffer.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaBuffer::GetCurrentLength']/*"/>	
        /// <msdn-id>ms698987</msdn-id>	
        /// <unmanaged>GetCurrentLength / SetCurrentLength</unmanaged>	
        /// <unmanaged-short>GetCurrentLength</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaBuffer::GetCurrentLength([Out] unsigned int* pcbCurrentLength)</unmanaged>
        public int CurrentLength
        {
            get { int __output__; GetCurrentLength(out __output__); return __output__; }
            set { SetCurrentLength(value); }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the allocated size of the buffer.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The buffer might or might not contain any valid data, and if there is valid data in the buffer, it might be smaller than the buffer's allocated size. To get the length of the valid data, call <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.GetCurrentLength"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaBuffer::GetMaxLength']/*"/>	
        /// <msdn-id>ms704840</msdn-id>	
        /// <unmanaged>GetMaxLength</unmanaged>	
        /// <unmanaged-short>GetMaxLength</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaBuffer::GetMaxLength([Out] unsigned int* pcbMaxLength)</unmanaged>
        public int MaxLength
        {
            get { int __output__; GetMaxLength(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Gives the caller access to the memory in the buffer, for reading or writing</p>	
        /// </summary>	
        /// <param name="cbMaxLengthRef"><dd> <p>Receives the maximum amount of data that can be written to the buffer. This parameter can be <strong><c>null</c></strong>. The same value is returned by the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.GetMaxLength"/></strong> method.</p> </dd></param>	
        /// <param name="cbCurrentLengthRef"><dd> <p>Receives the length of the valid data in the buffer, in bytes. This parameter can be <strong><c>null</c></strong>. The same value is returned by the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.GetCurrentLength"/></strong> method.</p> </dd></param>	
        /// <returns><dd> <p>Receives a reference to the start of the buffer.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This method gives the caller access to the entire buffer, up to the maximum size returned in the <em>pcbMaxLength</em> parameter. The value returned in <em>pcbCurrentLength</em> is the size of any valid data already in the buffer, which might be less than the total buffer size.</p><p>The reference returned in <em>ppbBuffer</em> is guaranteed to be valid, and can safely be accessed across the entire buffer for as long as the lock is held. When you are done accessing the buffer, call <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.Unlock"/></strong> to unlock the buffer. You must call <strong>Unlock</strong> once for each call to <strong>Lock</strong>. After you unlock the buffer, the reference returned in <em>ppbBuffer</em> is no longer valid, and should not be used. Generally, it is best to call <strong>Lock</strong> only when you need to access the buffer memory, and not earlier.</p><p>Locking the buffer does not prevent other threads from calling <strong>Lock</strong>, so you should not rely on this method to synchronize threads.</p><p>This method does not allocate any memory, or transfer ownership of the memory to the caller. Do not release or free the memory; the media buffer will free the memory when the media buffer is destroyed.</p><p>If you modify the contents of the buffer, update the current length by calling <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.SetCurrentLength"/></strong>.</p><p>If the buffer supports the <strong><see cref="SharpDX.MediaFoundation.Buffer2D"/></strong> interface, you should use the <strong><see cref="SharpDX.MediaFoundation.Buffer2D.Lock2D"/></strong> method to lock the buffer. For 2-D buffers, the <strong>Lock2D</strong> method is more efficient than the <strong>Lock</strong> method. If the buffer is locked using <strong>Lock2D</strong>, the Lock method might return <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaBuffer::Lock']/*"/>	
        /// <msdn-id>bb970366</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaBuffer::Lock([Out] void** ppbBuffer,[Out, Optional] unsigned int* pcbMaxLength,[Out, Optional] unsigned int* pcbCurrentLength)</unmanaged>	
        /// <unmanaged-short>IMFMediaBuffer::Lock</unmanaged-short>	
        public System.IntPtr Lock(out int cbMaxLengthRef, out int cbCurrentLengthRef)
        {
            unsafe
            {
                System.IntPtr bBufferOut;
                SharpDX.Result __result__;
                fixed (void* cbMaxLengthRef_ = &cbMaxLengthRef)
                fixed (void* cbCurrentLengthRef_ = &cbCurrentLengthRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &bBufferOut, cbMaxLengthRef_, cbCurrentLengthRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
                return bBufferOut;
            }
        }

        /// <summary>	
        /// <p> </p><p>Unlocks a buffer that was previously locked. Call this method once for every call to <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.Lock"/></strong>.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>D3DERR_INVALIDCALL</strong></dt> </dl> </td><td> <p>For Direct3D surface buffers, an error occurred when unlocking the surface.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>It is an error to call <strong>Unlock</strong> if you did not call <strong>Lock</strong> previously.</p><p>After calling this method, do not use the reference returned by the <strong>Lock</strong> method. It is no longer guaranteed to be valid.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaBuffer::Unlock']/*"/>	
        /// <msdn-id>ms696259</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaBuffer::Unlock()</unmanaged>	
        /// <unmanaged-short>IMFMediaBuffer::Unlock</unmanaged-short>	
        public void Unlock()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the length of the valid data in the buffer.</p>	
        /// </summary>	
        /// <param name="cbCurrentLengthRef"><dd> <p>Receives the length of the valid data, in bytes. If the buffer does not contain any valid data, the value is zero.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaBuffer::GetCurrentLength']/*"/>	
        /// <msdn-id>ms698987</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaBuffer::GetCurrentLength([Out] unsigned int* pcbCurrentLength)</unmanaged>	
        /// <unmanaged-short>IMFMediaBuffer::GetCurrentLength</unmanaged-short>	
        internal void GetCurrentLength(out int cbCurrentLengthRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cbCurrentLengthRef_ = &cbCurrentLengthRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cbCurrentLengthRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the length of the valid data in the buffer.</p>	
        /// </summary>	
        /// <param name="cbCurrentLength"><dd> <p>Length of the valid data, in bytes. This value cannot be greater than the allocated size of the buffer, which is returned by the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.GetMaxLength"/></strong> method.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The specified length is greater than the maximum size of the buffer.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method if you write data into the buffer.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaBuffer::SetCurrentLength']/*"/>	
        /// <msdn-id>ms703202</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaBuffer::SetCurrentLength([In] unsigned int cbCurrentLength)</unmanaged>	
        /// <unmanaged-short>IMFMediaBuffer::SetCurrentLength</unmanaged-short>	
        internal void SetCurrentLength(int cbCurrentLength)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cbCurrentLength, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the allocated size of the buffer.</p>	
        /// </summary>	
        /// <param name="cbMaxLengthRef"><dd> <p>Receives the allocated size of the buffer, in bytes.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The buffer might or might not contain any valid data, and if there is valid data in the buffer, it might be smaller than the buffer's allocated size. To get the length of the valid data, call <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.GetCurrentLength"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaBuffer::GetMaxLength']/*"/>	
        /// <msdn-id>ms704840</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaBuffer::GetMaxLength([Out] unsigned int* pcbMaxLength)</unmanaged>	
        /// <unmanaged-short>IMFMediaBuffer::GetMaxLength</unmanaged-short>	
        internal void GetMaxLength(out int cbMaxLengthRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cbMaxLengthRef_ = &cbMaxLengthRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cbMaxLengthRef_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables an application to play audio or video files.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The Media Engine implements this interface. To create an instance of the Media Engine, call <strong><see cref="SharpDX.MediaFoundation.MediaEngineClassFactory.CreateInstance"/></strong>.</p><p>This interface is extended with <strong><see cref="SharpDX.MediaFoundation.MediaEngineEx"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine']/*"/>	
    /// <msdn-id>hh447918</msdn-id>	
    /// <unmanaged>IMFMediaEngine</unmanaged>	
    /// <unmanaged-short>IMFMediaEngine</unmanaged-short>	
    [Guid("98a1b0bb-03eb-4935-ae7c-93c1fa0e1c93")]
    public partial class MediaEngine : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngine"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngine(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngine"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngine(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngine(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the most recent error status.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method returns the last error status, if any, that resulted from loading the media source. If there has not been an error, <em>ppError</em> receives the value <strong><c>null</c></strong>.</p><p>This method corresponds to the <strong>error</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetError']/*"/>	
        /// <msdn-id>hh447985</msdn-id>	
        /// <unmanaged>GetError</unmanaged>	
        /// <unmanaged-short>GetError</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngine::GetError([Out] IMFMediaError** ppError)</unmanaged>
        public SharpDX.MediaFoundation.MediaError Error
        {
            get { SharpDX.MediaFoundation.MediaError __output__; GetError(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Sets the current error code.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::SetErrorCode']/*"/>	
        /// <msdn-id>hh448012</msdn-id>	
        /// <unmanaged>SetErrorCode</unmanaged>	
        /// <unmanaged-short>SetErrorCode</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngine::SetErrorCode([In] MF_MEDIA_ENGINE_ERR error)</unmanaged>
        public SharpDX.MediaFoundation.MediaEngineErr ErrorCode
        {
            set { SetErrorCode(value); }
        }

        /// <summary>	
        /// <p>Sets a list of media sources.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to adding a list of <strong>source</strong> elements to a media element in HTML5. </p><p>The Media Engine tries to load each item in the <em>pSrcElements</em> list, until it finds one that loads successfully. After this method is called, the application can use the <strong><see cref="SharpDX.MediaFoundation.MediaEngineSrcElements"/></strong> interface to update the list at any time. To reload the list, call <strong><see cref="SharpDX.MediaFoundation.MediaEngine.Load"/></strong>.</p><p>This method completes asynchronously. When the operation starts, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.LoadStart"/></strong> event. If no errors occur during the <strong>Load</strong> operation, several other events are generated, including the following.</p><ul> <li><strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.LoadedMetadata"/></strong></li> <li><strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.LoadedData"/></strong></li> <li><strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.CanPlay"/></strong></li> <li><strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.CanPlayThrough"/></strong></li> </ul><p>If the Media Engine is unable to load a URL, it sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.Error"/></strong> event. </p><p>For more information about event handling in the Media Engine, see <strong><see cref="SharpDX.MediaFoundation.MediaEngineNotify"/></strong>.</p><p>If the application also calls <strong><see cref="SharpDX.MediaFoundation.MediaEngine.SetSource"/></strong>, the URL passed to <strong>SetSource</strong> takes precedence over the list given to <strong>SetSourceElements</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::SetSourceElements']/*"/>	
        /// <msdn-id>hh448018</msdn-id>	
        /// <unmanaged>SetSourceElements</unmanaged>	
        /// <unmanaged-short>SetSourceElements</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngine::SetSourceElements([In] IMFMediaEngineSrcElements* pSrcElements)</unmanaged>
        public SharpDX.MediaFoundation.MediaEngineSrcElements SourceElements
        {
            set { SetSourceElements(value); }
        }

        /// <summary>	
        /// <p>Gets the current network state of the media engine.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>networkState</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetNetworkState']/*"/>	
        /// <msdn-id>hh447989</msdn-id>	
        /// <unmanaged>GetNetworkState</unmanaged>	
        /// <unmanaged-short>GetNetworkState</unmanaged-short>	
        /// <unmanaged>unsigned short IMFMediaEngine::GetNetworkState()</unmanaged>
        public short NetworkState
        {
            get { return GetNetworkState(); }
        }

        /// <summary>	
        /// <p>Gets or sets the preload flag.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>preload</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. The value is a hint to the user-agent whether to preload the media resource.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetPreload']/*"/>	
        /// <msdn-id>hh447992</msdn-id>	
        /// <unmanaged>GetPreload / SetPreload</unmanaged>	
        /// <unmanaged-short>GetPreload</unmanaged-short>	
        /// <unmanaged>MF_MEDIA_ENGINE_PRELOAD IMFMediaEngine::GetPreload()</unmanaged>
        public SharpDX.MediaFoundation.MediaEnginePreload Preload
        {
            get { return GetPreload(); }
            set { SetPreload(value); }
        }

        /// <summary>	
        /// <p>Queries how much resource data the media engine has buffered.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>buffered</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>The returned  <strong><see cref="SharpDX.MediaFoundation.MediaTimeRange"/></strong> interface represents a list of time ranges. The time ranges indicate which portions of the media resource have been downloaded. The time range list can be empty.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetBuffered']/*"/>	
        /// <msdn-id>hh447980</msdn-id>	
        /// <unmanaged>GetBuffered</unmanaged>	
        /// <unmanaged-short>GetBuffered</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngine::GetBuffered([Out] IMFMediaTimeRange** ppBuffered)</unmanaged>
        public SharpDX.MediaFoundation.MediaTimeRange Buffered
        {
            get { SharpDX.MediaFoundation.MediaTimeRange __output__; GetBuffered(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets the ready state, which indicates whether the current media resource can be rendered.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>readyState</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetReadyState']/*"/>	
        /// <msdn-id>hh447993</msdn-id>	
        /// <unmanaged>GetReadyState</unmanaged>	
        /// <unmanaged-short>GetReadyState</unmanaged-short>	
        /// <unmanaged>unsigned short IMFMediaEngine::GetReadyState()</unmanaged>
        public short ReadyState
        {
            get { return GetReadyState(); }
        }

        /// <summary>	
        /// <p>Queries whether the Media Engine is currently seeking to a new playback position.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>seeking</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::IsSeeking']/*"/>	
        /// <msdn-id>hh448004</msdn-id>	
        /// <unmanaged>IsSeeking</unmanaged>	
        /// <unmanaged-short>IsSeeking</unmanaged-short>	
        /// <unmanaged>BOOL IMFMediaEngine::IsSeeking()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsSeeking
        {
            get { return IsSeeking_(); }
        }

        /// <summary>	
        /// <p>Gets or sets the current playback position.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>currentTime</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetCurrentTime']/*"/>	
        /// <msdn-id>hh447982</msdn-id>	
        /// <unmanaged>GetCurrentTime / SetCurrentTime</unmanaged>	
        /// <unmanaged-short>GetCurrentTime</unmanaged-short>	
        /// <unmanaged>double IMFMediaEngine::GetCurrentTime()</unmanaged>
        public double CurrentTime
        {
            get { return GetCurrentTime(); }
            set { SetCurrentTime(value); }
        }

        /// <summary>	
        /// <p>Gets the initial playback position.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>initialTime</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetStartTime']/*"/>	
        /// <msdn-id>hh447995</msdn-id>	
        /// <unmanaged>GetStartTime</unmanaged>	
        /// <unmanaged-short>GetStartTime</unmanaged-short>	
        /// <unmanaged>double IMFMediaEngine::GetStartTime()</unmanaged>
        public double StartTime
        {
            get { return GetStartTime(); }
        }

        /// <summary>	
        /// <p>Gets the duration of the media resource.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>duration</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>If the duration changes, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.DurationChange"/></strong> event. See <strong><see cref="SharpDX.MediaFoundation.MediaEngineNotify.EventNotify"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetDuration']/*"/>	
        /// <msdn-id>hh447984</msdn-id>	
        /// <unmanaged>GetDuration</unmanaged>	
        /// <unmanaged-short>GetDuration</unmanaged-short>	
        /// <unmanaged>double IMFMediaEngine::GetDuration()</unmanaged>
        public double Duration
        {
            get { return GetDuration(); }
        }

        /// <summary>	
        /// <p>Queries whether playback is currently paused.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>paused</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::IsPaused']/*"/>	
        /// <msdn-id>hh448003</msdn-id>	
        /// <unmanaged>IsPaused</unmanaged>	
        /// <unmanaged-short>IsPaused</unmanaged-short>	
        /// <unmanaged>BOOL IMFMediaEngine::IsPaused()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsPaused
        {
            get { return IsPaused_(); }
        }

        /// <summary>	
        /// <p>Gets or sets the default playback rate.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to getting the <strong>defaultPlaybackRate</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. </p><p>The default playback rate is used for the next call to the <strong><see cref="SharpDX.MediaFoundation.MediaEngine.Play"/></strong> method. To change the current playback rate, call <strong><see cref="SharpDX.MediaFoundation.MediaEngine.SetPlaybackRate"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetDefaultPlaybackRate']/*"/>	
        /// <msdn-id>hh447983</msdn-id>	
        /// <unmanaged>GetDefaultPlaybackRate / SetDefaultPlaybackRate</unmanaged>	
        /// <unmanaged-short>GetDefaultPlaybackRate</unmanaged-short>	
        /// <unmanaged>double IMFMediaEngine::GetDefaultPlaybackRate()</unmanaged>
        public double DefaultPlaybackRate
        {
            get { return GetDefaultPlaybackRate(); }
            set { SetDefaultPlaybackRate(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the current playback rate.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to getting the <strong>playbackRate</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetPlaybackRate']/*"/>	
        /// <msdn-id>hh447990</msdn-id>	
        /// <unmanaged>GetPlaybackRate / SetPlaybackRate</unmanaged>	
        /// <unmanaged-short>GetPlaybackRate</unmanaged-short>	
        /// <unmanaged>double IMFMediaEngine::GetPlaybackRate()</unmanaged>
        public double PlaybackRate
        {
            get { return GetPlaybackRate(); }
            set { SetPlaybackRate(value); }
        }

        /// <summary>	
        /// <p>Gets the time ranges that have been rendered.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>played</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetPlayed']/*"/>	
        /// <msdn-id>hh447991</msdn-id>	
        /// <unmanaged>GetPlayed</unmanaged>	
        /// <unmanaged-short>GetPlayed</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngine::GetPlayed([Out] IMFMediaTimeRange** ppPlayed)</unmanaged>
        public SharpDX.MediaFoundation.MediaTimeRange Played
        {
            get { SharpDX.MediaFoundation.MediaTimeRange __output__; GetPlayed(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets the time ranges to which the Media Engine can currently seek.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>seekable</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>To find out whether the media source supports seeking, call <strong><see cref="SharpDX.MediaFoundation.MediaEngineEx.GetResourceCharacteristics"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetSeekable']/*"/>	
        /// <msdn-id>hh447994</msdn-id>	
        /// <unmanaged>GetSeekable</unmanaged>	
        /// <unmanaged-short>GetSeekable</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngine::GetSeekable([Out] IMFMediaTimeRange** ppSeekable)</unmanaged>
        public SharpDX.MediaFoundation.MediaTimeRange Seekable
        {
            get { SharpDX.MediaFoundation.MediaTimeRange __output__; GetSeekable(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Queries whether playback has ended.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>ended</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::IsEnded']/*"/>	
        /// <msdn-id>hh448002</msdn-id>	
        /// <unmanaged>IsEnded</unmanaged>	
        /// <unmanaged-short>IsEnded</unmanaged-short>	
        /// <unmanaged>BOOL IMFMediaEngine::IsEnded()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsEnded
        {
            get { return IsEnded_(); }
        }

        /// <summary>	
        /// <p>Queries whether the Media Engine automatically begins playback.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>autoplay</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>If this method returns <strong>TRUE</strong>, playback begins automatically after the <strong><see cref="SharpDX.MediaFoundation.MediaEngine.Load"/></strong> method completes. Otherwise, playback begins when the application calls <strong><see cref="SharpDX.MediaFoundation.MediaEngine.Play"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetAutoPlay']/*"/>	
        /// <msdn-id>hh447979</msdn-id>	
        /// <unmanaged>GetAutoPlay / SetAutoPlay</unmanaged>	
        /// <unmanaged-short>GetAutoPlay</unmanaged-short>	
        /// <unmanaged>BOOL IMFMediaEngine::GetAutoPlay()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool AutoPlay
        {
            get { return GetAutoPlay(); }
            set { SetAutoPlay(value); }
        }

        /// <summary>	
        /// <p>Queries whether the Media Engine will loop playback.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to getting the <strong>loop</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>If looping is enabled, the Media Engine seeks to the start of the content when playback reaches the end.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetLoop']/*"/>	
        /// <msdn-id>hh447986</msdn-id>	
        /// <unmanaged>GetLoop / SetLoop</unmanaged>	
        /// <unmanaged-short>GetLoop</unmanaged-short>	
        /// <unmanaged>BOOL IMFMediaEngine::GetLoop()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool Loop
        {
            get { return GetLoop(); }
            set { SetLoop(value); }
        }

        /// <summary>	
        /// <p>Queries whether the audio is muted. </p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetMuted']/*"/>	
        /// <msdn-id>hh447987</msdn-id>	
        /// <unmanaged>GetMuted / SetMuted</unmanaged>	
        /// <unmanaged-short>GetMuted</unmanaged-short>	
        /// <unmanaged>BOOL IMFMediaEngine::GetMuted()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool Muted
        {
            get { return GetMuted(); }
            set { SetMuted(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the audio volume level.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetVolume']/*"/>	
        /// <msdn-id>hh447997</msdn-id>	
        /// <unmanaged>GetVolume / SetVolume</unmanaged>	
        /// <unmanaged-short>GetVolume</unmanaged-short>	
        /// <unmanaged>double IMFMediaEngine::GetVolume()</unmanaged>
        public double Volume
        {
            get { return GetVolume(); }
            set { SetVolume(value); }
        }

        /// <summary>	
        /// <p>Gets the most recent error status.</p>	
        /// </summary>	
        /// <param name="errorOut"><dd> <p>Receives either a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaError"/></strong> interface, or the value <strong><c>null</c></strong>. If the value is <strong>non-<c>null</c></strong>, the caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method returns the last error status, if any, that resulted from loading the media source. If there has not been an error, <em>ppError</em> receives the value <strong><c>null</c></strong>.</p><p>This method corresponds to the <strong>error</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetError']/*"/>	
        /// <msdn-id>hh447985</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::GetError([Out] IMFMediaError** ppError)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetError</unmanaged-short>	
        internal void GetError(out SharpDX.MediaFoundation.MediaError errorOut)
        {
            unsafe
            {
                IntPtr errorOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &errorOut_, ((void**)(*(void**)_nativePointer))[3]);
                errorOut = (errorOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaError(errorOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the current error code.</p>	
        /// </summary>	
        /// <param name="error"><dd> <p>The error code, as an <strong><see cref="SharpDX.MediaFoundation.MediaEngineErr"/></strong> value.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::SetErrorCode']/*"/>	
        /// <msdn-id>hh448012</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::SetErrorCode([In] MF_MEDIA_ENGINE_ERR error)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::SetErrorCode</unmanaged-short>	
        internal void SetErrorCode(SharpDX.MediaFoundation.MediaEngineErr error)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)error), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets a list of media sources.</p>	
        /// </summary>	
        /// <param name="srcElementsRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaEngineSrcElements"/></strong> interface. The caller must implement this interface. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to adding a list of <strong>source</strong> elements to a media element in HTML5. </p><p>The Media Engine tries to load each item in the <em>pSrcElements</em> list, until it finds one that loads successfully. After this method is called, the application can use the <strong><see cref="SharpDX.MediaFoundation.MediaEngineSrcElements"/></strong> interface to update the list at any time. To reload the list, call <strong><see cref="SharpDX.MediaFoundation.MediaEngine.Load"/></strong>.</p><p>This method completes asynchronously. When the operation starts, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.LoadStart"/></strong> event. If no errors occur during the <strong>Load</strong> operation, several other events are generated, including the following.</p><ul> <li><strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.LoadedMetadata"/></strong></li> <li><strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.LoadedData"/></strong></li> <li><strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.CanPlay"/></strong></li> <li><strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.CanPlayThrough"/></strong></li> </ul><p>If the Media Engine is unable to load a URL, it sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.Error"/></strong> event. </p><p>For more information about event handling in the Media Engine, see <strong><see cref="SharpDX.MediaFoundation.MediaEngineNotify"/></strong>.</p><p>If the application also calls <strong><see cref="SharpDX.MediaFoundation.MediaEngine.SetSource"/></strong>, the URL passed to <strong>SetSource</strong> takes precedence over the list given to <strong>SetSourceElements</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::SetSourceElements']/*"/>	
        /// <msdn-id>hh448018</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::SetSourceElements([In] IMFMediaEngineSrcElements* pSrcElements)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::SetSourceElements</unmanaged-short>	
        internal void SetSourceElements(SharpDX.MediaFoundation.MediaEngineSrcElements srcElementsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((srcElementsRef == null) ? IntPtr.Zero : srcElementsRef.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the URL of a media resource.</p>	
        /// </summary>	
        /// <param name="urlRef"><dd> <p>The URL of the media resource.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to setting the <strong>src</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>The URL specified by this method takes precedence over media resources specified in the <strong><see cref="SharpDX.MediaFoundation.MediaEngine.SetSourceElements"/></strong> method. To load the URL, call <strong><see cref="SharpDX.MediaFoundation.MediaEngine.Load"/></strong>.</p><p>This method asynchronously loads the URL. When the operation starts, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.LoadStart"/></strong> event. If no errors occur during the <strong>Load</strong> operation, several other events are generated, including the following.</p><ul> <li><strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.LoadedMetadata"/></strong></li> <li><strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.LoadedData"/></strong></li> <li><strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.CanPlay"/></strong></li> <li><strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.CanPlayThrough"/></strong></li> </ul><p>If the Media Engine is unable to load the URL, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.Error"/></strong> event. </p><p>For more information about event handling in the Media Engine, see <strong><see cref="SharpDX.MediaFoundation.MediaEngineNotify"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::SetSource']/*"/>	
        /// <msdn-id>hh448017</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::SetSource([In] void* pUrl)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::SetSource</unmanaged-short>	
        internal void SetSource(System.IntPtr urlRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)urlRef, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the URL of the current media resource, or an empty string if no media resource is present.</p>	
        /// </summary>	
        /// <param name="urlOut"><dd> <p>Receives a <strong>BSTR</strong> that contains the URL of the current media resource. If there is no media resource, <em>ppUrl</em> receives an empty string. The caller must free the  <strong>BSTR</strong> by calling <strong>SysFreeString</strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>currentSrc</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>Initially, the current media resource is empty. It is updated when the Media Engine performs the resource selection algorithm.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetCurrentSource']/*"/>	
        /// <msdn-id>hh447981</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::GetCurrentSource([Out] wchar_t** ppUrl)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetCurrentSource</unmanaged-short>	
        public void GetCurrentSource(System.IntPtr urlOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)urlOut, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the current network state of the media engine.</p>	
        /// </summary>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.MediaFoundation.MediaEngineNetwork"/></strong> enumeration value.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>networkState</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetNetworkState']/*"/>	
        /// <msdn-id>hh447989</msdn-id>	
        /// <unmanaged>unsigned short IMFMediaEngine::GetNetworkState()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetNetworkState</unmanaged-short>	
        internal short GetNetworkState()
        {
            unsafe
            {
                short __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callishort(_nativePointer, ((void**)(*(void**)_nativePointer))[8]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the preload flag.</p>	
        /// </summary>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.MediaFoundation.MediaEnginePreload"/></strong> enumeration value.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>preload</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. The value is a hint to the user-agent whether to preload the media resource.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetPreload']/*"/>	
        /// <msdn-id>hh447992</msdn-id>	
        /// <unmanaged>MF_MEDIA_ENGINE_PRELOAD IMFMediaEngine::GetPreload()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetPreload</unmanaged-short>	
        internal SharpDX.MediaFoundation.MediaEnginePreload GetPreload()
        {
            unsafe
            {
                SharpDX.MediaFoundation.MediaEnginePreload __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMediaFoundationMediaEnginePreload(_nativePointer, ((void**)(*(void**)_nativePointer))[9]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Sets the preload flag.</p>	
        /// </summary>	
        /// <param name="preload"><dd> <p>An <strong><see cref="SharpDX.MediaFoundation.MediaEnginePreload"/></strong> value equal to  the preload flag.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to setting the <strong>preload</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. The value is a hint to the user-agent whether to preload the media resource.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::SetPreload']/*"/>	
        /// <msdn-id>hh448016</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::SetPreload([In] MF_MEDIA_ENGINE_PRELOAD Preload)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::SetPreload</unmanaged-short>	
        internal void SetPreload(SharpDX.MediaFoundation.MediaEnginePreload preload)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)preload), ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries how much resource data the media engine has buffered.</p>	
        /// </summary>	
        /// <param name="bufferedOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaTimeRange"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>buffered</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>The returned  <strong><see cref="SharpDX.MediaFoundation.MediaTimeRange"/></strong> interface represents a list of time ranges. The time ranges indicate which portions of the media resource have been downloaded. The time range list can be empty.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetBuffered']/*"/>	
        /// <msdn-id>hh447980</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::GetBuffered([Out] IMFMediaTimeRange** ppBuffered)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetBuffered</unmanaged-short>	
        internal void GetBuffered(out SharpDX.MediaFoundation.MediaTimeRange bufferedOut)
        {
            unsafe
            {
                IntPtr bufferedOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &bufferedOut_, ((void**)(*(void**)_nativePointer))[11]);
                bufferedOut = (bufferedOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaTimeRange(bufferedOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Loads the current media source.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The main purpose of this method is to reload a list of source elements after updating the list. For more information, see <strong>SetSourceElements</strong>. Otherwise, calling this method is generally not required. To load a new media source, call <strong><see cref="SharpDX.MediaFoundation.MediaEngine.SetSource"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaEngine.SetSourceElements"/></strong>.</p><p>The <strong>Load</strong> method explictly invokes the Media Engine's media resource loading algorithm. Before calling this method, you must set the media resource by calling <strong><see cref="SharpDX.MediaFoundation.MediaEngine.SetSource"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaEngine.SetSourceElements"/></strong>. </p><p>This method completes asynchronously. When the <strong>Load</strong> operation starts, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.LoadStart"/></strong> event. If no errors occur during the <strong>Load</strong> operation, several other events are generated, including the following.</p><ul> <li><strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.LoadedMetadata"/></strong></li> <li><strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.LoadedData"/></strong></li> <li><strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.CanPlay"/></strong></li> <li><strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.CanPlayThrough"/></strong></li> </ul><p>If the Media Engine is unable to load the file, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.Error"/></strong> event. </p><p>For more information about event handling in the Media Engine, see <strong><see cref="SharpDX.MediaFoundation.MediaEngineNotify"/></strong>.</p><p>This method corresponds to the <strong>load</strong> method of the <strong>HTMLMediaElement</strong> interface in HTML5. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::Load']/*"/>	
        /// <msdn-id>hh448005</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::Load()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::Load</unmanaged-short>	
        public void Load()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries how likely it is that the Media Engine can play a specified type of media resource.</p>	
        /// </summary>	
        /// <param name="type"><dd> <p>A string that contains a MIME type with an optional codecs parameter, as defined in RFC 4281.</p> </dd></param>	
        /// <param name="answerRef"><dd> <p>Receives an <strong><see cref="SharpDX.MediaFoundation.MediaEngineCanPlay"/></strong> enumeration value.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>canPlayType</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>The <strong>canPlayType</strong> attribute defines the following values.</p><table> <tr><th>Value</th><th>Description</th></tr> <tr><td>"" (empty string)</td><td>The user-agent cannot play the resource, or the resource type is "application/octet-stream".</td></tr> <tr><td>"probably"</td><td>The user-agent probably can play the resource.</td></tr> <tr><td>"maybe"</td><td>Neither of the previous values applies.</td></tr> </table><p>?</p><p>The value "probably" is used because a MIME type for a media resource is generally not a complete description of the resource. For example, "video/mp4" specifies an MP4 file with video, but does not describe the codec. Even with the optional codecs parameter, the MIME type omits some information, such as the actual coded bit rate. Therefore, it is usually impossible to be certain that playback is possible until the actual media resource is opened.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::CanPlayType']/*"/>	
        /// <msdn-id>hh447978</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::CanPlayType([In] wchar_t* type,[Out] MF_MEDIA_ENGINE_CANPLAY* pAnswer)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::CanPlayType</unmanaged-short>	
        public void CanPlayType(string type, out SharpDX.MediaFoundation.MediaEngineCanPlay answerRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* type_ = type)
                fixed (void* answerRef_ = &answerRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)type_, answerRef_, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the ready state, which indicates whether the current media resource can be rendered.</p>	
        /// </summary>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.MediaFoundation.MediaEngineReady"/></strong> enumeration value.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>readyState</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetReadyState']/*"/>	
        /// <msdn-id>hh447993</msdn-id>	
        /// <unmanaged>unsigned short IMFMediaEngine::GetReadyState()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetReadyState</unmanaged-short>	
        internal short GetReadyState()
        {
            unsafe
            {
                short __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callishort(_nativePointer, ((void**)(*(void**)_nativePointer))[14]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Queries whether the Media Engine is currently seeking to a new playback position.</p>	
        /// </summary>	
        /// <returns><p>Returns <strong>TRUE</strong> if the Media Engine is seeking, or <strong><see cref="SharpDX.Result.False"/></strong> otherwise.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>seeking</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::IsSeeking']/*"/>	
        /// <msdn-id>hh448004</msdn-id>	
        /// <unmanaged>BOOL IMFMediaEngine::IsSeeking()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::IsSeeking</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsSeeking_()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[15]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the current playback position.</p>	
        /// </summary>	
        /// <returns><p>Returns the playback position, in seconds.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>currentTime</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetCurrentTime']/*"/>	
        /// <msdn-id>hh447982</msdn-id>	
        /// <unmanaged>double IMFMediaEngine::GetCurrentTime()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetCurrentTime</unmanaged-short>	
        internal double GetCurrentTime()
        {
            unsafe
            {
                double __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callidouble(_nativePointer, ((void**)(*(void**)_nativePointer))[16]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Seeks to a new playback position.</p>	
        /// </summary>	
        /// <param name="seekTime"><dd> <p>The new playback position, in seconds.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to setting the <strong>currentTime</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>The method completes asynchronously. When the seek operation starts, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.Seeking"/></strong> event. When the seek operation completes, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.Seeked"/></strong> event. See <strong>IMFMediaEventNotify::EventNotify</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::SetCurrentTime']/*"/>	
        /// <msdn-id>hh448010</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::SetCurrentTime([In] double seekTime)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::SetCurrentTime</unmanaged-short>	
        internal void SetCurrentTime(double seekTime)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, seekTime, ((void**)(*(void**)_nativePointer))[17]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the initial playback position.</p>	
        /// </summary>	
        /// <returns><p>Returns the initial playback position, in seconds.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>initialTime</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetStartTime']/*"/>	
        /// <msdn-id>hh447995</msdn-id>	
        /// <unmanaged>double IMFMediaEngine::GetStartTime()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetStartTime</unmanaged-short>	
        internal double GetStartTime()
        {
            unsafe
            {
                double __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callidouble(_nativePointer, ((void**)(*(void**)_nativePointer))[18]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the duration of the media resource.</p>	
        /// </summary>	
        /// <returns><p>Returns the duration, in seconds. If no media data is available, the method returns not-a-number (NaN). If the duration is unbounded, the method returns an infinite value.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>duration</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>If the duration changes, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.DurationChange"/></strong> event. See <strong><see cref="SharpDX.MediaFoundation.MediaEngineNotify.EventNotify"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetDuration']/*"/>	
        /// <msdn-id>hh447984</msdn-id>	
        /// <unmanaged>double IMFMediaEngine::GetDuration()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetDuration</unmanaged-short>	
        internal double GetDuration()
        {
            unsafe
            {
                double __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callidouble(_nativePointer, ((void**)(*(void**)_nativePointer))[19]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Queries whether playback is currently paused.</p>	
        /// </summary>	
        /// <returns><p>Returns <strong>TRUE</strong> if playback is paused, or  <strong><see cref="SharpDX.Result.False"/></strong> otherwise.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>paused</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::IsPaused']/*"/>	
        /// <msdn-id>hh448003</msdn-id>	
        /// <unmanaged>BOOL IMFMediaEngine::IsPaused()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::IsPaused</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsPaused_()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[20]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the default playback rate.</p>	
        /// </summary>	
        /// <returns><p>Returns the default playback rate, as a multiple of normal (1?) playback. A negative value indicates reverse playback.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to getting the <strong>defaultPlaybackRate</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. </p><p>The default playback rate is used for the next call to the <strong><see cref="SharpDX.MediaFoundation.MediaEngine.Play"/></strong> method. To change the current playback rate, call <strong><see cref="SharpDX.MediaFoundation.MediaEngine.SetPlaybackRate"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetDefaultPlaybackRate']/*"/>	
        /// <msdn-id>hh447983</msdn-id>	
        /// <unmanaged>double IMFMediaEngine::GetDefaultPlaybackRate()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetDefaultPlaybackRate</unmanaged-short>	
        internal double GetDefaultPlaybackRate()
        {
            unsafe
            {
                double __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callidouble(_nativePointer, ((void**)(*(void**)_nativePointer))[21]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Sets the default playback rate.</p>	
        /// </summary>	
        /// <param name="rate"><dd> <p>The default playback rate, as a multiple of normal (1?) playback. A negative value indicates reverse playback.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to setting the <strong>defaultPlaybackRate</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::SetDefaultPlaybackRate']/*"/>	
        /// <msdn-id>hh448011</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::SetDefaultPlaybackRate([In] double Rate)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::SetDefaultPlaybackRate</unmanaged-short>	
        internal void SetDefaultPlaybackRate(double rate)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, rate, ((void**)(*(void**)_nativePointer))[22]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the current playback rate.</p>	
        /// </summary>	
        /// <returns><p>Returns the playback rate, as a multiple of normal (1?) playback. A negative value indicates reverse playback.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to getting the <strong>playbackRate</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetPlaybackRate']/*"/>	
        /// <msdn-id>hh447990</msdn-id>	
        /// <unmanaged>double IMFMediaEngine::GetPlaybackRate()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetPlaybackRate</unmanaged-short>	
        internal double GetPlaybackRate()
        {
            unsafe
            {
                double __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callidouble(_nativePointer, ((void**)(*(void**)_nativePointer))[23]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Sets the current playback rate.</p>	
        /// </summary>	
        /// <param name="rate"><dd> <p>The playback rate, as a multiple of normal (1?) playback. A negative value indicates reverse playback.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to setting the <strong>playbackRate</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::SetPlaybackRate']/*"/>	
        /// <msdn-id>hh448015</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::SetPlaybackRate([In] double Rate)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::SetPlaybackRate</unmanaged-short>	
        internal void SetPlaybackRate(double rate)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, rate, ((void**)(*(void**)_nativePointer))[24]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the time ranges that have been rendered.</p>	
        /// </summary>	
        /// <param name="playedOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaTimeRange"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>played</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetPlayed']/*"/>	
        /// <msdn-id>hh447991</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::GetPlayed([Out] IMFMediaTimeRange** ppPlayed)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetPlayed</unmanaged-short>	
        internal void GetPlayed(out SharpDX.MediaFoundation.MediaTimeRange playedOut)
        {
            unsafe
            {
                IntPtr playedOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &playedOut_, ((void**)(*(void**)_nativePointer))[25]);
                playedOut = (playedOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaTimeRange(playedOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the time ranges to which the Media Engine can currently seek.</p>	
        /// </summary>	
        /// <param name="seekableOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaTimeRange"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>seekable</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>To find out whether the media source supports seeking, call <strong><see cref="SharpDX.MediaFoundation.MediaEngineEx.GetResourceCharacteristics"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetSeekable']/*"/>	
        /// <msdn-id>hh447994</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::GetSeekable([Out] IMFMediaTimeRange** ppSeekable)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetSeekable</unmanaged-short>	
        internal void GetSeekable(out SharpDX.MediaFoundation.MediaTimeRange seekableOut)
        {
            unsafe
            {
                IntPtr seekableOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &seekableOut_, ((void**)(*(void**)_nativePointer))[26]);
                seekableOut = (seekableOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaTimeRange(seekableOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries whether playback has ended.</p>	
        /// </summary>	
        /// <returns><p>Returns <strong>TRUE</strong> if the direction of playback is forward and playback has reached the end of the media resource. Returns <strong><see cref="SharpDX.Result.False"/></strong> otherwise.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>ended</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::IsEnded']/*"/>	
        /// <msdn-id>hh448002</msdn-id>	
        /// <unmanaged>BOOL IMFMediaEngine::IsEnded()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::IsEnded</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsEnded_()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[27]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Queries whether the Media Engine automatically begins playback.</p>	
        /// </summary>	
        /// <returns><p>Returns <strong>TRUE</strong> if the Media Engine automatically begins playback, or <strong><see cref="SharpDX.Result.False"/></strong> otherwise.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>autoplay</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>If this method returns <strong>TRUE</strong>, playback begins automatically after the <strong><see cref="SharpDX.MediaFoundation.MediaEngine.Load"/></strong> method completes. Otherwise, playback begins when the application calls <strong><see cref="SharpDX.MediaFoundation.MediaEngine.Play"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetAutoPlay']/*"/>	
        /// <msdn-id>hh447979</msdn-id>	
        /// <unmanaged>BOOL IMFMediaEngine::GetAutoPlay()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetAutoPlay</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool GetAutoPlay()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[28]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Specifies whether the Media Engine automatically begins playback.</p>	
        /// </summary>	
        /// <param name="autoPlay"><dd> <p>If <strong>TRUE</strong>, the Media Engine automatically begins playback after it loads a media source. Otherwise, playback does not begin until the application calls <strong><see cref="SharpDX.MediaFoundation.MediaEngine.Play"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to setting the <strong>autoplay</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::SetAutoPlay']/*"/>	
        /// <msdn-id>hh448009</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::SetAutoPlay([In] BOOL AutoPlay)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::SetAutoPlay</unmanaged-short>	
        internal void SetAutoPlay(SharpDX.Mathematics.Interop.RawBool autoPlay)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint6(_nativePointer, autoPlay, ((void**)(*(void**)_nativePointer))[29]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries whether the Media Engine will loop playback.</p>	
        /// </summary>	
        /// <returns><p>Returns <strong>TRUE</strong> if looping is enabled, or <strong><see cref="SharpDX.Result.False"/></strong> otherwise.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to getting the <strong>loop</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>If looping is enabled, the Media Engine seeks to the start of the content when playback reaches the end.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetLoop']/*"/>	
        /// <msdn-id>hh447986</msdn-id>	
        /// <unmanaged>BOOL IMFMediaEngine::GetLoop()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetLoop</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool GetLoop()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[30]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Specifies whether the Media Engine loops playback.</p>	
        /// </summary>	
        /// <param name="loop"><dd> <p>Specify <strong>TRUE</strong> to enable looping, or <strong><see cref="SharpDX.Result.False"/></strong> to disable looping.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If <em>Loop</em> is <strong>TRUE</strong>, playback loops back to the beginning when it reaches the end of the source.</p><p>This method corresponds to setting the <strong>loop</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::SetLoop']/*"/>	
        /// <msdn-id>hh448013</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::SetLoop([In] BOOL Loop)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::SetLoop</unmanaged-short>	
        internal void SetLoop(SharpDX.Mathematics.Interop.RawBool loop)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint6(_nativePointer, loop, ((void**)(*(void**)_nativePointer))[31]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Starts playback.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>play</strong> method of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>The method completes asynchronously. When the operation starts, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.Play"/></strong> event. When playback is under way, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.Playing"/></strong> event. See <strong>IMFMediaEventNotify::EventNotify</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::Play']/*"/>	
        /// <msdn-id>hh448008</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::Play()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::Play</unmanaged-short>	
        public void Play()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[32]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Pauses playback.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>pause</strong> method of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>The method completes asynchronously. When the transition to paused is complete, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.Pause"/>                </strong> event. See <strong>IMFMediaEventNotify::EventNotify</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::Pause']/*"/>	
        /// <msdn-id>hh448007</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::Pause()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::Pause</unmanaged-short>	
        public void Pause()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[33]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries whether the audio is muted. </p>	
        /// </summary>	
        /// <returns><p>Returns <strong>TRUE</strong> if the audio is muted, or <strong><see cref="SharpDX.Result.False"/></strong> otherwise.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetMuted']/*"/>	
        /// <msdn-id>hh447987</msdn-id>	
        /// <unmanaged>BOOL IMFMediaEngine::GetMuted()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetMuted</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool GetMuted()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[34]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Mutes or unmutes the audio. </p>	
        /// </summary>	
        /// <param name="muted"><dd> <p>Specify <strong>TRUE</strong> to mute the audio, or <strong><see cref="SharpDX.Result.False"/></strong> to unmute the audio. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::SetMuted']/*"/>	
        /// <msdn-id>hh448014</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::SetMuted([In] BOOL Muted)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::SetMuted</unmanaged-short>	
        internal void SetMuted(SharpDX.Mathematics.Interop.RawBool muted)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint6(_nativePointer, muted, ((void**)(*(void**)_nativePointer))[35]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the audio volume level.</p>	
        /// </summary>	
        /// <returns><p>Returns the volume level. Volume is expressed as an attenuation level, where 0.0 indicates silence and 1.0 indicates full volume (no attenuation).</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetVolume']/*"/>	
        /// <msdn-id>hh447997</msdn-id>	
        /// <unmanaged>double IMFMediaEngine::GetVolume()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetVolume</unmanaged-short>	
        internal double GetVolume()
        {
            unsafe
            {
                double __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callidouble(_nativePointer, ((void**)(*(void**)_nativePointer))[36]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Sets the audio volume level.</p>	
        /// </summary>	
        /// <param name="volume"><dd> <p>The volume level. Volume is expressed as an attenuation level, where 0.0 indicates silence and 1.0 indicates full volume (no attenuation). </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>When the audio balance changes, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.VolumeChange"/></strong> event. See <strong>IMFMediaEventNotify::EventNotify</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::SetVolume']/*"/>	
        /// <msdn-id>hh448019</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::SetVolume([In] double Volume)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::SetVolume</unmanaged-short>	
        internal void SetVolume(double volume)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, volume, ((void**)(*(void**)_nativePointer))[37]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries whether the current media resource contains a video stream.</p>	
        /// </summary>	
        /// <returns><p>Returns <strong>TRUE</strong> if the current media resource contains a video stream. Returns <strong><see cref="SharpDX.Result.False"/></strong> if there is no media resource or the media resource does not contain a video stream.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::HasVideo']/*"/>	
        /// <msdn-id>hh448001</msdn-id>	
        /// <unmanaged>BOOL IMFMediaEngine::HasVideo()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::HasVideo</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool HasVideo()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[38]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Queries whether the current media resource contains an audio stream.</p>	
        /// </summary>	
        /// <returns><p>Returns <strong>TRUE</strong> if the current media resource contains an audio stream. Returns <strong><see cref="SharpDX.Result.False"/></strong> if there is no media resource or the media resource does not contain an audio stream.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::HasAudio']/*"/>	
        /// <msdn-id>hh447998</msdn-id>	
        /// <unmanaged>BOOL IMFMediaEngine::HasAudio()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::HasAudio</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool HasAudio()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[39]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the size of the video frame, adjusted for aspect ratio.</p>	
        /// </summary>	
        /// <param name="cx"><dd> <p>Receives the width in pixels.</p> </dd></param>	
        /// <param name="cy"><dd> <p>Receives the height in pixels.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method adjusts for the correct picture aspect ratio.	
        /// For example, if the encoded frame is 720 ? 420 and the picture aspect ratio is 4:3, the method will return a size equal to 640 ? 480 pixels.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetNativeVideoSize']/*"/>	
        /// <msdn-id>hh447988</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::GetNativeVideoSize([Out, Optional] unsigned int* cx,[Out, Optional] unsigned int* cy)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetNativeVideoSize</unmanaged-short>	
        public void GetNativeVideoSize(out int cx, out int cy)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cx_ = &cx)
                fixed (void* cy_ = &cy)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cx_, cy_, ((void**)(*(void**)_nativePointer))[40]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the picture aspect ratio of the video stream.</p>	
        /// </summary>	
        /// <param name="cx"><dd> <p>Receives the x component of the aspect ratio.</p> </dd></param>	
        /// <param name="cy"><dd> <p>Receives the y component of the aspect ratio.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The Media Engine automatically converts the pixel aspect ratio to 1:1 (square pixels).</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::GetVideoAspectRatio']/*"/>	
        /// <msdn-id>hh447996</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::GetVideoAspectRatio([Out, Optional] unsigned int* cx,[Out, Optional] unsigned int* cy)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::GetVideoAspectRatio</unmanaged-short>	
        public void GetVideoAspectRatio(out int cx, out int cy)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cx_ = &cx)
                fixed (void* cy_ = &cy)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cx_, cy_, ((void**)(*(void**)_nativePointer))[41]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Shuts down the Media Engine and releases the resources it is using. </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::Shutdown']/*"/>	
        /// <msdn-id>hh448020</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::Shutdown()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::Shutdown</unmanaged-short>	
        public void Shutdown()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[42]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Copies the current video frame to a DXGI surface or WIC bitmap.</p>	
        /// </summary>	
        /// <param name="dstSurfRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of the destination surface. </p> </dd></param>	
        /// <param name="srcRef"><dd> <p>A reference to an <strong><see cref="SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure that specifies the source rectangle.</p> </dd></param>	
        /// <param name="dstRef"><dd> <p>A reference to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that specifies the destination rectangle.</p> </dd></param>	
        /// <param name="borderClrRef"><dd> <p>A reference to an <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that specifies the border color. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>In frame-server mode, call this method to blit the video frame to a DXGI or WIC surface. The application can call this method at any time after the Media Engine loads a video resource. Typically, however, the application calls <strong><see cref="SharpDX.MediaFoundation.MediaEngine.OnVideoStreamTick_"/></strong> first, to determine whether a new frame is available. If <strong>OnVideoStreamTick</strong> returns <strong><see cref="SharpDX.Result.Ok"/></strong>, the application then calls <strong>TransferVideoFrame</strong>.</p><p>The Media Engine scales and letterboxes the video to fit the destination rectangle. It fills the letterbox area with the border color.</p><p>For protected content, call the <strong><see cref="SharpDX.MediaFoundation.MediaEngineProtectedContent.TransferVideoFrame"/></strong> method instead of this method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::TransferVideoFrame']/*"/>	
        /// <msdn-id>hh448021</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::TransferVideoFrame([In] IUnknown* pDstSurf,[In, Optional] const MFVideoNormalizedRect* pSrc,[In] const RECT* pDst,[In, Optional] const MFARGB* pBorderClr)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::TransferVideoFrame</unmanaged-short>	
        public void TransferVideoFrame(SharpDX.ComObject dstSurfRef, SharpDX.MediaFoundation.VideoNormalizedRect? srcRef, SharpDX.Mathematics.Interop.RawRectangle dstRef, SharpDX.Mathematics.Interop.RawColorBGRA? borderClrRef)
        {
            unsafe
            {
                SharpDX.MediaFoundation.VideoNormalizedRect srcRef_;
                if (srcRef.HasValue)
                    srcRef_ = srcRef.Value;
                SharpDX.Mathematics.Interop.RawColorBGRA borderClrRef_;
                if (borderClrRef.HasValue)
                    borderClrRef_ = borderClrRef.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((dstSurfRef == null) ? IntPtr.Zero : dstSurfRef.NativePointer), (srcRef.HasValue) ? &srcRef_ : (void*)IntPtr.Zero, &dstRef, (borderClrRef.HasValue) ? &borderClrRef_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[43]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries the Media Engine to find out whether a new video frame is ready.</p>	
        /// </summary>	
        /// <param name="ptsRef"><dd> <p>If a new frame is ready, receives the presentation time of the frame.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p>The method succeeded, but the Media Engine does not have a new frame.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>A new video frame is ready for display.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>In frame-server mode, the application should call this method whenever a vertical blank occurs in the display device. If the method returns <strong><see cref="SharpDX.Result.Ok"/></strong>, call <strong><see cref="SharpDX.MediaFoundation.MediaEngine.TransferVideoFrame"/></strong> to blit the frame to the render target. If the method returns <strong>S_FALSE</strong>, wait for the next vertical blank and call the method again.</p><p>Do not call this method in rendering mode or audio-only mode. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngine::OnVideoStreamTick']/*"/>	
        /// <msdn-id>hh448006</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngine::OnVideoStreamTick([Out] longlong* pPts)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngine::OnVideoStreamTick</unmanaged-short>	
        internal SharpDX.Result OnVideoStreamTick_(out long ptsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* ptsRef_ = &ptsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ptsRef_, ((void**)(*(void**)_nativePointer))[44]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Creates a new instance of the Media Engine.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Before calling this method, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong>.</p><p>The Media Engine supports three distinct modes:</p><table> <tr><th>Mode</th><th>Description</th></tr> <tr><td>Frame-server mode</td><td> <p>In this mode, the Media Engine delivers uncompressed video frames to the application. The application is responsible for displaying each frame, using Microsoft Direct3D or any other rendering technique. </p> <p>The Media Engine renders the audio; the application is not responsible for audio rendering.</p> <p>Frame-server mode is the default mode. </p> </td></tr> <tr><td>Rendering mode</td><td> <p>In this mode, the Media Engine renders both audio and video. The video is rendered to a window or Microsoft DirectComposition visual provided by the application.</p> <p>To enable rendering mode, set either the <see cref="SharpDX.MediaFoundation.MediaEngineAttributeKeys.PlaybackHwnd"/> attribute or the  <see cref="SharpDX.MediaFoundation.MediaEngineAttributeKeys.PlaybackVisual"/> attribute.</p> </td></tr> <tr><td>Audio  mode</td><td> <p>In this mode, the Media Engine renders audio only, with no video.</p> <p>To enable audio mode, set the <strong><see cref="SharpDX.MediaFoundation.MediaEngineCreateFlags.AudioOnly"/></strong> flag in the <em>dwFlags</em> parameter.</p> </td></tr> </table><p>?</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineClassFactory']/*"/>	
    /// <msdn-id>hh447921</msdn-id>	
    /// <unmanaged>IMFMediaEngineClassFactory</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineClassFactory</unmanaged-short>	
    [Guid("4D645ACE-26AA-4688-9BE1-DF3516990B93")]
    public partial class MediaEngineClassFactory : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngineClassFactory"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngineClassFactory(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngineClassFactory"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngineClassFactory(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngineClassFactory(nativePointer);
        }


        /// <summary>Constant ClsidMFMediaEngineClassFactory.</summary>
        /// <unmanaged>CLSID_MFMediaEngineClassFactory</unmanaged>
        internal System.Guid ClsidMFMediaEngineClassFactory = new System.Guid("b44392da-499b-446b-a4cb-005fead0e6d5");

        /// <summary>	
        /// <p>Creates a new instance of the Media Engine.</p>	
        /// </summary>	
        /// <param name="flags"><dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.MediaEngineCreateFlags"/></strong> enumeration.</p> </dd></param>	
        /// <param name="attrRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of an attribute store. </p> <p>This parameter  specifies configuration attributes for the Media Engine. Call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAttributes"/></strong> to create the attribute store. Then, set one or more attributes from the list of Media Engine Attributes. For details, see Remarks.</p> </dd></param>	
        /// <param name="playerOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaEngine"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Attributenotfound"/></strong></dt> </dl> </td><td> <p>A required attribute was missing from <em>pAttr</em>, or an invalid combination of attributes was used.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Before calling this method, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong>.</p><p>The Media Engine supports three distinct modes:</p><table> <tr><th>Mode</th><th>Description</th></tr> <tr><td>Frame-server mode</td><td> <p>In this mode, the Media Engine delivers uncompressed video frames to the application. The application is responsible for displaying each frame, using Microsoft Direct3D or any other rendering technique. </p> <p>The Media Engine renders the audio; the application is not responsible for audio rendering.</p> <p>Frame-server mode is the default mode. </p> </td></tr> <tr><td>Rendering mode</td><td> <p>In this mode, the Media Engine renders both audio and video. The video is rendered to a window or Microsoft DirectComposition visual provided by the application.</p> <p>To enable rendering mode, set either the <see cref="SharpDX.MediaFoundation.MediaEngineAttributeKeys.PlaybackHwnd"/> attribute or the  <see cref="SharpDX.MediaFoundation.MediaEngineAttributeKeys.PlaybackVisual"/> attribute.</p> </td></tr> <tr><td>Audio  mode</td><td> <p>In this mode, the Media Engine renders audio only, with no video.</p> <p>To enable audio mode, set the <strong><see cref="SharpDX.MediaFoundation.MediaEngineCreateFlags.AudioOnly"/></strong> flag in the <em>dwFlags</em> parameter.</p> </td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineClassFactory::CreateInstance']/*"/>	
        /// <msdn-id>hh447921</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineClassFactory::CreateInstance([In] MF_MEDIA_ENGINE_CREATEFLAGS dwFlags,[In] IMFAttributes* pAttr,[Out, Fast] IMFMediaEngine** ppPlayer)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineClassFactory::CreateInstance</unmanaged-short>	
        internal void CreateInstance(SharpDX.MediaFoundation.MediaEngineCreateFlags flags, SharpDX.MediaFoundation.MediaAttributes attrRef, SharpDX.MediaFoundation.MediaEngine playerOut)
        {
            unsafe
            {
                IntPtr playerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)flags), (void*)((attrRef == null) ? IntPtr.Zero : attrRef.NativePointer), &playerOut_, ((void**)(*(void**)_nativePointer))[3]);
                ((SharpDX.MediaFoundation.MediaEngine)playerOut).NativePointer = playerOut_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a time range object.</p>	
        /// </summary>	
        /// <param name="timeRangeOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaTimeRange"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineClassFactory::CreateTimeRange']/*"/>	
        /// <msdn-id>hh447922</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineClassFactory::CreateTimeRange([Out, Fast] IMFMediaTimeRange** ppTimeRange)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineClassFactory::CreateTimeRange</unmanaged-short>	
        internal void CreateTimeRange(SharpDX.MediaFoundation.MediaTimeRange timeRangeOut)
        {
            unsafe
            {
                IntPtr timeRangeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &timeRangeOut_, ((void**)(*(void**)_nativePointer))[4]);
                ((SharpDX.MediaFoundation.MediaTimeRange)timeRangeOut).NativePointer = timeRangeOut_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a media error object.</p>	
        /// </summary>	
        /// <param name="errorOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaError"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineClassFactory::CreateError']/*"/>	
        /// <msdn-id>hh447920</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineClassFactory::CreateError([Out, Fast] IMFMediaError** ppError)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineClassFactory::CreateError</unmanaged-short>	
        internal void CreateError(SharpDX.MediaFoundation.MediaError errorOut)
        {
            unsafe
            {
                IntPtr errorOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &errorOut_, ((void**)(*(void**)_nativePointer))[5]);
                ((SharpDX.MediaFoundation.MediaError)errorOut).NativePointer = errorOut_;
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Creates an instance of the <strong><see cref="SharpDX.MediaFoundation.MediaKeys"/></strong> object.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineClassFactory2']/*"/>	
    /// <msdn-id>dn449731</msdn-id>	
    /// <unmanaged>IMFMediaEngineClassFactory2</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineClassFactory2</unmanaged-short>	
    [Guid("09083cef-867f-4bf6-8776-dee3a7b42fca")]
    public partial class MediaEngineClassFactory2 : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngineClassFactory2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngineClassFactory2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngineClassFactory2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngineClassFactory2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngineClassFactory2(nativePointer);
        }


        /// <summary>	
        /// <p>Creates a media keys object based on the specified key system.</p>	
        /// </summary>	
        /// <param name="keySystem"><dd> <p>The media key system.</p> </dd></param>	
        /// <param name="defaultCdmStorePath"><dd> <p>Points to the default file location for the  store Content Decryption Module (CDM) data.</p> </dd></param>	
        /// <param name="inprivateCdmStorePath"><dd> <p>Points to a the inprivate location for the  store Content Decryption Module (CDM) data. Specifying this path allows the CDM to comply with the application?s privacy policy by putting personal information in the file location indicated by this path.</p> </dd></param>	
        /// <param name="keysOut"><dd> <p>Receives the media keys.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineClassFactory2::CreateMediaKeys2']/*"/>	
        /// <msdn-id>dn449732</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineClassFactory2::CreateMediaKeys2([In] wchar_t* keySystem,[In] wchar_t* defaultCdmStorePath,[In, Optional] wchar_t* inprivateCdmStorePath,[Out] IMFMediaKeys** ppKeys)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineClassFactory2::CreateMediaKeys2</unmanaged-short>	
        public void CreateMediaKeys2(string keySystem, string defaultCdmStorePath, string inprivateCdmStorePath, out SharpDX.MediaFoundation.MediaKeys keysOut)
        {
            unsafe
            {
                IntPtr keysOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* keySystem_ = keySystem)
                fixed (char* defaultCdmStorePath_ = defaultCdmStorePath)
                fixed (char* inprivateCdmStorePath_ = inprivateCdmStorePath)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)keySystem_, (void*)defaultCdmStorePath_, (void*)inprivateCdmStorePath_, &keysOut_, ((void**)(*(void**)_nativePointer))[3]);
                keysOut = (keysOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaKeys(keysOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineClassFactory3']/*"/>	
    /// <unmanaged>IMFMediaEngineClassFactory3</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineClassFactory3</unmanaged-short>	
    [Guid("3787614f-65f7-4003-b673-ead8293a0e60")]
    public partial class MediaEngineClassFactory3 : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngineClassFactory3"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngineClassFactory3(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngineClassFactory3"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngineClassFactory3(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngineClassFactory3(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="keySystem">No documentation.</param>	
        /// <param name="supportedConfigurationsArrayOut">No documentation.</param>	
        /// <param name="uSize">No documentation.</param>	
        /// <param name="keyAccessOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineClassFactory3::CreateMediaKeySystemAccess']/*"/>	
        /// <unmanaged>HRESULT IMFMediaEngineClassFactory3::CreateMediaKeySystemAccess([In] wchar_t* keySystem,[In, Buffer] IPropertyStore** ppSupportedConfigurationsArray,[In] unsigned int uSize,[Out] IMFMediaKeySystemAccess** ppKeyAccess)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineClassFactory3::CreateMediaKeySystemAccess</unmanaged-short>	
        public void CreateMediaKeySystemAccess(string keySystem, SharpDX.ComObject[] supportedConfigurationsArrayOut, int uSize, out SharpDX.MediaFoundation.MediaKeySystemAccess keyAccessOut)
        {
            unsafe
            {
                IntPtr* supportedConfigurationsArrayOut_ = (IntPtr*)0;
                if (supportedConfigurationsArrayOut != null)
                {
                    IntPtr* supportedConfigurationsArrayOut__ = stackalloc IntPtr[supportedConfigurationsArrayOut.Length];
                    supportedConfigurationsArrayOut_ = supportedConfigurationsArrayOut__;
                    for (int i = 0; i < supportedConfigurationsArrayOut.Length; i++)
                        supportedConfigurationsArrayOut_[i] = (supportedConfigurationsArrayOut[i] == null) ? IntPtr.Zero : supportedConfigurationsArrayOut[i].NativePointer;
                }
                IntPtr keyAccessOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* keySystem_ = keySystem)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)keySystem_, supportedConfigurationsArrayOut_, uSize, &keyAccessOut_, ((void**)(*(void**)_nativePointer))[3]);
                keyAccessOut = (keyAccessOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaKeySystemAccess(keyAccessOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="keySystem">No documentation.</param>	
        /// <param name="supportedConfigurationsArrayOut">No documentation.</param>	
        /// <param name="uSize">No documentation.</param>	
        /// <param name="keyAccessOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineClassFactory3::CreateMediaKeySystemAccess']/*"/>	
        /// <unmanaged>HRESULT IMFMediaEngineClassFactory3::CreateMediaKeySystemAccess([In] wchar_t* keySystem,[In, Buffer] IPropertyStore** ppSupportedConfigurationsArray,[In] unsigned int uSize,[Out] IMFMediaKeySystemAccess** ppKeyAccess)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineClassFactory3::CreateMediaKeySystemAccess</unmanaged-short>	
        public void CreateMediaKeySystemAccess(string keySystem, SharpDX.ComArray<SharpDX.ComObject> supportedConfigurationsArrayOut, int uSize, out SharpDX.MediaFoundation.MediaKeySystemAccess keyAccessOut)
        {
            unsafe
            {
                IntPtr keyAccessOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* keySystem_ = keySystem)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)keySystem_, (void*)((supportedConfigurationsArrayOut == null) ? IntPtr.Zero : supportedConfigurationsArrayOut.NativePointer), uSize, &keyAccessOut_, ((void**)(*(void**)_nativePointer))[3]);
                keyAccessOut = (keyAccessOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaKeySystemAccess(keyAccessOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="keySystem">No documentation.</param>	
        /// <param name="supportedConfigurationsArrayOut">No documentation.</param>	
        /// <param name="uSize">No documentation.</param>	
        /// <param name="keyAccessOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineClassFactory3::CreateMediaKeySystemAccess']/*"/>	
        /// <unmanaged>HRESULT IMFMediaEngineClassFactory3::CreateMediaKeySystemAccess([In] wchar_t* keySystem,[In, Buffer] IPropertyStore** ppSupportedConfigurationsArray,[In] unsigned int uSize,[Out] IMFMediaKeySystemAccess** ppKeyAccess)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineClassFactory3::CreateMediaKeySystemAccess</unmanaged-short>	
        private void CreateMediaKeySystemAccess(System.IntPtr keySystem, System.IntPtr supportedConfigurationsArrayOut, int uSize, System.IntPtr keyAccessOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)keySystem, (void*)supportedConfigurationsArrayOut, uSize, (void*)keyAccessOut, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Gets a value that indicates if the specified key system supports the specified media type.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineClassFactoryEx']/*"/>	
    /// <msdn-id>dn280692</msdn-id>	
    /// <unmanaged>IMFMediaEngineClassFactoryEx</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineClassFactoryEx</unmanaged-short>	
    [Guid("c56156c6-ea5b-48a5-9df8-fbe035d0929e")]
    public partial class MediaEngineClassFactoryEx : SharpDX.MediaFoundation.MediaEngineClassFactory
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngineClassFactoryEx"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngineClassFactoryEx(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngineClassFactoryEx"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngineClassFactoryEx(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngineClassFactoryEx(nativePointer);
        }


        /// <summary>	
        /// <p>Creates an instance of <strong><see cref="SharpDX.MediaFoundation.MediaSourceExtension"/></strong>.</p>	
        /// </summary>	
        /// <param name="dwFlags">No documentation.</param>	
        /// <param name="attrRef">No documentation.</param>	
        /// <param name="mSEOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineClassFactoryEx::CreateMediaSourceExtension']/*"/>	
        /// <msdn-id>dn280691</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineClassFactoryEx::CreateMediaSourceExtension([In] unsigned int dwFlags,[In] IMFAttributes* pAttr,[Out] IMFMediaSourceExtension** ppMSE)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineClassFactoryEx::CreateMediaSourceExtension</unmanaged-short>	
        public void CreateMediaSourceExtension(int dwFlags, SharpDX.MediaFoundation.MediaAttributes attrRef, out SharpDX.MediaFoundation.MediaSourceExtension mSEOut)
        {
            unsafe
            {
                IntPtr mSEOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwFlags, (void*)((attrRef == null) ? IntPtr.Zero : attrRef.NativePointer), &mSEOut_, ((void**)(*(void**)_nativePointer))[6]);
                mSEOut = (mSEOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSourceExtension(mSEOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a media keys object based on the specified key system.</p>	
        /// </summary>	
        /// <param name="keySystem"><dd> <p>The media keys system.</p> </dd></param>	
        /// <param name="cdmStorePath"><dd> <p>Points to a location to store Content Decryption Module (CDM) data which might be locked by multiple process and so might be incompatible with store app suspension.</p> </dd></param>	
        /// <param name="keysOut"><dd> <p>The media keys.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Checks if <em>keySystem</em> is a supported key system and creates the related Content Decryption Module (CDM).	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineClassFactoryEx::CreateMediaKeys']/*"/>	
        /// <msdn-id>dn280690</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineClassFactoryEx::CreateMediaKeys([In] wchar_t* keySystem,[In, Optional] wchar_t* cdmStorePath,[Out] IMFMediaKeys** ppKeys)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineClassFactoryEx::CreateMediaKeys</unmanaged-short>	
        public void CreateMediaKeys(string keySystem, string cdmStorePath, out SharpDX.MediaFoundation.MediaKeys keysOut)
        {
            unsafe
            {
                IntPtr keysOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* keySystem_ = keySystem)
                fixed (char* cdmStorePath_ = cdmStorePath)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)keySystem_, (void*)cdmStorePath_, &keysOut_, ((void**)(*(void**)_nativePointer))[7]);
                keysOut = (keysOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaKeys(keysOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a value that indicates if the specified key system supports the specified media type.</p>	
        /// </summary>	
        /// <param name="type"><dd> <p>The MIME type to check support for.</p> </dd></param>	
        /// <param name="keySystem"><dd> <p>The key system to check support for.</p> </dd></param>	
        /// <param name="isSupported"><dd> <p><strong>true</strong> if type is supported by <em>keySystem</em>; otherwise, <strong>false.</strong></p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineClassFactoryEx::IsTypeSupported']/*"/>	
        /// <msdn-id>dn280692</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineClassFactoryEx::IsTypeSupported([In, Optional] wchar_t* type,[In] wchar_t* keySystem,[Out] BOOL* isSupported)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineClassFactoryEx::IsTypeSupported</unmanaged-short>	
        public void IsTypeSupported(string type, string keySystem, out SharpDX.Mathematics.Interop.RawBool isSupported)
        {
            unsafe
            {
                isSupported = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (char* type_ = type)
                fixed (char* keySystem_ = keySystem)
                fixed (void* isSupported_ = &isSupported)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)type_, (void*)keySystem_, isSupported_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Implemented by the media engine to add encrypted media extensions methods.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEME']/*"/>	
    /// <msdn-id>dn280693</msdn-id>	
    /// <unmanaged>IMFMediaEngineEME</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineEME</unmanaged-short>	
    [Guid("50dc93e4-ba4f-4275-ae66-83e836e57469")]
    public partial class MediaEngineEME : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngineEME"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngineEME(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngineEME"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngineEME(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngineEME(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the media keys object associated with the media engine or <strong>null</strong> if there is not a media keys object.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEME::get_Keys']/*"/>	
        /// <msdn-id>dn280694</msdn-id>	
        /// <unmanaged>get_Keys</unmanaged>	
        /// <unmanaged-short>get_Keys</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngineEME::get_Keys([Out, Optional] IMFMediaKeys** keys)</unmanaged>
        public SharpDX.MediaFoundation.MediaKeys Keys
        {
            get { SharpDX.MediaFoundation.MediaKeys __output__; GetKeys(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Sets the media keys object to use with the media engine.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEME::SetMediaKeys']/*"/>	
        /// <msdn-id>dn280695</msdn-id>	
        /// <unmanaged>SetMediaKeys</unmanaged>	
        /// <unmanaged-short>SetMediaKeys</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngineEME::SetMediaKeys([In, Optional] IMFMediaKeys* keys)</unmanaged>
        public SharpDX.MediaFoundation.MediaKeys MediaKeys
        {
            set { SetMediaKeys(value); }
        }

        /// <summary>	
        /// <p>Gets the media keys object associated with the media engine or <strong>null</strong> if there is not a media keys object.</p>	
        /// </summary>	
        /// <param name="keys"><dd> <p>The media keys object associated with the media engine or <strong>null</strong> if there is not a media keys object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEME::get_Keys']/*"/>	
        /// <msdn-id>dn280694</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEME::get_Keys([Out, Optional] IMFMediaKeys** keys)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEME::get_Keys</unmanaged-short>	
        internal void GetKeys(out SharpDX.MediaFoundation.MediaKeys keys)
        {
            unsafe
            {
                IntPtr keys_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &keys_, ((void**)(*(void**)_nativePointer))[3]);
                keys = (keys_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaKeys(keys_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the media keys object to use with the media engine.</p>	
        /// </summary>	
        /// <param name="keys"><dd> <p>The media keys.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEME::SetMediaKeys']/*"/>	
        /// <msdn-id>dn280695</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEME::SetMediaKeys([In, Optional] IMFMediaKeys* keys)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEME::SetMediaKeys</unmanaged-short>	
        internal void SetMediaKeys(SharpDX.MediaFoundation.MediaKeys keys)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((keys == null) ? IntPtr.Zero : keys.NativePointer), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEMENotify']/*"/>	
    /// <unmanaged>IMFMediaEngineEMENotify</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineEMENotify</unmanaged-short>	
    [Guid("9e184d15-cdb7-4f86-b49e-566689f4a601")]
    public partial class MediaEngineEMENotify : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngineEMENotify"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngineEMENotify(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngineEMENotify"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngineEMENotify(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngineEMENotify(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="bInitDataRef">No documentation.</param>	
        /// <param name="cb">No documentation.</param>	
        /// <param name="bstrInitDataType">No documentation.</param>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEMENotify::Encrypted']/*"/>	
        /// <unmanaged>void IMFMediaEngineEMENotify::Encrypted([In, Buffer, Optional] const unsigned char* pbInitData,[In] unsigned int cb,[In] wchar_t* bstrInitDataType)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEMENotify::Encrypted</unmanaged-short>	
        public void Encrypted(byte[] bInitDataRef, int cb, string bstrInitDataType)
        {
            unsafe
            {
                byte[] bInitDataRef__ = bInitDataRef;
                fixed (void* bInitDataRef_ = bInitDataRef__)
                fixed (char* bstrInitDataType_ = bstrInitDataType)
                    SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, bInitDataRef_, cb, (void*)bstrInitDataType_, ((void**)(*(void**)_nativePointer))[3]);
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEMENotify::WaitingForKey']/*"/>	
        /// <unmanaged>void IMFMediaEngineEMENotify::WaitingForKey()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEMENotify::WaitingForKey</unmanaged-short>	
        public void WaitingForKey()
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
            }
        }
    }
    /// <summary>	
    /// <p>Extends the <strong><see cref="SharpDX.MediaFoundation.MediaEngine"/></strong> interface.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.MediaFoundation.MediaEngine"/></strong> interface contains methods that map to the HTML5 media elements. The <strong><see cref="SharpDX.MediaFoundation.MediaEngineEx"/></strong> provides additional functionality that does not correspond directly to HTML5.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx']/*"/>	
    /// <msdn-id>hh447923</msdn-id>	
    /// <unmanaged>IMFMediaEngineEx</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineEx</unmanaged-short>	
    [Guid("83015ead-b1e6-40d0-a98a-37145ffe1ad1")]
    public partial class MediaEngineEx : SharpDX.MediaFoundation.MediaEngine
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngineEx"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngineEx(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngineEx"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngineEx(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngineEx(nativePointer);
        }


        /// <summary>	
        /// <p>Gets or sets the audio balance. </p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetBalance']/*"/>	
        /// <msdn-id>hh447934</msdn-id>	
        /// <unmanaged>GetBalance / SetBalance</unmanaged>	
        /// <unmanaged-short>GetBalance</unmanaged-short>	
        /// <unmanaged>double IMFMediaEngineEx::GetBalance()</unmanaged>
        public double Balance
        {
            get { return GetBalance(); }
            set { SetBalance(value); }
        }

        /// <summary>	
        /// <p>Gets various flags that describe the media resource.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetResourceCharacteristics']/*"/>	
        /// <msdn-id>hh447939</msdn-id>	
        /// <unmanaged>GetResourceCharacteristics</unmanaged>	
        /// <unmanaged-short>GetResourceCharacteristics</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetResourceCharacteristics([Out] RESOURCE_CHARACTERISTICS* pCharacteristics)</unmanaged>
        public SharpDX.MediaFoundation.ResourceCharacteristics ResourceCharacteristics
        {
            get { SharpDX.MediaFoundation.ResourceCharacteristics __output__; GetResourceCharacteristics(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets the number of streams in the media resource.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetNumberOfStreams']/*"/>	
        /// <msdn-id>hh447937</msdn-id>	
        /// <unmanaged>GetNumberOfStreams</unmanaged>	
        /// <unmanaged-short>GetNumberOfStreams</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetNumberOfStreams([Out] unsigned int* pdwStreamCount)</unmanaged>
        public int NumberOfStreams
        {
            get { int __output__; GetNumberOfStreams(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Queries whether the media resource contains protected content. </p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::IsProtected']/*"/>	
        /// <msdn-id>hh447950</msdn-id>	
        /// <unmanaged>IsProtected</unmanaged>	
        /// <unmanaged-short>IsProtected</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::IsProtected([Out] BOOL* pProtected)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsProtected
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; IsProtected_(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets or sets the time of the next timeline marker, if any.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetTimelineMarkerTimer']/*"/>	
        /// <msdn-id>hh447945</msdn-id>	
        /// <unmanaged>GetTimelineMarkerTimer / SetTimelineMarkerTimer</unmanaged>	
        /// <unmanaged-short>GetTimelineMarkerTimer</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetTimelineMarkerTimer([Out] double* pTimeToFire)</unmanaged>
        public double TimelineMarkerTimer
        {
            get { double __output__; GetTimelineMarkerTimer(out __output__); return __output__; }
            set { SetTimelineMarkerTimer(value); }
        }

        /// <summary>	
        /// <p>Queries whether the media resource contains stereoscopic 3D video.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::IsStereo3D']/*"/>	
        /// <msdn-id>hh447951</msdn-id>	
        /// <unmanaged>IsStereo3D</unmanaged>	
        /// <unmanaged-short>IsStereo3D</unmanaged-short>	
        /// <unmanaged>BOOL IMFMediaEngineEx::IsStereo3D()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsStereo3D
        {
            get { return IsStereo3D_(); }
        }

        /// <summary>	
        /// <p>For stereoscopic 3D video, gets the layout of the two views within a video frame.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetStereo3DFramePackingMode']/*"/>	
        /// <msdn-id>hh447941</msdn-id>	
        /// <unmanaged>GetStereo3DFramePackingMode / SetStereo3DFramePackingMode</unmanaged>	
        /// <unmanaged-short>GetStereo3DFramePackingMode</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetStereo3DFramePackingMode([Out] MF_MEDIA_ENGINE_S3D_PACKING_MODE* packMode)</unmanaged>
        public SharpDX.MediaFoundation.MediaEngineS3DPackingMode Stereo3DFramePackingMode
        {
            get { SharpDX.MediaFoundation.MediaEngineS3DPackingMode __output__; GetStereo3DFramePackingMode(out __output__); return __output__; }
            set { SetStereo3DFramePackingMode(value); }
        }

        /// <summary>	
        /// <p>For stereoscopic 3D video, queries how the Media Engine renders the 3D video content.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetStereo3DRenderMode']/*"/>	
        /// <msdn-id>hh447942</msdn-id>	
        /// <unmanaged>GetStereo3DRenderMode / SetStereo3DRenderMode</unmanaged>	
        /// <unmanaged-short>GetStereo3DRenderMode</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetStereo3DRenderMode([Out] MF3DVideoOutputType* outputType)</unmanaged>
        public SharpDX.MediaFoundation.Video3DOutputType Stereo3DRenderMode
        {
            get { SharpDX.MediaFoundation.Video3DOutputType __output__; GetStereo3DRenderMode(out __output__); return __output__; }
            set { SetStereo3DRenderMode(value); }
        }

        /// <summary>	
        /// <p>Gets a handle to the windowless swap chain.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>To enable windowless swap-chain mode, call <strong><see cref="SharpDX.MediaFoundation.MediaEngineEx.EnableWindowlessSwapchainMode"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetVideoSwapchainHandle']/*"/>	
        /// <msdn-id>hh447946</msdn-id>	
        /// <unmanaged>GetVideoSwapchainHandle</unmanaged>	
        /// <unmanaged-short>GetVideoSwapchainHandle</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetVideoSwapchainHandle([Out] void** phSwapchain)</unmanaged>
        public System.IntPtr VideoSwapchainHandle
        {
            get { System.IntPtr __output__; GetVideoSwapchainHandle(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets or sets the audio stream category used for the next call to <strong>SetSource</strong> or <strong>Load</strong>. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>For information on audio stream categories, see <strong><see cref="SharpDX.Multimedia.AudioStreamCategory"/> enumeration</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetAudioStreamCategory']/*"/>	
        /// <msdn-id>jj128310</msdn-id>	
        /// <unmanaged>GetAudioStreamCategory / SetAudioStreamCategory</unmanaged>	
        /// <unmanaged-short>GetAudioStreamCategory</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetAudioStreamCategory([Out] unsigned int* pCategory)</unmanaged>
        public int AudioStreamCategory
        {
            get { int __output__; GetAudioStreamCategory(out __output__); return __output__; }
            set { SetAudioStreamCategory(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the audio device endpoint role used for the next  call to <strong>SetSource</strong> or <strong>Load</strong>. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>For information on audio endpoint roles, see <strong>ERole  enumeration</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetAudioEndpointRole']/*"/>	
        /// <msdn-id>jj128309</msdn-id>	
        /// <unmanaged>GetAudioEndpointRole / SetAudioEndpointRole</unmanaged>	
        /// <unmanaged-short>GetAudioEndpointRole</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetAudioEndpointRole([Out] unsigned int* pRole)</unmanaged>
        public int AudioEndpointRole
        {
            get { int __output__; GetAudioEndpointRole(out __output__); return __output__; }
            set { SetAudioEndpointRole(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the real time mode used for the next call to <strong>SetSource</strong> or <strong>Load</strong>. </p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetRealTimeMode']/*"/>	
        /// <msdn-id>jj128311</msdn-id>	
        /// <unmanaged>GetRealTimeMode / SetRealTimeMode</unmanaged>	
        /// <unmanaged-short>GetRealTimeMode</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetRealTimeMode([Out] BOOL* pfEnabled)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool RealTimeMode
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; GetRealTimeMode(out __output__); return __output__; }
            set { SetRealTimeMode(value); }
        }

        /// <summary>	
        /// <p>Opens a media resource from a byte stream.</p>	
        /// </summary>	
        /// <param name="byteStreamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of the byte stream.</p> </dd></param>	
        /// <param name="uRLRef"><dd> <p>The URL of the byte stream.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::SetSourceFromByteStream']/*"/>	
        /// <msdn-id>hh447956</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::SetSourceFromByteStream([In] IMFByteStream* pByteStream,[In] void* pURL)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::SetSourceFromByteStream</unmanaged-short>	
        internal void SetSourceFromByteStream_(System.IntPtr byteStreamRef, System.IntPtr uRLRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)byteStreamRef, (void*)uRLRef, ((void**)(*(void**)_nativePointer))[45]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a playback statistic from the Media Engine.</p>	
        /// </summary>	
        /// <param name="statisticID"><dd> <p>A member of the <strong><see cref="SharpDX.MediaFoundation.MediaEngineStatistic"/></strong> enumeration that identifies the statistic to get.</p> </dd></param>	
        /// <param name="statisticRef"><dd> <p>A reference to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that receives the statistic. The data type and meaning of this value depends on the value of <em>StatisticID</em>. The caller must free the <strong><see cref="SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetStatistics']/*"/>	
        /// <msdn-id>hh447940</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetStatistics([In] MF_MEDIA_ENGINE_STATISTIC StatisticID,[Out] PROPVARIANT* pStatistic)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::GetStatistics</unmanaged-short>	
        public void GetStatistics(SharpDX.MediaFoundation.MediaEngineStatistic statisticID, out SharpDX.Win32.Variant statisticRef)
        {
            unsafe
            {
                statisticRef = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* statisticRef_ = &statisticRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)statisticID), statisticRef_, ((void**)(*(void**)_nativePointer))[46]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Updates the source rectangle, destination rectangle, and border color for the video.</p>	
        /// </summary>	
        /// <param name="srcRef"><dd> <p>A reference to an <strong><see cref="SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure that specifies the source rectangle. The source rectangle defines the area of the video frame that is displayed. If this parameter is <strong><c>null</c></strong>, the entire video frame is displayed.</p> </dd></param>	
        /// <param name="dstRef"><dd> <p>A reference to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that specifies the destination rectangle. The destination rectangle defines the area of the window or DirectComposition visual where the video is drawn.</p> </dd></param>	
        /// <param name="borderClrRef"><dd> <p>A reference to an <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that specifies the border color. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>In rendering mode, call this method to reposition the video, update the border color, or repaint the video frame. If all of the parameters are <strong><c>null</c></strong>, the method repaints the most recent video frame.</p><p>In frame-server mode, this method has no effect.</p><p>See <strong>Video Processor MFT</strong> for info regarding source and destination rectangles in the <strong>Video Processor MFT</strong>.   </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::UpdateVideoStream']/*"/>	
        /// <msdn-id>hh447961</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::UpdateVideoStream([In, Optional] const MFVideoNormalizedRect* pSrc,[In, Optional] const RECT* pDst,[In, Optional] const MFARGB* pBorderClr)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::UpdateVideoStream</unmanaged-short>	
        public void UpdateVideoStream(SharpDX.MediaFoundation.VideoNormalizedRect? srcRef, SharpDX.Mathematics.Interop.RawRectangle? dstRef, SharpDX.Mathematics.Interop.RawColorBGRA? borderClrRef)
        {
            unsafe
            {
                SharpDX.MediaFoundation.VideoNormalizedRect srcRef_;
                if (srcRef.HasValue)
                    srcRef_ = srcRef.Value;
                SharpDX.Mathematics.Interop.RawRectangle dstRef_;
                if (dstRef.HasValue)
                    dstRef_ = dstRef.Value;
                SharpDX.Mathematics.Interop.RawColorBGRA borderClrRef_;
                if (borderClrRef.HasValue)
                    borderClrRef_ = borderClrRef.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (srcRef.HasValue) ? &srcRef_ : (void*)IntPtr.Zero, (dstRef.HasValue) ? &dstRef_ : (void*)IntPtr.Zero, (borderClrRef.HasValue) ? &borderClrRef_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[47]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the audio balance. </p>	
        /// </summary>	
        /// <returns><p>Returns the balance. The value can be any number in the following range (inclusive). </p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt>-1</dt> </dl> </td><td> <p>The left channel is at full volume; the right channel is silent.</p> </td></tr> <tr><td> <dl> <dt>1</dt> </dl> </td><td> <p>The right channel is at full volume; the left channel is silent.</p> </td></tr> </table><p>?</p><p>If the value is zero, the left and right channels are at equal volumes. The default value is zero. </p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetBalance']/*"/>	
        /// <msdn-id>hh447934</msdn-id>	
        /// <unmanaged>double IMFMediaEngineEx::GetBalance()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::GetBalance</unmanaged-short>	
        internal double GetBalance()
        {
            unsafe
            {
                double __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callidouble(_nativePointer, ((void**)(*(void**)_nativePointer))[48]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Sets the audio balance.</p>	
        /// </summary>	
        /// <param name="balance"><dd> <p>The audio balance. The value can be any number in the following range (inclusive). </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>-1</dt> </dl> </td><td> <p>The left channel is at full volume; the right channel is silent.</p> </td></tr> <tr><td> <dl> <dt>1</dt> </dl> </td><td> <p>The right channel is at full volume; the left channel is silent.</p> </td></tr> </table> <p>?</p> <p>If the value is zero, the left and right channels are at equal volumes. The default value is zero. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>When the audio balance changes, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.BalanceChange"/></strong> event. See <strong>IMFMediaEventNotify::EventNotify</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::SetBalance']/*"/>	
        /// <msdn-id>hh447954</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::SetBalance([In] double balance)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::SetBalance</unmanaged-short>	
        internal void SetBalance(double balance)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, balance, ((void**)(*(void**)_nativePointer))[49]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries whether the Media Engine can play at a specified playback rate.</p>	
        /// </summary>	
        /// <param name="rate"><dd> <p>The requested playback rate.</p> </dd></param>	
        /// <returns><p>Returns <strong>TRUE</strong> if the playback rate is supported, or <strong><see cref="SharpDX.Result.False"/></strong> otherwise.</p></returns>	
        /// <remarks>	
        /// <p>Playback rates are expressed as a ratio of the current rate to the normal rate. For example, 1.0 is normal playback speed, 0.5 is half speed, and 2.0 is 2? speed. Positive values mean forward playback, and negative values mean reverse playback.</p><p>The results of this method can vary depending on the media resource that is currently loaded. Some media formats might support faster playback rates than others. Also, some formats might not support reverse play.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::IsPlaybackRateSupported']/*"/>	
        /// <msdn-id>hh447949</msdn-id>	
        /// <unmanaged>BOOL IMFMediaEngineEx::IsPlaybackRateSupported([In] double rate)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::IsPlaybackRateSupported</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool IsPlaybackRateSupported(double rate)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, rate, ((void**)(*(void**)_nativePointer))[50]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Steps forward or backward one frame.</p>	
        /// </summary>	
        /// <param name="forward"><dd> <p>Specify <strong>TRUE</strong> to step forward or <strong><see cref="SharpDX.Result.False"/></strong> to step backward.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The frame-step direction is independent of the current playback direction.</p><p>This method completes asynchronously. When the operation completes, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.FrameStepCompleted"/></strong> event and enters the paused state.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::FrameStep']/*"/>	
        /// <msdn-id>hh447933</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::FrameStep([In] BOOL Forward)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::FrameStep</unmanaged-short>	
        public void FrameStep(SharpDX.Mathematics.Interop.RawBool forward)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint6(_nativePointer, forward, ((void**)(*(void**)_nativePointer))[51]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets various flags that describe the media resource.</p>	
        /// </summary>	
        /// <param name="characteristicsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.MediaSourceCharacteristics"/> enumeration</strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetResourceCharacteristics']/*"/>	
        /// <msdn-id>hh447939</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetResourceCharacteristics([Out] RESOURCE_CHARACTERISTICS* pCharacteristics)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::GetResourceCharacteristics</unmanaged-short>	
        internal void GetResourceCharacteristics(out SharpDX.MediaFoundation.ResourceCharacteristics characteristicsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* characteristicsRef_ = &characteristicsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, characteristicsRef_, ((void**)(*(void**)_nativePointer))[52]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a presentation attribute from the media resource.</p>	
        /// </summary>	
        /// <param name="guidMFAttribute"><dd> <p>The attribute to query. For a list of presentation attributes, see Presentation Descriptor Attributes.</p> </dd></param>	
        /// <param name="vValueRef"><dd> <p>A reference to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that receives the value. The method fills the <strong><see cref="SharpDX.Win32.Variant"/></strong> with a copy of the stored value. The caller must free the <strong><see cref="SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetPresentationAttribute']/*"/>	
        /// <msdn-id>hh447938</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetPresentationAttribute([In] const GUID&amp; guidMFAttribute,[Out] PROPVARIANT* pvValue)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::GetPresentationAttribute</unmanaged-short>	
        public void GetPresentationAttribute(System.Guid guidMFAttribute, out SharpDX.Win32.Variant vValueRef)
        {
            unsafe
            {
                vValueRef = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* vValueRef_ = &vValueRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidMFAttribute, vValueRef_, ((void**)(*(void**)_nativePointer))[53]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the number of streams in the media resource.</p>	
        /// </summary>	
        /// <param name="dwStreamCountRef"><dd> <p>Receives the number of streams.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetNumberOfStreams']/*"/>	
        /// <msdn-id>hh447937</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetNumberOfStreams([Out] unsigned int* pdwStreamCount)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::GetNumberOfStreams</unmanaged-short>	
        internal void GetNumberOfStreams(out int dwStreamCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwStreamCountRef_ = &dwStreamCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamCountRef_, ((void**)(*(void**)_nativePointer))[54]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a stream-level attribute from the media resource.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of the stream. To get the number of streams, call <strong><see cref="SharpDX.MediaFoundation.MediaEngineEx.GetNumberOfStreams"/></strong>.</p> </dd></param>	
        /// <param name="guidMFAttribute"><dd> <p>The attribute to query. Possible values are listed in the following topics:</p> <ul> <li> Stream Descriptor Attributes </li> <li> Media Type Attributes </li> </ul> </dd></param>	
        /// <param name="vValueRef"><dd> <p>A reference to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that receives the value. The method fills the <strong><see cref="SharpDX.Win32.Variant"/></strong> with a copy of the stored value. Call <strong>PropVariantClear</strong> to free the memory allocated by the method. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetStreamAttribute']/*"/>	
        /// <msdn-id>hh447943</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetStreamAttribute([In] unsigned int dwStreamIndex,[In] const GUID&amp; guidMFAttribute,[Out] PROPVARIANT* pvValue)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::GetStreamAttribute</unmanaged-short>	
        public void GetStreamAttribute(int dwStreamIndex, System.Guid guidMFAttribute, out SharpDX.Win32.Variant vValueRef)
        {
            unsafe
            {
                vValueRef = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* vValueRef_ = &vValueRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, &guidMFAttribute, vValueRef_, ((void**)(*(void**)_nativePointer))[55]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries whether a stream is selected to play.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of the stream. To get the number of streams, call <strong><see cref="SharpDX.MediaFoundation.MediaEngineEx.GetNumberOfStreams"/></strong>.</p> </dd></param>	
        /// <param name="enabledRef"><dd> <p>Receives a Boolean value.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>TRUE</strong></strong></dt> </dl> </td><td> <p>The stream is selected. During playback, this stream will play.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.Result.False"/></strong></strong></dt> </dl> </td><td> <p>The stream is not selected. During playback, this stream will not play.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetStreamSelection']/*"/>	
        /// <msdn-id>hh447944</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetStreamSelection([In] unsigned int dwStreamIndex,[Out] BOOL* pEnabled)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::GetStreamSelection</unmanaged-short>	
        public void GetStreamSelection(int dwStreamIndex, out SharpDX.Mathematics.Interop.RawBool enabledRef)
        {
            unsafe
            {
                enabledRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* enabledRef_ = &enabledRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, enabledRef_, ((void**)(*(void**)_nativePointer))[56]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Selects or deselects a stream for playback. </p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of the stream. To get the number of streams, call <strong><see cref="SharpDX.MediaFoundation.MediaEngineEx.GetNumberOfStreams"/></strong>.</p> </dd></param>	
        /// <param name="enabled"><dd> <p>Specifies whether to select or deselect the stream.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>TRUE</strong></strong></dt> </dl> </td><td> <p>The stream is selected. During playback, this stream will play.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.Result.False"/></strong></strong></dt> </dl> </td><td> <p>The stream is not selected. During playback, this stream will not play.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::SetStreamSelection']/*"/>	
        /// <msdn-id>hh447959</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::SetStreamSelection([In] unsigned int dwStreamIndex,[In] BOOL Enabled)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::SetStreamSelection</unmanaged-short>	
        public void SetStreamSelection(int dwStreamIndex, SharpDX.Mathematics.Interop.RawBool enabled)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint19(_nativePointer, dwStreamIndex, enabled, ((void**)(*(void**)_nativePointer))[57]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Applies the stream selections from previous calls to <strong>SetStreamSelection</strong>.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::ApplyStreamSelections']/*"/>	
        /// <msdn-id>jj151917</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::ApplyStreamSelections()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::ApplyStreamSelections</unmanaged-short>	
        public void ApplyStreamSelections()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[58]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries whether the media resource contains protected content. </p>	
        /// </summary>	
        /// <param name="protectedRef"><dd> <p>Receives the value <strong>TRUE</strong> if the media resource contains protected content, or <strong><see cref="SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::IsProtected']/*"/>	
        /// <msdn-id>hh447950</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::IsProtected([Out] BOOL* pProtected)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::IsProtected</unmanaged-short>	
        internal void IsProtected_(out SharpDX.Mathematics.Interop.RawBool protectedRef)
        {
            unsafe
            {
                protectedRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* protectedRef_ = &protectedRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, protectedRef_, ((void**)(*(void**)_nativePointer))[59]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Inserts a video effect.</p>	
        /// </summary>	
        /// <param name="effectRef"><dd> <p>One of the following: </p> <ul> <li>A reference to the <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> interface of a Media Foundation transform (MFT) that implements the video effect.</li> <li>A reference to the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface of an activation object. The activation object must create an MFT for the video effect.</li> </ul> </dd></param>	
        /// <param name="fOptional"><dd> <p>Specifies whether the effect is optional.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>TRUE</strong></strong></dt> </dl> </td><td> <p>The effect is optional. If the Media Engine cannot add the effect, it ignores the effect and  continues playback.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.Result.False"/></strong></strong></dt> </dl> </td><td> <p>The effect is required. If the Media Engine object cannot add the effect, a playback error occurs.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The maximum number of video effects was reached.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The effect is applied when the next media resource is loaded.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::InsertVideoEffect']/*"/>	
        /// <msdn-id>hh447948</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::InsertVideoEffect([In] IUnknown* pEffect,[In] BOOL fOptional)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::InsertVideoEffect</unmanaged-short>	
        public void InsertVideoEffect(SharpDX.ComObject effectRef, SharpDX.Mathematics.Interop.RawBool fOptional)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint15(_nativePointer, (void*)((effectRef == null) ? IntPtr.Zero : effectRef.NativePointer), fOptional, ((void**)(*(void**)_nativePointer))[60]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Inserts an audio effect.</p>	
        /// </summary>	
        /// <param name="effectRef"><dd> <p>One of the following: </p> <ul> <li>A reference to the <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> interface of a Media Foundation transform (MFT) that implements the audio effect.</li> <li>A reference to the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface of an activation object. The activation object must create an MFT for the audio effect.</li> </ul> </dd></param>	
        /// <param name="fOptional"><dd> <p>Specifies whether the effect is optional.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>TRUE</strong></strong></dt> </dl> </td><td> <p>The effect is optional. If the Media Engine cannot add the effect, it ignores the effect and  continues playback.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.Result.False"/></strong></strong></dt> </dl> </td><td> <p>The effect is required. If the Media Engine object cannot add the effect, a playback error occurs.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The maximum number of audio effects was reached.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The effect is applied when the next media resource is loaded.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::InsertAudioEffect']/*"/>	
        /// <msdn-id>hh447947</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::InsertAudioEffect([In] IUnknown* pEffect,[In] BOOL fOptional)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::InsertAudioEffect</unmanaged-short>	
        public void InsertAudioEffect(SharpDX.ComObject effectRef, SharpDX.Mathematics.Interop.RawBool fOptional)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint15(_nativePointer, (void*)((effectRef == null) ? IntPtr.Zero : effectRef.NativePointer), fOptional, ((void**)(*(void**)_nativePointer))[61]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Removes all audio and video effects.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Call this method to remove all of the effects that were added with the <strong>InsertAudioEffect</strong> and <strong>InsertVideoEffect</strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::RemoveAllEffects']/*"/>	
        /// <msdn-id>hh447952</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::RemoveAllEffects()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::RemoveAllEffects</unmanaged-short>	
        public void RemoveAllEffects()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[62]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Specifies a presentation time when the Media Engine will send a marker event.</p>	
        /// </summary>	
        /// <param name="timeToFire"><dd> <p>The presentation time for the marker event, in seconds.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>When playback reaches the time specified by <em>timeToFire</em>, the Media Engine sends an <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.TimelineMarker"/></strong> event through the <strong><see cref="SharpDX.MediaFoundation.MediaEngineNotify.EventNotify"/></strong> method. Calling this method cancels any previous marker that is still pending. </p><p>If the application seeks past the marker point, the Media Engine cancels the marker and does not send the event.</p><p>During  forward playback, set <em>timeToFire</em> to a value greater than the current playback position. During reverse playback, set <em>timeToFire</em> to a value less than the playback position.</p><p>To cancel a marker, call <strong><see cref="SharpDX.MediaFoundation.MediaEngineEx.CancelTimelineMarkerTimer"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::SetTimelineMarkerTimer']/*"/>	
        /// <msdn-id>hh447960</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::SetTimelineMarkerTimer([In] double timeToFire)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::SetTimelineMarkerTimer</unmanaged-short>	
        internal void SetTimelineMarkerTimer(double timeToFire)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, timeToFire, ((void**)(*(void**)_nativePointer))[63]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the time of the next timeline marker, if any.</p>	
        /// </summary>	
        /// <param name="timeToFireRef"><dd> <p>Receives the marker time, in seconds. If no marker is set, this parameter receives the value <strong>NaN</strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetTimelineMarkerTimer']/*"/>	
        /// <msdn-id>hh447945</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetTimelineMarkerTimer([Out] double* pTimeToFire)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::GetTimelineMarkerTimer</unmanaged-short>	
        internal void GetTimelineMarkerTimer(out double timeToFireRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* timeToFireRef_ = &timeToFireRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, timeToFireRef_, ((void**)(*(void**)_nativePointer))[64]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Cancels the next pending timeline marker.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Call this method to cancel the <strong><see cref="SharpDX.MediaFoundation.MediaEngineEx.SetTimelineMarkerTimer"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::CancelTimelineMarkerTimer']/*"/>	
        /// <msdn-id>hh447929</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::CancelTimelineMarkerTimer()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::CancelTimelineMarkerTimer</unmanaged-short>	
        public void CancelTimelineMarkerTimer()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[65]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries whether the media resource contains stereoscopic 3D video.</p>	
        /// </summary>	
        /// <returns><p>Returns <strong>TRUE</strong> if the media resource contains 3D video, or <strong><see cref="SharpDX.Result.False"/></strong> otherwise.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::IsStereo3D']/*"/>	
        /// <msdn-id>hh447951</msdn-id>	
        /// <unmanaged>BOOL IMFMediaEngineEx::IsStereo3D()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::IsStereo3D</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsStereo3D_()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[66]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>For stereoscopic 3D video, gets the layout of the two views within a video frame.</p>	
        /// </summary>	
        /// <param name="ackModeRef"><dd> <p>Receives a member of the <strong><see cref="SharpDX.MediaFoundation.MediaEngineS3DPackingMode"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetStereo3DFramePackingMode']/*"/>	
        /// <msdn-id>hh447941</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetStereo3DFramePackingMode([Out] MF_MEDIA_ENGINE_S3D_PACKING_MODE* packMode)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::GetStereo3DFramePackingMode</unmanaged-short>	
        internal void GetStereo3DFramePackingMode(out SharpDX.MediaFoundation.MediaEngineS3DPackingMode ackModeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* ackModeRef_ = &ackModeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ackModeRef_, ((void**)(*(void**)_nativePointer))[67]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>For stereoscopic 3D video, sets the layout of the two views within a video frame.</p>	
        /// </summary>	
        /// <param name="packMode"><dd> <p>A member of the <strong><see cref="SharpDX.MediaFoundation.MediaEngineS3DPackingMode"/></strong> enumeration that specifies the layout. The two views can be arranged side-by-side, or top-to-bottom.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::SetStereo3DFramePackingMode']/*"/>	
        /// <msdn-id>hh447957</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::SetStereo3DFramePackingMode([In] MF_MEDIA_ENGINE_S3D_PACKING_MODE packMode)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::SetStereo3DFramePackingMode</unmanaged-short>	
        internal void SetStereo3DFramePackingMode(SharpDX.MediaFoundation.MediaEngineS3DPackingMode packMode)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)packMode), ((void**)(*(void**)_nativePointer))[68]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>For stereoscopic 3D video, queries how the Media Engine renders the 3D video content.</p>	
        /// </summary>	
        /// <param name="outputType"><dd> <p>Receives a member of the <strong><see cref="SharpDX.MediaFoundation.Video3DOutputType"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetStereo3DRenderMode']/*"/>	
        /// <msdn-id>hh447942</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetStereo3DRenderMode([Out] MF3DVideoOutputType* outputType)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::GetStereo3DRenderMode</unmanaged-short>	
        internal void GetStereo3DRenderMode(out SharpDX.MediaFoundation.Video3DOutputType outputType)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* outputType_ = &outputType)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, outputType_, ((void**)(*(void**)_nativePointer))[69]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>For stereoscopic 3D video, specifies how the Media Engine renders the 3D video content.</p>	
        /// </summary>	
        /// <param name="outputType"><dd> <p>A member of the <strong><see cref="SharpDX.MediaFoundation.Video3DOutputType"/></strong> enumeration that specifies the 3D video rendering mode.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::SetStereo3DRenderMode']/*"/>	
        /// <msdn-id>hh447958</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::SetStereo3DRenderMode([In] MF3DVideoOutputType outputType)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::SetStereo3DRenderMode</unmanaged-short>	
        internal void SetStereo3DRenderMode(SharpDX.MediaFoundation.Video3DOutputType outputType)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)outputType), ((void**)(*(void**)_nativePointer))[70]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Enables or disables windowless swap-chain mode.</p>	
        /// </summary>	
        /// <param name="fEnable"><dd> <p>If <strong>TRUE</strong>, windowless swap-chain mode is enabled. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>In windowless swap-chain mode, the Media Engine creates a windowless swap chain and presents video frames to the swap chain. To render the video, call <strong><see cref="SharpDX.MediaFoundation.MediaEngineEx.GetVideoSwapchainHandle"/></strong> to get a handle to the swap chain, and then associate the handle with a Microsoft DirectComposition visual.  </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::EnableWindowlessSwapchainMode']/*"/>	
        /// <msdn-id>hh447932</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::EnableWindowlessSwapchainMode([In] BOOL fEnable)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::EnableWindowlessSwapchainMode</unmanaged-short>	
        public void EnableWindowlessSwapchainMode(SharpDX.Mathematics.Interop.RawBool fEnable)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint6(_nativePointer, fEnable, ((void**)(*(void**)_nativePointer))[71]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a handle to the windowless swap chain.</p>	
        /// </summary>	
        /// <param name="hSwapchainRef"><dd> <p>Receives a handle to the swap chain.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To enable windowless swap-chain mode, call <strong><see cref="SharpDX.MediaFoundation.MediaEngineEx.EnableWindowlessSwapchainMode"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetVideoSwapchainHandle']/*"/>	
        /// <msdn-id>hh447946</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetVideoSwapchainHandle([Out] void** phSwapchain)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::GetVideoSwapchainHandle</unmanaged-short>	
        internal void GetVideoSwapchainHandle(out System.IntPtr hSwapchainRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* hSwapchainRef_ = &hSwapchainRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, hSwapchainRef_, ((void**)(*(void**)_nativePointer))[72]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Enables or disables mirroring of the video.</p>	
        /// </summary>	
        /// <param name="fEnable"><dd> <p>If <strong>TRUE</strong>, the video is mirrored horizontally. Otherwise, the video is displayed normally.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::EnableHorizontalMirrorMode']/*"/>	
        /// <msdn-id>hh447931</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::EnableHorizontalMirrorMode([In] BOOL fEnable)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::EnableHorizontalMirrorMode</unmanaged-short>	
        public void EnableHorizontalMirrorMode(SharpDX.Mathematics.Interop.RawBool fEnable)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint6(_nativePointer, fEnable, ((void**)(*(void**)_nativePointer))[73]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the audio stream category used for the next call to <strong>SetSource</strong> or <strong>Load</strong>. </p>	
        /// </summary>	
        /// <param name="categoryRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>For information on audio stream categories, see <strong><see cref="SharpDX.Multimedia.AudioStreamCategory"/> enumeration</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetAudioStreamCategory']/*"/>	
        /// <msdn-id>jj128310</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetAudioStreamCategory([Out] unsigned int* pCategory)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::GetAudioStreamCategory</unmanaged-short>	
        internal void GetAudioStreamCategory(out int categoryRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* categoryRef_ = &categoryRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, categoryRef_, ((void**)(*(void**)_nativePointer))[74]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the audio stream category for the next call to  <strong>SetSource</strong> or <strong>Load</strong>. </p>	
        /// </summary>	
        /// <param name="category">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>For information on audio stream categories, see <strong><see cref="SharpDX.Multimedia.AudioStreamCategory"/> enumeration</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::SetAudioStreamCategory']/*"/>	
        /// <msdn-id>jj128313</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::SetAudioStreamCategory([In] unsigned int category)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::SetAudioStreamCategory</unmanaged-short>	
        internal void SetAudioStreamCategory(int category)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, category, ((void**)(*(void**)_nativePointer))[75]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the audio device endpoint role used for the next  call to <strong>SetSource</strong> or <strong>Load</strong>. </p>	
        /// </summary>	
        /// <param name="roleRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>For information on audio endpoint roles, see <strong>ERole  enumeration</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetAudioEndpointRole']/*"/>	
        /// <msdn-id>jj128309</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetAudioEndpointRole([Out] unsigned int* pRole)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::GetAudioEndpointRole</unmanaged-short>	
        internal void GetAudioEndpointRole(out int roleRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* roleRef_ = &roleRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, roleRef_, ((void**)(*(void**)_nativePointer))[76]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the audio device endpoint used for the next call to <strong>SetSource</strong> or <strong>Load</strong>. </p>	
        /// </summary>	
        /// <param name="role">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>For information on audio endpoint roles, see <strong>ERole  enumeration</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::SetAudioEndpointRole']/*"/>	
        /// <msdn-id>jj128312</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::SetAudioEndpointRole([In] unsigned int role)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::SetAudioEndpointRole</unmanaged-short>	
        internal void SetAudioEndpointRole(int role)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, role, ((void**)(*(void**)_nativePointer))[77]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the real time mode used for the next call to <strong>SetSource</strong> or <strong>Load</strong>. </p>	
        /// </summary>	
        /// <param name="fEnabledRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::GetRealTimeMode']/*"/>	
        /// <msdn-id>jj128311</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::GetRealTimeMode([Out] BOOL* pfEnabled)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::GetRealTimeMode</unmanaged-short>	
        internal void GetRealTimeMode(out SharpDX.Mathematics.Interop.RawBool fEnabledRef)
        {
            unsafe
            {
                fEnabledRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fEnabledRef_ = &fEnabledRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fEnabledRef_, ((void**)(*(void**)_nativePointer))[78]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the real time mode used for the next call to  <strong>SetSource</strong> or <strong>Load</strong>. </p>	
        /// </summary>	
        /// <param name="fEnable">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::SetRealTimeMode']/*"/>	
        /// <msdn-id>jj128315</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::SetRealTimeMode([In] BOOL fEnable)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::SetRealTimeMode</unmanaged-short>	
        internal void SetRealTimeMode(SharpDX.Mathematics.Interop.RawBool fEnable)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint6(_nativePointer, fEnable, ((void**)(*(void**)_nativePointer))[79]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Seeks to a new playback position using the  specified <strong><see cref="SharpDX.MediaFoundation.MediaEngineSeekMode"/></strong>.</p>	
        /// </summary>	
        /// <param name="seekTime">No documentation.</param>	
        /// <param name="seekMode">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::SetCurrentTimeEx']/*"/>	
        /// <msdn-id>jj128314</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::SetCurrentTimeEx([In] double seekTime,[In] MF_MEDIA_ENGINE_SEEK_MODE seekMode)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::SetCurrentTimeEx</unmanaged-short>	
        public void SetCurrentTimeEx(double seekTime, SharpDX.MediaFoundation.MediaEngineSeekMode seekMode)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, seekTime, unchecked((int)seekMode), ((void**)(*(void**)_nativePointer))[80]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Enables or disables the time update timer.</p>	
        /// </summary>	
        /// <param name="fEnableTimer"><dd> <p>If <strong>TRUE</strong>, the update timer is enabled. Otherwise, the timer is disabled.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineEx::EnableTimeUpdateTimer']/*"/>	
        /// <msdn-id>jj128308</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineEx::EnableTimeUpdateTimer([In] BOOL fEnableTimer)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineEx::EnableTimeUpdateTimer</unmanaged-short>	
        public void EnableTimeUpdateTimer(SharpDX.Mathematics.Interop.RawBool fEnableTimer)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint6(_nativePointer, fEnableTimer, ((void**)(*(void**)_nativePointer))[81]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables an application to load media resources in the Media Engine.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To use this interface, set the <see cref="SharpDX.MediaFoundation.MediaEngineAttributeKeys.Extension"/> attribute when you call the <strong><see cref="SharpDX.MediaFoundation.MediaEngineClassFactory.CreateInstance"/></strong> method.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineExtension']/*"/>	
    /// <msdn-id>hh447924</msdn-id>	
    /// <unmanaged>IMFMediaEngineExtension</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineExtension</unmanaged-short>	
    [Guid("2f69d622-20b5-41e9-afdf-89ced1dda04e")]
    public partial class MediaEngineExtension : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngineExtension"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngineExtension(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngineExtension"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngineExtension(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngineExtension(nativePointer);
        }


        /// <summary>	
        /// <p>Queries whether the object can load a specified type of media resource.</p>	
        /// </summary>	
        /// <param name="audioOnly"><dd> <p>If <strong>TRUE</strong>, the Media Engine is set to audio-only mode. Otherwise, the Media Engine is set to audio-video mode.</p> </dd></param>	
        /// <param name="mimeType"><dd> <p>A string that contains a MIME type with an optional codecs parameter, as defined in RFC 4281.</p> </dd></param>	
        /// <param name="answerRef"><dd> <p>Receives a member of the <strong><see cref="SharpDX.MediaFoundation.MediaEngineCanPlay"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Implement this method if your Media Engine extension supports one or more MIME types.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineExtension::CanPlayType']/*"/>	
        /// <msdn-id>hh447927</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineExtension::CanPlayType([In] BOOL AudioOnly,[In] wchar_t* MimeType,[Out] MF_MEDIA_ENGINE_CANPLAY* pAnswer)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineExtension::CanPlayType</unmanaged-short>	
        public void CanPlayType(SharpDX.Mathematics.Interop.RawBool audioOnly, string mimeType, out SharpDX.MediaFoundation.MediaEngineCanPlay answerRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* mimeType_ = mimeType)
                fixed (void* answerRef_ = &answerRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint17(_nativePointer, audioOnly, (void*)mimeType_, answerRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Begins an asynchronous request to create either a byte stream or a media source.</p>	
        /// </summary>	
        /// <param name="bstrURL"><dd> <p>The URL of the media resource.</p> </dd></param>	
        /// <param name="byteStreamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface.</p> <p>If the <em>type</em> parameter equals  <strong><see cref="SharpDX.MediaFoundation.ObjectType.ByteStream"/></strong>, this parameter is <strong><c>null</c></strong>. </p> <p>If <em>type</em> equals <strong><see cref="SharpDX.MediaFoundation.ObjectType.MediaSource"/></strong>, this parameter either contains a reference to a byte stream or is <strong><c>null</c></strong>. See Remarks for more information.</p> </dd></param>	
        /// <param name="type"><dd> <p>A member of the <strong><see cref="SharpDX.MediaFoundation.ObjectType"/></strong> enumeration that specifies which type of object to create.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.ObjectType.ByteStream"/></strong></dt> </dl> </td><td> <p>Create a byte stream. The byte stream must support the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.ObjectType.MediaSource"/></strong></dt> </dl> </td><td> <p>Create a media source. The media source must support the <strong><see cref="SharpDX.MediaFoundation.MediaSource"/></strong> interface.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="iUnknownCancelCookieOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface.  This reference can be used to cancel the asynchronous operation, by passing the reference to the <strong><see cref="SharpDX.MediaFoundation.MediaEngineExtension.CancelObjectCreation"/></strong> method. </p> <p>The caller must release the interface. This parameter can be <c>null</c>.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface. This interface is used to signal the completion of the asynchronous operation.</p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of an object impemented by the caller. You can use this object to hold state information for the callback. The object is returned to the caller when the callback is invoked. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method requests the object to create either a byte stream or a media source, depending on the value of the <em>type</em> parameter:</p><ul> <li>If <em>type</em> is <strong><see cref="SharpDX.MediaFoundation.ObjectType.ByteStream"/></strong>, the method creates a byte stream for the URL that is specified in <em>bstrURL</em>. In this case, the <em>pByteStream</em> parameter is <strong><c>null</c></strong>. </li> <li>If <em>type</em> is <strong><see cref="SharpDX.MediaFoundation.ObjectType.MediaSource"/></strong>, the method creates a media source, using the byte stream that is specified in the <em>pByteStream</em> parameter. Note that <em>pByteStream</em> can also be <strong><c>null</c></strong> in this case.</li> </ul><p>The method is performed asynchronously. The Media Engine calls the <strong><see cref="SharpDX.MediaFoundation.MediaEngineExtension.EndCreateObject"/></strong> method to complete the operation.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineExtension::BeginCreateObject']/*"/>	
        /// <msdn-id>hh447925</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineExtension::BeginCreateObject([In] wchar_t* bstrURL,[In, Optional] IMFByteStream* pByteStream,[In] MF_OBJECT_TYPE type,[Out] IUnknown** ppIUnknownCancelCookie,[In] IMFAsyncCallback* pCallback,[In, Optional] IUnknown* punkState)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineExtension::BeginCreateObject</unmanaged-short>	
        internal void BeginCreateObject__(string bstrURL, System.IntPtr byteStreamRef, SharpDX.MediaFoundation.ObjectType type, out SharpDX.ComObject iUnknownCancelCookieOut, System.IntPtr callbackRef, SharpDX.ComObject unkStateRef)
        {
            unsafe
            {
                IntPtr iUnknownCancelCookieOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* bstrURL_ = bstrURL)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)bstrURL_, (void*)byteStreamRef, unchecked((int)type), &iUnknownCancelCookieOut_, (void*)callbackRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), ((void**)(*(void**)_nativePointer))[4]);
                iUnknownCancelCookieOut = (iUnknownCancelCookieOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(iUnknownCancelCookieOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Cancels the current request to create an object.</p>	
        /// </summary>	
        /// <param name="iUnknownCancelCookieRef"><dd> <p>The reference that was returned in the the <em>ppIUnknownCancelCookie</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.MediaEngineExtension.BeginCreateObject__"/></strong> method. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method attempts to cancel a previous call to <strong>BeginCreateObject</strong>. Because that method is asynchronous, however, it might complete before the operation can be canceled.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineExtension::CancelObjectCreation']/*"/>	
        /// <msdn-id>hh447926</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineExtension::CancelObjectCreation([In] IUnknown* pIUnknownCancelCookie)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineExtension::CancelObjectCreation</unmanaged-short>	
        public void CancelObjectCreation(SharpDX.ComObject iUnknownCancelCookieRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iUnknownCancelCookieRef == null) ? IntPtr.Zero : iUnknownCancelCookieRef.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Completes an asynchronous request to create a byte stream or media source.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface.</p> </dd></param>	
        /// <param name="objectOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of the byte stream or media source. The caller must release the interface</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The Media Engine calls this method to complete the <strong><see cref="SharpDX.MediaFoundation.MediaEngineExtension.BeginCreateObject__"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineExtension::EndCreateObject']/*"/>	
        /// <msdn-id>hh447928</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineExtension::EndCreateObject([In] IMFAsyncResult* pResult,[Out] IUnknown** ppObject)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineExtension::EndCreateObject</unmanaged-short>	
        public void EndCreateObject(SharpDX.MediaFoundation.AsyncResult resultRef, out SharpDX.ComObject objectOut)
        {
            unsafe
            {
                IntPtr objectOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), &objectOut_, ((void**)(*(void**)_nativePointer))[6]);
                objectOut = (objectOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(objectOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a callback to the media engine to notify key request data.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineNeedKeyNotify']/*"/>	
    /// <msdn-id>dn280696</msdn-id>	
    /// <unmanaged>IMFMediaEngineNeedKeyNotify</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineNeedKeyNotify</unmanaged-short>	
    [Guid("46a30204-a696-4b18-8804-246b8f031bb1")]
    public partial class MediaEngineNeedKeyNotify : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngineNeedKeyNotify"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngineNeedKeyNotify(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngineNeedKeyNotify"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngineNeedKeyNotify(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngineNeedKeyNotify(nativePointer);
        }


        /// <summary>	
        /// <p>Notifies the application that a key or keys are needed along with any initialization data.</p>	
        /// </summary>	
        /// <param name="initData"><dd> <p>The initialization data.</p> </dd></param>	
        /// <param name="cb"><dd> <p>The count in bytes of <em>initData</em>.</p> </dd></param>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineNeedKeyNotify::NeedKey']/*"/>	
        /// <msdn-id>dn280697</msdn-id>	
        /// <unmanaged>void IMFMediaEngineNeedKeyNotify::NeedKey([In, Buffer, Optional] const unsigned char* initData,[In] unsigned int cb)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineNeedKeyNotify::NeedKey</unmanaged-short>	
        public void NeedKey(byte[] initData, int cb)
        {
            unsafe
            {
                byte[] initData__ = initData;
                fixed (void* initData_ = initData__)
                    SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, initData_, cb, ((void**)(*(void**)_nativePointer))[3]);
            }
        }
    }
    /// <summary>	
    /// <p>Callback interface for the <strong><see cref="SharpDX.MediaFoundation.MediaEngine"/></strong> interface. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To set the callback reference on the Media Engine, set the <see cref="SharpDX.MediaFoundation.MediaEngineAttributeKeys.Callback"/> attribute in the <strong><see cref="SharpDX.MediaFoundation.MediaEngineClassFactory.CreateInstance"/></strong> method.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineNotify']/*"/>	
    /// <msdn-id>hh447962</msdn-id>	
    /// <unmanaged>IMFMediaEngineNotify</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineNotify</unmanaged-short>	
    [Guid("fee7c112-e776-42b5-9bbf-0048524e2bd5")]
    internal partial interface MediaEngineNotify : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p>Notifies the application when a playback event occurs.</p>	
        /// </summary>	
        /// <param name="@event"><dd> <p>A member of the <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent"/></strong> enumeration that specifies the event.</p> </dd></param>	
        /// <param name="param1"><dd> <p>The first event parameter. The meaning of this parameter depends on the event code.</p> </dd></param>	
        /// <param name="param2"><dd> <p>The second event parameter. The meaning of this parameter depends on the event code.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineNotify::EventNotify']/*"/>	
        /// <msdn-id>hh447963</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineNotify::EventNotify([In] unsigned int event,[In] ULONG_PTR param1,[In] unsigned int param2)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineNotify::EventNotify</unmanaged-short>	
        /* public void EventNotify(int @event, System.IntPtr param1, int param2) */
    }
    /// <summary>	
    /// <p>Provides methods for getting information about the   Output Protection Manager (OPM).</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To get a reference to this interface, call <strong>QueryInterface</strong> on the Media Engine.</p><p>The <strong><see cref="SharpDX.MediaFoundation.MediaEngineEvent.OpmInformation"/></strong> <strong><see cref="SharpDX.MediaFoundation.MediaEvent"/></strong> event is raised when there is a change in the OPM status.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineOPMInfo']/*"/>	
    /// <msdn-id>dn280698</msdn-id>	
    /// <unmanaged>IMFMediaEngineOPMInfo</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineOPMInfo</unmanaged-short>	
    [Guid("765763e6-6c01-4b01-bb0f-b829f60ed28c")]
    public partial class MediaEngineOPMInfo : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngineOPMInfo"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngineOPMInfo(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngineOPMInfo"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngineOPMInfo(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngineOPMInfo(nativePointer);
        }


        /// <summary>	
        /// <p>Gets status information about the   Output Protection Manager (OPM).</p>	
        /// </summary>	
        /// <param name="statusRef">No documentation.</param>	
        /// <param name="constrictedRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded</p> </td></tr> <tr><td> <dl> <dt><strong>INVALIDARG</strong></dt> </dl> </td><td> <p>If any of the parameters are <strong><c>null</c></strong>.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineOPMInfo::GetOPMInfo']/*"/>	
        /// <msdn-id>dn280699</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineOPMInfo::GetOPMInfo([Out] MF_MEDIA_ENGINE_OPM_STATUS* pStatus,[Out] BOOL* pConstricted)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineOPMInfo::GetOPMInfo</unmanaged-short>	
        public void GetOPMInfo(out SharpDX.MediaFoundation.MediaEngineOpmStatus statusRef, out SharpDX.Mathematics.Interop.RawBool constrictedRef)
        {
            unsafe
            {
                constrictedRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* statusRef_ = &statusRef)
                fixed (void* constrictedRef_ = &constrictedRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, statusRef_, constrictedRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Copies a protected video frame to a DXGI surface.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>For protected content, call this method instead of the <strong><see cref="SharpDX.MediaFoundation.MediaEngine.TransferVideoFrame"/></strong> method.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineProtectedContent']/*"/>	
    /// <msdn-id>hh447970</msdn-id>	
    /// <unmanaged>IMFMediaEngineProtectedContent</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineProtectedContent</unmanaged-short>	
    [Guid("9f8021e8-9c8c-487e-bb5c-79aa4779938c")]
    public partial class MediaEngineProtectedContent : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngineProtectedContent"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngineProtectedContent(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngineProtectedContent"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngineProtectedContent(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngineProtectedContent(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the content protections that must be applied in frame-server mode.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineProtectedContent::GetRequiredProtections']/*"/>	
        /// <msdn-id>hh447965</msdn-id>	
        /// <unmanaged>GetRequiredProtections</unmanaged>	
        /// <unmanaged-short>GetRequiredProtections</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngineProtectedContent::GetRequiredProtections([Out] unsigned int* pFrameProtectionFlags)</unmanaged>
        public int RequiredProtections
        {
            get { int __output__; GetRequiredProtections(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Specifies the window that should receive output link protections.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>In frame-server mode, call this method to specify the destination window for protected video content. The Media Engine uses this window to set link protections, using the Output Protection Manager (OPM).</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineProtectedContent::SetOPMWindow']/*"/>	
        /// <msdn-id>hh447968</msdn-id>	
        /// <unmanaged>SetOPMWindow</unmanaged>	
        /// <unmanaged-short>SetOPMWindow</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngineProtectedContent::SetOPMWindow([In] HWND hwnd)</unmanaged>
        public System.IntPtr OPMWindow
        {
            set { SetOPMWindow(value); }
        }

        /// <summary>	
        /// <p>Sets the content protection manager (CPM).</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The Media Engine uses the CPM to handle events related to protected content, such as license acquisition.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineProtectedContent::SetContentProtectionManager']/*"/>	
        /// <msdn-id>hh447967</msdn-id>	
        /// <unmanaged>SetContentProtectionManager</unmanaged>	
        /// <unmanaged-short>SetContentProtectionManager</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEngineProtectedContent::SetContentProtectionManager([In, Optional] void* pCPM)</unmanaged>
        internal System.IntPtr ContentProtectionManager
        {
            set { SetContentProtectionManager(value); }
        }

        /// <summary>	
        /// <p>Enables the Media Engine to access protected content while in frame-server mode.</p>	
        /// </summary>	
        /// <param name="unkDeviceContextRef"><dd> <p>A reference to the Direct3D?11 device content. The Media Engine queries this reference for the <strong><see cref="SharpDX.Direct3D11.VideoContext"/></strong> interface. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>In frame-server mode, this method enables the Media Engine to share protected content with the Direct3D?11 device.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineProtectedContent::ShareResources']/*"/>	
        /// <msdn-id>hh447969</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineProtectedContent::ShareResources([In] IUnknown* pUnkDeviceContext)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineProtectedContent::ShareResources</unmanaged-short>	
        public void ShareResources(SharpDX.ComObject unkDeviceContextRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((unkDeviceContextRef == null) ? IntPtr.Zero : unkDeviceContextRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the content protections that must be applied in frame-server mode.</p>	
        /// </summary>	
        /// <param name="frameProtectionFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.MediaEngineFrameProtectionFlags"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineProtectedContent::GetRequiredProtections']/*"/>	
        /// <msdn-id>hh447965</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineProtectedContent::GetRequiredProtections([Out] unsigned int* pFrameProtectionFlags)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineProtectedContent::GetRequiredProtections</unmanaged-short>	
        internal void GetRequiredProtections(out int frameProtectionFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* frameProtectionFlagsRef_ = &frameProtectionFlagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, frameProtectionFlagsRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Specifies the window that should receive output link protections.</p>	
        /// </summary>	
        /// <param name="hwnd"><dd> <p>A handle to the window.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>In frame-server mode, call this method to specify the destination window for protected video content. The Media Engine uses this window to set link protections, using the Output Protection Manager (OPM).</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineProtectedContent::SetOPMWindow']/*"/>	
        /// <msdn-id>hh447968</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineProtectedContent::SetOPMWindow([In] HWND hwnd)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineProtectedContent::SetOPMWindow</unmanaged-short>	
        internal void SetOPMWindow(System.IntPtr hwnd)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)hwnd, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Copies a protected video frame to a DXGI surface.</p>	
        /// </summary>	
        /// <param name="dstSurfRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of the destination surface.</p> </dd></param>	
        /// <param name="srcRef"><dd> <p>A reference to an <strong><see cref="SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure that specifies the source rectangle.</p> </dd></param>	
        /// <param name="dstRef"><dd> <p>A reference to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that specifies the destination rectangle.</p> </dd></param>	
        /// <param name="borderClrRef"><dd> <p>A reference to an <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that specifies the border color. </p> </dd></param>	
        /// <param name="frameProtectionFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.MediaEngineFrameProtectionFlags"/></strong> enumeration. These flags indicate which content protections the application must apply before presenting the surface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>For protected content, call this method instead of the <strong><see cref="SharpDX.MediaFoundation.MediaEngine.TransferVideoFrame"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineProtectedContent::TransferVideoFrame']/*"/>	
        /// <msdn-id>hh447970</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineProtectedContent::TransferVideoFrame([In] IUnknown* pDstSurf,[In, Optional] const MFVideoNormalizedRect* pSrc,[In] const RECT* pDst,[In, Optional] const MFARGB* pBorderClr,[Out] unsigned int* pFrameProtectionFlags)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineProtectedContent::TransferVideoFrame</unmanaged-short>	
        public void TransferVideoFrame(SharpDX.ComObject dstSurfRef, SharpDX.MediaFoundation.VideoNormalizedRect? srcRef, SharpDX.Mathematics.Interop.RawRectangle dstRef, SharpDX.Mathematics.Interop.RawColorBGRA? borderClrRef, out int frameProtectionFlagsRef)
        {
            unsafe
            {
                SharpDX.MediaFoundation.VideoNormalizedRect srcRef_;
                if (srcRef.HasValue)
                    srcRef_ = srcRef.Value;
                SharpDX.Mathematics.Interop.RawColorBGRA borderClrRef_;
                if (borderClrRef.HasValue)
                    borderClrRef_ = borderClrRef.Value;
                SharpDX.Result __result__;
                fixed (void* frameProtectionFlagsRef_ = &frameProtectionFlagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((dstSurfRef == null) ? IntPtr.Zero : dstSurfRef.NativePointer), (srcRef.HasValue) ? &srcRef_ : (void*)IntPtr.Zero, &dstRef, (borderClrRef.HasValue) ? &borderClrRef_ : (void*)IntPtr.Zero, frameProtectionFlagsRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the content protection manager (CPM).</p>	
        /// </summary>	
        /// <param name="cPMRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.ContentProtectionManager"/></strong> interface, implemented by the caller.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The Media Engine uses the CPM to handle events related to protected content, such as license acquisition.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineProtectedContent::SetContentProtectionManager']/*"/>	
        /// <msdn-id>hh447967</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineProtectedContent::SetContentProtectionManager([In, Optional] void* pCPM)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineProtectedContent::SetContentProtectionManager</unmanaged-short>	
        internal void SetContentProtectionManager(System.IntPtr cPMRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)cPMRef, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the application's certificate.</p>	
        /// </summary>	
        /// <param name="bBlobRef"><dd> <p>A reference to a buffer that contains the certificate in X.509 format, followed by the application identifier signed with a SHA-256 signature using the private key from the certificate.</p> </dd></param>	
        /// <param name="cbBlob"><dd> <p>The size of the <em>pbBlob</em> buffer, in bytes.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Call this method to access protected video content in frame-server mode.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineProtectedContent::SetApplicationCertificate']/*"/>	
        /// <msdn-id>hh447966</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineProtectedContent::SetApplicationCertificate([In, Buffer] const unsigned char* pbBlob,[In] unsigned int cbBlob)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineProtectedContent::SetApplicationCertificate</unmanaged-short>	
        public void SetApplicationCertificate(byte[] bBlobRef, int cbBlob)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* bBlobRef_ = bBlobRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bBlobRef_, cbBlob, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides the Media Engine with a list of media resources.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.MediaFoundation.MediaEngineSrcElements"/></strong> interface represents an ordered list of media resources.</p><p>This interface enables the application to provide the same audio/video content in several different encoding formats, such as H.264 and Windows Media Video. If a particular codec is not present on the user's computer, the Media Engine will try the next URL in the list. To use this interface, do the following:</p><ol> <li>Create an implementation of this interface.</li> <li>Initialize your implementation with a list of URLs. Optionally, provide MIME types and media query strings for each URL.</li> <li>Call the <strong><see cref="SharpDX.MediaFoundation.MediaEngine.SetSourceElements"/></strong> method.</li> </ol>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineSrcElements']/*"/>	
    /// <msdn-id>hh447971</msdn-id>	
    /// <unmanaged>IMFMediaEngineSrcElements</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineSrcElements</unmanaged-short>	
    [Guid("7a5e5354-b114-4c72-b991-3131d75032ea")]
    public partial class MediaEngineSrcElements : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngineSrcElements"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngineSrcElements(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngineSrcElements"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngineSrcElements(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngineSrcElements(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the number of source elements in the list.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineSrcElements::GetLength']/*"/>	
        /// <msdn-id>hh447973</msdn-id>	
        /// <unmanaged>GetLength</unmanaged>	
        /// <unmanaged-short>GetLength</unmanaged-short>	
        /// <unmanaged>unsigned int IMFMediaEngineSrcElements::GetLength()</unmanaged>
        public int Length
        {
            get { return GetLength(); }
        }

        /// <summary>	
        /// <p>Gets the number of source elements in the list.</p>	
        /// </summary>	
        /// <returns><p>Returns the number of source elements.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineSrcElements::GetLength']/*"/>	
        /// <msdn-id>hh447973</msdn-id>	
        /// <unmanaged>unsigned int IMFMediaEngineSrcElements::GetLength()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineSrcElements::GetLength</unmanaged-short>	
        internal int GetLength()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the URL of an element in the list.</p>	
        /// </summary>	
        /// <param name="index"><dd> <p>The zero-based index of the source element. To get the number of source elements, call <strong><see cref="SharpDX.MediaFoundation.MediaEngineSrcElements.GetLength"/></strong>.</p> </dd></param>	
        /// <param name="uRLRef"><dd> <p>Receives a <strong>BSTR</strong> that contains the URL of the source element. The caller must free the  <strong>BSTR</strong> by calling <strong>SysFreeString</strong>. If no URL is set, this parameter receives the value <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineSrcElements::GetURL']/*"/>	
        /// <msdn-id>hh447976</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineSrcElements::GetURL([In] unsigned int index,[Out] wchar_t** pURL)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineSrcElements::GetURL</unmanaged-short>	
        public void GetURL(int index, System.IntPtr uRLRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, index, (void*)uRLRef, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the MIME type of an element in the list.</p>	
        /// </summary>	
        /// <param name="index"><dd> <p>The zero-based index of the source element. To get the number of source elements, call <strong><see cref="SharpDX.MediaFoundation.MediaEngineSrcElements.GetLength"/></strong>.</p> </dd></param>	
        /// <param name="typeRef"><dd> <p>Receives a <strong>BSTR</strong> that contains the MIME type. The caller must free the  <strong>BSTR</strong> by calling <strong>SysFreeString</strong>. If no MIME type is set, this parameter receives the value <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineSrcElements::GetType']/*"/>	
        /// <msdn-id>hh447975</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineSrcElements::GetType([In] unsigned int index,[Out] wchar_t** pType)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineSrcElements::GetType</unmanaged-short>	
        public void GetTypeInfo(int index, System.IntPtr typeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, index, (void*)typeRef, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the intended media type of an element in the list.</p>	
        /// </summary>	
        /// <param name="index"><dd> <p>The zero-based index of the source element. To get the number of source elements, call <strong><see cref="SharpDX.MediaFoundation.MediaEngineSrcElements.GetLength"/></strong>.</p> </dd></param>	
        /// <param name="mediaRef"><dd> <p>Receives a <strong>BSTR</strong> that contains a media-query string. The caller must free the  <strong>BSTR</strong> by calling <strong>SysFreeString</strong>. If no media type is set, this parameter receives the value <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The string returned in <em>pMedia</em> should be a media-query string that conforms to the W3C <em>Media Queries</em> specification.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineSrcElements::GetMedia']/*"/>	
        /// <msdn-id>hh447974</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineSrcElements::GetMedia([In] unsigned int index,[Out] wchar_t** pMedia)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineSrcElements::GetMedia</unmanaged-short>	
        public void GetMedia(int index, System.IntPtr mediaRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, index, (void*)mediaRef, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Adds a source element to the end of the list.</p>	
        /// </summary>	
        /// <param name="uRLRef"><dd> <p>The URL of the source element, or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="typeRef"><dd> <p>The MIME type of the source element, or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="mediaRef"><dd> <p>A media-query string that specifies the intended media type, or <strong><c>null</c></strong>. If specified, the string should conform to the W3C <em>Media Queries</em> specification.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Any of the parameters to this method can be <strong><c>null</c></strong>.</p><p>This method allocates copies of the <strong>BSTR</strong>s that are passed in.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineSrcElements::AddElement']/*"/>	
        /// <msdn-id>hh447972</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineSrcElements::AddElement([In, Optional] wchar_t* pURL,[In, Optional] wchar_t* pType,[In, Optional] wchar_t* pMedia)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineSrcElements::AddElement</unmanaged-short>	
        public void AddElement(string uRLRef, string typeRef, string mediaRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* uRLRef_ = uRLRef)
                fixed (char* typeRef_ = typeRef)
                fixed (char* mediaRef_ = mediaRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)uRLRef_, (void*)typeRef_, (void*)mediaRef_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Removes all of the source elements from the list.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineSrcElements::RemoveAllElements']/*"/>	
        /// <msdn-id>hh447977</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineSrcElements::RemoveAllElements()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineSrcElements::RemoveAllElements</unmanaged-short>	
        public void RemoveAllElements()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Extends the <strong><see cref="SharpDX.MediaFoundation.MediaEngineSrcElements"/></strong> interface to provide additional capabilities.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineSrcElementsEx']/*"/>	
    /// <msdn-id>dn280700</msdn-id>	
    /// <unmanaged>IMFMediaEngineSrcElementsEx</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineSrcElementsEx</unmanaged-short>	
    [Guid("654a6bb3-e1a3-424a-9908-53a43a0dfda0")]
    public partial class MediaEngineSrcElementsEx : SharpDX.MediaFoundation.MediaEngineSrcElements
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngineSrcElementsEx"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngineSrcElementsEx(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngineSrcElementsEx"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngineSrcElementsEx(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngineSrcElementsEx(nativePointer);
        }


        /// <summary>	
        /// <p>Provides an enhanced version of <strong><see cref="SharpDX.MediaFoundation.MediaEngineSrcElements.AddElement"/></strong> to add the key system intended to be used with content to an element.</p>	
        /// </summary>	
        /// <param name="uRLRef">No documentation.</param>	
        /// <param name="typeRef">No documentation.</param>	
        /// <param name="mediaRef">No documentation.</param>	
        /// <param name="keySystem">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineSrcElementsEx::AddElementEx']/*"/>	
        /// <msdn-id>dn280701</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineSrcElementsEx::AddElementEx([In, Optional] wchar_t* pURL,[In, Optional] wchar_t* pType,[In, Optional] wchar_t* pMedia,[In, Optional] wchar_t* keySystem)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineSrcElementsEx::AddElementEx</unmanaged-short>	
        public void AddElementEx(string uRLRef, string typeRef, string mediaRef, string keySystem)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* uRLRef_ = uRLRef)
                fixed (char* typeRef_ = typeRef)
                fixed (char* mediaRef_ = mediaRef)
                fixed (char* keySystem_ = keySystem)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)uRLRef_, (void*)typeRef_, (void*)mediaRef_, (void*)keySystem_, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the key system for the given source element index.</p>	
        /// </summary>	
        /// <param name="index"><dd> <p>The source element index.</p> </dd></param>	
        /// <param name="typeRef"><dd> <p>The MIME type of the source element.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineSrcElementsEx::GetKeySystem']/*"/>	
        /// <msdn-id>dn280702</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineSrcElementsEx::GetKeySystem([In] unsigned int index,[Out, Optional] wchar_t** pType)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineSrcElementsEx::GetKeySystem</unmanaged-short>	
        public void GetKeySystem(int index, System.IntPtr typeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, index, (void*)typeRef, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables the media source to be transferred between  the media engine and the sharing engine for Play To.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineSupportsSourceTransfer']/*"/>	
    /// <msdn-id>dn280703</msdn-id>	
    /// <unmanaged>IMFMediaEngineSupportsSourceTransfer</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineSupportsSourceTransfer</unmanaged-short>	
    [Guid("a724b056-1b2e-4642-a6f3-db9420c52908")]
    public partial class MediaEngineSupportsSourceTransfer : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngineSupportsSourceTransfer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngineSupportsSourceTransfer(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngineSupportsSourceTransfer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngineSupportsSourceTransfer(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngineSupportsSourceTransfer(nativePointer);
        }


        /// <summary>	
        /// <p>Specifies wether or not the source should be transferred.</p>	
        /// </summary>	
        /// <param name="fShouldTransferRef"><dd> <p><strong>true</strong> if the source should be transferred; otherwise, <strong>false</strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineSupportsSourceTransfer::ShouldTransferSource']/*"/>	
        /// <msdn-id>dn280706</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineSupportsSourceTransfer::ShouldTransferSource([Out] BOOL* pfShouldTransfer)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineSupportsSourceTransfer::ShouldTransferSource</unmanaged-short>	
        public void ShouldTransferSource(out SharpDX.Mathematics.Interop.RawBool fShouldTransferRef)
        {
            unsafe
            {
                fShouldTransferRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fShouldTransferRef_ = &fShouldTransferRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fShouldTransferRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Detaches the media source.</p>	
        /// </summary>	
        /// <param name="byteStreamOut"><dd> <p>Receives the byte stream.</p> </dd></param>	
        /// <param name="mediaSourceOut"><dd> <p>Receives the media source.</p> </dd></param>	
        /// <param name="mSEOut"><dd> <p>Receives the media source extension.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineSupportsSourceTransfer::DetachMediaSource']/*"/>	
        /// <msdn-id>dn280705</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineSupportsSourceTransfer::DetachMediaSource([Out] IMFByteStream** ppByteStream,[Out] IMFMediaSource** ppMediaSource,[Out] IMFMediaSourceExtension** ppMSE)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineSupportsSourceTransfer::DetachMediaSource</unmanaged-short>	
        public void DetachMediaSource(out SharpDX.MediaFoundation.IByteStream byteStreamOut, out SharpDX.MediaFoundation.MediaSource mediaSourceOut, out SharpDX.MediaFoundation.MediaSourceExtension mSEOut)
        {
            unsafe
            {
                IntPtr byteStreamOut_ = IntPtr.Zero;
                IntPtr mediaSourceOut_ = IntPtr.Zero;
                IntPtr mSEOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &byteStreamOut_, &mediaSourceOut_, &mSEOut_, ((void**)(*(void**)_nativePointer))[4]);
                byteStreamOut = (byteStreamOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.ByteStream(byteStreamOut_);
                mediaSourceOut = (mediaSourceOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSource(mediaSourceOut_);
                mSEOut = (mSEOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSourceExtension(mSEOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Attaches the media source.</p>	
        /// </summary>	
        /// <param name="byteStreamRef"><dd> <p>Specifies the byte stream. </p> </dd></param>	
        /// <param name="mediaSourceRef"><dd> <p>Specifies the media source.</p> </dd></param>	
        /// <param name="mSERef"><dd> <p>Specifies the media source extension.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineSupportsSourceTransfer::AttachMediaSource']/*"/>	
        /// <msdn-id>dn280704</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineSupportsSourceTransfer::AttachMediaSource([In, Optional] IMFByteStream* pByteStream,[In] IMFMediaSource* pMediaSource,[In, Optional] IMFMediaSourceExtension* pMSE)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineSupportsSourceTransfer::AttachMediaSource</unmanaged-short>	
        internal void AttachMediaSource_(System.IntPtr byteStreamRef, SharpDX.MediaFoundation.MediaSource mediaSourceRef, SharpDX.MediaFoundation.MediaSourceExtension mSERef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)byteStreamRef, (void*)((mediaSourceRef == null) ? IntPtr.Zero : mediaSourceRef.NativePointer), (void*)((mSERef == null) ? IntPtr.Zero : mSERef.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineTransferSource']/*"/>	
    /// <unmanaged>IMFMediaEngineTransferSource</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineTransferSource</unmanaged-short>	
    [Guid("24230452-fe54-40cc-94f3-fcc394c340d6")]
    public partial class MediaEngineTransferSource : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngineTransferSource"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngineTransferSource(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngineTransferSource"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngineTransferSource(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngineTransferSource(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="destination">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineTransferSource::TransferSourceToMediaEngine']/*"/>	
        /// <unmanaged>HRESULT IMFMediaEngineTransferSource::TransferSourceToMediaEngine([In] IMFMediaEngine* destination)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineTransferSource::TransferSourceToMediaEngine</unmanaged-short>	
        public void TransferSourceToMediaEngine(SharpDX.MediaFoundation.MediaEngine destination)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((destination == null) ? IntPtr.Zero : destination.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Enables playback of web audio.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineWebSupport']/*"/>	
    /// <msdn-id>mt668766</msdn-id>	
    /// <unmanaged>IMFMediaEngineWebSupport</unmanaged>	
    /// <unmanaged-short>IMFMediaEngineWebSupport</unmanaged-short>	
    [Guid("ba2743a1-07e0-48ef-84b6-9a2ed023ca6c")]
    public partial class MediaEngineWebSupport : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEngineWebSupport"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEngineWebSupport(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEngineWebSupport"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEngineWebSupport(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEngineWebSupport(nativePointer);
        }


        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a value indicating if the connecting to Web audio should delay the page's load event.</p>	
        /// </summary>	
        /// <returns><p>True if connection to Web audio should delay the page's load event; otherwise, false.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineWebSupport::ShouldDelayTheLoadEvent']/*"/>	
        /// <msdn-id>mt668769</msdn-id>	
        /// <unmanaged>BOOL IMFMediaEngineWebSupport::ShouldDelayTheLoadEvent()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineWebSupport::ShouldDelayTheLoadEvent</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool ShouldDelayTheLoadEvent()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Connects web audio to Media Engine using the specified sample rate.</p>	
        /// </summary>	
        /// <param name="dwSampleRate"><dd> <p>The sample rate of the web audio.</p> </dd></param>	
        /// <param name="sourceProviderOut"><dd> <p>The sample rate of the web audio.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> on successful completion.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineWebSupport::ConnectWebAudio']/*"/>	
        /// <msdn-id>mt668767</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineWebSupport::ConnectWebAudio([In] unsigned int dwSampleRate,[Out] IAudioSourceProvider** ppSourceProvider)</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineWebSupport::ConnectWebAudio</unmanaged-short>	
        public void ConnectWebAudio(int dwSampleRate, out SharpDX.MediaFoundation.IAudioSourceProvider sourceProviderOut)
        {
            unsafe
            {
                IntPtr sourceProviderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwSampleRate, &sourceProviderOut_, ((void**)(*(void**)_nativePointer))[4]);
                sourceProviderOut = (sourceProviderOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.IAudioSourceProvider(sourceProviderOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Disconnects web audio from the Media Engine </p>	
        /// </summary>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> on successful completion.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEngineWebSupport::DisconnectWebAudio']/*"/>	
        /// <msdn-id>mt668768</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEngineWebSupport::DisconnectWebAudio()</unmanaged>	
        /// <unmanaged-short>IMFMediaEngineWebSupport::DisconnectWebAudio</unmanaged-short>	
        public void DisconnectWebAudio()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides the current error status for the Media Engine.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.MediaFoundation.MediaError"/></strong> interface corresponds to the <strong>MediaError</strong> object in HTML5.</p><p>To get a reference to this interface, call <strong><see cref="SharpDX.MediaFoundation.MediaEngine.GetError"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaError']/*"/>	
    /// <msdn-id>hh448022</msdn-id>	
    /// <unmanaged>IMFMediaError</unmanaged>	
    /// <unmanaged-short>IMFMediaError</unmanaged-short>	
    [Guid("fc0e10d2-ab2a-4501-a951-06bb1075184c")]
    public partial class MediaError : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaError"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaError(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaError"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaError(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaError(nativePointer);
        }


        /// <summary>	
        /// <p>Gets or sets the extended error code.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaError::GetExtendedErrorCode']/*"/>	
        /// <msdn-id>hh448024</msdn-id>	
        /// <unmanaged>GetExtendedErrorCode / SetExtendedErrorCode</unmanaged>	
        /// <unmanaged-short>GetExtendedErrorCode</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaError::GetExtendedErrorCode()</unmanaged>
        public SharpDX.Result ExtendedErrorCode
        {
            get { return GetExtendedErrorCode(); }
            set { SetExtendedErrorCode(value); }
        }

        /// <summary>	
        /// <p>Gets the error code.</p>	
        /// </summary>	
        /// <returns><p>Returns a value from the <strong><see cref="SharpDX.MediaFoundation.MediaEngineErr"/></strong> enumeration.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaError::GetErrorCode']/*"/>	
        /// <msdn-id>hh448023</msdn-id>	
        /// <unmanaged>unsigned short IMFMediaError::GetErrorCode()</unmanaged>	
        /// <unmanaged-short>IMFMediaError::GetErrorCode</unmanaged-short>	
        public short GetErrorCode()
        {
            unsafe
            {
                short __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callishort(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the extended error code.</p>	
        /// </summary>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value that gives additional information about the last error.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaError::GetExtendedErrorCode']/*"/>	
        /// <msdn-id>hh448024</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaError::GetExtendedErrorCode()</unmanaged>	
        /// <unmanaged-short>IMFMediaError::GetExtendedErrorCode</unmanaged-short>	
        internal SharpDX.Result GetExtendedErrorCode()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Sets the error code.</p>	
        /// </summary>	
        /// <param name="error"><dd> <p>The error code, specified as an <strong><see cref="SharpDX.MediaFoundation.MediaEngineErr"/></strong> value.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaError::SetErrorCode']/*"/>	
        /// <msdn-id>hh448025</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaError::SetErrorCode([In] MF_MEDIA_ENGINE_ERR error)</unmanaged>	
        /// <unmanaged-short>IMFMediaError::SetErrorCode</unmanaged-short>	
        public void SetErrorCode(SharpDX.MediaFoundation.MediaEngineErr error)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)error), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the extended error code.</p>	
        /// </summary>	
        /// <param name="error"><dd> <p>An <strong><see cref="SharpDX.Result"/></strong> value that gives additional information about the last error.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaError::SetExtendedErrorCode']/*"/>	
        /// <msdn-id>hh448026</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaError::SetExtendedErrorCode([In] HRESULT error)</unmanaged>	
        /// <unmanaged-short>IMFMediaError::SetExtendedErrorCode</unmanaged-short>	
        internal void SetExtendedErrorCode(SharpDX.Result error)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint45(_nativePointer, error, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents an event generated by a Media Foundation object. Use this interface to get information about the event.</p><p>To get a reference to this interface, call <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator.BeginGetEvent_"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator.GetEvent"/></strong> on the event generator.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If you are implementing an object that generates events, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateMediaEvent"/></strong> function to create a new event object.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEvent']/*"/>	
    /// <msdn-id>ms702249</msdn-id>	
    /// <unmanaged>IMFMediaEvent</unmanaged>	
    /// <unmanaged-short>IMFMediaEvent</unmanaged-short>	
    [Guid("DF598932-F10C-4E39-BBA2-C308F101DAA3")]
    public partial class MediaEvent : SharpDX.MediaFoundation.MediaAttributes
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEvent"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEvent(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEvent"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEvent(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEvent(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the event type. The event type indicates what happened to trigger the event. It also defines the meaning of the event value.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEvent::GetType']/*"/>	
        /// <msdn-id>ms702255</msdn-id>	
        /// <unmanaged>GetType</unmanaged>	
        /// <unmanaged-short>GetType</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEvent::GetType([Out] MEDIA_EVENT_TYPES* pmet)</unmanaged>
        public SharpDX.MediaFoundation.MediaEventTypes TypeInfo
        {
            get { SharpDX.MediaFoundation.MediaEventTypes __output__; GetTypeInfo(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the extended type of the event.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>To define a custom event, create a new extended-type <see cref="System.Guid"/> and send an <see cref="SharpDX.MediaFoundation.MediaEventTypes.ExtendedType"/> event with that <see cref="System.Guid"/>.</p><p>Some standard Media Foundation events also use the extended type to differentiate between types of event data.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEvent::GetExtendedType']/*"/>	
        /// <msdn-id>ms697235</msdn-id>	
        /// <unmanaged>GetExtendedType</unmanaged>	
        /// <unmanaged-short>GetExtendedType</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEvent::GetExtendedType([Out] GUID* pguidExtendedType)</unmanaged>
        public System.Guid ExtendedType
        {
            get { System.Guid __output__; GetExtendedType(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves an <strong><see cref="SharpDX.Result"/></strong> that specifies the event status.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEvent::GetStatus']/*"/>	
        /// <msdn-id>ms704650</msdn-id>	
        /// <unmanaged>GetStatus</unmanaged>	
        /// <unmanaged-short>GetStatus</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEvent::GetStatus([Out] HRESULT* phrStatus)</unmanaged>
        public SharpDX.Result Status
        {
            get { SharpDX.Result __output__; GetStatus(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the value associated with the event, if any. The value is retrieved as a <strong><see cref="SharpDX.Win32.Variant"/></strong> structure. The actual data type and the meaning of the value depend on the event.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Before calling this method, call <strong>PropVariantInit</strong> to initialize the <strong><see cref="SharpDX.Win32.Variant"/></strong> structure. After the method returns, call <strong>PropVariantClear</strong> to free the memory that was allocated for the <strong><see cref="SharpDX.Win32.Variant"/></strong> data.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEvent::GetValue']/*"/>	
        /// <msdn-id>ms693864</msdn-id>	
        /// <unmanaged>GetValue</unmanaged>	
        /// <unmanaged-short>GetValue</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaEvent::GetValue([Out] PROPVARIANT* pvValue)</unmanaged>
        public SharpDX.Win32.Variant Value
        {
            get { SharpDX.Win32.Variant __output__; GetValue(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the event type. The event type indicates what happened to trigger the event. It also defines the meaning of the event value.</p>	
        /// </summary>	
        /// <param name="metRef"><dd> <p>Receives the event type. For a list of event types, see Media Foundation Events.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEvent::GetType']/*"/>	
        /// <msdn-id>ms702255</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEvent::GetType([Out] MEDIA_EVENT_TYPES* pmet)</unmanaged>	
        /// <unmanaged-short>IMFMediaEvent::GetType</unmanaged-short>	
        internal void GetTypeInfo(out SharpDX.MediaFoundation.MediaEventTypes metRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* metRef_ = &metRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, metRef_, ((void**)(*(void**)_nativePointer))[33]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the extended type of the event.</p>	
        /// </summary>	
        /// <param name="guidExtendedTypeRef"><dd> <p>Receives a <strong><see cref="System.Guid"/></strong> that identifies the extended type.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To define a custom event, create a new extended-type <see cref="System.Guid"/> and send an <see cref="SharpDX.MediaFoundation.MediaEventTypes.ExtendedType"/> event with that <see cref="System.Guid"/>.</p><p>Some standard Media Foundation events also use the extended type to differentiate between types of event data.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEvent::GetExtendedType']/*"/>	
        /// <msdn-id>ms697235</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEvent::GetExtendedType([Out] GUID* pguidExtendedType)</unmanaged>	
        /// <unmanaged-short>IMFMediaEvent::GetExtendedType</unmanaged-short>	
        internal void GetExtendedType(out System.Guid guidExtendedTypeRef)
        {
            unsafe
            {
                guidExtendedTypeRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* guidExtendedTypeRef_ = &guidExtendedTypeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, guidExtendedTypeRef_, ((void**)(*(void**)_nativePointer))[34]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves an <strong><see cref="SharpDX.Result"/></strong> that specifies the event status.</p>	
        /// </summary>	
        /// <param name="hrStatusRef"><dd> <p>Receives the event status. If the operation that generated the event was successful, the value is a success code. A failure code means that an error condition triggered the event.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEvent::GetStatus']/*"/>	
        /// <msdn-id>ms704650</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEvent::GetStatus([Out] HRESULT* phrStatus)</unmanaged>	
        /// <unmanaged-short>IMFMediaEvent::GetStatus</unmanaged-short>	
        internal void GetStatus(out SharpDX.Result hrStatusRef)
        {
            unsafe
            {
                hrStatusRef = new SharpDX.Result();
                SharpDX.Result __result__;
                fixed (void* hrStatusRef_ = &hrStatusRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, hrStatusRef_, ((void**)(*(void**)_nativePointer))[35]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the value associated with the event, if any. The value is retrieved as a <strong><see cref="SharpDX.Win32.Variant"/></strong> structure. The actual data type and the meaning of the value depend on the event.</p>	
        /// </summary>	
        /// <param name="vValueRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.Win32.Variant"/></strong> structure. The method fills this structure with the data.</p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Before calling this method, call <strong>PropVariantInit</strong> to initialize the <strong><see cref="SharpDX.Win32.Variant"/></strong> structure. After the method returns, call <strong>PropVariantClear</strong> to free the memory that was allocated for the <strong><see cref="SharpDX.Win32.Variant"/></strong> data.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEvent::GetValue']/*"/>	
        /// <msdn-id>ms693864</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEvent::GetValue([Out] PROPVARIANT* pvValue)</unmanaged>	
        /// <unmanaged-short>IMFMediaEvent::GetValue</unmanaged-short>	
        internal void GetValue(out SharpDX.Win32.Variant vValueRef)
        {
            unsafe
            {
                vValueRef = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* vValueRef_ = &vValueRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, vValueRef_, ((void**)(*(void**)_nativePointer))[36]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Retrieves events from any Media Foundation object that generates events. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An object that supports this interface maintains a queue of events. The client of the object can retrieve the events either synchronously or asynchronously. The synchronous method is <strong>GetEvent</strong>. The asynchronous methods are <strong>BeginGetEvent</strong> and <strong>EndGetEvent</strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEventGenerator']/*"/>	
    /// <msdn-id>ms701755</msdn-id>	
    /// <unmanaged>IMFMediaEventGenerator</unmanaged>	
    /// <unmanaged-short>IMFMediaEventGenerator</unmanaged-short>	
    [Guid("2CD0BD52-BCD5-4B89-B62C-EADC0C031E7D")]
    public partial class MediaEventGenerator : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEventGenerator"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEventGenerator(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEventGenerator"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEventGenerator(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEventGenerator(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the next event in the queue. This method is synchronous.</p>	
        /// </summary>	
        /// <param name="dwFlags"><dd> <p>Specifies one of the following values.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>0</strong></dt> </dl> </td><td> <p>The method blocks until the event generator queues an event.</p> </td></tr> <tr><td><dl> <dt><strong>MF_EVENT_FLAG_NO_WAIT</strong></dt> </dl> </td><td> <p>The method returns immediately.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="eventOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaEvent"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><c>null</c> reference argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.MultipleSubScribers"/></strong></dt> </dl> </td><td> <p>There is a pending request.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoEventsAvailable"/></strong></dt> </dl> </td><td> <p>There are no events in the queue.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The object was shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method executes synchronously.</p><p>If the queue already contains an event, the method returns <see cref="SharpDX.Result.Ok"/> immediately. If the queue does not contain an event, the behavior depends on the value of <em>dwFlags</em>:</p><ul> <li> <p>If <em>dwFlags</em> is 0, the method blocks indefinitely until a new event is queued, or until the event generator is shut down.</p> </li> <li> <p>If <em>dwFlags</em> is MF_EVENT_FLAG_NO_WAIT, the method fails immediately with the return code <see cref="SharpDX.MediaFoundation.ResultCode.NoEventsAvailable"/>.</p> </li> </ul><p>This method returns <see cref="SharpDX.MediaFoundation.ResultCode.MultipleSubScribers"/> if you previously called <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator.BeginGetEvent_"/></strong> and have not yet called <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator.EndGetEvent"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEventGenerator::GetEvent']/*"/>	
        /// <msdn-id>ms704754</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEventGenerator::GetEvent([In] unsigned int dwFlags,[Out] IMFMediaEvent** ppEvent)</unmanaged>	
        /// <unmanaged-short>IMFMediaEventGenerator::GetEvent</unmanaged-short>	
        internal void GetEvent(int dwFlags, out SharpDX.MediaFoundation.MediaEvent eventOut)
        {
            unsafe
            {
                IntPtr eventOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwFlags, &eventOut_, ((void**)(*(void**)_nativePointer))[3]);
                eventOut = (eventOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaEvent(eventOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Begins an asynchronous request for the next event in the queue.</p>	
        /// </summary>	
        /// <param name="callbackRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The client must implement this interface.</p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.MultipleBegin"/></strong></dt> </dl> </td><td> <p>There is a pending request with the same callback reference and a different state object.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.MultipleSubScribers"/></strong></dt> </dl> </td><td> <p>There is a pending request with a different callback reference.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The object was shut down.</p> </td></tr> <tr><td> <dl> <dt><strong>MF_S_MULTIPLE_BEGIN</strong></dt> </dl> </td><td> <p>There is a pending request with the same callback reference and state object.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When a new event is available, the event generator calls the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method. The <strong>Invoke</strong> method should call <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator.EndGetEvent"/></strong> to get a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaEvent"/></strong> interface, and use that interface to examine the event.</p><p>Do not call <strong>BeginGetEvent</strong> a second time before calling <strong>EndGetEvent</strong>. While the first call is still pending, additional calls to the same object will fail. Also, the <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator.GetEvent"/></strong> method fails if an asynchronous request is still pending.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEventGenerator::BeginGetEvent']/*"/>	
        /// <msdn-id>ms701637</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEventGenerator::BeginGetEvent([In] IMFAsyncCallback* pCallback,[In] void* punkState)</unmanaged>	
        /// <unmanaged-short>IMFMediaEventGenerator::BeginGetEvent</unmanaged-short>	
        internal void BeginGetEvent_(System.IntPtr callbackRef, System.IntPtr unkStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)callbackRef, (void*)unkStateRef, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Completes an asynchronous request for the next event in the queue.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>Invoke</strong> method.</p> </dd></param>	
        /// <returns><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaEvent"/></strong> interface. The caller must release the interface.</p> </dd></returns>	
        /// <remarks>	
        /// <p>Call this method from inside your application's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method. For example code, see <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator.BeginGetEvent_"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEventGenerator::EndGetEvent']/*"/>	
        /// <msdn-id>ms698866</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEventGenerator::EndGetEvent([In] IMFAsyncResult* pResult,[Out] IMFMediaEvent** ppEvent)</unmanaged>	
        /// <unmanaged-short>IMFMediaEventGenerator::EndGetEvent</unmanaged-short>	
        public SharpDX.MediaFoundation.MediaEvent EndGetEvent(SharpDX.MediaFoundation.AsyncResult resultRef)
        {
            unsafe
            {
                SharpDX.MediaFoundation.MediaEvent eventOut;
                IntPtr eventOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), &eventOut_, ((void**)(*(void**)_nativePointer))[5]);
                eventOut = (eventOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaEvent(eventOut_);
                __result__.CheckError();
                return eventOut;
            }
        }

        /// <summary>	
        /// <p> </p><p>Puts a new event in the object's queue.</p>	
        /// </summary>	
        /// <param name="met"><dd> <p>Specifies the event type. The event type is returned by the event's <strong><see cref="SharpDX.MediaFoundation.MediaEvent.GetTypeInfo"/></strong> method. For a list of event types, see Media Foundation Events.</p> </dd></param>	
        /// <param name="guidExtendedType"><dd> <p>The extended type. If the event does not have an extended type, use the value GUID_NULL. The extended type is returned by the event's <strong><see cref="SharpDX.MediaFoundation.MediaEvent.GetExtendedType"/></strong> method.</p> </dd></param>	
        /// <param name="hrStatus"><dd> <p>A success or failure code indicating the status of the event. This value is returned by the event's <strong><see cref="SharpDX.MediaFoundation.MediaEvent.GetStatus"/></strong> method.</p> </dd></param>	
        /// <param name="vValueRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that contains the event value. This parameter can be <strong><c>null</c></strong>. This value is returned by the event's <strong><see cref="SharpDX.MediaFoundation.MediaEvent.GetValue"/></strong> method.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The object was shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEventGenerator::QueueEvent']/*"/>	
        /// <msdn-id>ms696255</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEventGenerator::QueueEvent([In] unsigned int met,[In] const GUID&amp; guidExtendedType,[In] HRESULT hrStatus,[In, Optional] const PROPVARIANT* pvValue)</unmanaged>	
        /// <unmanaged-short>IMFMediaEventGenerator::QueueEvent</unmanaged-short>	
        public void QueueEvent(int met, System.Guid guidExtendedType, SharpDX.Result hrStatus, SharpDX.Win32.Variant? vValueRef)
        {
            unsafe
            {
                SharpDX.Win32.Variant vValueRef_;
                if (vValueRef.HasValue)
                    vValueRef_ = vValueRef.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint47(_nativePointer, met, &guidExtendedType, hrStatus, (vValueRef.HasValue) ? &vValueRef_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides an event queue for applications that need to implement the <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator"/></strong> interface.</p><p>This interface is exposed by a helper object that implements an event queue. If you are writing a component that implements the <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator"/></strong> interface, you can use this object in your implementation. The event queue object is thread safe and provides methods to queue events and to pull them from the queue either synchronously or asynchronously. To create the event queue object, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateEventQueue"/></strong>.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEventQueue']/*"/>	
    /// <msdn-id>ms704617</msdn-id>	
    /// <unmanaged>IMFMediaEventQueue</unmanaged>	
    /// <unmanaged-short>IMFMediaEventQueue</unmanaged-short>	
    [Guid("36f846fc-2256-48b6-b58e-e2b638316581")]
    public partial class MediaEventQueue : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaEventQueue"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaEventQueue(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaEventQueue"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaEventQueue(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaEventQueue(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the next event in the queue. This method is synchronous.</p><p>Call this method inside your implementation of <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator.GetEvent"/></strong>. Pass the parameters from that method directly to this method.</p>	
        /// </summary>	
        /// <param name="dwFlags">No documentation.</param>	
        /// <param name="eventOut">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEventQueue::GetEvent']/*"/>	
        /// <msdn-id>ms702270</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEventQueue::GetEvent([In] unsigned int dwFlags,[Out] IMFMediaEvent** ppEvent)</unmanaged>	
        /// <unmanaged-short>IMFMediaEventQueue::GetEvent</unmanaged-short>	
        public void GetEvent(int dwFlags, out SharpDX.MediaFoundation.MediaEvent eventOut)
        {
            unsafe
            {
                IntPtr eventOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwFlags, &eventOut_, ((void**)(*(void**)_nativePointer))[3]);
                eventOut = (eventOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaEvent(eventOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Begins an asynchronous request for the next event in the queue.</p><p>Call this method inside your implementation of <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator.BeginGetEvent_"/></strong>. Pass the parameters from that method directly to this method.</p>	
        /// </summary>	
        /// <param name="callbackRef">No documentation.</param>	
        /// <param name="unkStateRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEventQueue::BeginGetEvent']/*"/>	
        /// <msdn-id>ms696998</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEventQueue::BeginGetEvent([In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>	
        /// <unmanaged-short>IMFMediaEventQueue::BeginGetEvent</unmanaged-short>	
        internal void BeginGetEvent_(System.IntPtr callbackRef, SharpDX.ComObject unkStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)callbackRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Completes an asynchronous request for the next event in the queue.</p><p>Call this method inside your implementation of <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator.EndGetEvent"/></strong>. Pass the parameters from that method directly to this method.</p>	
        /// </summary>	
        /// <param name="resultRef">No documentation.</param>	
        /// <param name="eventOut">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEventQueue::EndGetEvent']/*"/>	
        /// <msdn-id>ms702986</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEventQueue::EndGetEvent([In] IMFAsyncResult* pResult,[Out] IMFMediaEvent** ppEvent)</unmanaged>	
        /// <unmanaged-short>IMFMediaEventQueue::EndGetEvent</unmanaged-short>	
        public void EndGetEvent(SharpDX.MediaFoundation.AsyncResult resultRef, out SharpDX.MediaFoundation.MediaEvent eventOut)
        {
            unsafe
            {
                IntPtr eventOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), &eventOut_, ((void**)(*(void**)_nativePointer))[5]);
                eventOut = (eventOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaEvent(eventOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Puts an event in the queue.</p>	
        /// </summary>	
        /// <param name="eventRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaEvent"/></strong> interface of the event to be put in the queue.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method when your component needs to raise an event that contains attributes. To create the event object, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateMediaEvent"/></strong>. Add attributes to the event by using methods from the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. (The <strong><see cref="SharpDX.MediaFoundation.MediaEvent"/></strong> interface inherits <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong>.)</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEventQueue::QueueEvent']/*"/>	
        /// <msdn-id>ms704792</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEventQueue::QueueEvent([In] IMFMediaEvent* pEvent)</unmanaged>	
        /// <unmanaged-short>IMFMediaEventQueue::QueueEvent</unmanaged-short>	
        public void QueueEvent(SharpDX.MediaFoundation.MediaEvent eventRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((eventRef == null) ? IntPtr.Zero : eventRef.NativePointer), ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Creates an event, sets a <strong><see cref="SharpDX.Win32.Variant"/></strong> as the event data, and puts the event in the queue.</p><p>Call this method inside your implementation of <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator.QueueEvent"/></strong>. Pass the parameters from that method directly to this method.</p><p>You can also call this method when your component needs to raise an event that does not contain attributes. If the event data is an <strong><see cref="SharpDX.ComObject"/></strong> reference, you can use <strong><see cref="SharpDX.MediaFoundation.MediaEventQueue.QueueEventParamUnk"/></strong>. If the event contains attributes, use <strong><see cref="SharpDX.MediaFoundation.MediaEventQueue.QueueEvent"/></strong> instead.</p>	
        /// </summary>	
        /// <param name="met">No documentation.</param>	
        /// <param name="guidExtendedType">No documentation.</param>	
        /// <param name="hrStatus">No documentation.</param>	
        /// <param name="vValueRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEventQueue::QueueEventParamVar']/*"/>	
        /// <msdn-id>ms704641</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEventQueue::QueueEventParamVar([In] unsigned int met,[In] const GUID&amp; guidExtendedType,[In] HRESULT hrStatus,[In] const PROPVARIANT* pvValue)</unmanaged>	
        /// <unmanaged-short>IMFMediaEventQueue::QueueEventParamVar</unmanaged-short>	
        public void QueueEventParamVar(int met, System.Guid guidExtendedType, SharpDX.Result hrStatus, SharpDX.Win32.Variant vValueRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint47(_nativePointer, met, &guidExtendedType, hrStatus, &vValueRef, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Creates an event, sets an <strong><see cref="SharpDX.ComObject"/></strong> reference as the event data, and puts the event in the queue.</p>	
        /// </summary>	
        /// <param name="met"><dd> <p>Specifies the event type of the event to be added to the queue. The event type is returned by the event's <strong><see cref="SharpDX.MediaFoundation.MediaEvent.GetTypeInfo"/></strong> method. For a list of event types, see Media Foundation Events.</p> </dd></param>	
        /// <param name="guidExtendedType"><dd> <p>The extended type of the event. If the event does not have an extended type, use the value GUID_NULL. The extended type is returned by the event's <strong><see cref="SharpDX.MediaFoundation.MediaEvent.GetExtendedType"/></strong> method.</p> </dd></param>	
        /// <param name="hrStatus"><dd> <p>A success or failure code indicating the status of the event. This value is returned by the event's <strong><see cref="SharpDX.MediaFoundation.MediaEvent.GetStatus"/></strong> method.</p> </dd></param>	
        /// <param name="unkRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface. The method sets this reference as the event value. The reference is returned by the event's <strong><see cref="SharpDX.MediaFoundation.MediaEvent.GetValue"/></strong> method.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method when your component needs to raise an event that contains an <strong><see cref="SharpDX.ComObject"/></strong> reference value and no attributes. If the event contains attributes, use <strong><see cref="SharpDX.MediaFoundation.MediaEventQueue.QueueEvent"/></strong> instead.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEventQueue::QueueEventParamUnk']/*"/>	
        /// <msdn-id>ms704686</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEventQueue::QueueEventParamUnk([In] unsigned int met,[In] const GUID&amp; guidExtendedType,[In] HRESULT hrStatus,[In] IUnknown* pUnk)</unmanaged>	
        /// <unmanaged-short>IMFMediaEventQueue::QueueEventParamUnk</unmanaged-short>	
        public void QueueEventParamUnk(int met, System.Guid guidExtendedType, SharpDX.Result hrStatus, SharpDX.ComObject unkRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint47(_nativePointer, met, &guidExtendedType, hrStatus, (void*)((unkRef == null) ? IntPtr.Zero : unkRef.NativePointer), ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Shuts down the event queue.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method when your component shuts down. After this method is called, all <strong><see cref="SharpDX.MediaFoundation.MediaEventQueue"/></strong> methods return <strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong>.</p><p>This method removes all of the events from the queue.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaEventQueue::Shutdown']/*"/>	
        /// <msdn-id>ms698923</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaEventQueue::Shutdown()</unmanaged>	
        /// <unmanaged-short>IMFMediaEventQueue::Shutdown</unmanaged-short>	
        public void Shutdown()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a media keys used for decrypting media data using a Digital Rights Management (DRM) key system. </p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeys']/*"/>	
    /// <msdn-id>dn280711</msdn-id>	
    /// <unmanaged>IMFMediaKeys</unmanaged>	
    /// <unmanaged-short>IMFMediaKeys</unmanaged-short>	
    [Guid("5cb31c05-61ff-418f-afda-caaf41421a38")]
    public partial class MediaKeys : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaKeys"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaKeys(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaKeys"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaKeys(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaKeys(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the suspend notify interface of the Content Decryption Module (CDM).</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeys::GetSuspendNotify']/*"/>	
        /// <msdn-id>dn280723</msdn-id>	
        /// <unmanaged>GetSuspendNotify</unmanaged>	
        /// <unmanaged-short>GetSuspendNotify</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaKeys::GetSuspendNotify([Out] IMFCdmSuspendNotify** notify)</unmanaged>
        public SharpDX.MediaFoundation.CdmSuspendNotify SuspendNotify
        {
            get { SharpDX.MediaFoundation.CdmSuspendNotify __output__; GetSuspendNotify(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Creates a media key session object using the specified initialization data and custom data.	
        /// .	
        /// </p>	
        /// </summary>	
        /// <param name="mimeType"><dd> <p>The MIME type of the media container used for the content.</p> </dd></param>	
        /// <param name="initData"><dd> <p>The initialization data for the key system. </p> </dd></param>	
        /// <param name="cb"><dd> <p>The count in bytes of <em>initData</em>.</p> </dd></param>	
        /// <param name="customData"><dd> <p>Custom data sent to the key system.</p> </dd></param>	
        /// <param name="cbCustomData"><dd> <p>The count in bytes of <em>cbCustomData</em>.</p> </dd></param>	
        /// <param name="notify"><dd> <p>notify</p> </dd></param>	
        /// <param name="sessionOut"><dd> <p>The media key session.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeys::CreateSession']/*"/>	
        /// <msdn-id>dn280722</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaKeys::CreateSession([In, Optional] wchar_t* mimeType,[In, Buffer, Optional] const unsigned char* initData,[In, Optional] unsigned int cb,[In, Buffer, Optional] const unsigned char* customData,[In] unsigned int cbCustomData,[In] IMFMediaKeySessionNotify* notify,[Out] IMFMediaKeySession** ppSession)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeys::CreateSession</unmanaged-short>	
        public void CreateSession(string mimeType, byte[] initData, int cb, byte[] customData, int cbCustomData, SharpDX.MediaFoundation.MediaKeySessionNotify notify, out SharpDX.MediaFoundation.MediaKeySession sessionOut)
        {
            unsafe
            {
                byte[] initData__ = initData;
                byte[] customData__ = customData;
                IntPtr sessionOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* mimeType_ = mimeType)
                fixed (void* initData_ = initData__)
                fixed (void* customData_ = customData__)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)mimeType_, initData_, cb, customData_, cbCustomData, (void*)((notify == null) ? IntPtr.Zero : notify.NativePointer), &sessionOut_, ((void**)(*(void**)_nativePointer))[3]);
                sessionOut = (sessionOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaKeySession(sessionOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the key system string the <strong><see cref="SharpDX.MediaFoundation.MediaKeys"/></strong> object was created with.</p>	
        /// </summary>	
        /// <param name="keySystem">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeys::get_KeySystem']/*"/>	
        /// <msdn-id>dn280724</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaKeys::get_KeySystem([Out] wchar_t** keySystem)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeys::get_KeySystem</unmanaged-short>	
        public void GetKeySystem(System.IntPtr keySystem)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)keySystem, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p></p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><strong>Shutdown</strong> should be called by the application before final release.  The Content Decryption Module (CDM) reference and any other resources is released at this point.  However, related sessions are not freed or closed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeys::Shutdown']/*"/>	
        /// <msdn-id>dn280725</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaKeys::Shutdown()</unmanaged>	
        /// <unmanaged-short>IMFMediaKeys::Shutdown</unmanaged-short>	
        public void Shutdown()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the suspend notify interface of the Content Decryption Module (CDM).</p>	
        /// </summary>	
        /// <param name="notify"><dd> <p>The suspend notify interface of the Content Decryption Module (CDM).</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeys::GetSuspendNotify']/*"/>	
        /// <msdn-id>dn280723</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaKeys::GetSuspendNotify([Out] IMFCdmSuspendNotify** notify)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeys::GetSuspendNotify</unmanaged-short>	
        internal void GetSuspendNotify(out SharpDX.MediaFoundation.CdmSuspendNotify notify)
        {
            unsafe
            {
                IntPtr notify_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &notify_, ((void**)(*(void**)_nativePointer))[6]);
                notify = (notify_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.CdmSuspendNotify(notify_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeys2']/*"/>	
    /// <unmanaged>IMFMediaKeys2</unmanaged>	
    /// <unmanaged-short>IMFMediaKeys2</unmanaged-short>	
    [Guid("45892507-ad66-4de2-83a2-acbb13cd8d43")]
    public partial class MediaKeys2 : SharpDX.MediaFoundation.MediaKeys
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaKeys2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaKeys2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaKeys2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaKeys2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaKeys2(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="eSessionType">No documentation.</param>	
        /// <param name="mFMediaKeySessionNotify2Ref">No documentation.</param>	
        /// <param name="sessionOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeys2::CreateSession2']/*"/>	
        /// <unmanaged>HRESULT IMFMediaKeys2::CreateSession2([In] MF_MEDIAKEYSESSION_TYPE eSessionType,[In] IMFMediaKeySessionNotify2* pMFMediaKeySessionNotify2,[Out] IMFMediaKeySession2** ppSession)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeys2::CreateSession2</unmanaged-short>	
        public void CreateSession2(SharpDX.MediaFoundation.MediaKeysessionType eSessionType, SharpDX.MediaFoundation.MediaKeySessionNotify2 mFMediaKeySessionNotify2Ref, out SharpDX.MediaFoundation.MediaKeySession2 sessionOut)
        {
            unsafe
            {
                IntPtr sessionOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)eSessionType), (void*)((mFMediaKeySessionNotify2Ref == null) ? IntPtr.Zero : mFMediaKeySessionNotify2Ref.NativePointer), &sessionOut_, ((void**)(*(void**)_nativePointer))[7]);
                sessionOut = (sessionOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaKeySession2(sessionOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="bServerCertificateRef">No documentation.</param>	
        /// <param name="cb">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeys2::SetServerCertificate']/*"/>	
        /// <unmanaged>HRESULT IMFMediaKeys2::SetServerCertificate([In, Buffer, Optional] const unsigned char* pbServerCertificate,[In] unsigned int cb)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeys2::SetServerCertificate</unmanaged-short>	
        public void SetServerCertificate(byte[] bServerCertificateRef, int cb)
        {
            unsafe
            {
                byte[] bServerCertificateRef__ = bServerCertificateRef;
                SharpDX.Result __result__;
                fixed (void* bServerCertificateRef_ = bServerCertificateRef__)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bServerCertificateRef_, cb, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="systemCode">No documentation.</param>	
        /// <param name="code">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeys2::GetDOMException']/*"/>	
        /// <unmanaged>HRESULT IMFMediaKeys2::GetDOMException([In] HRESULT systemCode,[Out] HRESULT* code)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeys2::GetDOMException</unmanaged-short>	
        public void GetDOMException(SharpDX.Result systemCode, out SharpDX.Result code)
        {
            unsafe
            {
                code = new SharpDX.Result();
                SharpDX.Result __result__;
                fixed (void* code_ = &code)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint86(_nativePointer, systemCode, code_, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a session with the Digital Rights Management (DRM) key system.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySession']/*"/>	
    /// <msdn-id>dn280712</msdn-id>	
    /// <unmanaged>IMFMediaKeySession</unmanaged>	
    /// <unmanaged-short>IMFMediaKeySession</unmanaged-short>	
    [Guid("24fa67d5-d1d0-4dc5-995c-c0efdc191fb5")]
    public partial class MediaKeySession : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaKeySession"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaKeySession(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaKeySession"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaKeySession(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaKeySession(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the error state associated with the media key session.</p>	
        /// </summary>	
        /// <param name="code"><dd> <p>The error code.</p> </dd></param>	
        /// <param name="systemCode"><dd> <p>Platform specific error information.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySession::GetError']/*"/>	
        /// <msdn-id>dn280718</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaKeySession::GetError([Out] unsigned short* code,[Out] unsigned int* systemCode)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySession::GetError</unmanaged-short>	
        public void GetError(out short code, out int systemCode)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* code_ = &code)
                fixed (void* systemCode_ = &systemCode)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, code_, systemCode_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the name of the  key system name the media keys object was created with.</p>	
        /// </summary>	
        /// <param name="keySystem"><dd> <p>The name of the key system.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySession::get_KeySystem']/*"/>	
        /// <msdn-id>dn280719</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaKeySession::get_KeySystem([Out] wchar_t** keySystem)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySession::get_KeySystem</unmanaged-short>	
        public void GetKeySystem(System.IntPtr keySystem)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)keySystem, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a unique session id created for this session.</p>	
        /// </summary>	
        /// <param name="sessionId"><dd> <p>The media key session id.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySession::get_SessionId']/*"/>	
        /// <msdn-id>dn280720</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaKeySession::get_SessionId([Out] wchar_t** sessionId)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySession::get_SessionId</unmanaged-short>	
        public void GetSessionId(System.IntPtr sessionId)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)sessionId, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Passes in a key value with any associated data required by the Content Decryption Module for the given key system.</p>	
        /// </summary>	
        /// <param name="key"><dd></dd></param>	
        /// <param name="cb"><dd> <p>The count in bytes of <em>key</em>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySession::Update']/*"/>	
        /// <msdn-id>dn280721</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaKeySession::Update([In, Buffer] const unsigned char* key,[In] unsigned int cb)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySession::Update</unmanaged-short>	
        public void Update(byte[] key, int cb)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* key_ = key)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, key_, cb, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Closes the media key session and must be called before the key session is released.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySession::Close']/*"/>	
        /// <msdn-id>dn280717</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaKeySession::Close()</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySession::Close</unmanaged-short>	
        public void Close()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySession2']/*"/>	
    /// <unmanaged>IMFMediaKeySession2</unmanaged>	
    /// <unmanaged-short>IMFMediaKeySession2</unmanaged-short>	
    [Guid("e9707e05-6d55-4636-b185-3de21210bd75")]
    public partial class MediaKeySession2 : SharpDX.MediaFoundation.MediaKeySession
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaKeySession2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaKeySession2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaKeySession2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaKeySession2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaKeySession2(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySession2::get_Expiration']/*"/>	
        /// <unmanaged>get_Expiration</unmanaged>	
        /// <unmanaged-short>get_Expiration</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaKeySession2::get_Expiration([Out] double* dblExpiration)</unmanaged>
        public double Expiration
        {
            get { double __output__; GetExpiration(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="keyStatusesArrayRef">No documentation.</param>	
        /// <param name="uSizeRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySession2::get_KeyStatuses']/*"/>	
        /// <unmanaged>HRESULT IMFMediaKeySession2::get_KeyStatuses([Out, Buffer] MFMediaKeyStatus** pKeyStatusesArray,[Out] unsigned int* puSize)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySession2::get_KeyStatuses</unmanaged-short>	
        public void GetKeyStatuses(SharpDX.MediaFoundation.MediaKeyStatus[] keyStatusesArrayRef, out int uSizeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* keyStatusesArrayRef_ = keyStatusesArrayRef)
                fixed (void* uSizeRef_ = &uSizeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, keyStatusesArrayRef_, uSizeRef_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="bstrSessionId">No documentation.</param>	
        /// <param name="fLoadedRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySession2::Load']/*"/>	
        /// <unmanaged>HRESULT IMFMediaKeySession2::Load([In] wchar_t* bstrSessionId,[Out] BOOL* pfLoaded)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySession2::Load</unmanaged-short>	
        public void Load(string bstrSessionId, out SharpDX.Mathematics.Interop.RawBool fLoadedRef)
        {
            unsafe
            {
                fLoadedRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (char* bstrSessionId_ = bstrSessionId)
                fixed (void* fLoadedRef_ = &fLoadedRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)bstrSessionId_, fLoadedRef_, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="initDataType">No documentation.</param>	
        /// <param name="bInitDataRef">No documentation.</param>	
        /// <param name="cb">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySession2::GenerateRequest']/*"/>	
        /// <unmanaged>HRESULT IMFMediaKeySession2::GenerateRequest([In] wchar_t* initDataType,[In, Buffer] const unsigned char* pbInitData,[In] unsigned int cb)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySession2::GenerateRequest</unmanaged-short>	
        public void GenerateRequest(string initDataType, byte[] bInitDataRef, int cb)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* initDataType_ = initDataType)
                fixed (void* bInitDataRef_ = bInitDataRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)initDataType_, bInitDataRef_, cb, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dblExpiration">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySession2::get_Expiration']/*"/>	
        /// <unmanaged>HRESULT IMFMediaKeySession2::get_Expiration([Out] double* dblExpiration)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySession2::get_Expiration</unmanaged-short>	
        internal void GetExpiration(out double dblExpiration)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dblExpiration_ = &dblExpiration)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dblExpiration_, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySession2::Remove']/*"/>	
        /// <unmanaged>HRESULT IMFMediaKeySession2::Remove()</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySession2::Remove</unmanaged-short>	
        public void Remove()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySession2::Shutdown']/*"/>	
        /// <unmanaged>HRESULT IMFMediaKeySession2::Shutdown()</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySession2::Shutdown</unmanaged-short>	
        public void Shutdown()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides a mechanism for notifying the app about information regarding the media key session. </p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySessionNotify']/*"/>	
    /// <msdn-id>dn280713</msdn-id>	
    /// <unmanaged>IMFMediaKeySessionNotify</unmanaged>	
    /// <unmanaged-short>IMFMediaKeySessionNotify</unmanaged-short>	
    [Guid("6a0083f9-8947-4c1d-9ce0-cdee22b23135")]
    public partial class MediaKeySessionNotify : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaKeySessionNotify"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaKeySessionNotify(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaKeySessionNotify"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaKeySessionNotify(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaKeySessionNotify(nativePointer);
        }


        /// <summary>	
        /// <p>Passes information to the application so it can initiate a key acquisition.</p>	
        /// </summary>	
        /// <param name="destinationURL"><dd> <p>The URL to send the message to.</p> </dd></param>	
        /// <param name="message"><dd> <p>The message to send to the application.</p> </dd></param>	
        /// <param name="cb"><dd> <p>The length in bytes of <em>message</em>.</p> </dd></param>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySessionNotify::KeyMessage']/*"/>	
        /// <msdn-id>dn280716</msdn-id>	
        /// <unmanaged>void IMFMediaKeySessionNotify::KeyMessage([In, Optional] wchar_t* destinationURL,[In, Buffer] const unsigned char* message,[In] unsigned int cb)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySessionNotify::KeyMessage</unmanaged-short>	
        public void KeyMessage(string destinationURL, byte[] message, int cb)
        {
            unsafe
            {
                fixed (char* destinationURL_ = destinationURL)
                fixed (void* message_ = message)
                    SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, (void*)destinationURL_, message_, cb, ((void**)(*(void**)_nativePointer))[3]);
            }
        }

        /// <summary>	
        /// <p>Notifies the application that the key has been added.  </p>	
        /// </summary>	
        /// <remarks>	
        /// <p><strong>KeyAdded</strong> can also be called if the keys requested for the session have already been acquired.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySessionNotify::KeyAdded']/*"/>	
        /// <msdn-id>dn280714</msdn-id>	
        /// <unmanaged>void IMFMediaKeySessionNotify::KeyAdded()</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySessionNotify::KeyAdded</unmanaged-short>	
        public void KeyAdded()
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
            }
        }

        /// <summary>	
        /// <p>Notifies the application that an error occurred while processing the key.</p>	
        /// </summary>	
        /// <param name="code"><dd></dd></param>	
        /// <param name="systemCode"><dd></dd></param>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySessionNotify::KeyError']/*"/>	
        /// <msdn-id>dn280715</msdn-id>	
        /// <unmanaged>void IMFMediaKeySessionNotify::KeyError([In] unsigned short code,[In] unsigned int systemCode)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySessionNotify::KeyError</unmanaged-short>	
        public void KeyError(short code, int systemCode)
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, code, systemCode, ((void**)(*(void**)_nativePointer))[5]);
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySessionNotify2']/*"/>	
    /// <unmanaged>IMFMediaKeySessionNotify2</unmanaged>	
    /// <unmanaged-short>IMFMediaKeySessionNotify2</unmanaged-short>	
    [Guid("c3a9e92a-da88-46b0-a110-6cf953026cb9")]
    public partial class MediaKeySessionNotify2 : SharpDX.MediaFoundation.MediaKeySessionNotify
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaKeySessionNotify2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaKeySessionNotify2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaKeySessionNotify2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaKeySessionNotify2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaKeySessionNotify2(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="eMessageType">No documentation.</param>	
        /// <param name="destinationURL">No documentation.</param>	
        /// <param name="bMessageRef">No documentation.</param>	
        /// <param name="cbMessage">No documentation.</param>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySessionNotify2::KeyMessage2']/*"/>	
        /// <unmanaged>void IMFMediaKeySessionNotify2::KeyMessage2([In] MF_MEDIAKEYSESSION_MESSAGETYPE eMessageType,[In, Optional] wchar_t* destinationURL,[In, Buffer] const unsigned char* pbMessage,[In] unsigned int cbMessage)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySessionNotify2::KeyMessage2</unmanaged-short>	
        public void KeyMessage2(SharpDX.MediaFoundation.MediaKeysessionMessagetype eMessageType, string destinationURL, byte[] bMessageRef, int cbMessage)
        {
            unsafe
            {
                fixed (char* destinationURL_ = destinationURL)
                fixed (void* bMessageRef_ = bMessageRef)
                    SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, unchecked((int)eMessageType), (void*)destinationURL_, bMessageRef_, cbMessage, ((void**)(*(void**)_nativePointer))[6]);
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySessionNotify2::KeyStatusChange']/*"/>	
        /// <unmanaged>void IMFMediaKeySessionNotify2::KeyStatusChange()</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySessionNotify2::KeyStatusChange</unmanaged-short>	
        public void KeyStatusChange()
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[7]);
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySystemAccess']/*"/>	
    /// <unmanaged>IMFMediaKeySystemAccess</unmanaged>	
    /// <unmanaged-short>IMFMediaKeySystemAccess</unmanaged-short>	
    [Guid("aec63fda-7a97-4944-b35c-6c6df8085cc3")]
    public partial class MediaKeySystemAccess : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaKeySystemAccess"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaKeySystemAccess(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaKeySystemAccess"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaKeySystemAccess(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaKeySystemAccess(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySystemAccess::get_SupportedConfiguration']/*"/>	
        /// <unmanaged>get_SupportedConfiguration</unmanaged>	
        /// <unmanaged-short>get_SupportedConfiguration</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaKeySystemAccess::get_SupportedConfiguration([Out] IPropertyStore** ppSupportedConfiguration)</unmanaged>
        public SharpDX.ComObject SupportedConfiguration
        {
            get { SharpDX.ComObject __output__; GetSupportedConfiguration(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="cdmCustomConfigRef">No documentation.</param>	
        /// <param name="keysOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySystemAccess::CreateMediaKeys']/*"/>	
        /// <unmanaged>HRESULT IMFMediaKeySystemAccess::CreateMediaKeys([In, Optional] IPropertyStore* pCdmCustomConfig,[Out] IMFMediaKeys2** ppKeys)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySystemAccess::CreateMediaKeys</unmanaged-short>	
        public void CreateMediaKeys(SharpDX.ComObject cdmCustomConfigRef, out SharpDX.MediaFoundation.MediaKeys2 keysOut)
        {
            unsafe
            {
                IntPtr keysOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((cdmCustomConfigRef == null) ? IntPtr.Zero : cdmCustomConfigRef.NativePointer), &keysOut_, ((void**)(*(void**)_nativePointer))[3]);
                keysOut = (keysOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaKeys2(keysOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="supportedConfigurationOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySystemAccess::get_SupportedConfiguration']/*"/>	
        /// <unmanaged>HRESULT IMFMediaKeySystemAccess::get_SupportedConfiguration([Out] IPropertyStore** ppSupportedConfiguration)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySystemAccess::get_SupportedConfiguration</unmanaged-short>	
        internal void GetSupportedConfiguration(out SharpDX.ComObject supportedConfigurationOut)
        {
            unsafe
            {
                IntPtr supportedConfigurationOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &supportedConfigurationOut_, ((void**)(*(void**)_nativePointer))[4]);
                supportedConfigurationOut = (supportedConfigurationOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(supportedConfigurationOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="keySystemRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaKeySystemAccess::get_KeySystem']/*"/>	
        /// <unmanaged>HRESULT IMFMediaKeySystemAccess::get_KeySystem([Out] wchar_t** pKeySystem)</unmanaged>	
        /// <unmanaged-short>IMFMediaKeySystemAccess::get_KeySystem</unmanaged-short>	
        public void GetKeySystem(System.IntPtr keySystemRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)keySystemRef, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides playback controls for protected and unprotected content. The Media Session and the protected media path (PMP) session objects expose this interface. This interface is the primary interface that applications use to control the Media Foundation pipeline.</p><p>To obtain a reference to this interface, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateMediaSession"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreatePMPMediaSession"/></strong>.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSession']/*"/>	
    /// <msdn-id>ms705662</msdn-id>	
    /// <unmanaged>IMFMediaSession</unmanaged>	
    /// <unmanaged-short>IMFMediaSession</unmanaged-short>	
    [Guid("90377834-21D0-4dee-8214-BA2E3E6C1127")]
    public partial class MediaSession : SharpDX.MediaFoundation.MediaEventGenerator
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaSession"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaSession(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaSession"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaSession(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaSession(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the Media Session's presentation clock.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The application can query the returned <strong><see cref="SharpDX.MediaFoundation.Clock"/></strong> reference for the <strong><see cref="SharpDX.MediaFoundation.PresentationClock"/></strong> interface. However, the application should not use this interface to control the state of the presentation clock. Instead, the application should always call the transport control methods on the Media Session's <strong><see cref="SharpDX.MediaFoundation.MediaSession"/></strong> interface, such as <strong>Start</strong>, <strong>Stop</strong>, and <strong>Pause</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSession::GetClock']/*"/>	
        /// <msdn-id>bb970342</msdn-id>	
        /// <unmanaged>GetClock</unmanaged>	
        /// <unmanaged-short>GetClock</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaSession::GetClock([Out] IMFClock** ppClock)</unmanaged>
        public SharpDX.MediaFoundation.Clock Clock
        {
            get { SharpDX.MediaFoundation.Clock __output__; GetClock(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the capabilities of the Media Session, based on the current presentation.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSession::GetSessionCapabilities']/*"/>	
        /// <msdn-id>ms696229</msdn-id>	
        /// <unmanaged>GetSessionCapabilities</unmanaged>	
        /// <unmanaged-short>GetSessionCapabilities</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaSession::GetSessionCapabilities([Out] unsigned int* pdwCaps)</unmanaged>
        public int SessionCapabilities
        {
            get { int __output__; GetSessionCapabilities(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Sets a topology on the Media Session. </p>	
        /// </summary>	
        /// <param name="dwSetTopologyFlags"><dd> <p> Bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.SessionSetTopologyFlags"/></strong> enumeration. </p> </dd></param>	
        /// <param name="topologyRef"><dd> <p> Pointer to the topology object's <strong><see cref="SharpDX.MediaFoundation.Topology"/></strong> interface. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p> The operation cannot be performed in the Media Session's current state. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p> The Media Session has been shut down. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TopoInvalidTimeAttributes"/></strong></dt> </dl> </td><td> <p>The topology has invalid values for one or more of the following attributes:</p> <ul> <li> <strong><see cref="SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Mediastart"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Mediastop"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.TopologyAttributeKeys.ProjectStart"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.TopologyAttributeKeys.ProjectStop"/></strong> </li> </ul> </td></tr> <tr><td> <dl> <dt><strong>NS_E_DRM_DEBUGGING_NOT_ALLOWED</strong></dt> </dl> </td><td> <p> Protected content cannot be played while debugging. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If <em>pTopology</em> is a full topology, set the <strong><see cref="SharpDX.MediaFoundation.SessionSetTopologyFlags.Noresolution"/></strong> flag in the <em>dwSetTopologyFlags</em> parameter. Otherwise, the topology is assumed to be a partial topology. The Media Session uses the topology loader to resolve a partial topology into a full topology.</p><p>If the Media Session is currently paused or stopped, the <strong>SetTopology</strong> method does not take effect until the next call to <strong><see cref="SharpDX.MediaFoundation.MediaSession.Start"/></strong>.</p><p>If the Media Session is currently running, or on the next call to <strong>Start</strong>, the <strong>SetTopology</strong> method does the following:</p><ul> <li>If the <strong><see cref="SharpDX.MediaFoundation.SessionSetTopologyFlags.Immediate"/></strong> flag is set in <em>dwSetTopologyFlags</em>, the Media Session ends the current presentation immediately, clears all pending topologies, and uses <em>pTopology</em> to start a new presentation.</li> <li>Otherwise, the Media Session queues <em>pTopology</em> and starts the new presentation when the current presentation has completed. If there is no current presentation, the new presentation starts immediately.</li> <li>Starting in Windows?7, you can also specify the <strong><see cref="SharpDX.MediaFoundation.SessionSetTopologyFlags.ClearCurrent"/></strong> flag to clear the current topology but leave any other pending topologies on the queue.</li> </ul><p> This method is asynchronous. If the method returns <see cref="SharpDX.Result.Ok"/>, the Media Session sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.SessionTopologySet"/> event when the operation completes. If the Media Session is currently paused to stopped, the Media Session does not send the <see cref="SharpDX.MediaFoundation.MediaEventTypes.SessionTopologySet"/> event until the next call to <strong><see cref="SharpDX.MediaFoundation.MediaSession.Start"/></strong> </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSession::SetTopology']/*"/>	
        /// <msdn-id>ms704785</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSession::SetTopology([In] MFSESSION_SETTOPOLOGY_FLAGS dwSetTopologyFlags,[In, Optional] IMFTopology* pTopology)</unmanaged>	
        /// <unmanaged-short>IMFMediaSession::SetTopology</unmanaged-short>	
        public void SetTopology(SharpDX.MediaFoundation.SessionSetTopologyFlags dwSetTopologyFlags, SharpDX.MediaFoundation.Topology topologyRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)dwSetTopologyFlags), (void*)((topologyRef == null) ? IntPtr.Zero : topologyRef.NativePointer), ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Clears all of the presentations that are queued for playback in the Media Session.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p> The operation cannot be performed in the Media Session's current state. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p> The Media Session has been shut down. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is asynchronous. When the operation completes, the Media Session sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.SessionTopologiesCleared"/> event.</p><p>This method does not clear the current topology; it only removes topologies that are placed in the queue, waiting for playback. To remove the current topology, call <strong><see cref="SharpDX.MediaFoundation.MediaSession.SetTopology"/></strong> with the <strong><see cref="SharpDX.MediaFoundation.SessionSetTopologyFlags.ClearCurrent"/></strong> flag.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSession::ClearTopologies']/*"/>	
        /// <msdn-id>ms705648</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSession::ClearTopologies()</unmanaged>	
        /// <unmanaged-short>IMFMediaSession::ClearTopologies</unmanaged-short>	
        public void ClearTopologies()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Starts the Media Session. </p>	
        /// </summary>	
        /// <param name="guidTimeFormatRef"><dd> <p>Pointer to a <see cref="System.Guid"/> that specifies the time format for the <em>pvarStartPosition</em> parameter. This parameter can be <strong><c>null</c></strong>. The value <strong><c>null</c></strong> is equivalent to passing in <strong>GUID_NULL</strong>.</p> <p>The following time format GUIDs are defined:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>GUID_NULL</strong></dt> </dl> </td><td> <p>Presentation time. The <em>pvarStartPosition</em> parameter must have one of the following <strong><see cref="SharpDX.Win32.Variant"/></strong> types.</p> <ul> <li><strong>VT_I8</strong>: The <em>pvarStartPosition</em> parameter contains the starting position in 100-nanosecond units, relative to the start of the presentation.</li> <li><strong>VT_EMPTY</strong>: Playback starts from the current position.</li> </ul> <p>All media sources support this time format.</p> </td></tr> <tr><td><dl> <dt><strong>MF_TIME_FORMAT_SEGMENT_OFFSET</strong></dt> </dl> </td><td> <p>Segment offset. This time format is supported by the Sequencer Source. The starting time is an offset within a segment.</p> <p>Call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSequencerSegmentOffset"/></strong> function to create the <strong><see cref="SharpDX.Win32.Variant"/></strong> value for the <em>pvarStartPosition</em> parameter.</p> </td></tr> <tr><td><dl> <dt><strong>MF_TIME_FORMAT_ENTRY_RELATIVE</strong></dt> </dl> </td><td> <strong>Note</strong>??Requires Windows?7 or later. ? <p>Skip to a playlist entry. The <em>pvarStartPosition</em> parameter specifies the index of the playlist entry, relative to the current entry. For example, the value 2 skips forward two entries. To skip backward, pass a negative value. The <strong><see cref="SharpDX.Win32.Variant"/></strong> type is <strong>VT_I4</strong>.</p> <p>If a media source supports this time format, the <strong><see cref="SharpDX.MediaFoundation.MediaSource.GetCharacteristics"/></strong> method returns one or both of the following flags:</p> <ul> <li><strong><see cref="SharpDX.MediaFoundation.MediaSourceCharacteristics.CanSkipforward"/></strong></li> <li><strong><see cref="SharpDX.MediaFoundation.MediaSourceCharacteristics.CanSkipbackward"/></strong></li> </ul> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="varStartPositionRef"><dd> <p> Pointer to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that specifies the starting position for playback. The meaning and data type of this parameter are indicated by the <em>pguidTimeFormat</em> parameter. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p> The operation cannot be performed in the Media Session's current state. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p> The Media Session has been shut down. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When this method is called, the Media Session starts the presentation clock and begins to process media samples.</p><p>This method is asynchronous. When the method completes, the Media Session sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.SessionStarted"/> event.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSession::Start']/*"/>	
        /// <msdn-id>ms694908</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSession::Start([In, Optional] const GUID* pguidTimeFormat,[In, Optional] const PROPVARIANT* pvarStartPosition)</unmanaged>	
        /// <unmanaged-short>IMFMediaSession::Start</unmanaged-short>	
        public void Start(System.Guid? guidTimeFormatRef, SharpDX.Win32.Variant? varStartPositionRef)
        {
            unsafe
            {
                System.Guid guidTimeFormatRef_;
                if (guidTimeFormatRef.HasValue)
                    guidTimeFormatRef_ = guidTimeFormatRef.Value;
                SharpDX.Win32.Variant varStartPositionRef_;
                if (varStartPositionRef.HasValue)
                    varStartPositionRef_ = varStartPositionRef.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (guidTimeFormatRef.HasValue) ? &guidTimeFormatRef_ : (void*)IntPtr.Zero, (varStartPositionRef.HasValue) ? &varStartPositionRef_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Pauses the Media Session.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The operation cannot be performed in the Media Session's current state.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The Media Session has been shut down.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.SessionPausewhilestopped"/></strong></dt> </dl> </td><td> <p>The Media Session cannot pause while stopped.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method pauses the presentation clock.</p><p>This method is asynchronous. When the operation completes, the Media Session sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.SessionPaused"/> event.</p><p>This method fails if the Media Session is stopped.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSession::Pause']/*"/>	
        /// <msdn-id>ms705650</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSession::Pause()</unmanaged>	
        /// <unmanaged-short>IMFMediaSession::Pause</unmanaged-short>	
        public void Pause()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Stops the Media Session.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The operation cannot be performed in the Media Session's current state.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The Media Session has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is asynchronous. When the operation completes, the Media Session sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.SessionStopped"/> event.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSession::Stop']/*"/>	
        /// <msdn-id>ms701607</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSession::Stop()</unmanaged>	
        /// <unmanaged-short>IMFMediaSession::Stop</unmanaged-short>	
        public void Stop()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Closes the Media Session and releases all of the resources it is using.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The Media Session has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is asynchronous. When the operation completes, the Media Session sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.SessionClosed"/> event.</p><p>After the <strong>Close</strong> method is called, the only valid methods on the Media Session are the following:</p><ul> <li> <p> <strong><see cref="SharpDX.MediaFoundation.MediaSession.GetClock"/></strong> </p> </li> <li> <p> <strong><see cref="SharpDX.MediaFoundation.MediaSession.GetFullTopology"/></strong> </p> </li> <li> <p> <strong><see cref="SharpDX.MediaFoundation.MediaSession.GetSessionCapabilities"/></strong> </p> </li> <li> <p> <strong><see cref="SharpDX.MediaFoundation.MediaSession.Shutdown"/></strong> </p> </li> </ul><p>All other methods return <see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/>, or else queue an event with that error code.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSession::Close']/*"/>	
        /// <msdn-id>ms698928</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSession::Close()</unmanaged>	
        /// <unmanaged-short>IMFMediaSession::Close</unmanaged-short>	
        public void Close()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Shuts down the Media Session and releases all the resources used by the Media Session.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method when you are done using the Media Session, before the final call to <strong>IUnknown::Release</strong>. Otherwise, your application will leak memory.</p><p>After this method is called, other <strong><see cref="SharpDX.MediaFoundation.MediaSession"/></strong> methods return <see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSession::Shutdown']/*"/>	
        /// <msdn-id>ms697318</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSession::Shutdown()</unmanaged>	
        /// <unmanaged-short>IMFMediaSession::Shutdown</unmanaged-short>	
        public void Shutdown()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the Media Session's presentation clock.</p>	
        /// </summary>	
        /// <param name="clockOut"><dd> <p>Receives a reference to the presentation clock's <strong><see cref="SharpDX.MediaFoundation.Clock"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_UNEXPECTED</strong></dt> </dl> </td><td> <p>The Media Session does not have a presentation clock.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The Media Session has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The application can query the returned <strong><see cref="SharpDX.MediaFoundation.Clock"/></strong> reference for the <strong><see cref="SharpDX.MediaFoundation.PresentationClock"/></strong> interface. However, the application should not use this interface to control the state of the presentation clock. Instead, the application should always call the transport control methods on the Media Session's <strong><see cref="SharpDX.MediaFoundation.MediaSession"/></strong> interface, such as <strong>Start</strong>, <strong>Stop</strong>, and <strong>Pause</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSession::GetClock']/*"/>	
        /// <msdn-id>bb970342</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSession::GetClock([Out] IMFClock** ppClock)</unmanaged>	
        /// <unmanaged-short>IMFMediaSession::GetClock</unmanaged-short>	
        internal void GetClock(out SharpDX.MediaFoundation.Clock clockOut)
        {
            unsafe
            {
                IntPtr clockOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &clockOut_, ((void**)(*(void**)_nativePointer))[14]);
                clockOut = (clockOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Clock(clockOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the capabilities of the Media Session, based on the current presentation.</p>	
        /// </summary>	
        /// <param name="dwCapsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more of the following flags.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MFSESSIONCAP_PAUSE</strong></dt> </dl> </td><td> <p>The Media Session can be paused.</p> </td></tr> <tr><td><dl> <dt><strong>MFSESSIONCAP_RATE_FORWARD</strong></dt> </dl> </td><td> <p>The Media Session supports forward playback at rates faster than 1.0.</p> </td></tr> <tr><td><dl> <dt><strong>MFSESSIONCAP_RATE_REVERSE</strong></dt> </dl> </td><td> <p>The Media Session supports reverse playback.</p> </td></tr> <tr><td><dl> <dt><strong>MFSESSIONCAP_SEEK</strong></dt> </dl> </td><td> <p>The Media Session can be seeked.</p> </td></tr> <tr><td><dl> <dt><strong>MFSESSIONCAP_START</strong></dt> </dl> </td><td> <p>The Media Session can be started.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p><c>null</c> reference argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The Media Session has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSession::GetSessionCapabilities']/*"/>	
        /// <msdn-id>ms696229</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSession::GetSessionCapabilities([Out] unsigned int* pdwCaps)</unmanaged>	
        /// <unmanaged-short>IMFMediaSession::GetSessionCapabilities</unmanaged-short>	
        internal void GetSessionCapabilities(out int dwCapsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwCapsRef_ = &dwCapsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwCapsRef_, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets a topology from the Media Session.</p><p>This method can get the current topology or a queued topology.</p>	
        /// </summary>	
        /// <param name="dwGetFullTopologyFlags"><dd> <p> Bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.SessionGetFullTopologyFlags"/></strong> enumeration. </p> </dd></param>	
        /// <param name="topoId"><dd> <p>The identifier of the topology. This parameter is ignored if the <em>dwGetFullTopologyFlags</em> parameter contains the <strong><see cref="SharpDX.MediaFoundation.SessionGetFullTopologyFlags.Current"/></strong> flag. To get the identifier of a topology, call <strong><see cref="SharpDX.MediaFoundation.Topology.GetTopologyID"/></strong>. </p> </dd></param>	
        /// <param name="fullTopologyOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Topology"/></strong> interface of the topology. The caller must release the interface. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p> The Media Session has been shut down. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If the <strong><see cref="SharpDX.MediaFoundation.SessionGetFullTopologyFlags.Current"/></strong> flag is specified in the <em>dwGetFullTopologyFlags</em> parameter, the method returns the topology for the current presentation. Otherwise, the method searches all of the queued topologies for one that matches the identifier given in the <em>TopoId</em> parameter. </p><p> This method can be used to retrieve the topology for the current presentation or any pending presentations. It cannot be used to retrieve a topology that has already ended. </p><p> The topology returned in <em>ppFullTopo</em> is a full topology, not a partial topology. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSession::GetFullTopology']/*"/>	
        /// <msdn-id>bb970422</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSession::GetFullTopology([In] unsigned int dwGetFullTopologyFlags,[In] unsigned longlong TopoId,[Out] IMFTopology** ppFullTopology)</unmanaged>	
        /// <unmanaged-short>IMFMediaSession::GetFullTopology</unmanaged-short>	
        public void GetFullTopology(int dwGetFullTopologyFlags, long topoId, out SharpDX.MediaFoundation.Topology fullTopologyOut)
        {
            unsafe
            {
                IntPtr fullTopologyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwGetFullTopologyFlags, topoId, &fullTopologyOut_, ((void**)(*(void**)_nativePointer))[16]);
                fullTopologyOut = (fullTopologyOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Topology(fullTopologyOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Implemented by media sink objects. This interface is the base interface for all Media Foundation media sinks. Stream sinks handle the actual processing of data on each stream.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSink']/*"/>	
    /// <msdn-id>ms694262</msdn-id>	
    /// <unmanaged>IMFMediaSink</unmanaged>	
    /// <unmanaged-short>IMFMediaSink</unmanaged-short>	
    [Guid("6ef2a660-47c0-4666-b13d-cbb717f2fa2c")]
    public partial class MediaSink : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaSink"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaSink(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaSink"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaSink(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaSink(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Gets the characteristics of the media sink.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> The characteristics of a media sink are fixed throughout the life time of the sink. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSink::GetCharacteristics']/*"/>	
        /// <msdn-id>ms701973</msdn-id>	
        /// <unmanaged>GetCharacteristics</unmanaged>	
        /// <unmanaged-short>GetCharacteristics</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaSink::GetCharacteristics([Out] unsigned int* pdwCharacteristics)</unmanaged>
        public int Characteristics
        {
            get { int __output__; GetCharacteristics(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Gets the number of stream sinks on this media sink.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSink::GetStreamSinkCount']/*"/>	
        /// <msdn-id>ms703020</msdn-id>	
        /// <unmanaged>GetStreamSinkCount</unmanaged>	
        /// <unmanaged-short>GetStreamSinkCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaSink::GetStreamSinkCount([Out] unsigned int* pcStreamSinkCount)</unmanaged>
        public int StreamSinkCount
        {
            get { int __output__; GetStreamSinkCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Gets the presentation clock that was set on the media sink.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSink::GetPresentationClock']/*"/>	
        /// <msdn-id>ms705665</msdn-id>	
        /// <unmanaged>GetPresentationClock / SetPresentationClock</unmanaged>	
        /// <unmanaged-short>GetPresentationClock</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaSink::GetPresentationClock([Out] IMFPresentationClock** ppPresentationClock)</unmanaged>
        public SharpDX.MediaFoundation.PresentationClock PresentationClock
        {
            get { SharpDX.MediaFoundation.PresentationClock __output__; GetPresentationClock(out __output__); return __output__; }
            set { SetPresentationClock(value); }
        }

        /// <summary>	
        /// <p> </p><p>Gets the characteristics of the media sink.</p>	
        /// </summary>	
        /// <param name="dwCharacteristicsRef"><dd> <p> Receives a bitwise <strong>OR</strong> of zero or more flags. The following flags are defined: </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>MEDIASINK_FIXED_STREAMS</strong></strong></dt> <dt>0x00000001</dt> </dl> </td><td> <p> The media sink has a fixed number of streams. It does not support the <strong><see cref="SharpDX.MediaFoundation.MediaSink.AddStreamSink"/></strong> and <strong><see cref="SharpDX.MediaFoundation.MediaSink.RemoveStreamSink"/></strong> methods. This flag is a hint to the application. </p> </td></tr> <tr><td><dl> <dt><strong><strong>MEDIASINK_CANNOT_MATCH_CLOCK</strong></strong></dt> <dt>0x00000002</dt> </dl> </td><td> <p>The media sink cannot match rates with an external clock.</p> <p>For best results, this media sink should be used as the time source for the presentation clock. If any other time source is used, the media sink cannot match rates with the clock, with poor results (for example, glitching).</p> <p>This flag should be used sparingly, because it limits how the pipeline can be configured.</p> <p>For more information about the presentation clock, see Presentation Clock.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MEDIASINK_RATELESS</strong></strong></dt> <dt>0x00000004</dt> </dl> </td><td> <p>The media sink is rateless. It consumes samples as quickly as possible, and does not synchronize itself to a presentation clock.</p> <p>Most archiving sinks are rateless.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MEDIASINK_CLOCK_REQUIRED</strong></strong></dt> <dt>0x00000008</dt> </dl> </td><td> <p>The media sink requires a presentation clock. The presentation clock is set by calling the media sink's <strong><see cref="SharpDX.MediaFoundation.MediaSink.SetPresentationClock"/></strong> method.</p> <p>This flag is obsolete, because all media sinks must support the <strong>SetPresentationClock</strong> method, even if the media sink ignores the clock (as in a rateless media sink).</p> </td></tr> <tr><td><dl> <dt><strong><strong>MEDIASINK_CAN_PREROLL</strong></strong></dt> <dt>0x00000010</dt> </dl> </td><td> <p> The media sink can accept preroll samples before the presentation clock starts. The media sink exposes the <strong><see cref="SharpDX.MediaFoundation.MediaSinkPreroll"/></strong> interface. </p> </td></tr> <tr><td><dl> <dt><strong><strong>MEDIASINK_REQUIRE_REFERENCE_MEDIATYPE</strong></strong></dt> <dt>0x00000020</dt> </dl> </td><td> <p>The first stream sink (index 0) is a reference stream. The reference stream must have a media type before the media types can be set on the other stream sinks.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p> The media sink's <strong>Shutdown</strong> method has been called. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> The characteristics of a media sink are fixed throughout the life time of the sink. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSink::GetCharacteristics']/*"/>	
        /// <msdn-id>ms701973</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSink::GetCharacteristics([Out] unsigned int* pdwCharacteristics)</unmanaged>	
        /// <unmanaged-short>IMFMediaSink::GetCharacteristics</unmanaged-short>	
        internal void GetCharacteristics(out int dwCharacteristicsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwCharacteristicsRef_ = &dwCharacteristicsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwCharacteristicsRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Adds a new stream sink to the media sink.</p>	
        /// </summary>	
        /// <param name="dwStreamSinkIdentifier"><dd> <p>Identifier for the new stream. The value is arbitrary but must be unique.</p> </dd></param>	
        /// <param name="mediaTypeRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface, specifying the media type for the stream. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="streamSinkOut"><dd> <p>Receives a reference to the new stream sink's <strong><see cref="SharpDX.MediaFoundation.StreamSink"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The specified stream identifier is not valid.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.StreamsInkExists"/></strong></dt> </dl> </td><td> <p>There is already a stream sink with the same stream identifier.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.StreamsInksFixed"/></strong></dt> </dl> </td><td> <p>This media sink has a fixed set of stream sinks. New stream sinks cannot be added.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Not all media sinks support this method. If the media sink does not support this method, the <strong><see cref="SharpDX.MediaFoundation.MediaSink.GetCharacteristics"/></strong> method returns the MEDIASINK_FIXED_STREAMS flag.</p><p>If <em>pMediaType</em> is <strong><c>null</c></strong>, use the <strong><see cref="SharpDX.MediaFoundation.MediaTypeHandler"/></strong> interface to set the media type. Call <strong><see cref="SharpDX.MediaFoundation.StreamSink.GetMediaTypeHandler"/></strong> to get a reference to the interface.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSink::AddStreamSink']/*"/>	
        /// <msdn-id>ms694890</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSink::AddStreamSink([In] unsigned int dwStreamSinkIdentifier,[In, Optional] IMFMediaType* pMediaType,[Out] IMFStreamSink** ppStreamSink)</unmanaged>	
        /// <unmanaged-short>IMFMediaSink::AddStreamSink</unmanaged-short>	
        public void AddStreamSink(int dwStreamSinkIdentifier, SharpDX.MediaFoundation.MediaType mediaTypeRef, out SharpDX.MediaFoundation.StreamSink streamSinkOut)
        {
            unsafe
            {
                IntPtr streamSinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamSinkIdentifier, (void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), &streamSinkOut_, ((void**)(*(void**)_nativePointer))[4]);
                streamSinkOut = (streamSinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.StreamSink(streamSinkOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Removes a stream sink from the media sink.</p>	
        /// </summary>	
        /// <param name="dwStreamSinkIdentifier"><dd> <p>Identifier of the stream to remove. The stream identifier is defined when you call <strong><see cref="SharpDX.MediaFoundation.MediaSink.AddStreamSink"/></strong> to add the stream sink.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>This particular stream sink cannot be removed.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The stream number is not valid.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotInitializeD"/></strong></dt> </dl> </td><td> <p>The media sink has not been initialized.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.StreamsInksFixed"/></strong></dt> </dl> </td><td> <p>This media sink has a fixed set of stream sinks. Stream sinks cannot be removed.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>After this method is called, the corresponding stream sink object is no longer valid. The <strong><see cref="SharpDX.MediaFoundation.MediaSink.GetStreamSinkByIndex"/></strong> and <strong><see cref="SharpDX.MediaFoundation.MediaSink.GetStreamSinkById"/></strong> methods will no longer return that stream sink. You can re-use the stream identifier if you add another stream (by calling <strong>AddStreamSink</strong>).</p><p>Not all media sinks support this method. If the media sink does not support this method, the <strong><see cref="SharpDX.MediaFoundation.MediaSink.GetCharacteristics"/></strong> method returns the MEDIASINK_FIXED_STREAMS flag.</p><p>In some cases, the media sink supports this method but does not allow every stream sink to be removed. (For example, it might not allow stream 0 to be removed.)</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSink::RemoveStreamSink']/*"/>	
        /// <msdn-id>ms705627</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSink::RemoveStreamSink([In] unsigned int dwStreamSinkIdentifier)</unmanaged>	
        /// <unmanaged-short>IMFMediaSink::RemoveStreamSink</unmanaged-short>	
        public void RemoveStreamSink(int dwStreamSinkIdentifier)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamSinkIdentifier, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Gets the number of stream sinks on this media sink.</p>	
        /// </summary>	
        /// <param name="cStreamSinkCountRef"><dd> <p>Receives the number of stream sinks.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSink::GetStreamSinkCount']/*"/>	
        /// <msdn-id>ms703020</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSink::GetStreamSinkCount([Out] unsigned int* pcStreamSinkCount)</unmanaged>	
        /// <unmanaged-short>IMFMediaSink::GetStreamSinkCount</unmanaged-short>	
        internal void GetStreamSinkCount(out int cStreamSinkCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cStreamSinkCountRef_ = &cStreamSinkCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cStreamSinkCountRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Gets a stream sink, specified by index.</p>	
        /// </summary>	
        /// <param name="dwIndex"><dd> <p>Zero-based index of the stream. To get the number of streams, call <strong><see cref="SharpDX.MediaFoundation.MediaSink.GetStreamSinkCount"/></strong>.</p> </dd></param>	
        /// <param name="streamSinkOut"><dd> <p>Receives a reference to the stream's <strong><see cref="SharpDX.MediaFoundation.StreamSink"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidIndex"/></strong></dt> </dl> </td><td> <p>Invalid index.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Enumerating stream sinks is not a thread-safe operation, because stream sinks can be added or removed between calls to this method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSink::GetStreamSinkByIndex']/*"/>	
        /// <msdn-id>ms693512</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSink::GetStreamSinkByIndex([In] unsigned int dwIndex,[Out] IMFStreamSink** ppStreamSink)</unmanaged>	
        /// <unmanaged-short>IMFMediaSink::GetStreamSinkByIndex</unmanaged-short>	
        public void GetStreamSinkByIndex(int dwIndex, out SharpDX.MediaFoundation.StreamSink streamSinkOut)
        {
            unsafe
            {
                IntPtr streamSinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwIndex, &streamSinkOut_, ((void**)(*(void**)_nativePointer))[7]);
                streamSinkOut = (streamSinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.StreamSink(streamSinkOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Gets a stream sink, specified by stream identifier.</p>	
        /// </summary>	
        /// <param name="dwStreamSinkIdentifier"><dd> <p>Stream identifier of the stream sink.</p> </dd></param>	
        /// <param name="streamSinkOut"><dd> <p>Receives a reference to the stream's <strong><see cref="SharpDX.MediaFoundation.StreamSink"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The stream identifier is not valid.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If you add a stream sink by calling the <strong><see cref="SharpDX.MediaFoundation.MediaSink.AddStreamSink"/></strong> method, the stream identifier is specified in the <em>dwStreamSinkIdentifier</em> parameter of that method. If the media sink has a fixed set of streams, the media sink assigns the stream identifiers.</p><p>To enumerate the streams by index number instead of stream identifier, call <strong><see cref="SharpDX.MediaFoundation.MediaSink.GetStreamSinkByIndex"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSink::GetStreamSinkById']/*"/>	
        /// <msdn-id>ms695360</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSink::GetStreamSinkById([In] unsigned int dwStreamSinkIdentifier,[Out] IMFStreamSink** ppStreamSink)</unmanaged>	
        /// <unmanaged-short>IMFMediaSink::GetStreamSinkById</unmanaged-short>	
        public void GetStreamSinkById(int dwStreamSinkIdentifier, out SharpDX.MediaFoundation.StreamSink streamSinkOut)
        {
            unsafe
            {
                IntPtr streamSinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamSinkIdentifier, &streamSinkOut_, ((void**)(*(void**)_nativePointer))[8]);
                streamSinkOut = (streamSinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.StreamSink(streamSinkOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the presentation clock on the media sink.</p>	
        /// </summary>	
        /// <param name="presentationClockRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.PresentationClock"/></strong> interface of the presentation clock, or <strong><c>null</c></strong>. If the value is <strong><c>null</c></strong>, the media sink stops listening to the presentaton clock that was previously set, if any.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ClockNoTimeSource"/></strong></dt> </dl> </td><td> <p>The presentation clock does not have a time source. Call <strong>SetTimeSource</strong> on the presentation clock.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>During streaming, the media sink attempts to match rates with the presentation clock. Ideally, the media sink presents samples at the correct time according to the presentation clock and does not fall behind. Rateless media sinks are an exception to this rule, as they consume samples as quickly as possible and ignore the clock. If the sink is rateless, the <strong><see cref="SharpDX.MediaFoundation.MediaSink.GetCharacteristics"/></strong> method returns the MEDIASINK_RATELESS flag.</p><p>The presentation clock must have a time source. Before calling this method, call <strong><see cref="SharpDX.MediaFoundation.PresentationClock.SetTimeSource"/></strong> on the presentation clock to set the presentation time source. Some media sinks provide time sources; therefore, the media sink might be the time source for its own presentation clock. Regardless of what object provides the time source, however, the media sink must attempt to match rates with the clock specified in <em>pPresentationClock</em>. If a media sink cannot match rates with an external time source, the media sink's <strong><see cref="SharpDX.MediaFoundation.MediaSink.GetCharacteristics"/></strong> method retrieves the MEDIASINK_CANNOT_MATCH_CLOCK flag. In this case, <strong>SetPresentationClock</strong> will still succeed, but the results will not be optimal. The sink might not render samples quickly enough to match rates with the presentation clock.</p><p>If <em>pPresentationClock</em> is non-<strong><c>null</c></strong>, the media sink must register for clock state notifications, by calling <strong><see cref="SharpDX.MediaFoundation.PresentationClock.AddClockStateSink_"/></strong> on the presentation clock. If the method is called again with a new presentation clock, or if <em>pPresentationClock</em> is <strong><c>null</c></strong>, the media sink must call <strong><see cref="SharpDX.MediaFoundation.PresentationClock.RemoveClockStateSink_"/></strong> to deregister itself from the previous clock.</p><p>All media sinks must support this method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSink::SetPresentationClock']/*"/>	
        /// <msdn-id>ms700160</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSink::SetPresentationClock([In, Optional] IMFPresentationClock* pPresentationClock)</unmanaged>	
        /// <unmanaged-short>IMFMediaSink::SetPresentationClock</unmanaged-short>	
        internal void SetPresentationClock(SharpDX.MediaFoundation.PresentationClock presentationClockRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((presentationClockRef == null) ? IntPtr.Zero : presentationClockRef.NativePointer), ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Gets the presentation clock that was set on the media sink.</p>	
        /// </summary>	
        /// <param name="presentationClockOut"><dd> <p>Receives a reference to the presentation clock's <strong><see cref="SharpDX.MediaFoundation.PresentationClock"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoClock"/></strong></dt> </dl> </td><td> <p>No clock has been set. To set the presentation clock, call <strong><see cref="SharpDX.MediaFoundation.MediaSink.SetPresentationClock"/></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSink::GetPresentationClock']/*"/>	
        /// <msdn-id>ms705665</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSink::GetPresentationClock([Out] IMFPresentationClock** ppPresentationClock)</unmanaged>	
        /// <unmanaged-short>IMFMediaSink::GetPresentationClock</unmanaged-short>	
        internal void GetPresentationClock(out SharpDX.MediaFoundation.PresentationClock presentationClockOut)
        {
            unsafe
            {
                IntPtr presentationClockOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &presentationClockOut_, ((void**)(*(void**)_nativePointer))[10]);
                presentationClockOut = (presentationClockOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PresentationClock(presentationClockOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Shuts down the media sink and releases the resources it is using.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink was shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the application creates the media sink, it is responsible for calling <strong>Shutdown</strong> to avoid memory or resource leaks. In most applications, however, the application creates an activation object for the media sink, and the Media Session uses that object to create the media sink. In that case, the Media Session ? not the application ? shuts down the media sink. (For more information, see Activation Objects.)</p><p>After this method returns, all methods on the media sink return <see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/>,  except for <strong><see cref="SharpDX.ComObject"/></strong> methods and <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator"/></strong> methods. The sink will not raise any events after this method is called.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSink::Shutdown']/*"/>	
        /// <msdn-id>ms702084</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSink::Shutdown()</unmanaged>	
        /// <unmanaged-short>IMFMediaSink::Shutdown</unmanaged-short>	
        public void Shutdown()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables a media sink to receive samples before the presentation clock is started.</p><p>To get a reference to this interface, call <strong>QueryInterface</strong> on the media sink.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Media sinks can implement this interface to support seamless playback and transitions. If a media sink exposes this interface, it can receive samples before the presentation clock starts. It can then pre-process the samples, so that rendering can begin immediately when the clock starts. Prerolling helps to avoid glitches during playback.</p><p>If a media sink supports preroll, the media sink's <strong><see cref="SharpDX.MediaFoundation.MediaSink.GetCharacteristics"/></strong> method should return the MEDIASINK_CAN_PREROLL flag.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSinkPreroll']/*"/>	
    /// <msdn-id>ms699832</msdn-id>	
    /// <unmanaged>IMFMediaSinkPreroll</unmanaged>	
    /// <unmanaged-short>IMFMediaSinkPreroll</unmanaged-short>	
    [Guid("5dfd4b2a-7674-4110-a4e6-8a68fd5f3688")]
    public partial class MediaSinkPreroll : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaSinkPreroll"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaSinkPreroll(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaSinkPreroll"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaSinkPreroll(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaSinkPreroll(nativePointer);
        }


        /// <summary>	
        /// <p> Notifies the media sink that the presentation clock is about to start. </p>	
        /// </summary>	
        /// <param name="hnsUpcomingStartTime"><dd> <p> The upcoming start time for the presentation clock, in 100-nanosecond units. This time is the same value that will be given to the <strong><see cref="SharpDX.MediaFoundation.PresentationClock.Start"/></strong> method when the presentation clock is started. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> After this method is called, the media sink sends any number of <see cref="SharpDX.MediaFoundation.MediaEventTypes.StreamSinkRequestSample"/> events to request samples, until is has enough preroll data. When it has enough preroll data, the media sink sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.StreamSinkPrerolled"/> event. This event signals that the client can start the presentation clock. </p><p> During preroll, the media sink can prepare the samples that it receives, so that they are ready to be rendered. It does not actually render any samples until the clock starts. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSinkPreroll::NotifyPreroll']/*"/>	
        /// <msdn-id>ms703799</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSinkPreroll::NotifyPreroll([In] longlong hnsUpcomingStartTime)</unmanaged>	
        /// <unmanaged-short>IMFMediaSinkPreroll::NotifyPreroll</unmanaged-short>	
        public void NotifyPreroll(long hnsUpcomingStartTime)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, hnsUpcomingStartTime, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Implemented by media source objects.</p><p>Media sources are objects that generate media data. For example, the data might come from a video file, a network stream, or a hardware device, such as a camera. Each media source contains one or more streams, and each stream delivers data of one type, such as audio or video.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>In Windows?8, this interface is extended with <strong><see cref="SharpDX.MediaFoundation.MediaSourceEx"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSource']/*"/>	
    /// <msdn-id>ms700189</msdn-id>	
    /// <unmanaged>IMFMediaSource</unmanaged>	
    /// <unmanaged-short>IMFMediaSource</unmanaged-short>	
    [Guid("279a808d-aec7-40c8-9c6b-a6b492c78a66")]
    public partial class MediaSource : SharpDX.MediaFoundation.MediaEventGenerator
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaSource"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaSource(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaSource"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaSource(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaSource(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the characteristics of the media source.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The characteristics of a media source can change at any time. If this happens, the source sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.SourceCharacteristicsChanged"/> event.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSource::GetCharacteristics']/*"/>	
        /// <msdn-id>ms703148</msdn-id>	
        /// <unmanaged>GetCharacteristics</unmanaged>	
        /// <unmanaged-short>GetCharacteristics</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaSource::GetCharacteristics([Out] unsigned int* pdwCharacteristics)</unmanaged>
        public int Characteristics
        {
            get { int __output__; GetCharacteristics(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the characteristics of the media source.</p>	
        /// </summary>	
        /// <param name="dwCharacteristicsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.MediaSourceCharacteristics"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media source's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The characteristics of a media source can change at any time. If this happens, the source sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.SourceCharacteristicsChanged"/> event.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSource::GetCharacteristics']/*"/>	
        /// <msdn-id>ms703148</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSource::GetCharacteristics([Out] unsigned int* pdwCharacteristics)</unmanaged>	
        /// <unmanaged-short>IMFMediaSource::GetCharacteristics</unmanaged-short>	
        internal void GetCharacteristics(out int dwCharacteristicsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwCharacteristicsRef_ = &dwCharacteristicsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwCharacteristicsRef_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a copy of the media source's presentation descriptor. Applications use the presentation descriptor to select streams and to get information about the source content.</p>	
        /// </summary>	
        /// <param name="presentationDescriptorOut"><dd> <p>Receives a reference to the presentation descriptor's <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media source's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The presentation descriptor contains the media source's default settings for the presentation. The application can change these settings by selecting or deselecting streams, or by changing the media type on a stream. Do not modify the presentation descriptor unless the source is stopped. The changes take affect when the source's <strong><see cref="SharpDX.MediaFoundation.MediaSource.Start"/></strong> method is called.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSource::CreatePresentationDescriptor']/*"/>	
        /// <msdn-id>ms702261</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSource::CreatePresentationDescriptor([Out] IMFPresentationDescriptor** ppPresentationDescriptor)</unmanaged>	
        /// <unmanaged-short>IMFMediaSource::CreatePresentationDescriptor</unmanaged-short>	
        public void CreatePresentationDescriptor(out SharpDX.MediaFoundation.PresentationDescriptor presentationDescriptorOut)
        {
            unsafe
            {
                IntPtr presentationDescriptorOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &presentationDescriptorOut_, ((void**)(*(void**)_nativePointer))[8]);
                presentationDescriptorOut = (presentationDescriptorOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PresentationDescriptor(presentationDescriptorOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Starts, seeks, or restarts the media source by specifying where to start playback.</p>	
        /// </summary>	
        /// <param name="presentationDescriptorRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the media source's presentation descriptor. To get the presentation descriptor, call <strong><see cref="SharpDX.MediaFoundation.MediaSource.CreatePresentationDescriptor"/></strong>. You can modify the presentation descriptor before calling <strong>Start</strong>, to select or deselect streams or change the media types. </p> </dd></param>	
        /// <param name="guidTimeFormatRef"><dd> <p> Pointer to a <see cref="System.Guid"/> that specifies the time format. The time format defines the units for the <em>pvarStartPosition</em> parameter. If the value <em></em> is <strong>GUID_NULL</strong>, the time format is 100-nanosecond units. Some media sources might support additional time format GUIDs. This parameter can be <strong><c>null</c></strong>. If the value is <strong><c>null</c></strong>, it is equalivent to <strong>GUID_NULL</strong>. </p> </dd></param>	
        /// <param name="varStartPositionRef"><dd> <p> Specifies where to start playback. The units of this parameter are indicated by the time format given in <em>pguidTimeFormat</em>. If the time format is <strong>GUID_NULL</strong>, the variant type must be <strong>VT_I8</strong> or <strong>VT_EMPTY</strong>. Use <strong>VT_I8</strong> to specify a new starting position, in 100-nanosecond units. Use <strong>VT_EMPTY</strong> to start from the current position. Other time formats might use other <strong><see cref="SharpDX.Win32.Variant"/></strong> types. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.AsfOufOfRange"/></strong></dt> </dl> </td><td> <p> The start position is past the end of the presentation (ASF media source). </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.HwMftFailedStartStreaming"/></strong></dt> </dl> </td><td> <p>A hardware device was unable to start streaming. This error code can be returned by a media source that represents a hardware device, such as a camera. For example, if the camera is already being used by another application, the method might return this error code.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p> The start request is not valid. For example, the start position is past the end of the presentation. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p> The media source's <strong>Shutdown</strong> method has been called. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedTimeFormat"/></strong></dt> </dl> </td><td> <p> The media source does not support the time format specified in <em>pguidTimeFormat</em>. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is asynchronous. If the operation succeeds, the media source sends the following events:</p><ul> <li> For each new stream, the source sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.NewStream"/> event. This event is sent for the first <strong>Start</strong> call in which the stream appears. The event data is a reference to the stream's <strong><see cref="SharpDX.MediaFoundation.MediaStream"/></strong> interface. </li> <li> For each <em>updated</em> stream, the source sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.UpdatedStream"/> event. A stream is updated if the stream already existed when <strong>Start</strong> was called (for example, if the application seeks during playback). The event data is a reference to the stream's <strong><see cref="SharpDX.MediaFoundation.MediaStream"/></strong> interface. </li> <li> If the previous state was stopped, the source sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.SourceStarted"/> event. </li> <li> If the previous state was started or paused and the starting position is the current position (<strong>VT_EMPTY</strong>), the source sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.SourceStarted"/> event. </li> <li> If the previous state was started or paused, and a new starting position is specified, the source sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.SourceSeeked"/> event. </li> <li> If the source sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.SourceStarted"/> event, each media stream sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.StreamStarted"/> event. If the source sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.SourceSeeked"/> event, each stream sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.StreamSeeked"/> event. </li> </ul><p> If the start operation fails asynchronously (after the method returns <strong><see cref="SharpDX.Result.Ok"/></strong>), the media source sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.SourceStarted"/> event that contains a failure code, without sending any of the other events listed here. If the method fails synchronously (returns an error code), no events are raised. </p><p> A call to <strong>Start</strong> results in a <em>seek</em> if the previous state was started or paused, and the new starting position is not <strong>VT_EMPTY</strong>. Not every media source can seek. If a media source can seek, the <strong><see cref="SharpDX.MediaFoundation.MediaSource.GetCharacteristics"/></strong> method returns the <strong><see cref="SharpDX.MediaFoundation.MediaSourceCharacteristics.CanSeek"/></strong> flag. </p><p> Events from the media source are not synchronized with events from the media streams. If you seek a media source, therefore, you can still receive samples from the earlier position after getting the <see cref="SharpDX.MediaFoundation.MediaEventTypes.SourceSeeked"/> event. If you need to synchronize the operations, wait for the stream event, <see cref="SharpDX.MediaFoundation.MediaEventTypes.StreamSeeked"/>, which marks the exact point in the stream where the seek occurs. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSource::Start']/*"/>	
        /// <msdn-id>ms694101</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSource::Start([In, Optional] IMFPresentationDescriptor* pPresentationDescriptor,[In, Optional] const GUID* pguidTimeFormat,[In, Optional] const PROPVARIANT* pvarStartPosition)</unmanaged>	
        /// <unmanaged-short>IMFMediaSource::Start</unmanaged-short>	
        public void Start(SharpDX.MediaFoundation.PresentationDescriptor presentationDescriptorRef, System.Guid? guidTimeFormatRef, SharpDX.Win32.Variant? varStartPositionRef)
        {
            unsafe
            {
                System.Guid guidTimeFormatRef_;
                if (guidTimeFormatRef.HasValue)
                    guidTimeFormatRef_ = guidTimeFormatRef.Value;
                SharpDX.Win32.Variant varStartPositionRef_;
                if (varStartPositionRef.HasValue)
                    varStartPositionRef_ = varStartPositionRef.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((presentationDescriptorRef == null) ? IntPtr.Zero : presentationDescriptorRef.NativePointer), (guidTimeFormatRef.HasValue) ? &guidTimeFormatRef_ : (void*)IntPtr.Zero, (varStartPositionRef.HasValue) ? &varStartPositionRef_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Stops all active streams in the media source.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media source's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is asynchronous. When the operation completes, the media source sends and <see cref="SharpDX.MediaFoundation.MediaEventTypes.SourceStopped"/> event, and every active stream sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.StreamStopped"/> event. If the method returns a failure code, no events are raised.</p><p>When a media source is stopped, its current position reverts to zero. After that, if the <strong>Start</strong> method is called with VT_EMPTY for the starting position, playback starts from the beginning of the presentation.</p><p>While the source is stopped, no streams produce data.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSource::Stop']/*"/>	
        /// <msdn-id>ms702045</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSource::Stop()</unmanaged>	
        /// <unmanaged-short>IMFMediaSource::Stop</unmanaged-short>	
        public void Stop()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Pauses all active streams in the media source.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStateTransition"/></strong></dt> </dl> </td><td> <p>Invalid state transition. The media source must be in the started state.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media source's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is asynchronous. When the operation completes, the media source sends and <see cref="SharpDX.MediaFoundation.MediaEventTypes.SourcePaused"/> event, and every active stream sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.StreamPaused"/> event. If the method returns a failure code, no events are raised.</p><p>The media source must be in the started state. The method fails if the media source is paused or stopped.</p><p>While the source is paused, calls to <strong><see cref="SharpDX.MediaFoundation.MediaStream.RequestSample"/></strong> succeed, but the streams will not deliver any samples until after the source is started again. Note that the source's event queue is not serialized with the stream event queues, so the client might receive some samples after the <see cref="SharpDX.MediaFoundation.MediaEventTypes.SourcePaused"/> event, due to multi-threading issues. But the client will not receive any samples from a stream after the <see cref="SharpDX.MediaFoundation.MediaEventTypes.StreamPaused"/> event.</p><p>Not every media source can pause. If a media source can pause, the <strong><see cref="SharpDX.MediaFoundation.MediaSource.GetCharacteristics"/></strong> method returns the <see cref="SharpDX.MediaFoundation.MediaSourceCharacteristics.CanPause"/> flag.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSource::Pause']/*"/>	
        /// <msdn-id>ms694275</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSource::Pause()</unmanaged>	
        /// <unmanaged-short>IMFMediaSource::Pause</unmanaged-short>	
        public void Pause()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Shuts down the media source and releases the resources it is using.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the application creates the media source, either directly or through the source resolver, the application is responsible for calling <strong>Shutdown</strong> to avoid memory or resource leaks.</p><p>After this method is called, methods on the media source and all of its media streams return <see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/> (except for <strong><see cref="SharpDX.ComObject"/></strong> methods).</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSource::Shutdown']/*"/>	
        /// <msdn-id>ms703110</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSource::Shutdown()</unmanaged>	
        /// <unmanaged-short>IMFMediaSource::Shutdown</unmanaged-short>	
        public void Shutdown()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSource2']/*"/>	
    /// <unmanaged>IMFMediaSource2</unmanaged>	
    /// <unmanaged-short>IMFMediaSource2</unmanaged-short>	
    [Guid("FBB03414-D13B-4786-8319-5AC51FC0A136")]
    public partial class MediaSource2 : SharpDX.MediaFoundation.MediaSourceEx
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaSource2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaSource2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaSource2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaSource2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaSource2(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwStreamID">No documentation.</param>	
        /// <param name="mediaTypeRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSource2::SetMediaType']/*"/>	
        /// <unmanaged>HRESULT IMFMediaSource2::SetMediaType([In] unsigned int dwStreamID,[In] IMFMediaType* pMediaType)</unmanaged>	
        /// <unmanaged-short>IMFMediaSource2::SetMediaType</unmanaged-short>	
        public void SetMediaType(int dwStreamID, SharpDX.MediaFoundation.MediaType mediaTypeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamID, (void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Extends the <strong><see cref="SharpDX.MediaFoundation.MediaSource"/></strong> interface to provide additional capabilities for a media source.</p><p>To get a reference to this interface, call <strong>QueryInterface</strong> on the media source. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Implementations of this interface can return <strong>E_NOTIMPL</strong> for any methods that are not required by the media source.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceEx']/*"/>	
    /// <msdn-id>hh448029</msdn-id>	
    /// <unmanaged>IMFMediaSourceEx</unmanaged>	
    /// <unmanaged-short>IMFMediaSourceEx</unmanaged-short>	
    [Guid("3C9B2EB9-86D5-4514-A394-F56664F9F0D8")]
    public partial class MediaSourceEx : SharpDX.MediaFoundation.MediaSource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaSourceEx"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaSourceEx(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaSourceEx"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaSourceEx(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaSourceEx(nativePointer);
        }


        /// <summary>	
        /// <p>Gets an attribute store for the media source.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Use the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> reference to get or set attributes that apply to the entire source. For stream-level attributes, use the <strong><see cref="SharpDX.MediaFoundation.MediaSourceEx.GetStreamAttributes"/></strong> method instead.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceEx::GetSourceAttributes']/*"/>	
        /// <msdn-id>hh448030</msdn-id>	
        /// <unmanaged>GetSourceAttributes</unmanaged>	
        /// <unmanaged-short>GetSourceAttributes</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaSourceEx::GetSourceAttributes([Out] IMFAttributes** ppAttributes)</unmanaged>
        public SharpDX.MediaFoundation.MediaAttributes SourceAttributes
        {
            get { SharpDX.MediaFoundation.MediaAttributes __output__; GetSourceAttributes(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Sets a reference to the Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager on the media source.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceEx::SetD3DManager']/*"/>	
        /// <msdn-id>hh448032</msdn-id>	
        /// <unmanaged>SetD3DManager</unmanaged>	
        /// <unmanaged-short>SetD3DManager</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaSourceEx::SetD3DManager([In, Optional] IUnknown* pManager)</unmanaged>
        public SharpDX.ComObject D3DManager
        {
            set { SetD3DManager(value); }
        }

        /// <summary>	
        /// <p>Gets an attribute store for the media source.</p>	
        /// </summary>	
        /// <param name="attributesOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>The media source does not support source-level attributes.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Use the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> reference to get or set attributes that apply to the entire source. For stream-level attributes, use the <strong><see cref="SharpDX.MediaFoundation.MediaSourceEx.GetStreamAttributes"/></strong> method instead.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceEx::GetSourceAttributes']/*"/>	
        /// <msdn-id>hh448030</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSourceEx::GetSourceAttributes([Out] IMFAttributes** ppAttributes)</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceEx::GetSourceAttributes</unmanaged-short>	
        internal void GetSourceAttributes(out SharpDX.MediaFoundation.MediaAttributes attributesOut)
        {
            unsafe
            {
                IntPtr attributesOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &attributesOut_, ((void**)(*(void**)_nativePointer))[13]);
                attributesOut = (attributesOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(attributesOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets an attribute store for a stream on the media source.</p>	
        /// </summary>	
        /// <param name="dwStreamIdentifier"><dd> <p>The identifier of the stream. To get the identifier, call <strong><see cref="SharpDX.MediaFoundation.StreamDescriptor.GetStreamIdentifier"/></strong> on the stream descriptor.</p> </dd></param>	
        /// <param name="attributesOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>The media source does not support stream-level attributes.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>Invalid stream identifier.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Use the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> reference to get or set attributes that apply to the specified stream. For attributes that apply to the entire source, use the <strong><see cref="SharpDX.MediaFoundation.MediaSourceEx.GetSourceAttributes"/></strong> method instead.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceEx::GetStreamAttributes']/*"/>	
        /// <msdn-id>hh448031</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSourceEx::GetStreamAttributes([In] unsigned int dwStreamIdentifier,[Out] IMFAttributes** ppAttributes)</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceEx::GetStreamAttributes</unmanaged-short>	
        public void GetStreamAttributes(int dwStreamIdentifier, out SharpDX.MediaFoundation.MediaAttributes attributesOut)
        {
            unsafe
            {
                IntPtr attributesOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIdentifier, &attributesOut_, ((void**)(*(void**)_nativePointer))[14]);
                attributesOut = (attributesOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(attributesOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets a reference to the Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager on the media source.</p>	
        /// </summary>	
        /// <param name="managerRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of the DXGI Manager. The media source should query this reference for the <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> interface.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>The media source does not support source-level attributes.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceEx::SetD3DManager']/*"/>	
        /// <msdn-id>hh448032</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSourceEx::SetD3DManager([In, Optional] IUnknown* pManager)</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceEx::SetD3DManager</unmanaged-short>	
        internal void SetD3DManager(SharpDX.ComObject managerRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((managerRef == null) ? IntPtr.Zero : managerRef.NativePointer), ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides functionality for the Media Source Extension (MSE).</p>	
    /// </summary>	
    /// <remarks>	
    /// <p> Media Source Extensions (MSE) is a World Wide Web Consortium (W3C) standard that extends the HTML5 media  elements to enable dynamically changing the media stream without the use of plug-ins. The   <strong><see cref="SharpDX.MediaFoundation.MediaSourceExtension"/></strong> interface  and the related Microsoft Win32 API implement MSE and are expected to only be called by web browsers implementing MSE.  </p><p>The MSE media source keeps track of the ready state of the of the source as well as a list of <strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong> objects which provide media data for the source.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtension']/*"/>	
    /// <msdn-id>dn280726</msdn-id>	
    /// <unmanaged>IMFMediaSourceExtension</unmanaged>	
    /// <unmanaged-short>IMFMediaSourceExtension</unmanaged-short>	
    [Guid("e467b94e-a713-4562-a802-816a42e9008a")]
    public partial class MediaSourceExtension : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaSourceExtension"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaSourceExtension(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaSourceExtension"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaSourceExtension(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaSourceExtension(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the collection of source buffers associated with this media source.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtension::GetSourceBuffers']/*"/>	
        /// <msdn-id>dn280736</msdn-id>	
        /// <unmanaged>GetSourceBuffers</unmanaged>	
        /// <unmanaged-short>GetSourceBuffers</unmanaged-short>	
        /// <unmanaged>IMFSourceBufferList* IMFMediaSourceExtension::GetSourceBuffers()</unmanaged>
        public SharpDX.MediaFoundation.SourceBufferList SourceBuffers
        {
            get { return GetSourceBuffers(); }
        }

        /// <summary>	
        /// <p>Gets the source buffers that are actively supplying media data to the media source.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtension::GetActiveSourceBuffers']/*"/>	
        /// <msdn-id>dn280732</msdn-id>	
        /// <unmanaged>GetActiveSourceBuffers</unmanaged>	
        /// <unmanaged-short>GetActiveSourceBuffers</unmanaged-short>	
        /// <unmanaged>IMFSourceBufferList* IMFMediaSourceExtension::GetActiveSourceBuffers()</unmanaged>
        public SharpDX.MediaFoundation.SourceBufferList ActiveSourceBuffers
        {
            get { return GetActiveSourceBuffers(); }
        }

        /// <summary>	
        /// <p>Gets the ready state of the media source.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtension::GetReadyState']/*"/>	
        /// <msdn-id>dn280734</msdn-id>	
        /// <unmanaged>GetReadyState</unmanaged>	
        /// <unmanaged-short>GetReadyState</unmanaged-short>	
        /// <unmanaged>MF_MSE_READY IMFMediaSourceExtension::GetReadyState()</unmanaged>
        public SharpDX.MediaFoundation.MultisampledEReady ReadyState
        {
            get { return GetReadyState(); }
        }

        /// <summary>	
        /// <p>Gets or sets the duration of the media source in 100-nanosecond units.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtension::GetDuration']/*"/>	
        /// <msdn-id>dn280733</msdn-id>	
        /// <unmanaged>GetDuration / SetDuration</unmanaged>	
        /// <unmanaged-short>GetDuration</unmanaged-short>	
        /// <unmanaged>double IMFMediaSourceExtension::GetDuration()</unmanaged>
        public double Duration
        {
            get { return GetDuration(); }
            set { SetDuration(value); }
        }

        /// <summary>	
        /// <p>Indicate that the end of the media stream has been reached. </p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtension::SetEndOfStream']/*"/>	
        /// <msdn-id>dn280740</msdn-id>	
        /// <unmanaged>SetEndOfStream</unmanaged>	
        /// <unmanaged-short>SetEndOfStream</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaSourceExtension::SetEndOfStream([In] MF_MSE_ERROR error)</unmanaged>
        public SharpDX.MediaFoundation.MultisampledEError EndOfStream
        {
            set { SetEndOfStream(value); }
        }

        /// <summary>	
        /// <p>Gets the collection of source buffers associated with this media source.</p>	
        /// </summary>	
        /// <returns><p>The collection of source buffers.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtension::GetSourceBuffers']/*"/>	
        /// <msdn-id>dn280736</msdn-id>	
        /// <unmanaged>IMFSourceBufferList* IMFMediaSourceExtension::GetSourceBuffers()</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceExtension::GetSourceBuffers</unmanaged-short>	
        internal SharpDX.MediaFoundation.SourceBufferList GetSourceBuffers()
        {
            unsafe
            {
                SharpDX.MediaFoundation.SourceBufferList __result__;
                __result__ =
                new SharpDX.MediaFoundation.SourceBufferList((IntPtr)SharpDX.MediaFoundation.LocalInterop.CalliSystemIntPtr(_nativePointer, ((void**)(*(void**)_nativePointer))[3]));
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the source buffers that are actively supplying media data to the media source.</p>	
        /// </summary>	
        /// <returns><p>The list of active source buffers.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtension::GetActiveSourceBuffers']/*"/>	
        /// <msdn-id>dn280732</msdn-id>	
        /// <unmanaged>IMFSourceBufferList* IMFMediaSourceExtension::GetActiveSourceBuffers()</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceExtension::GetActiveSourceBuffers</unmanaged-short>	
        internal SharpDX.MediaFoundation.SourceBufferList GetActiveSourceBuffers()
        {
            unsafe
            {
                SharpDX.MediaFoundation.SourceBufferList __result__;
                __result__ =
                new SharpDX.MediaFoundation.SourceBufferList((IntPtr)SharpDX.MediaFoundation.LocalInterop.CalliSystemIntPtr(_nativePointer, ((void**)(*(void**)_nativePointer))[4]));
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the ready state of the media source.</p>	
        /// </summary>	
        /// <returns><p>The ready state of the media source.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtension::GetReadyState']/*"/>	
        /// <msdn-id>dn280734</msdn-id>	
        /// <unmanaged>MF_MSE_READY IMFMediaSourceExtension::GetReadyState()</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceExtension::GetReadyState</unmanaged-short>	
        internal SharpDX.MediaFoundation.MultisampledEReady GetReadyState()
        {
            unsafe
            {
                SharpDX.MediaFoundation.MultisampledEReady __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMediaFoundationMultisampledEReady(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the duration of the media source in 100-nanosecond units.</p>	
        /// </summary>	
        /// <returns><p>The duration of the media source in 100-nanosecond units. </p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtension::GetDuration']/*"/>	
        /// <msdn-id>dn280733</msdn-id>	
        /// <unmanaged>double IMFMediaSourceExtension::GetDuration()</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceExtension::GetDuration</unmanaged-short>	
        internal double GetDuration()
        {
            unsafe
            {
                double __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callidouble(_nativePointer, ((void**)(*(void**)_nativePointer))[6]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Sets the duration of the media source in 100-nanosecond units.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p>The duration of the media source in 100-nanosecond units.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtension::SetDuration']/*"/>	
        /// <msdn-id>dn280739</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSourceExtension::SetDuration([In] double duration)</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceExtension::SetDuration</unmanaged-short>	
        internal void SetDuration(double duration)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, duration, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Adds a <strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong> to the collection of buffers associated with the <strong><see cref="SharpDX.MediaFoundation.MediaSourceExtension"/></strong>.</p>	
        /// </summary>	
        /// <param name="type">No documentation.</param>	
        /// <param name="notifyRef">No documentation.</param>	
        /// <param name="sourceBufferOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtension::AddSourceBuffer']/*"/>	
        /// <msdn-id>dn280731</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSourceExtension::AddSourceBuffer([In] wchar_t* type,[In] IMFSourceBufferNotify* pNotify,[Out] IMFSourceBuffer** ppSourceBuffer)</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceExtension::AddSourceBuffer</unmanaged-short>	
        public void AddSourceBuffer(string type, SharpDX.MediaFoundation.SourceBufferNotify notifyRef, out SharpDX.MediaFoundation.SourceBuffer sourceBufferOut)
        {
            unsafe
            {
                IntPtr sourceBufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* type_ = type)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)type_, (void*)((notifyRef == null) ? IntPtr.Zero : notifyRef.NativePointer), &sourceBufferOut_, ((void**)(*(void**)_nativePointer))[8]);
                sourceBufferOut = (sourceBufferOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.SourceBuffer(sourceBufferOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Removes the specified source buffer from the collection of source buffers managed by the <strong><see cref="SharpDX.MediaFoundation.MediaSourceExtension"/></strong> object.</p>	
        /// </summary>	
        /// <param name="sourceBufferRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtension::RemoveSourceBuffer']/*"/>	
        /// <msdn-id>dn280738</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSourceExtension::RemoveSourceBuffer([In] IMFSourceBuffer* pSourceBuffer)</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceExtension::RemoveSourceBuffer</unmanaged-short>	
        public void RemoveSourceBuffer(SharpDX.MediaFoundation.SourceBuffer sourceBufferRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((sourceBufferRef == null) ? IntPtr.Zero : sourceBufferRef.NativePointer), ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Indicate that the end of the media stream has been reached. </p>	
        /// </summary>	
        /// <param name="error"><dd> <p>Used to pass error information.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtension::SetEndOfStream']/*"/>	
        /// <msdn-id>dn280740</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSourceExtension::SetEndOfStream([In] MF_MSE_ERROR error)</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceExtension::SetEndOfStream</unmanaged-short>	
        internal void SetEndOfStream(SharpDX.MediaFoundation.MultisampledEError error)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)error), ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a value that indicates if the specified MIME type is supported by the media source.</p>	
        /// </summary>	
        /// <param name="type"><dd> <p>The media type to check support for.</p> </dd></param>	
        /// <returns><p><strong>true</strong> if the media type is supported; otherwise, <strong>false</strong>.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtension::IsTypeSupported']/*"/>	
        /// <msdn-id>dn280737</msdn-id>	
        /// <unmanaged>BOOL IMFMediaSourceExtension::IsTypeSupported([In] wchar_t* type)</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceExtension::IsTypeSupported</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool IsTypeSupported(string type)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                fixed (char* type_ = type)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, (void*)type_, ((void**)(*(void**)_nativePointer))[11]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the <strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong> at the specified index in the collection of buffers.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex">No documentation.</param>	
        /// <returns><p>The source buffer.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtension::GetSourceBuffer']/*"/>	
        /// <msdn-id>dn280735</msdn-id>	
        /// <unmanaged>IMFSourceBuffer* IMFMediaSourceExtension::GetSourceBuffer([In] unsigned int dwStreamIndex)</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceExtension::GetSourceBuffer</unmanaged-short>	
        public SharpDX.MediaFoundation.SourceBuffer GetSourceBuffer(int dwStreamIndex)
        {
            unsafe
            {
                SharpDX.MediaFoundation.SourceBuffer __result__;
                __result__ =
                new SharpDX.MediaFoundation.SourceBuffer((IntPtr)SharpDX.MediaFoundation.LocalInterop.CalliSystemIntPtr(_nativePointer, dwStreamIndex, ((void**)(*(void**)_nativePointer))[12]));
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Provides functionality for raising events associated with <strong><see cref="SharpDX.MediaFoundation.MediaSourceExtension"/></strong>.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtensionNotify']/*"/>	
    /// <msdn-id>dn280727</msdn-id>	
    /// <unmanaged>IMFMediaSourceExtensionNotify</unmanaged>	
    /// <unmanaged-short>IMFMediaSourceExtensionNotify</unmanaged-short>	
    [Guid("a7901327-05dd-4469-a7b7-0e01979e361d")]
    public partial class MediaSourceExtensionNotify : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaSourceExtensionNotify"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaSourceExtensionNotify(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaSourceExtensionNotify"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaSourceExtensionNotify(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaSourceExtensionNotify(nativePointer);
        }


        /// <summary>	
        /// <p>Used to indicate that the  media source has opened.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtensionNotify::OnSourceOpen']/*"/>	
        /// <msdn-id>dn280730</msdn-id>	
        /// <unmanaged>void IMFMediaSourceExtensionNotify::OnSourceOpen()</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceExtensionNotify::OnSourceOpen</unmanaged-short>	
        public void OnSourceOpen()
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
            }
        }

        /// <summary>	
        /// <p>Used to indicate that the media source has ended.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtensionNotify::OnSourceEnded']/*"/>	
        /// <msdn-id>dn280729</msdn-id>	
        /// <unmanaged>void IMFMediaSourceExtensionNotify::OnSourceEnded()</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceExtensionNotify::OnSourceEnded</unmanaged-short>	
        public void OnSourceEnded()
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
            }
        }

        /// <summary>	
        /// <p>Used to indicate that the media source has closed.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceExtensionNotify::OnSourceClose']/*"/>	
        /// <msdn-id>dn280728</msdn-id>	
        /// <unmanaged>void IMFMediaSourceExtensionNotify::OnSourceClose()</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceExtensionNotify::OnSourceClose</unmanaged-short>	
        public void OnSourceClose()
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Notifies the source when playback has reached the end of a segment. For timelines, this corresponds to reaching a mark-out point.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourcePresentationProvider']/*"/>	
    /// <msdn-id>ms705639</msdn-id>	
    /// <unmanaged>IMFMediaSourcePresentationProvider</unmanaged>	
    /// <unmanaged-short>IMFMediaSourcePresentationProvider</unmanaged-short>	
    [Guid("0E1D600a-C9F3-442d-8C51-A42D2D49452F")]
    public partial class MediaSourcePresentationProvider : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaSourcePresentationProvider"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaSourcePresentationProvider(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaSourcePresentationProvider"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaSourcePresentationProvider(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaSourcePresentationProvider(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Notifies the source when playback has reached the end of a segment. For timelines, this corresponds to reaching a mark-out point.</p>	
        /// </summary>	
        /// <param name="presentationDescriptorRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the presentation descriptor for the segment that has ended.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourcePresentationProvider::ForceEndOfPresentation']/*"/>	
        /// <msdn-id>ms705639</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSourcePresentationProvider::ForceEndOfPresentation([In, Optional] IMFPresentationDescriptor* pPresentationDescriptor)</unmanaged>	
        /// <unmanaged-short>IMFMediaSourcePresentationProvider::ForceEndOfPresentation</unmanaged-short>	
        public void ForceEndOfPresentation(SharpDX.MediaFoundation.PresentationDescriptor presentationDescriptorRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((presentationDescriptorRef == null) ? IntPtr.Zero : presentationDescriptorRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables an application to get a topology from the sequencer source. This interface is exposed by the sequencer source object.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceTopologyProvider']/*"/>	
    /// <msdn-id>ms699013</msdn-id>	
    /// <unmanaged>IMFMediaSourceTopologyProvider</unmanaged>	
    /// <unmanaged-short>IMFMediaSourceTopologyProvider</unmanaged-short>	
    [Guid("0E1D6009-C9F3-442d-8C51-A42D2D49452F")]
    public partial class MediaSourceTopologyProvider : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaSourceTopologyProvider"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaSourceTopologyProvider(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaSourceTopologyProvider"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaSourceTopologyProvider(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaSourceTopologyProvider(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Returns a topology for a media source that builds an internal topology.</p>	
        /// </summary>	
        /// <param name="presentationDescriptorRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the media source's presentation descriptor. To get this reference, either call <strong><see cref="SharpDX.MediaFoundation.MediaSource.CreatePresentationDescriptor"/></strong> on the media source, or get the reference from the <see cref="SharpDX.MediaFoundation.MediaEventTypes.NewPresentation"/> event.</p> </dd></param>	
        /// <param name="topologyOut"><dd> <p>Receives a reference to the topology's <strong><see cref="SharpDX.MediaFoundation.Topology"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument. For example, a <strong><c>null</c></strong> input parameter, or the presentation descriptor is not valid.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaSourceTopologyProvider::GetMediaSourceTopology']/*"/>	
        /// <msdn-id>bb970383</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaSourceTopologyProvider::GetMediaSourceTopology([In, Optional] IMFPresentationDescriptor* pPresentationDescriptor,[Out] IMFTopology** ppTopology)</unmanaged>	
        /// <unmanaged-short>IMFMediaSourceTopologyProvider::GetMediaSourceTopology</unmanaged-short>	
        public void GetMediaSourceTopology(SharpDX.MediaFoundation.PresentationDescriptor presentationDescriptorRef, out SharpDX.MediaFoundation.Topology topologyOut)
        {
            unsafe
            {
                IntPtr topologyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((presentationDescriptorRef == null) ? IntPtr.Zero : presentationDescriptorRef.NativePointer), &topologyOut_, ((void**)(*(void**)_nativePointer))[3]);
                topologyOut = (topologyOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Topology(topologyOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Represents one stream in a media source. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Streams are created when a media source is started. For each stream, the media source sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.NewStream"/> event with a reference to the stream's <strong><see cref="SharpDX.MediaFoundation.MediaStream"/></strong> interface.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaStream']/*"/>	
    /// <msdn-id>ms697561</msdn-id>	
    /// <unmanaged>IMFMediaStream</unmanaged>	
    /// <unmanaged-short>IMFMediaStream</unmanaged-short>	
    [Guid("D182108F-4EC6-443f-AA42-A71106EC825F")]
    public partial class MediaStream : SharpDX.MediaFoundation.MediaEventGenerator
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaStream"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaStream(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaStream"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaStream(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaStream(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves a reference to the media source that created this media stream.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaStream::GetMediaSource']/*"/>	
        /// <msdn-id>ms705668</msdn-id>	
        /// <unmanaged>GetMediaSource</unmanaged>	
        /// <unmanaged-short>GetMediaSource</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaStream::GetMediaSource([Out] IMFMediaSource** ppMediaSource)</unmanaged>
        public SharpDX.MediaFoundation.MediaSource MediaSource
        {
            get { SharpDX.MediaFoundation.MediaSource __output__; GetMediaSource(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a stream descriptor for this media stream.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Do not modify the stream descriptor. To change the presentation, call <strong><see cref="SharpDX.MediaFoundation.MediaSource.CreatePresentationDescriptor"/></strong> and modify the presentation descriptor.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaStream::GetStreamDescriptor']/*"/>	
        /// <msdn-id>ms697244</msdn-id>	
        /// <unmanaged>GetStreamDescriptor</unmanaged>	
        /// <unmanaged-short>GetStreamDescriptor</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaStream::GetStreamDescriptor([Out] IMFStreamDescriptor** ppStreamDescriptor)</unmanaged>
        public SharpDX.MediaFoundation.StreamDescriptor StreamDescriptor
        {
            get { SharpDX.MediaFoundation.StreamDescriptor __output__; GetStreamDescriptor(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a reference to the media source that created this media stream.</p>	
        /// </summary>	
        /// <param name="mediaSourceOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaSource"/></strong> interface of the media source. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media source's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaStream::GetMediaSource']/*"/>	
        /// <msdn-id>ms705668</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaStream::GetMediaSource([Out] IMFMediaSource** ppMediaSource)</unmanaged>	
        /// <unmanaged-short>IMFMediaStream::GetMediaSource</unmanaged-short>	
        internal void GetMediaSource(out SharpDX.MediaFoundation.MediaSource mediaSourceOut)
        {
            unsafe
            {
                IntPtr mediaSourceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &mediaSourceOut_, ((void**)(*(void**)_nativePointer))[7]);
                mediaSourceOut = (mediaSourceOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSource(mediaSourceOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a stream descriptor for this media stream.</p>	
        /// </summary>	
        /// <param name="streamDescriptorOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.StreamDescriptor"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media source's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Do not modify the stream descriptor. To change the presentation, call <strong><see cref="SharpDX.MediaFoundation.MediaSource.CreatePresentationDescriptor"/></strong> and modify the presentation descriptor.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaStream::GetStreamDescriptor']/*"/>	
        /// <msdn-id>ms697244</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaStream::GetStreamDescriptor([Out] IMFStreamDescriptor** ppStreamDescriptor)</unmanaged>	
        /// <unmanaged-short>IMFMediaStream::GetStreamDescriptor</unmanaged-short>	
        internal void GetStreamDescriptor(out SharpDX.MediaFoundation.StreamDescriptor streamDescriptorOut)
        {
            unsafe
            {
                IntPtr streamDescriptorOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &streamDescriptorOut_, ((void**)(*(void**)_nativePointer))[8]);
                streamDescriptorOut = (streamDescriptorOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.StreamDescriptor(streamDescriptorOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Requests a sample from the media source. </p>	
        /// </summary>	
        /// <param name="tokenRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface to an object that is used as a token for the request. The caller must implement this object. This parameter can be <strong><c>null</c></strong>. See Remarks.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.EndOfStream"/></strong></dt> </dl> </td><td> <p> The end of the stream was reached. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.MediaSourceWrongState"/></strong></dt> </dl> </td><td> <p> The media source is stopped.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p> The source's <strong>Shutdown</strong> method has been called. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If <em>pToken</em> is not <strong><c>null</c></strong>, the media stream calls <strong>AddRef</strong> on <em>pToken</em> and places the token in a first-in, first-out queue.</p><p>When the next sample is available, the media stream stream does the following:</p><ol> <li> Pulls the first token from the queue. </li> <li> Sets the <strong><see cref="SharpDX.MediaFoundation.SampleAttributeKeys.Token"/></strong> attribute on the media sample. The attribute data is a reference to the token object. </li> <li> Sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.MediaSample"/> event. The event data is a reference to the media sample's <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface. </li> <li> Calls <strong>Release</strong> on the token. </li> </ol><p>If the media stream cannot fulfill the caller's request for a sample, it simply releases the token object and skips steps 2 and 3.</p><p>The caller should monitor the reference count on the request token. If the media stream sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.MediaSample"/> event, get the <strong><see cref="SharpDX.MediaFoundation.SampleAttributeKeys.Token"/></strong> attribute from the sample and match the attribute value against the token. If the token's reference count falls to zero and you did not receive an <see cref="SharpDX.MediaFoundation.MediaEventTypes.MediaSample"/> event, it means that the request was dropped.</p><p>Because the Media Foundation pipeline is multithreaded, the source's <strong>RequestSample</strong> method might get called after the source has stopped. If the media source is stopped, the method should return <strong><see cref="SharpDX.MediaFoundation.ResultCode.MediaSourceWrongState"/></strong>. The pipeline does not treat this return code as an error condition. If the source returns any other error code, the pipeline treats it as fatal error and halts the session.</p><strong>Note</strong>??Earlier versions of the documentation listed the wrong error code for this case.?<p>If the media source is paused, the method succeeds, but the stream does not deliver the sample until the source is started again.</p><p>If a media source enounters an error asynchronously while processing data, it should signal the error in one of the following ways (but not both):</p><ul> <li>Return an error code from the next <strong>RequestSample</strong> call.</li> <li>Send an <see cref="SharpDX.MediaFoundation.MediaEventTypes.Error"/> event.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaStream::RequestSample']/*"/>	
        /// <msdn-id>ms696240</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaStream::RequestSample([In] IUnknown* pToken)</unmanaged>	
        /// <unmanaged-short>IMFMediaStream::RequestSample</unmanaged-short>	
        public void RequestSample(SharpDX.ComObject tokenRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((tokenRef == null) ? IntPtr.Zero : tokenRef.NativePointer), ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaStream2']/*"/>	
    /// <unmanaged>IMFMediaStream2</unmanaged>	
    /// <unmanaged-short>IMFMediaStream2</unmanaged-short>	
    [Guid("C5BC37D6-75C7-46A1-A132-81B5F723C20F")]
    public partial class MediaStream2 : SharpDX.MediaFoundation.MediaStream
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaStream2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaStream2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaStream2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaStream2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaStream2(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaStream2::GetStreamState']/*"/>	
        /// <unmanaged>GetStreamState / SetStreamState</unmanaged>	
        /// <unmanaged-short>GetStreamState</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaStream2::GetStreamState([Out] MF_STREAM_STATE* value)</unmanaged>
        public SharpDX.MediaFoundation.StreamState StreamState
        {
            get { SharpDX.MediaFoundation.StreamState __output__; GetStreamState(out __output__); return __output__; }
            set { SetStreamState(value); }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="value">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaStream2::SetStreamState']/*"/>	
        /// <unmanaged>HRESULT IMFMediaStream2::SetStreamState([In] MF_STREAM_STATE value)</unmanaged>	
        /// <unmanaged-short>IMFMediaStream2::SetStreamState</unmanaged-short>	
        internal void SetStreamState(SharpDX.MediaFoundation.StreamState value)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)value), ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="value">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaStream2::GetStreamState']/*"/>	
        /// <unmanaged>HRESULT IMFMediaStream2::GetStreamState([Out] MF_STREAM_STATE* value)</unmanaged>	
        /// <unmanaged-short>IMFMediaStream2::GetStreamState</unmanaged-short>	
        internal void GetStreamState(out SharpDX.MediaFoundation.StreamState value)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* value_ = &value)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, value_, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a request for a  sample from a MediaStreamSource. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p><strong>MFMediaStreamSourceSampleRequest</strong> is implemented by the <strong>Windows.Media.Core.MediaStreamSourceSampleRequest</strong> runtime class.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaStreamSourceSampleRequest']/*"/>	
    /// <msdn-id>dn280741</msdn-id>	
    /// <unmanaged>IMFMediaStreamSourceSampleRequest</unmanaged>	
    /// <unmanaged-short>IMFMediaStreamSourceSampleRequest</unmanaged-short>	
    [Guid("380b9af9-a85b-4e78-a2af-ea5ce645c6b4")]
    public partial class MediaStreamSourceSampleRequest : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaStreamSourceSampleRequest"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaStreamSourceSampleRequest(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaStreamSourceSampleRequest"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaStreamSourceSampleRequest(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaStreamSourceSampleRequest(nativePointer);
        }


        /// <summary>	
        /// <p>Sets the sample for the media stream source.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaStreamSourceSampleRequest::SetSample']/*"/>	
        /// <msdn-id>dn280742</msdn-id>	
        /// <unmanaged>SetSample</unmanaged>	
        /// <unmanaged-short>SetSample</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaStreamSourceSampleRequest::SetSample([In, Optional] IMFSample* value)</unmanaged>
        public SharpDX.MediaFoundation.Sample Sample
        {
            set { SetSample(value); }
        }

        /// <summary>	
        /// <p>Sets the sample for the media stream source.</p>	
        /// </summary>	
        /// <param name="value"><dd> <p>The sample for the media stream source.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaStreamSourceSampleRequest::SetSample']/*"/>	
        /// <msdn-id>dn280742</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaStreamSourceSampleRequest::SetSample([In, Optional] IMFSample* value)</unmanaged>	
        /// <unmanaged-short>IMFMediaStreamSourceSampleRequest::SetSample</unmanaged-short>	
        internal void SetSample(SharpDX.MediaFoundation.Sample value)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((value == null) ? IntPtr.Zero : value.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a list of time ranges, where each range is defined by a start and end time.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.MediaFoundation.MediaTimeRange"/></strong> interface corresponds to the <strong>TimeRanges</strong> interface in HTML5.</p><p>Several <strong><see cref="SharpDX.MediaFoundation.MediaEngine"/></strong> methods return <strong><see cref="SharpDX.MediaFoundation.MediaTimeRange"/></strong> references.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTimeRange']/*"/>	
    /// <msdn-id>hh448033</msdn-id>	
    /// <unmanaged>IMFMediaTimeRange</unmanaged>	
    /// <unmanaged-short>IMFMediaTimeRange</unmanaged-short>	
    [Guid("db71a2fc-078a-414e-9df9-8c2531b0aa6c")]
    public partial class MediaTimeRange : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaTimeRange"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaTimeRange(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaTimeRange"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaTimeRange(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaTimeRange(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the number of time ranges contained in the object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>TimeRanges.length</strong> attribute in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTimeRange::GetLength']/*"/>	
        /// <msdn-id>hh448038</msdn-id>	
        /// <unmanaged>GetLength</unmanaged>	
        /// <unmanaged-short>GetLength</unmanaged-short>	
        /// <unmanaged>unsigned int IMFMediaTimeRange::GetLength()</unmanaged>
        public int Length
        {
            get { return GetLength(); }
        }

        /// <summary>	
        /// <p>Gets the number of time ranges contained in the object.</p>	
        /// </summary>	
        /// <returns><p>Returns the number of time ranges.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>TimeRanges.length</strong> attribute in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTimeRange::GetLength']/*"/>	
        /// <msdn-id>hh448038</msdn-id>	
        /// <unmanaged>unsigned int IMFMediaTimeRange::GetLength()</unmanaged>	
        /// <unmanaged-short>IMFMediaTimeRange::GetLength</unmanaged-short>	
        internal int GetLength()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the start time for a specified time range.</p>	
        /// </summary>	
        /// <param name="index"><dd> <p>The zero-based index of the time range to query. To get the  number of time ranges, call <strong><see cref="SharpDX.MediaFoundation.MediaTimeRange.GetLength"/></strong>.</p> </dd></param>	
        /// <param name="startRef"><dd> <p>Receives the start time, in seconds.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>TimeRanges.start</strong> method in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTimeRange::GetStart']/*"/>	
        /// <msdn-id>hh448039</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaTimeRange::GetStart([In] unsigned int index,[Out] double* pStart)</unmanaged>	
        /// <unmanaged-short>IMFMediaTimeRange::GetStart</unmanaged-short>	
        public void GetStart(int index, out double startRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* startRef_ = &startRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, index, startRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the end time for a specified time range.</p>	
        /// </summary>	
        /// <param name="index"><dd> <p>The zero-based index of the time range to query. To get the  number of time ranges, call <strong><see cref="SharpDX.MediaFoundation.MediaTimeRange.GetLength"/></strong>.</p> </dd></param>	
        /// <param name="endRef"><dd> <p>Receives the end time, in seconds.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method corresponds to the <strong>TimeRanges.end</strong> method in HTML5.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTimeRange::GetEnd']/*"/>	
        /// <msdn-id>hh448037</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaTimeRange::GetEnd([In] unsigned int index,[Out] double* pEnd)</unmanaged>	
        /// <unmanaged-short>IMFMediaTimeRange::GetEnd</unmanaged-short>	
        public void GetEnd(int index, out double endRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* endRef_ = &endRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, index, endRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries whether a specified time falls within any of the time ranges.</p>	
        /// </summary>	
        /// <param name="time"><dd> <p>The time, in seconds.</p> </dd></param>	
        /// <returns><p>Returns <strong>TRUE</strong> if any time range contained in this object spans the value of the <em>time</em> parameter. Otherwise, returns <strong><see cref="SharpDX.Result.False"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>This method returns <strong>TRUE</strong> if the following condition holds for any time range in the list:</p><dl> <dd>(<em>start</em> &lt;= <em>time</em>) &amp;&amp; (<em>time</em> &lt;= <em>end</em>)</dd> </dl>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTimeRange::ContainsTime']/*"/>	
        /// <msdn-id>hh448036</msdn-id>	
        /// <unmanaged>BOOL IMFMediaTimeRange::ContainsTime([In] double time)</unmanaged>	
        /// <unmanaged-short>IMFMediaTimeRange::ContainsTime</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool ContainsTime(double time)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, time, ((void**)(*(void**)_nativePointer))[6]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Adds a new range to the list of time ranges.</p>	
        /// </summary>	
        /// <param name="startTime"><dd> <p>The start time, in seconds.</p> </dd></param>	
        /// <param name="endTime"><dd> <p>The end time, in seconds.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If the new range intersects a range already in the list, the two ranges are combined. Otherwise, the new range is added to the list.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTimeRange::AddRange']/*"/>	
        /// <msdn-id>hh448034</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaTimeRange::AddRange([In] double startTime,[In] double endTime)</unmanaged>	
        /// <unmanaged-short>IMFMediaTimeRange::AddRange</unmanaged-short>	
        public void AddRange(double startTime, double endTime)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, startTime, endTime, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Clears the list of time ranges.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTimeRange::Clear']/*"/>	
        /// <msdn-id>hh448035</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaTimeRange::Clear()</unmanaged>	
        /// <unmanaged-short>IMFMediaTimeRange::Clear</unmanaged-short>	
        public void Clear()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Represents a description of a media format. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p> To create a new media type, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateMediaType"/></strong>. </p><p> All of the information in a media type is stored as attributes. To clone a media type, call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.CopyAllItems"/></strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaType']/*"/>	
    /// <msdn-id>ms704850</msdn-id>	
    /// <unmanaged>IMFMediaType</unmanaged>	
    /// <unmanaged-short>IMFMediaType</unmanaged-short>	
    [Guid("44ae0fa8-ea31-4109-8d2e-4cae4997c555")]
    public partial class MediaType : SharpDX.MediaFoundation.MediaAttributes
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaType"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaType(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaType"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaType(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaType(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the major type of the format. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p> This method is equivalent to getting the <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.MajorType"/></strong> attribute from the media type. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaType::GetMajorType']/*"/>	
        /// <msdn-id>ms701588</msdn-id>	
        /// <unmanaged>GetMajorType</unmanaged>	
        /// <unmanaged-short>GetMajorType</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaType::GetMajorType([Out] GUID* pguidMajorType)</unmanaged>
        public System.Guid MajorType
        {
            get { System.Guid __output__; GetMajorType(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Queries whether the media type is a temporally compressed format. Temporal compression uses information from previously decoded samples when decompressing the current sample.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> This method returns <strong><see cref="SharpDX.Result.False"/></strong> in <em>pfCompressed</em> if the media type's <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.AllSamplesIndependent"/></strong> attribute is <strong>TRUE</strong>. If the <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.AllSamplesIndependent"/></strong> attribute is <strong><see cref="SharpDX.Result.False"/></strong> or not set, the method returns <strong>TRUE</strong>. </p><p> If the method returns <strong>TRUE</strong> in <em>pfCompressed</em>, it is a hint that the format has temporal compression applied to it. If the method returns <strong><see cref="SharpDX.Result.False"/></strong>, the format does not use temporal compression, although it might use intra-frame compression. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaType::IsCompressedFormat']/*"/>	
        /// <msdn-id>ms703821</msdn-id>	
        /// <unmanaged>IsCompressedFormat</unmanaged>	
        /// <unmanaged-short>IsCompressedFormat</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaType::IsCompressedFormat([Out] BOOL* pfCompressed)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsCompressedFormat
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; IsCompressedFormat_(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets the major type of the format. </p>	
        /// </summary>	
        /// <param name="guidMajorTypeRef"><dd> <p>Receives the major type <strong><see cref="System.Guid"/></strong>. The major type describes the broad category of the format, such as audio or video. For a list of possible values, see Major Media Types. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Attributenotfound"/></strong></dt> </dl> </td><td> <p> The major type is not set. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> This method is equivalent to getting the <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.MajorType"/></strong> attribute from the media type. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaType::GetMajorType']/*"/>	
        /// <msdn-id>ms701588</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaType::GetMajorType([Out] GUID* pguidMajorType)</unmanaged>	
        /// <unmanaged-short>IMFMediaType::GetMajorType</unmanaged-short>	
        internal void GetMajorType(out System.Guid guidMajorTypeRef)
        {
            unsafe
            {
                guidMajorTypeRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* guidMajorTypeRef_ = &guidMajorTypeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, guidMajorTypeRef_, ((void**)(*(void**)_nativePointer))[33]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Queries whether the media type is a temporally compressed format. Temporal compression uses information from previously decoded samples when decompressing the current sample.</p>	
        /// </summary>	
        /// <param name="fCompressedRef"><dd> <p>Receives a Boolean value. The value is <strong>TRUE</strong> if the format uses temporal compression, or <strong><see cref="SharpDX.Result.False"/></strong> if the format does not use temporal compression.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This method returns <strong><see cref="SharpDX.Result.False"/></strong> in <em>pfCompressed</em> if the media type's <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.AllSamplesIndependent"/></strong> attribute is <strong>TRUE</strong>. If the <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.AllSamplesIndependent"/></strong> attribute is <strong><see cref="SharpDX.Result.False"/></strong> or not set, the method returns <strong>TRUE</strong>. </p><p> If the method returns <strong>TRUE</strong> in <em>pfCompressed</em>, it is a hint that the format has temporal compression applied to it. If the method returns <strong><see cref="SharpDX.Result.False"/></strong>, the format does not use temporal compression, although it might use intra-frame compression. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaType::IsCompressedFormat']/*"/>	
        /// <msdn-id>ms703821</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaType::IsCompressedFormat([Out] BOOL* pfCompressed)</unmanaged>	
        /// <unmanaged-short>IMFMediaType::IsCompressedFormat</unmanaged-short>	
        internal void IsCompressedFormat_(out SharpDX.Mathematics.Interop.RawBool fCompressedRef)
        {
            unsafe
            {
                fCompressedRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fCompressedRef_ = &fCompressedRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fCompressedRef_, ((void**)(*(void**)_nativePointer))[34]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Compares two media types and determines whether they are identical. If they are not identical, the method indicates how the two formats differ. </p>	
        /// </summary>	
        /// <param name="iMediaTypeRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type to compare.</p> </dd></param>	
        /// <param name="dwFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags, indicating the degree of similarity between the two media types. The following flags are defined.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MF_MEDIATYPE_EQUAL_MAJOR_TYPES</strong></dt> <dt>0x00000001</dt> </dl> </td><td> <p>The major types are the same. The major type is specified by the <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.MajorType"/></strong> attribute.</p> </td></tr> <tr><td><dl> <dt><strong>MF_MEDIATYPE_EQUAL_FORMAT_TYPES</strong></dt> <dt>0x00000002</dt> </dl> </td><td> <p>The subtypes are the same, or neither media type has a subtype. The subtype is specified by the <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.Subtype"/></strong> attribute.</p> </td></tr> <tr><td><dl> <dt><strong>MF_MEDIATYPE_EQUAL_FORMAT_DATA</strong></dt> <dt>0x00000004</dt> </dl> </td><td> <p>The attributes in one of the media types are a  subset of the attributes in the other, and the values of these attributes match, excluding the value of the <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.UserData"/></strong>, <see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.FrameRateRangeMin"/>,  and <see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.FrameRateRangeMax"/> attributes.</p> <p>Specifically, the method takes the media type with the smaller number of attributes and checks whether each attribute from that type is present in the other media type and has the same value (not including <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.UserData"/></strong>, <see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.FrameRateRangeMin"/>,  and <see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.FrameRateRangeMax"/>). </p> <p>To perform other comparisons, use the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.Compare"/></strong> method. For example, the <strong>Compare</strong> method can test for identical attributes, or test the intersection of the two attribute sets. For more information, see <strong><see cref="SharpDX.MediaFoundation.AttributesMatchType"/></strong>.</p> </td></tr> <tr><td><dl> <dt><strong>MF_MEDIATYPE_EQUAL_FORMAT_USER_DATA</strong></dt> <dt>0x00000008</dt> </dl> </td><td> <p>The user data is identical, or neither media type contains user data. User data is specified by the <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.UserData"/></strong> attribute.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p> The types are not equal. Examine the <em>pdwFlags</em> parameter to determine how the types differ. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The types are equal. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> One or both media types are invalid. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> Both of the media types must have a major type, or the method returns <strong>E_INVALIDARG</strong>. </p><p> If the method succeeds and all of the comparison flags are set in <em>pdwFlags</em>, the return value is <strong><see cref="SharpDX.Result.Ok"/></strong>. If the method succeeds but one or more comparison flags are not set, the method returns <strong>S_FALSE</strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaType::IsEqual']/*"/>	
        /// <msdn-id>ms696980</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaType::IsEqual([In, Optional] IMFMediaType* pIMediaType,[Out] unsigned int* pdwFlags)</unmanaged>	
        /// <unmanaged-short>IMFMediaType::IsEqual</unmanaged-short>	
        public void IsEqual(SharpDX.MediaFoundation.MediaType iMediaTypeRef, out int dwFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwFlagsRef_ = &dwFlagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iMediaTypeRef == null) ? IntPtr.Zero : iMediaTypeRef.NativePointer), dwFlagsRef_, ((void**)(*(void**)_nativePointer))[35]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves an alternative representation of the media type. Currently only the DirectShow <strong><see cref="SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure is supported.</p>	
        /// </summary>	
        /// <param name="guidRepresentation"><dd> <p> <see cref="System.Guid"/> that specifies the representation to retrieve. The following values are defined. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>AM_MEDIA_TYPE_REPRESENTATION</strong></dt> </dl> </td><td> <p> Convert the media type to a DirectShow <strong><see cref="SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure. The method selects the most appropriate format structure (<strong>pbFormat</strong>). </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_MFVideoFormat</strong></dt> </dl> </td><td> <p> Convert the media type to a DirectShow <strong><see cref="SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure with an <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> format structure. </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_VideoInfo</strong></dt> </dl> </td><td> <p> Convert the media type to a DirectShow <strong><see cref="SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure with a <strong><see cref="SharpDX.Win32.Unsupported.VideoInfoHeader"/></strong> format structure. </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_VideoInfo2</strong></dt> </dl> </td><td> <p> Convert the media type to a DirectShow <strong><see cref="SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure with a <strong><see cref="SharpDX.MediaFoundation.VideoInformationHeader2"/></strong> format structure. </p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="vRepresentationOut"><dd> <p> Receives a reference to a structure that contains the representation. The method allocates the memory for the structure. The caller must release the memory by calling <strong><see cref="SharpDX.MediaFoundation.MediaType.FreeRepresentation"/></strong>. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Attributenotfound"/></strong></dt> </dl> </td><td> <p> The details of the media type do not match the requested representation. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidMediaType"/></strong></dt> </dl> </td><td> <p> The media type is not valid. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedRepresentation"/></strong></dt> </dl> </td><td> <p> The media type does not support the requested representation. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If you request a specific format structure in the <em>guidRepresentation</em> parameter, such as <strong><see cref="SharpDX.Win32.Unsupported.VideoInfoHeader"/></strong>, you might lose some of the format information. </p><p> You can also use the <strong>MFInitAMMediaTypeFromMFMediaType</strong> function to convert a Media Foundation media type into a DirectShow media type. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaType::GetRepresentation']/*"/>	
        /// <msdn-id>ms695248</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaType::GetRepresentation([In] GUID guidRepresentation,[Out] void** ppvRepresentation)</unmanaged>	
        /// <unmanaged-short>IMFMediaType::GetRepresentation</unmanaged-short>	
        public void GetRepresentation(System.Guid guidRepresentation, out System.IntPtr vRepresentationOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vRepresentationOut_ = &vRepresentationOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, guidRepresentation, vRepresentationOut_, ((void**)(*(void**)_nativePointer))[36]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves an alternative representation of the media type. Currently only the DirectShow <strong><see cref="SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure is supported.</p>	
        /// </summary>	
        /// <param name="guidRepresentation"><dd> <p> <see cref="System.Guid"/> that specifies the representation to retrieve. The following values are defined. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>AM_MEDIA_TYPE_REPRESENTATION</strong></dt> </dl> </td><td> <p> Convert the media type to a DirectShow <strong><see cref="SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure. The method selects the most appropriate format structure (<strong>pbFormat</strong>). </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_MFVideoFormat</strong></dt> </dl> </td><td> <p> Convert the media type to a DirectShow <strong><see cref="SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure with an <strong><see cref="SharpDX.MediaFoundation.VideoFormat"/></strong> format structure. </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_VideoInfo</strong></dt> </dl> </td><td> <p> Convert the media type to a DirectShow <strong><see cref="SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure with a <strong><see cref="SharpDX.Win32.Unsupported.VideoInfoHeader"/></strong> format structure. </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_VideoInfo2</strong></dt> </dl> </td><td> <p> Convert the media type to a DirectShow <strong><see cref="SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure with a <strong><see cref="SharpDX.MediaFoundation.VideoInformationHeader2"/></strong> format structure. </p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="vRepresentationRef"><dd> <p> Receives a reference to a structure that contains the representation. The method allocates the memory for the structure. The caller must release the memory by calling <strong><see cref="SharpDX.MediaFoundation.MediaType.FreeRepresentation"/></strong>. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Attributenotfound"/></strong></dt> </dl> </td><td> <p> The details of the media type do not match the requested representation. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidMediaType"/></strong></dt> </dl> </td><td> <p> The media type is not valid. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedRepresentation"/></strong></dt> </dl> </td><td> <p> The media type does not support the requested representation. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If you request a specific format structure in the <em>guidRepresentation</em> parameter, such as <strong><see cref="SharpDX.Win32.Unsupported.VideoInfoHeader"/></strong>, you might lose some of the format information. </p><p> You can also use the <strong>MFInitAMMediaTypeFromMFMediaType</strong> function to convert a Media Foundation media type into a DirectShow media type. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaType::FreeRepresentation']/*"/>	
        /// <msdn-id>ms695248</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaType::FreeRepresentation([In] GUID guidRepresentation,[In] void* pvRepresentation)</unmanaged>	
        /// <unmanaged-short>IMFMediaType::FreeRepresentation</unmanaged-short>	
        public void FreeRepresentation(System.Guid guidRepresentation, System.IntPtr vRepresentationRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, guidRepresentation, (void*)vRepresentationRef, ((void**)(*(void**)_nativePointer))[37]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Gets and sets media types on an object, such as a media source or media sink. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is exposed by <em>media-type handlers</em>.</p><ul> <li> For media sources, get the media-type handler from the stream descriptor by calling <strong><see cref="SharpDX.MediaFoundation.StreamDescriptor.GetMediaTypeHandler"/></strong>.</li> <li>For media sinks, get the media-type handler by calling <strong><see cref="SharpDX.MediaFoundation.StreamSink.GetMediaTypeHandler"/></strong>.</li> </ul><p>If you are implementing a custom media source or media sink, you can create a simple media-type handler by calling <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSimpleTypeHandler"/></strong>, or you can provide your own implementation.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTypeHandler']/*"/>	
    /// <msdn-id>ms697311</msdn-id>	
    /// <unmanaged>IMFMediaTypeHandler</unmanaged>	
    /// <unmanaged-short>IMFMediaTypeHandler</unmanaged-short>	
    [Guid("e93dcf6c-4b07-4e1e-8123-aa16ed6eadf5")]
    public partial class MediaTypeHandler : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MediaTypeHandler"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MediaTypeHandler(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MediaTypeHandler"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MediaTypeHandler(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MediaTypeHandler(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the number of media types in the object's list of supported media types.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> To get the supported media types, call <strong><see cref="SharpDX.MediaFoundation.MediaTypeHandler.GetMediaTypeByIndex"/></strong>. </p><p> For a media source, the media type handler for each stream must contain at least one supported media type. For media sinks, the media type handler for each stream might contain zero media types. In that case, the application must provide the media type. To test whether a particular media type is supported, call <strong><see cref="SharpDX.MediaFoundation.MediaTypeHandler.IsMediaTypeSupported"/></strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTypeHandler::GetMediaTypeCount']/*"/>	
        /// <msdn-id>bb970517</msdn-id>	
        /// <unmanaged>GetMediaTypeCount</unmanaged>	
        /// <unmanaged-short>GetMediaTypeCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaTypeHandler::GetMediaTypeCount([Out] unsigned int* pdwTypeCount)</unmanaged>
        public int MediaTypeCount
        {
            get { int __output__; GetMediaTypeCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the current media type of the object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTypeHandler::GetCurrentMediaType']/*"/>	
        /// <msdn-id>bb970492</msdn-id>	
        /// <unmanaged>GetCurrentMediaType / SetCurrentMediaType</unmanaged>	
        /// <unmanaged-short>GetCurrentMediaType</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaTypeHandler::GetCurrentMediaType([Out] IMFMediaType** ppMediaType)</unmanaged>
        public SharpDX.MediaFoundation.MediaType CurrentMediaType
        {
            get { SharpDX.MediaFoundation.MediaType __output__; GetCurrentMediaType(out __output__); return __output__; }
            set { SetCurrentMediaType(value); }
        }

        /// <summary>	
        /// <p>Gets the major media type of the object. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The major type identifies what kind of data is in the stream, such as audio or video. To get the specific details of the format, call <strong><see cref="SharpDX.MediaFoundation.MediaTypeHandler.GetCurrentMediaType"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTypeHandler::GetMajorType']/*"/>	
        /// <msdn-id>bb970337</msdn-id>	
        /// <unmanaged>GetMajorType</unmanaged>	
        /// <unmanaged-short>GetMajorType</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMediaTypeHandler::GetMajorType([Out] GUID* pguidMajorType)</unmanaged>
        public System.Guid MajorType
        {
            get { System.Guid __output__; GetMajorType(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Queries whether the object supports a specified media type.</p>	
        /// </summary>	
        /// <param name="mediaTypeRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type to check. </p> </dd></param>	
        /// <param name="mediaTypeOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the closest matching media type, or receives the value <strong><c>null</c></strong>. If non-<strong><c>null</c></strong>, the caller must release the interface. This parameter can be <strong><c>null</c></strong>. See Remarks. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidMediaType"/></strong></dt> </dl> </td><td> <p> The object does not support this media type. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If the object supports the media type given in <em>pMediaType</em>, the method returns <strong><see cref="SharpDX.Result.Ok"/></strong>. For a media source, it means the source can generate data that conforms to that media type. For a media sink, it means the sink can receive data that conforms to that media type. If the object does not support the media type, the method fails. </p><p> The <em>ppMediaType</em> parameter is optional. If the method fails, the object might use <em>ppMediaType</em> to return a media type that the object does support, and which closely matches the one given in <em>pMediaType</em>. The method is not guaranteed to return a media type in <em>ppMediaType</em>. If no type is returned, this parameter receives a <strong><c>null</c></strong> reference. If the method succeeds, this parameter receives a <strong><c>null</c></strong> reference. If the caller sets <em>ppMediaType</em> to <strong><c>null</c></strong>, this parameter is ignored. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with SP2 and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTypeHandler::IsMediaTypeSupported']/*"/>	
        /// <msdn-id>bb970559</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaTypeHandler::IsMediaTypeSupported([In] IMFMediaType* pMediaType,[Out, Optional] IMFMediaType** ppMediaType)</unmanaged>	
        /// <unmanaged-short>IMFMediaTypeHandler::IsMediaTypeSupported</unmanaged-short>	
        public void IsMediaTypeSupported(SharpDX.MediaFoundation.MediaType mediaTypeRef, out SharpDX.MediaFoundation.MediaType mediaTypeOut)
        {
            unsafe
            {
                IntPtr mediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), &mediaTypeOut_, ((void**)(*(void**)_nativePointer))[3]);
                mediaTypeOut = (mediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(mediaTypeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of media types in the object's list of supported media types.</p>	
        /// </summary>	
        /// <param name="dwTypeCountRef"><dd> <p>Receives the number of media types in the list.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> To get the supported media types, call <strong><see cref="SharpDX.MediaFoundation.MediaTypeHandler.GetMediaTypeByIndex"/></strong>. </p><p> For a media source, the media type handler for each stream must contain at least one supported media type. For media sinks, the media type handler for each stream might contain zero media types. In that case, the application must provide the media type. To test whether a particular media type is supported, call <strong><see cref="SharpDX.MediaFoundation.MediaTypeHandler.IsMediaTypeSupported"/></strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTypeHandler::GetMediaTypeCount']/*"/>	
        /// <msdn-id>bb970517</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaTypeHandler::GetMediaTypeCount([Out] unsigned int* pdwTypeCount)</unmanaged>	
        /// <unmanaged-short>IMFMediaTypeHandler::GetMediaTypeCount</unmanaged-short>	
        internal void GetMediaTypeCount(out int dwTypeCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwTypeCountRef_ = &dwTypeCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwTypeCountRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a media type from the object's list of supported media types.</p>	
        /// </summary>	
        /// <param name="dwIndex"><dd> <p> Zero-based index of the media type to retrieve. To get the number of media types in the list, call <strong><see cref="SharpDX.MediaFoundation.MediaTypeHandler.GetMediaTypeCount"/></strong>. </p> </dd></param>	
        /// <param name="typeOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoMoreTypes"/></strong></dt> </dl> </td><td> <p> The <em>dwIndex</em> parameter is out of range. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Media types are returned in the approximate order of preference. The list of supported types is not guaranteed to be complete. To test whether a particular media type is supported, call <strong><see cref="SharpDX.MediaFoundation.MediaTypeHandler.IsMediaTypeSupported"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTypeHandler::GetMediaTypeByIndex']/*"/>	
        /// <msdn-id>bb970473</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaTypeHandler::GetMediaTypeByIndex([In] unsigned int dwIndex,[Out] IMFMediaType** ppType)</unmanaged>	
        /// <unmanaged-short>IMFMediaTypeHandler::GetMediaTypeByIndex</unmanaged-short>	
        public void GetMediaTypeByIndex(int dwIndex, out SharpDX.MediaFoundation.MediaType typeOut)
        {
            unsafe
            {
                IntPtr typeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwIndex, &typeOut_, ((void**)(*(void**)_nativePointer))[5]);
                typeOut = (typeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(typeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the object's media type.</p>	
        /// </summary>	
        /// <param name="mediaTypeRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the new media type.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p> Invalid request. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>For media sources, setting the media type means the source will generate data that conforms to that media type. For media sinks, setting the media type means the sink can receive data that conforms to that media type.</p><p>Any implementation of this method should check whether <em>pMediaType</em> differs from the object's current media type. If the types are identical, the method should return <see cref="SharpDX.Result.Ok"/> but avoid releasing and recreating resources unnecessarily. If the types are not identical, the method should validate the new type.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTypeHandler::SetCurrentMediaType']/*"/>	
        /// <msdn-id>bb970432</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaTypeHandler::SetCurrentMediaType([In] IMFMediaType* pMediaType)</unmanaged>	
        /// <unmanaged-short>IMFMediaTypeHandler::SetCurrentMediaType</unmanaged-short>	
        internal void SetCurrentMediaType(SharpDX.MediaFoundation.MediaType mediaTypeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the current media type of the object.</p>	
        /// </summary>	
        /// <param name="mediaTypeOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotInitializeD"/></strong></dt> </dl> </td><td> <p> No media type is set. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTypeHandler::GetCurrentMediaType']/*"/>	
        /// <msdn-id>bb970492</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaTypeHandler::GetCurrentMediaType([Out] IMFMediaType** ppMediaType)</unmanaged>	
        /// <unmanaged-short>IMFMediaTypeHandler::GetCurrentMediaType</unmanaged-short>	
        internal void GetCurrentMediaType(out SharpDX.MediaFoundation.MediaType mediaTypeOut)
        {
            unsafe
            {
                IntPtr mediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &mediaTypeOut_, ((void**)(*(void**)_nativePointer))[7]);
                mediaTypeOut = (mediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(mediaTypeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the major media type of the object. </p>	
        /// </summary>	
        /// <param name="guidMajorTypeRef"><dd> <p>Receives a <see cref="System.Guid"/> that identifies the major type. For a list of possible values, see Major Media Types. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The major type identifies what kind of data is in the stream, such as audio or video. To get the specific details of the format, call <strong><see cref="SharpDX.MediaFoundation.MediaTypeHandler.GetCurrentMediaType"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMediaTypeHandler::GetMajorType']/*"/>	
        /// <msdn-id>bb970337</msdn-id>	
        /// <unmanaged>HRESULT IMFMediaTypeHandler::GetMajorType([Out] GUID* pguidMajorType)</unmanaged>	
        /// <unmanaged-short>IMFMediaTypeHandler::GetMajorType</unmanaged-short>	
        internal void GetMajorType(out System.Guid guidMajorTypeRef)
        {
            unsafe
            {
                guidMajorTypeRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* guidMajorTypeRef_ = &guidMajorTypeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, guidMajorTypeRef_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Manages metadata for an object. Metadata is information that describes a media file, stream, or other content. Metadata consists of individual properties, where each property contains a descriptive name and a value. A property may be associated with a particular language.</p><p>To get this interface from a media source, use the <strong><see cref="SharpDX.MediaFoundation.MetadataProvider"/></strong> interface.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMetadata']/*"/>	
    /// <msdn-id>ms696970</msdn-id>	
    /// <unmanaged>IMFMetadata</unmanaged>	
    /// <unmanaged-short>IMFMetadata</unmanaged-short>	
    [Guid("F88CFB8C-EF16-4991-B450-CB8C69E51704")]
    public partial class Metadata : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.Metadata"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Metadata(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.Metadata"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.Metadata(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.Metadata(nativePointer);
        }


        /// <summary>	
        /// <p> Gets a list of the languages in which metadata is available.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> For more information about language tags, see RFC 1766, "Tags for the Identification of Languages". </p><p> To set the current language, call <strong><see cref="SharpDX.MediaFoundation.Metadata.SetLanguage"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMetadata::GetAllLanguages']/*"/>	
        /// <msdn-id>ms698736</msdn-id>	
        /// <unmanaged>GetAllLanguages</unmanaged>	
        /// <unmanaged-short>GetAllLanguages</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMetadata::GetAllLanguages([Out] PROPVARIANT* ppvLanguages)</unmanaged>
        public SharpDX.Win32.Variant AllLanguages
        {
            get { SharpDX.Win32.Variant __output__; GetAllLanguages(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Gets a list of all the metadata property names on this object.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMetadata::GetAllPropertyNames']/*"/>	
        /// <msdn-id>ms704581</msdn-id>	
        /// <unmanaged>GetAllPropertyNames</unmanaged>	
        /// <unmanaged-short>GetAllPropertyNames</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMetadata::GetAllPropertyNames([Out] PROPVARIANT* ppvNames)</unmanaged>
        public SharpDX.Win32.Variant AllPropertyNames
        {
            get { SharpDX.Win32.Variant __output__; GetAllPropertyNames(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Sets the language for setting and retrieving metadata. </p>	
        /// </summary>	
        /// <param name="wszRFC1766Ref"><dd> <p>Pointer to a null-terminated string containing an RFC 1766-compliant language tag.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>For more information about language tags, see RFC 1766, "Tags for the Identification of Languages".</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMetadata::SetLanguage']/*"/>	
        /// <msdn-id>ms703982</msdn-id>	
        /// <unmanaged>HRESULT IMFMetadata::SetLanguage([In] const wchar_t* pwszRFC1766)</unmanaged>	
        /// <unmanaged-short>IMFMetadata::SetLanguage</unmanaged-short>	
        public void SetLanguage(string wszRFC1766Ref)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* wszRFC1766Ref_ = wszRFC1766Ref)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)wszRFC1766Ref_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the current language setting.</p>	
        /// </summary>	
        /// <param name="wszRFC1766Out"><dd> <p> Receives a reference to a null-terminated string containing an RFC 1766-compliant language tag. The caller must release the string by calling <strong>CoTaskMemFree</strong>. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>The metadata provider does not support multiple languages.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p> No language was set. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>For more information about language tags, see RFC 1766, "Tags for the Identification of Languages."</p><p>The <strong><see cref="SharpDX.MediaFoundation.Metadata.SetLanguage"/></strong> and <strong><see cref="SharpDX.MediaFoundation.Metadata.GetProperty"/></strong> methods set and get metadata for the current language setting.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMetadata::GetLanguage']/*"/>	
        /// <msdn-id>ms698978</msdn-id>	
        /// <unmanaged>HRESULT IMFMetadata::GetLanguage([Out] wchar_t** ppwszRFC1766)</unmanaged>	
        /// <unmanaged-short>IMFMetadata::GetLanguage</unmanaged-short>	
        public void GetLanguage(System.IntPtr wszRFC1766Out)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)wszRFC1766Out, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets a list of the languages in which metadata is available.</p>	
        /// </summary>	
        /// <param name="vLanguagesOut"><dd> <p> A reference to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that receives the list of languages. The list is returned as an array of null-terminated wide-character strings. Each string in the array is an RFC 1766-compliant language tag. </p> <p>The returned <strong><see cref="SharpDX.Win32.Variant"/></strong> type is VT_VECTOR | VT_LPWSTR. The list might be empty, if no language tags are present. The caller must free the <strong><see cref="SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> For more information about language tags, see RFC 1766, "Tags for the Identification of Languages". </p><p> To set the current language, call <strong><see cref="SharpDX.MediaFoundation.Metadata.SetLanguage"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMetadata::GetAllLanguages']/*"/>	
        /// <msdn-id>ms698736</msdn-id>	
        /// <unmanaged>HRESULT IMFMetadata::GetAllLanguages([Out] PROPVARIANT* ppvLanguages)</unmanaged>	
        /// <unmanaged-short>IMFMetadata::GetAllLanguages</unmanaged-short>	
        internal void GetAllLanguages(out SharpDX.Win32.Variant vLanguagesOut)
        {
            unsafe
            {
                vLanguagesOut = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* vLanguagesOut_ = &vLanguagesOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, vLanguagesOut_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the value of a metadata property. </p>	
        /// </summary>	
        /// <param name="wszNameRef"><dd> <p>Pointer to a null-terminated string containing the name of the property.</p> </dd></param>	
        /// <param name="vValueOut"><dd> <p>Pointer to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that contains the value of the property. For multivalued properties, use a <strong><see cref="SharpDX.Win32.Variant"/></strong> with a VT_VECTOR type.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMetadata::SetProperty']/*"/>	
        /// <msdn-id>ms696972</msdn-id>	
        /// <unmanaged>HRESULT IMFMetadata::SetProperty([In] const wchar_t* pwszName,[In] const PROPVARIANT* ppvValue)</unmanaged>	
        /// <unmanaged-short>IMFMetadata::SetProperty</unmanaged-short>	
        public void SetProperty(string wszNameRef, SharpDX.Win32.Variant vValueOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* wszNameRef_ = wszNameRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)wszNameRef_, &vValueOut, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the value of a metadata property.</p>	
        /// </summary>	
        /// <param name="wszNameRef"><dd> <p> A reference to a null-terminated string that containings the name of the property. To get the list of property names, call <strong><see cref="SharpDX.MediaFoundation.Metadata.GetAllPropertyNames"/></strong>.</p> </dd></param>	
        /// <param name="vValueOut"><dd> <p> Pointer to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that receives the value of the property. The <strong><see cref="SharpDX.Win32.Variant"/></strong> type depends on the property. For multivalued properties, the <strong><see cref="SharpDX.Win32.Variant"/></strong> is a <strong>VT_VECTOR</strong> type. The caller must free the <strong><see cref="SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.PropertyNotFound"/></strong></dt> </dl> </td><td> <p> The requested property was not found. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMetadata::GetProperty']/*"/>	
        /// <msdn-id>ms694844</msdn-id>	
        /// <unmanaged>HRESULT IMFMetadata::GetProperty([In] const wchar_t* pwszName,[Out] PROPVARIANT* ppvValue)</unmanaged>	
        /// <unmanaged-short>IMFMetadata::GetProperty</unmanaged-short>	
        public void GetProperty(string wszNameRef, out SharpDX.Win32.Variant vValueOut)
        {
            unsafe
            {
                vValueOut = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (char* wszNameRef_ = wszNameRef)
                fixed (void* vValueOut_ = &vValueOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)wszNameRef_, vValueOut_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Deletes a metadata property.</p>	
        /// </summary>	
        /// <param name="wszNameRef"><dd> <p>Pointer to a null-terminated string containing the name of the property.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.PropertyNotFound"/></strong></dt> </dl> </td><td> <p> The property was not found. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>For a media source, deleting a property from the metadata collection does not change the original content.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMetadata::DeleteProperty']/*"/>	
        /// <msdn-id>ms699021</msdn-id>	
        /// <unmanaged>HRESULT IMFMetadata::DeleteProperty([In] const wchar_t* pwszName)</unmanaged>	
        /// <unmanaged-short>IMFMetadata::DeleteProperty</unmanaged-short>	
        public void DeleteProperty(string wszNameRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* wszNameRef_ = wszNameRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)wszNameRef_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets a list of all the metadata property names on this object.</p>	
        /// </summary>	
        /// <param name="vNamesOut"><dd> <p>Pointer to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that receives an array of null-terminated wide-character strings. If no properties are available, the <strong><see cref="SharpDX.Win32.Variant"/></strong> type is VT_EMPTY. Otherwise, the <strong><see cref="SharpDX.Win32.Variant"/></strong> type is VT_VECTOR | VT_LPWSTR. The caller must free the <strong><see cref="SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMetadata::GetAllPropertyNames']/*"/>	
        /// <msdn-id>ms704581</msdn-id>	
        /// <unmanaged>HRESULT IMFMetadata::GetAllPropertyNames([Out] PROPVARIANT* ppvNames)</unmanaged>	
        /// <unmanaged-short>IMFMetadata::GetAllPropertyNames</unmanaged-short>	
        internal void GetAllPropertyNames(out SharpDX.Win32.Variant vNamesOut)
        {
            unsafe
            {
                vNamesOut = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* vNamesOut_ = &vNamesOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, vNamesOut_, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Gets metadata from a media source or other object.</p><p>If a media source supports this interface, it must expose the interface as a service. To get a reference to this interface from a media source, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong>. The service identifier is <strong><see cref="SharpDX.MediaFoundation.MediaServiceKeys.MetadataProvider"/></strong>. Other types of object can expose this interface through <strong>QueryInterface</strong>.</p><p>Use this interface to get a reference to the <strong><see cref="SharpDX.MediaFoundation.Metadata"/></strong> interface.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMetadataProvider']/*"/>	
    /// <msdn-id>ms705606</msdn-id>	
    /// <unmanaged>IMFMetadataProvider</unmanaged>	
    /// <unmanaged-short>IMFMetadataProvider</unmanaged-short>	
    [Guid("56181D2D-E221-4adb-B1C8-3CEE6A53F76F")]
    public partial class MetadataProvider : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MetadataProvider"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MetadataProvider(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MetadataProvider"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MetadataProvider(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MetadataProvider(nativePointer);
        }


        /// <summary>	
        /// <p> Gets a collection of metadata, either for an entire presentation, or for one stream in the presentation.</p>	
        /// </summary>	
        /// <param name="presentationDescriptorRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the media source's presentation descriptor. </p> </dd></param>	
        /// <param name="dwStreamIdentifier"><dd> <p> If this parameter is zero, the method retrieves metadata that applies to the entire presentation. Otherwise, this <em></em> parameter specifies a stream identifier, and the method retrieves metadata for that stream. To get the stream identifier for a stream, call <strong><see cref="SharpDX.MediaFoundation.StreamDescriptor.GetStreamIdentifier"/></strong>. </p> </dd></param>	
        /// <param name="dwFlags"><dd> <p> Reserved. Must be zero. </p> </dd></param>	
        /// <param name="mFMetadataOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Metadata"/></strong> interface. Use this interface to access the metadata. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.PropertyNotFound"/></strong></dt> </dl> </td><td> <p>No metadata is available for the requested stream or presentation.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMetadataProvider::GetMFMetadata']/*"/>	
        /// <msdn-id>ms694097</msdn-id>	
        /// <unmanaged>HRESULT IMFMetadataProvider::GetMFMetadata([In, Optional] IMFPresentationDescriptor* pPresentationDescriptor,[In] unsigned int dwStreamIdentifier,[In] unsigned int dwFlags,[Out] IMFMetadata** ppMFMetadata)</unmanaged>	
        /// <unmanaged-short>IMFMetadataProvider::GetMFMetadata</unmanaged-short>	
        public void GetMFMetadata(SharpDX.MediaFoundation.PresentationDescriptor presentationDescriptorRef, int dwStreamIdentifier, int dwFlags, out SharpDX.MediaFoundation.Metadata mFMetadataOut)
        {
            unsafe
            {
                IntPtr mFMetadataOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((presentationDescriptorRef == null) ? IntPtr.Zero : presentationDescriptorRef.NativePointer), dwStreamIdentifier, dwFlags, &mFMetadataOut_, ((void**)(*(void**)_nativePointer))[3]);
                mFMetadataOut = (mFMetadataOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Metadata(mFMetadataOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Contains data that is needed to implement the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p> Any custom implementation of the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface must inherit this structure. For more information, see Custom Asynchronous Result Objects. </p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='MFASYNCRESULT']/*"/>	
    /// <msdn-id>aa379769</msdn-id>	
    /// <unmanaged>MFASYNCRESULT</unmanaged>	
    /// <unmanaged-short>MFASYNCRESULT</unmanaged-short>	
    public partial class Mfasyncresult : SharpDX.MediaFoundation.AsyncResult
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.Mfasyncresult"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Mfasyncresult(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.Mfasyncresult"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.Mfasyncresult(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.Mfasyncresult(nativePointer);
        }

    }
    /// <summary>	
    /// <p> Receives state-change notifications from the presentation clock. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To receive state-change notifications from the presentation clock, implement this interface and call <strong><see cref="SharpDX.MediaFoundation.PresentationClock.AddClockStateSink_"/></strong> on the presentation clock.</p><p>This interface must be implemented by:</p><ul> <li> <p>Presentation time sources. The presentation clock uses this interface to request change states from the time source.</p> </li> <li> <p>Media sinks. Media sinks use this interface to get notifications when the presentation clock changes.</p> </li> </ul><p>Other objects that need to be notified can implement this interface.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamAttributesManager']/*"/>	
    /// <msdn-id>ms701593</msdn-id>	
    /// <unmanaged>IMFMuxStreamAttributesManager</unmanaged>	
    /// <unmanaged-short>IMFMuxStreamAttributesManager</unmanaged-short>	
    [Guid("CE8BD576-E440-43B3-BE34-1E53F565F7E8")]
    public partial class MuxStreamAttributesManager : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MuxStreamAttributesManager"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MuxStreamAttributesManager(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MuxStreamAttributesManager"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MuxStreamAttributesManager(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MuxStreamAttributesManager(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamAttributesManager::GetStreamCount']/*"/>	
        /// <unmanaged>GetStreamCount</unmanaged>	
        /// <unmanaged-short>GetStreamCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMuxStreamAttributesManager::GetStreamCount([Out] unsigned int* pdwMuxStreamCount)</unmanaged>
        public int StreamCount
        {
            get { int __output__; GetStreamCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwMuxStreamCountRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamAttributesManager::GetStreamCount']/*"/>	
        /// <unmanaged>HRESULT IMFMuxStreamAttributesManager::GetStreamCount([Out] unsigned int* pdwMuxStreamCount)</unmanaged>	
        /// <unmanaged-short>IMFMuxStreamAttributesManager::GetStreamCount</unmanaged-short>	
        internal void GetStreamCount(out int dwMuxStreamCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwMuxStreamCountRef_ = &dwMuxStreamCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwMuxStreamCountRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> for the substream with the specified index.</p>	
        /// </summary>	
        /// <param name="dwMuxStreamIndex">No documentation.</param>	
        /// <param name="streamAttributesOut">No documentation.</param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> Invalid argument. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> The stream specified substream index is invalid. Call <strong>GetStreamCount</strong> to get the number of substreams managed by the multiplexed media source.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamAttributesManager::GetAttributes']/*"/>	
        /// <msdn-id>mt797928</msdn-id>	
        /// <unmanaged>HRESULT IMFMuxStreamAttributesManager::GetAttributes([In] unsigned int dwMuxStreamIndex,[Out] IMFAttributes** ppStreamAttributes)</unmanaged>	
        /// <unmanaged-short>IMFMuxStreamAttributesManager::GetAttributes</unmanaged-short>	
        public void GetAttributes(int dwMuxStreamIndex, out SharpDX.MediaFoundation.MediaAttributes streamAttributesOut)
        {
            unsafe
            {
                IntPtr streamAttributesOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwMuxStreamIndex, &streamAttributesOut_, ((void**)(*(void**)_nativePointer))[4]);
                streamAttributesOut = (streamAttributesOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(streamAttributesOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a byte stream from some data source, which might be a local file, a network file, or some other source. The <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface supports the typical stream operations, such as reading, writing, and seeking. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p> The following functions return <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> references for local files: </p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.BeginCreateFile"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateFile"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateTempFile"/></strong> </li> </ul><p> A byte stream for a media souce can be opened with read access. A byte stream for an archive media sink should be opened with both read and write access. (Read access may be required, because the archive sink might need to read portions of the file as it writes.) </p><p>Some implementations of this interface also expose one or more of the following interfaces:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.ByteStreamBuffering"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.ByteStreamCacheControl"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.ServiceProvider"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaEventGenerator"/></strong> </li> </ul><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamMediaTypeManager']/*"/>	
    /// <msdn-id>ms698720</msdn-id>	
    /// <unmanaged>IMFMuxStreamMediaTypeManager</unmanaged>	
    /// <unmanaged-short>IMFMuxStreamMediaTypeManager</unmanaged-short>	
    [Guid("505A2C72-42F7-4690-AEAB-8F513D0FFDB8")]
    public partial class MuxStreamMediaTypeManager : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MuxStreamMediaTypeManager"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MuxStreamMediaTypeManager(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MuxStreamMediaTypeManager"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MuxStreamMediaTypeManager(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MuxStreamMediaTypeManager(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamMediaTypeManager::GetStreamCount']/*"/>	
        /// <unmanaged>GetStreamCount</unmanaged>	
        /// <unmanaged-short>GetStreamCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMuxStreamMediaTypeManager::GetStreamCount([Out] unsigned int* pdwMuxStreamCount)</unmanaged>
        public int StreamCount
        {
            get { int __output__; GetStreamCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamMediaTypeManager::GetStreamConfigurationCount']/*"/>	
        /// <unmanaged>GetStreamConfigurationCount</unmanaged>	
        /// <unmanaged-short>GetStreamConfigurationCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMuxStreamMediaTypeManager::GetStreamConfigurationCount([Out] unsigned int* pdwCount)</unmanaged>
        public int StreamConfigurationCount
        {
            get { int __output__; GetStreamConfigurationCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwMuxStreamCountRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamMediaTypeManager::GetStreamCount']/*"/>	
        /// <unmanaged>HRESULT IMFMuxStreamMediaTypeManager::GetStreamCount([Out] unsigned int* pdwMuxStreamCount)</unmanaged>	
        /// <unmanaged-short>IMFMuxStreamMediaTypeManager::GetStreamCount</unmanaged-short>	
        internal void GetStreamCount(out int dwMuxStreamCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwMuxStreamCountRef_ = &dwMuxStreamCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwMuxStreamCountRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwMuxStreamIndex">No documentation.</param>	
        /// <param name="mediaTypeOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamMediaTypeManager::GetMediaType']/*"/>	
        /// <unmanaged>HRESULT IMFMuxStreamMediaTypeManager::GetMediaType([In] unsigned int dwMuxStreamIndex,[Out] IMFMediaType** ppMediaType)</unmanaged>	
        /// <unmanaged-short>IMFMuxStreamMediaTypeManager::GetMediaType</unmanaged-short>	
        public void GetMediaType(int dwMuxStreamIndex, out SharpDX.MediaFoundation.MediaType mediaTypeOut)
        {
            unsafe
            {
                IntPtr mediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwMuxStreamIndex, &mediaTypeOut_, ((void**)(*(void**)_nativePointer))[4]);
                mediaTypeOut = (mediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(mediaTypeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwCountRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamMediaTypeManager::GetStreamConfigurationCount']/*"/>	
        /// <unmanaged>HRESULT IMFMuxStreamMediaTypeManager::GetStreamConfigurationCount([Out] unsigned int* pdwCount)</unmanaged>	
        /// <unmanaged-short>IMFMuxStreamMediaTypeManager::GetStreamConfigurationCount</unmanaged-short>	
        internal void GetStreamConfigurationCount(out int dwCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwCountRef_ = &dwCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwCountRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="ullStreamMask">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamMediaTypeManager::AddStreamConfiguration']/*"/>	
        /// <unmanaged>HRESULT IMFMuxStreamMediaTypeManager::AddStreamConfiguration([In] unsigned longlong ullStreamMask)</unmanaged>	
        /// <unmanaged-short>IMFMuxStreamMediaTypeManager::AddStreamConfiguration</unmanaged-short>	
        public void AddStreamConfiguration(long ullStreamMask)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ullStreamMask, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="ullStreamMask">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamMediaTypeManager::RemoveStreamConfiguration']/*"/>	
        /// <unmanaged>HRESULT IMFMuxStreamMediaTypeManager::RemoveStreamConfiguration([In] unsigned longlong ullStreamMask)</unmanaged>	
        /// <unmanaged-short>IMFMuxStreamMediaTypeManager::RemoveStreamConfiguration</unmanaged-short>	
        public void RemoveStreamConfiguration(long ullStreamMask)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ullStreamMask, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="ulIndex">No documentation.</param>	
        /// <param name="ullStreamMaskRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamMediaTypeManager::GetStreamConfiguration']/*"/>	
        /// <unmanaged>HRESULT IMFMuxStreamMediaTypeManager::GetStreamConfiguration([In] unsigned int ulIndex,[Out] unsigned longlong* pullStreamMask)</unmanaged>	
        /// <unmanaged-short>IMFMuxStreamMediaTypeManager::GetStreamConfiguration</unmanaged-short>	
        public void GetStreamConfiguration(int ulIndex, out long ullStreamMaskRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* ullStreamMaskRef_ = &ullStreamMaskRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ulIndex, ullStreamMaskRef_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Provides the ability to retrieve <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> objects for individual substreams within the output of a multiplexed media source.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamSampleManager']/*"/>	
    /// <msdn-id>mt797937</msdn-id>	
    /// <unmanaged>IMFMuxStreamSampleManager</unmanaged>	
    /// <unmanaged-short>IMFMuxStreamSampleManager</unmanaged-short>	
    [Guid("74ABBC19-B1CC-4E41-BB8B-9D9B86A8F6CA")]
    public partial class MuxStreamSampleManager : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.MuxStreamSampleManager"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MuxStreamSampleManager(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.MuxStreamSampleManager"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.MuxStreamSampleManager(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.MuxStreamSampleManager(nativePointer);
        }


        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Provides the ability to retrieve <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> objects for individual substreams within the output of a multiplexed media source.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamSampleManager::GetStreamCount']/*"/>	
        /// <msdn-id>mt797937</msdn-id>	
        /// <unmanaged>GetStreamCount</unmanaged>	
        /// <unmanaged-short>GetStreamCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFMuxStreamSampleManager::GetStreamCount([Out] unsigned int* pdwMuxStreamCount)</unmanaged>
        public int StreamCount
        {
            get { int __output__; GetStreamCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamSampleManager::GetStreamConfiguration']/*"/>	
        /// <unmanaged>GetStreamConfiguration</unmanaged>	
        /// <unmanaged-short>GetStreamConfiguration</unmanaged-short>	
        /// <unmanaged>unsigned longlong IMFMuxStreamSampleManager::GetStreamConfiguration()</unmanaged>
        public long StreamConfiguration
        {
            get { return GetStreamConfiguration(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Provides the ability to retrieve <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> objects for individual substreams within the output of a multiplexed media source.</p>	
        /// </summary>	
        /// <param name="dwMuxStreamCountRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamSampleManager::GetStreamCount']/*"/>	
        /// <msdn-id>mt797937</msdn-id>	
        /// <unmanaged>HRESULT IMFMuxStreamSampleManager::GetStreamCount([Out] unsigned int* pdwMuxStreamCount)</unmanaged>	
        /// <unmanaged-short>IMFMuxStreamSampleManager::GetStreamCount</unmanaged-short>	
        internal void GetStreamCount(out int dwMuxStreamCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwMuxStreamCountRef_ = &dwMuxStreamCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwMuxStreamCountRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwMuxStreamIndex">No documentation.</param>	
        /// <param name="sampleOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamSampleManager::GetSample']/*"/>	
        /// <unmanaged>HRESULT IMFMuxStreamSampleManager::GetSample([In] unsigned int dwMuxStreamIndex,[Out] IMFSample** ppSample)</unmanaged>	
        /// <unmanaged-short>IMFMuxStreamSampleManager::GetSample</unmanaged-short>	
        public void GetSample(int dwMuxStreamIndex, out SharpDX.MediaFoundation.Sample sampleOut)
        {
            unsafe
            {
                IntPtr sampleOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwMuxStreamIndex, &sampleOut_, ((void**)(*(void**)_nativePointer))[4]);
                sampleOut = (sampleOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Sample(sampleOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFMuxStreamSampleManager::GetStreamConfiguration']/*"/>	
        /// <unmanaged>unsigned longlong IMFMuxStreamSampleManager::GetStreamConfiguration()</unmanaged>	
        /// <unmanaged-short>IMFMuxStreamSampleManager::GetStreamConfiguration</unmanaged-short>	
        internal long GetStreamConfiguration()
        {
            unsafe
            {
                long __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callilong(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Retrieves the user name.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If the user name is not available, the method might succeed and set *<em>pcbData</em> to zero.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCredential']/*"/>	
    /// <msdn-id>ms694290</msdn-id>	
    /// <unmanaged>IMFNetCredential</unmanaged>	
    /// <unmanaged-short>IMFNetCredential</unmanaged-short>	
    [Guid("5b87ef6a-7ed8-434f-ba0e-184fac1628d1")]
    public partial class NetCredential : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.NetCredential"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public NetCredential(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.NetCredential"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.NetCredential(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.NetCredential(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Sets the user name.</p>	
        /// </summary>	
        /// <param name="bDataRef"><dd> <p>Pointer to a buffer that contains the user name. If <em>fDataIsEncrypted</em> is <strong><see cref="SharpDX.Result.False"/></strong>, the buffer is a wide-character string. Otherwise, the buffer contains encrypted data.</p> </dd></param>	
        /// <param name="cbData"><dd> <p>Size of <em>pbData</em>, in bytes. If <em>fDataIsEncrypted</em> is <strong><see cref="SharpDX.Result.False"/></strong>, the size includes the terminating null character.</p> </dd></param>	
        /// <param name="fDataIsEncrypted"><dd> <p>If <strong>TRUE</strong>, the user name is encrypted. Otherwise, the user name is not encrypted.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCredential::SetUser']/*"/>	
        /// <msdn-id>ms693551</msdn-id>	
        /// <unmanaged>HRESULT IMFNetCredential::SetUser([In, Buffer] unsigned char* pbData,[In] unsigned int cbData,[In] BOOL fDataIsEncrypted)</unmanaged>	
        /// <unmanaged-short>IMFNetCredential::SetUser</unmanaged-short>	
        public void SetUser(byte[] bDataRef, int cbData, SharpDX.Mathematics.Interop.RawBool fDataIsEncrypted)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* bDataRef_ = bDataRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint39(_nativePointer, bDataRef_, cbData, fDataIsEncrypted, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the password.</p>	
        /// </summary>	
        /// <param name="bDataRef"><dd> <p>Pointer to a buffer that contains the password. If <em>fDataIsEncrypted</em> is <strong><see cref="SharpDX.Result.False"/></strong>, the buffer is a wide-character string. Otherwise, the buffer contains encrypted data.</p> </dd></param>	
        /// <param name="cbData"><dd> <p>Size of <em>pbData</em>, in bytes. If <em>fDataIsEncrypted</em> is <strong><see cref="SharpDX.Result.False"/></strong>, the size includes the terminating null character.</p> </dd></param>	
        /// <param name="fDataIsEncrypted"><dd> <p>If <strong>TRUE</strong>, the password is encrypted. Otherwise, the password is not encrypted.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCredential::SetPassword']/*"/>	
        /// <msdn-id>ms699838</msdn-id>	
        /// <unmanaged>HRESULT IMFNetCredential::SetPassword([In, Buffer] unsigned char* pbData,[In] unsigned int cbData,[In] BOOL fDataIsEncrypted)</unmanaged>	
        /// <unmanaged-short>IMFNetCredential::SetPassword</unmanaged-short>	
        public void SetPassword(byte[] bDataRef, int cbData, SharpDX.Mathematics.Interop.RawBool fDataIsEncrypted)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* bDataRef_ = bDataRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint39(_nativePointer, bDataRef_, cbData, fDataIsEncrypted, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the user name.</p>	
        /// </summary>	
        /// <param name="bDataRef"><dd> <p>Pointer to a buffer that receives the user name. To find the required buffer size, set this parameter to <strong><c>null</c></strong>. If <em>fEncryptData</em> is <strong><see cref="SharpDX.Result.False"/></strong>, the buffer contains a wide-character string. Otherwise, the buffer contains encrypted data.</p> </dd></param>	
        /// <param name="cbDataRef"><dd> <p>On input, specifies the size of the <em>pbData</em> buffer, in bytes. On output, receives the required buffer size. If <em>fEncryptData</em> is <strong><see cref="SharpDX.Result.False"/></strong>, the size includes the terminating null character.</p> </dd></param>	
        /// <param name="fEncryptData"><dd> <p>If <strong>TRUE</strong>, the method returns an encrypted string. Otherwise, the method returns an unencrypted string.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the user name is not available, the method might succeed and set *<em>pcbData</em> to zero.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCredential::GetUser']/*"/>	
        /// <msdn-id>ms694290</msdn-id>	
        /// <unmanaged>HRESULT IMFNetCredential::GetUser([Out, Buffer, Optional] unsigned char* pbData,[InOut] unsigned int* pcbData,[In] BOOL fEncryptData)</unmanaged>	
        /// <unmanaged-short>IMFNetCredential::GetUser</unmanaged-short>	
        public void GetUser(byte[] bDataRef, ref int cbDataRef, SharpDX.Mathematics.Interop.RawBool fEncryptData)
        {
            unsafe
            {
                byte[] bDataRef__ = bDataRef;
                SharpDX.Result __result__;
                fixed (void* bDataRef_ = bDataRef__)
                fixed (void* cbDataRef_ = &cbDataRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint67(_nativePointer, bDataRef_, cbDataRef_, fEncryptData, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the password.</p>	
        /// </summary>	
        /// <param name="bDataRef"><dd> <p>Pointer to a buffer that receives the password. To find the required buffer size, set this parameter to <strong><c>null</c></strong>. If <em>fEncryptData</em> is <strong><see cref="SharpDX.Result.False"/></strong>, the buffer contains a wide-character string. Otherwise, the buffer contains encrypted data.</p> </dd></param>	
        /// <param name="cbDataRef"><dd> <p>On input, specifies the size of the <em>pbData</em> buffer, in bytes. On output, receives the required buffer size. If <em>fEncryptData</em> is <strong><see cref="SharpDX.Result.False"/></strong>, the size includes the terminating null character.</p> </dd></param>	
        /// <param name="fEncryptData"><dd> <p>If <strong>TRUE</strong>, the method returns an encrypted string. Otherwise, the method returns an unencrypted string.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the password is not available, the method might succeed and set *<em>pcbData</em> to zero.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCredential::GetPassword']/*"/>	
        /// <msdn-id>ms702055</msdn-id>	
        /// <unmanaged>HRESULT IMFNetCredential::GetPassword([Out, Buffer, Optional] unsigned char* pbData,[InOut] unsigned int* pcbData,[In] BOOL fEncryptData)</unmanaged>	
        /// <unmanaged-short>IMFNetCredential::GetPassword</unmanaged-short>	
        public void GetPassword(byte[] bDataRef, ref int cbDataRef, SharpDX.Mathematics.Interop.RawBool fEncryptData)
        {
            unsafe
            {
                byte[] bDataRef__ = bDataRef;
                SharpDX.Result __result__;
                fixed (void* bDataRef_ = bDataRef__)
                fixed (void* cbDataRef_ = &cbDataRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint67(_nativePointer, bDataRef_, cbDataRef_, fEncryptData, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Queries whether logged-on credentials should be used.</p>	
        /// </summary>	
        /// <param name="fLoggedOnUserRef"><dd> <p>Receives a Boolean value. If logged-on credentials should be used, the value is <strong>TRUE</strong>. Otherwise, the value is <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCredential::LoggedOnUser']/*"/>	
        /// <msdn-id>ms698960</msdn-id>	
        /// <unmanaged>HRESULT IMFNetCredential::LoggedOnUser([Out] BOOL* pfLoggedOnUser)</unmanaged>	
        /// <unmanaged-short>IMFNetCredential::LoggedOnUser</unmanaged-short>	
        public void LoggedOnUser(out SharpDX.Mathematics.Interop.RawBool fLoggedOnUserRef)
        {
            unsafe
            {
                fLoggedOnUserRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fLoggedOnUserRef_ = &fLoggedOnUserRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fLoggedOnUserRef_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Gets credentials from the credential cache.</p><p>This interface is implemented by the credential cache object. Applications that implement the <strong><see cref="SharpDX.MediaFoundation.NetCredentialManager"/></strong> interface can use this object to store the user's credentials. To create the credential cache object, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateCredentialCache"/></strong>.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCredentialCache']/*"/>	
    /// <msdn-id>ms703796</msdn-id>	
    /// <unmanaged>IMFNetCredentialCache</unmanaged>	
    /// <unmanaged-short>IMFNetCredentialCache</unmanaged-short>	
    [Guid("5b87ef6c-7ed8-434f-ba0e-184fac1628d1")]
    public partial class NetCredentialCache : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.NetCredentialCache"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public NetCredentialCache(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.NetCredentialCache"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.NetCredentialCache(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.NetCredentialCache(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the credential object for the specified URL.</p>	
        /// </summary>	
        /// <param name="szUrlRef"><dd> <p>A null-terminated wide-character string containing the URL for which the credential is needed.</p> </dd></param>	
        /// <param name="szRealmRef"><dd> <p>A null-terminated wide-character string containing the realm for the authentication.</p> </dd></param>	
        /// <param name="dwAuthenticationFlags"><dd> <p>Bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.NetAuthenticationFlags"/></strong> enumeration.</p> </dd></param>	
        /// <param name="credOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.NetCredential"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <param name="dwRequirementsFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.NetCredentialRequirements"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCredentialCache::GetCredential']/*"/>	
        /// <msdn-id>ms699842</msdn-id>	
        /// <unmanaged>HRESULT IMFNetCredentialCache::GetCredential([In] const wchar_t* pszUrl,[In] const wchar_t* pszRealm,[In] unsigned int dwAuthenticationFlags,[Out] IMFNetCredential** ppCred,[Out] unsigned int* pdwRequirementsFlags)</unmanaged>	
        /// <unmanaged-short>IMFNetCredentialCache::GetCredential</unmanaged-short>	
        public void GetCredential(string szUrlRef, string szRealmRef, int dwAuthenticationFlags, out SharpDX.MediaFoundation.NetCredential credOut, out int dwRequirementsFlagsRef)
        {
            unsafe
            {
                IntPtr credOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* szUrlRef_ = szUrlRef)
                fixed (char* szRealmRef_ = szRealmRef)
                fixed (void* dwRequirementsFlagsRef_ = &dwRequirementsFlagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szUrlRef_, (void*)szRealmRef_, dwAuthenticationFlags, &credOut_, dwRequirementsFlagsRef_, ((void**)(*(void**)_nativePointer))[3]);
                credOut = (credOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.NetCredential(credOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Reports whether the credential object provided successfully passed the authentication challenge.</p>	
        /// </summary>	
        /// <param name="credRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.NetCredential"/></strong> interface.</p> </dd></param>	
        /// <param name="fGood"><dd> <p><strong>TRUE</strong> if the credential object succeeded in the authentication challenge; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is called by the network source into the credential manager.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCredentialCache::SetGood']/*"/>	
        /// <msdn-id>ms704649</msdn-id>	
        /// <unmanaged>HRESULT IMFNetCredentialCache::SetGood([In] IMFNetCredential* pCred,[In] BOOL fGood)</unmanaged>	
        /// <unmanaged-short>IMFNetCredentialCache::SetGood</unmanaged-short>	
        public void SetGood(SharpDX.MediaFoundation.NetCredential credRef, SharpDX.Mathematics.Interop.RawBool fGood)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint15(_nativePointer, (void*)((credRef == null) ? IntPtr.Zero : credRef.NativePointer), fGood, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Specifies how user credentials are stored.</p>	
        /// </summary>	
        /// <param name="credRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.NetCredential"/></strong> interface. Obtain this reference by calling <strong><see cref="SharpDX.MediaFoundation.NetCredentialCache.GetCredential"/></strong>.</p> </dd></param>	
        /// <param name="dwOptionsFlags"><dd> <p>Bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.NetCredentialOptions"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If no flags are specified, the credentials are cached in memory. This method can be implemented by the credential manager and called by the network source.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCredentialCache::SetUserOptions']/*"/>	
        /// <msdn-id>ms693547</msdn-id>	
        /// <unmanaged>HRESULT IMFNetCredentialCache::SetUserOptions([In] IMFNetCredential* pCred,[In] unsigned int dwOptionsFlags)</unmanaged>	
        /// <unmanaged-short>IMFNetCredentialCache::SetUserOptions</unmanaged-short>	
        public void SetUserOptions(SharpDX.MediaFoundation.NetCredential credRef, int dwOptionsFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((credRef == null) ? IntPtr.Zero : credRef.NativePointer), dwOptionsFlags, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Implemented by applications to provide user credentials for a network source.</p><p>To use this interface, implement it in your application. Then create a property store object and set the <strong>MFNETSOURCE_CREDENTIAL_MANAGER</strong> property. The value of the property is a reference to your application's <strong><see cref="SharpDX.MediaFoundation.NetCredentialManager"/></strong> interface. Then pass the property store to one of the source resolver's creation functions, such as <strong><see cref="SharpDX.MediaFoundation.SourceResolver.CreateObjectFromURL"/></strong>, in the <em>pProps</em> parameter.</p><p>Media Foundation does not provide a default implementation of this interface. Applications that support authentication must implement this interface.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCredentialManager']/*"/>	
    /// <msdn-id>ms693499</msdn-id>	
    /// <unmanaged>IMFNetCredentialManager</unmanaged>	
    /// <unmanaged-short>IMFNetCredentialManager</unmanaged-short>	
    [Guid("5b87ef6b-7ed8-434f-ba0e-184fac1628d1")]
    public partial class NetCredentialManager : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.NetCredentialManager"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public NetCredentialManager(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.NetCredentialManager"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.NetCredentialManager(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.NetCredentialManager(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Begins an asynchronous request to retrieve the user's credentials.</p>	
        /// </summary>	
        /// <param name="paramRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.MediaFoundation.NetCredentialManagerGetParam"/></strong> structure.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>	
        /// <param name="stateRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCredentialManager::BeginGetCredentials']/*"/>	
        /// <msdn-id>ms705663</msdn-id>	
        /// <unmanaged>HRESULT IMFNetCredentialManager::BeginGetCredentials([In] MFNetCredentialManagerGetParam* pParam,[In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>	
        /// <unmanaged-short>IMFNetCredentialManager::BeginGetCredentials</unmanaged-short>	
        internal void BeginGetCredentials_(ref SharpDX.MediaFoundation.NetCredentialManagerGetParam paramRef, System.IntPtr callbackRef, SharpDX.ComObject stateRef)
        {
            unsafe
            {
                var paramRef_ = new SharpDX.MediaFoundation.NetCredentialManagerGetParam.__Native();
                paramRef.__MarshalTo(ref paramRef_);
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &paramRef_, (void*)callbackRef, (void*)((stateRef == null) ? IntPtr.Zero : stateRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                paramRef.__MarshalFree(ref paramRef_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Completes an asynchronous request to retrieve the user's credentials.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface that contains the asynchronous result.</p> </dd></param>	
        /// <param name="credOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.NetCredential"/></strong> interface, which is used to retrieve the credentials. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCredentialManager::EndGetCredentials']/*"/>	
        /// <msdn-id>ms701589</msdn-id>	
        /// <unmanaged>HRESULT IMFNetCredentialManager::EndGetCredentials([In] IMFAsyncResult* pResult,[Out] IMFNetCredential** ppCred)</unmanaged>	
        /// <unmanaged-short>IMFNetCredentialManager::EndGetCredentials</unmanaged-short>	
        public void EndGetCredentials(SharpDX.MediaFoundation.AsyncResult resultRef, out SharpDX.MediaFoundation.NetCredential credOut)
        {
            unsafe
            {
                IntPtr credOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), &credOut_, ((void**)(*(void**)_nativePointer))[4]);
                credOut = (credOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.NetCredential(credOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Specifies whether the user's credentials succeeded in the authentication challenge. The network source calls this method to informs the application whether the user's credentials were authenticated.</p>	
        /// </summary>	
        /// <param name="credRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.NetCredential"/></strong> interface.</p> </dd></param>	
        /// <param name="fGood"><dd> <p>Boolean value. The value is <strong>TRUE</strong> if the credentials succeeded in the authentication challenge. Otherwise, the value is <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCredentialManager::SetGood']/*"/>	
        /// <msdn-id>ms705614</msdn-id>	
        /// <unmanaged>HRESULT IMFNetCredentialManager::SetGood([In] IMFNetCredential* pCred,[In] BOOL fGood)</unmanaged>	
        /// <unmanaged-short>IMFNetCredentialManager::SetGood</unmanaged-short>	
        public void SetGood(SharpDX.MediaFoundation.NetCredential credRef, SharpDX.Mathematics.Interop.RawBool fGood)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint15(_nativePointer, (void*)((credRef == null) ? IntPtr.Zero : credRef.NativePointer), fGood, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCrossOriginSupport']/*"/>	
    /// <unmanaged>IMFNetCrossOriginSupport</unmanaged>	
    /// <unmanaged-short>IMFNetCrossOriginSupport</unmanaged-short>	
    [Guid("bc2b7d44-a72d-49d5-8376-1480dee58b22")]
    public partial class NetCrossOriginSupport : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.NetCrossOriginSupport"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public NetCrossOriginSupport(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.NetCrossOriginSupport"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.NetCrossOriginSupport(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.NetCrossOriginSupport(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCrossOriginSupport::GetCrossOriginPolicy']/*"/>	
        /// <unmanaged>GetCrossOriginPolicy</unmanaged>	
        /// <unmanaged-short>GetCrossOriginPolicy</unmanaged-short>	
        /// <unmanaged>HRESULT IMFNetCrossOriginSupport::GetCrossOriginPolicy([Out] MF_CROSS_ORIGIN_POLICY* pPolicy)</unmanaged>
        public SharpDX.MediaFoundation.CrossOriginPolicy CrossOriginPolicy
        {
            get { SharpDX.MediaFoundation.CrossOriginPolicy __output__; GetCrossOriginPolicy(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="policyRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCrossOriginSupport::GetCrossOriginPolicy']/*"/>	
        /// <unmanaged>HRESULT IMFNetCrossOriginSupport::GetCrossOriginPolicy([Out] MF_CROSS_ORIGIN_POLICY* pPolicy)</unmanaged>	
        /// <unmanaged-short>IMFNetCrossOriginSupport::GetCrossOriginPolicy</unmanaged-short>	
        internal void GetCrossOriginPolicy(out SharpDX.MediaFoundation.CrossOriginPolicy policyRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* policyRef_ = &policyRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, policyRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="wszSourceOrigin">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCrossOriginSupport::GetSourceOrigin']/*"/>	
        /// <unmanaged>HRESULT IMFNetCrossOriginSupport::GetSourceOrigin([Out] wchar_t** wszSourceOrigin)</unmanaged>	
        /// <unmanaged-short>IMFNetCrossOriginSupport::GetSourceOrigin</unmanaged-short>	
        public void GetSourceOrigin(System.IntPtr wszSourceOrigin)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)wszSourceOrigin, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="wszURL">No documentation.</param>	
        /// <param name="fIsSameOriginRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetCrossOriginSupport::IsSameOrigin']/*"/>	
        /// <unmanaged>HRESULT IMFNetCrossOriginSupport::IsSameOrigin([In] const wchar_t* wszURL,[Out] BOOL* pfIsSameOrigin)</unmanaged>	
        /// <unmanaged-short>IMFNetCrossOriginSupport::IsSameOrigin</unmanaged-short>	
        public void IsSameOrigin(string wszURL, out SharpDX.Mathematics.Interop.RawBool fIsSameOriginRef)
        {
            unsafe
            {
                fIsSameOriginRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (char* wszURL_ = wszURL)
                fixed (void* fIsSameOriginRef_ = &fIsSameOriginRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)wszURL_, fIsSameOriginRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Determines the proxy to use when connecting to a server. The network source uses this interface.</p><p>Applications can create the proxy locator configured by the application by implementing the <strong><see cref="SharpDX.MediaFoundation.NetProxyLocatorFactory"/></strong> interface and setting the <strong>MFNETSOURCE_PROXYLOCATORFACTORY</strong> property on the source resolver. Otherwise, the network source uses the default Media Foundation implementation.</p><p>To create the default proxy locator, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateProxyLocator"/></strong>.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetProxyLocator']/*"/>	
    /// <msdn-id>ms695417</msdn-id>	
    /// <unmanaged>IMFNetProxyLocator</unmanaged>	
    /// <unmanaged-short>IMFNetProxyLocator</unmanaged-short>	
    [Guid("e9cd0383-a268-4bb4-82de-658d53574d41")]
    public partial class NetProxyLocator : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.NetProxyLocator"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public NetProxyLocator(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.NetProxyLocator"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.NetProxyLocator(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.NetProxyLocator(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Initializes the proxy locator object.</p>	
        /// </summary>	
        /// <param name="szHostRef"><dd> <p>Null-terminated wide-character string containing the hostname of the destination server.</p> </dd></param>	
        /// <param name="szUrlRef"><dd> <p>Null-terminated wide-character string containing the destination URL.</p> </dd></param>	
        /// <param name="fReserved"><dd> <p>Reserved. Set to <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetProxyLocator::FindFirstProxy']/*"/>	
        /// <msdn-id>ms697016</msdn-id>	
        /// <unmanaged>HRESULT IMFNetProxyLocator::FindFirstProxy([In] const wchar_t* pszHost,[In] const wchar_t* pszUrl,[In] BOOL fReserved)</unmanaged>	
        /// <unmanaged-short>IMFNetProxyLocator::FindFirstProxy</unmanaged-short>	
        public void FindFirstProxy(string szHostRef, string szUrlRef, SharpDX.Mathematics.Interop.RawBool fReserved)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* szHostRef_ = szHostRef)
                fixed (char* szUrlRef_ = szUrlRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint67(_nativePointer, (void*)szHostRef_, (void*)szUrlRef_, fReserved, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Determines the next proxy to use.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p>There are no more proxy objects.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetProxyLocator::FindNextProxy']/*"/>	
        /// <msdn-id>ms700807</msdn-id>	
        /// <unmanaged>HRESULT IMFNetProxyLocator::FindNextProxy()</unmanaged>	
        /// <unmanaged-short>IMFNetProxyLocator::FindNextProxy</unmanaged-short>	
        public void FindNextProxy()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Keeps a record of the success or failure of using the current proxy.</p>	
        /// </summary>	
        /// <param name="hrOp"><dd> <p><strong><see cref="SharpDX.Result"/></strong> specifying the result of using the current proxy for connection.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetProxyLocator::RegisterProxyResult']/*"/>	
        /// <msdn-id>ms696180</msdn-id>	
        /// <unmanaged>HRESULT IMFNetProxyLocator::RegisterProxyResult([In] HRESULT hrOp)</unmanaged>	
        /// <unmanaged-short>IMFNetProxyLocator::RegisterProxyResult</unmanaged-short>	
        public void RegisterProxyResult(SharpDX.Result hrOp)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint45(_nativePointer, hrOp, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the current proxy information including hostname and port.</p>	
        /// </summary>	
        /// <param name="szStrRef"><dd> <p>Pointer to a buffer that receives a null-terminated string containing the proxy hostname and port. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="cchStrRef"><dd> <p>On input, specifies the number of elements in the <em>pszStr</em> array. On output, receives the required size of the buffer.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOT_SUFFICIENT_BUFFER</strong></dt> </dl> </td><td> <p>The buffer specified in <em>pszStr</em> is too small.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetProxyLocator::GetCurrentProxy']/*"/>	
        /// <msdn-id>ms697327</msdn-id>	
        /// <unmanaged>HRESULT IMFNetProxyLocator::GetCurrentProxy([Out, Buffer, Optional] wchar_t* pszStr,[In] unsigned int* pcchStr)</unmanaged>	
        /// <unmanaged-short>IMFNetProxyLocator::GetCurrentProxy</unmanaged-short>	
        public void GetCurrentProxy(System.IntPtr szStrRef, int cchStrRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szStrRef, &cchStrRef, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Creates a new instance of the default proxy locator.</p>	
        /// </summary>	
        /// <param name="proxyLocatorOut"><dd> <p>Receives a reference to the new proxy locator object's <strong><see cref="SharpDX.MediaFoundation.NetProxyLocator"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetProxyLocator::Clone']/*"/>	
        /// <msdn-id>ms697210</msdn-id>	
        /// <unmanaged>HRESULT IMFNetProxyLocator::Clone([In] IMFNetProxyLocator** ppProxyLocator)</unmanaged>	
        /// <unmanaged-short>IMFNetProxyLocator::Clone</unmanaged-short>	
        public void Clone(out SharpDX.MediaFoundation.NetProxyLocator proxyLocatorOut)
        {
            unsafe
            {
                IntPtr proxyLocatorOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &proxyLocatorOut_, ((void**)(*(void**)_nativePointer))[7]);
                proxyLocatorOut = (proxyLocatorOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.NetProxyLocator(proxyLocatorOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Creates an <strong><see cref="SharpDX.MediaFoundation.NetProxyLocator"/></strong> interface proxy locator object based on the protocol name.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetProxyLocatorFactory']/*"/>	
    /// <msdn-id>ms694154</msdn-id>	
    /// <unmanaged>IMFNetProxyLocatorFactory</unmanaged>	
    /// <unmanaged-short>IMFNetProxyLocatorFactory</unmanaged-short>	
    [Guid("e9cd0384-a268-4bb4-82de-658d53574d41")]
    public partial class NetProxyLocatorFactory : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.NetProxyLocatorFactory"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public NetProxyLocatorFactory(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.NetProxyLocatorFactory"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.NetProxyLocatorFactory(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.NetProxyLocatorFactory(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Creates an <strong><see cref="SharpDX.MediaFoundation.NetProxyLocator"/></strong> interface proxy locator object based on the protocol name.</p>	
        /// </summary>	
        /// <param name="szProtocolRef">No documentation.</param>	
        /// <param name="proxyLocatorOut">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetProxyLocatorFactory::CreateProxyLocator']/*"/>	
        /// <msdn-id>ms694154</msdn-id>	
        /// <unmanaged>HRESULT IMFNetProxyLocatorFactory::CreateProxyLocator([In] const wchar_t* pszProtocol,[Out] IMFNetProxyLocator** ppProxyLocator)</unmanaged>	
        /// <unmanaged-short>IMFNetProxyLocatorFactory::CreateProxyLocator</unmanaged-short>	
        public void CreateProxyLocator(string szProtocolRef, out SharpDX.MediaFoundation.NetProxyLocator proxyLocatorOut)
        {
            unsafe
            {
                IntPtr proxyLocatorOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* szProtocolRef_ = szProtocolRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szProtocolRef_, &proxyLocatorOut_, ((void**)(*(void**)_nativePointer))[3]);
                proxyLocatorOut = (proxyLocatorOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.NetProxyLocator(proxyLocatorOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Notifies the application when a byte stream requests a URL, and enables the application to block URL redirection.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To set the callback interface:</p><ol> <li>Query the byte stream object for the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface.</li> <li>Call <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.Set"/></strong> to set the MFNETSOURCE_RESOURCE_FILTER attribute.</li> </ol>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetResourceFilter']/*"/>	
    /// <msdn-id>hh448040</msdn-id>	
    /// <unmanaged>IMFNetResourceFilter</unmanaged>	
    /// <unmanaged-short>IMFNetResourceFilter</unmanaged-short>	
    [Guid("091878a3-bf11-4a5c-bc9f-33995b06ef2d")]
    public partial class NetResourceFilter : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.NetResourceFilter"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public NetResourceFilter(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.NetResourceFilter"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.NetResourceFilter(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.NetResourceFilter(nativePointer);
        }


        /// <summary>	
        /// <p>Called when the byte stream redirects to a URL.</p>	
        /// </summary>	
        /// <param name="szUrlRef"><dd> <p>The URL to which the connection has been redirected.</p> </dd></param>	
        /// <param name="vbCancelRef"><dd> <p>To cancel the redirection, set this parameter to <strong>VARIANT_TRUE</strong>. To allow the redirection, set this parameter to <strong>VARIANT_FALSE</strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetResourceFilter::OnRedirect']/*"/>	
        /// <msdn-id>hh448041</msdn-id>	
        /// <unmanaged>HRESULT IMFNetResourceFilter::OnRedirect([In] const wchar_t* pszUrl,[Out] short* pvbCancel)</unmanaged>	
        /// <unmanaged-short>IMFNetResourceFilter::OnRedirect</unmanaged-short>	
        public void OnRedirect(string szUrlRef, out short vbCancelRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* szUrlRef_ = szUrlRef)
                fixed (void* vbCancelRef_ = &vbCancelRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szUrlRef_, vbCancelRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Called when the byte stream requests a URL.</p>	
        /// </summary>	
        /// <param name="szUrlRef"><dd> <p>The URL that the byte stream is requesting.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetResourceFilter::OnSendingRequest']/*"/>	
        /// <msdn-id>hh448042</msdn-id>	
        /// <unmanaged>HRESULT IMFNetResourceFilter::OnSendingRequest([In] const wchar_t* pszUrl)</unmanaged>	
        /// <unmanaged-short>IMFNetResourceFilter::OnSendingRequest</unmanaged-short>	
        public void OnSendingRequest(string szUrlRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* szUrlRef_ = szUrlRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szUrlRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Retrieves the number of protocols supported by the network scheme plug-in.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetSchemeHandlerConfig']/*"/>	
    /// <msdn-id>ms701625</msdn-id>	
    /// <unmanaged>IMFNetSchemeHandlerConfig</unmanaged>	
    /// <unmanaged-short>IMFNetSchemeHandlerConfig</unmanaged-short>	
    [Guid("7BE19E73-C9BF-468a-AC5A-A5E8653BEC87")]
    public partial class NetSchemeHandlerConfig : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.NetSchemeHandlerConfig"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public NetSchemeHandlerConfig(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.NetSchemeHandlerConfig"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.NetSchemeHandlerConfig(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.NetSchemeHandlerConfig(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the number of protocols supported by the network scheme plug-in.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetSchemeHandlerConfig::GetNumberOfSupportedProtocols']/*"/>	
        /// <msdn-id>ms701625</msdn-id>	
        /// <unmanaged>GetNumberOfSupportedProtocols</unmanaged>	
        /// <unmanaged-short>GetNumberOfSupportedProtocols</unmanaged-short>	
        /// <unmanaged>HRESULT IMFNetSchemeHandlerConfig::GetNumberOfSupportedProtocols([Out] unsigned int* pcProtocols)</unmanaged>
        public int NumberOfSupportedProtocols
        {
            get { int __output__; GetNumberOfSupportedProtocols(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of protocols supported by the network scheme plug-in.</p>	
        /// </summary>	
        /// <param name="cProtocolsRef"><dd> <p>Receives the number of protocols.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetSchemeHandlerConfig::GetNumberOfSupportedProtocols']/*"/>	
        /// <msdn-id>ms701625</msdn-id>	
        /// <unmanaged>HRESULT IMFNetSchemeHandlerConfig::GetNumberOfSupportedProtocols([Out] unsigned int* pcProtocols)</unmanaged>	
        /// <unmanaged-short>IMFNetSchemeHandlerConfig::GetNumberOfSupportedProtocols</unmanaged-short>	
        internal void GetNumberOfSupportedProtocols(out int cProtocolsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cProtocolsRef_ = &cProtocolsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cProtocolsRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a supported protocol by index</p>	
        /// </summary>	
        /// <param name="nProtocolIndex"><dd> <p>Zero-based index of the protocol to retrieve. To get the number of supported protocols, call <strong><see cref="SharpDX.MediaFoundation.NetSchemeHandlerConfig.GetNumberOfSupportedProtocols"/></strong>.</p> </dd></param>	
        /// <param name="nProtocolTypeRef"><dd> <p>Receives a member of the <strong><see cref="SharpDX.MediaFoundation.NetsourceProtocolType"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The value passed in the <em>nProtocolIndex</em> parameter was greater than the total number of supported protocols, returned by <strong>GetNumberOfSupportedProtocols</strong>.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetSchemeHandlerConfig::GetSupportedProtocolType']/*"/>	
        /// <msdn-id>ms697058</msdn-id>	
        /// <unmanaged>HRESULT IMFNetSchemeHandlerConfig::GetSupportedProtocolType([In] unsigned int nProtocolIndex,[Out] MFNETSOURCE_PROTOCOL_TYPE* pnProtocolType)</unmanaged>	
        /// <unmanaged-short>IMFNetSchemeHandlerConfig::GetSupportedProtocolType</unmanaged-short>	
        public void GetSupportedProtocolType(int nProtocolIndex, out SharpDX.MediaFoundation.NetsourceProtocolType nProtocolTypeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* nProtocolTypeRef_ = &nProtocolTypeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, nProtocolIndex, nProtocolTypeRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Not implemented in this release.</p>	
        /// </summary>	
        /// <returns><p>This method returns <see cref="SharpDX.Result.Ok"/>.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFNetSchemeHandlerConfig::ResetProtocolRolloverSettings']/*"/>	
        /// <msdn-id>ms705604</msdn-id>	
        /// <unmanaged>HRESULT IMFNetSchemeHandlerConfig::ResetProtocolRolloverSettings()</unmanaged>	
        /// <unmanaged-short>IMFNetSchemeHandlerConfig::ResetProtocolRolloverSettings</unmanaged-short>	
        public void ResetProtocolRolloverSettings()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Marshals an interface reference to and from a stream.</p><p>Stream objects that support <strong><see cref="SharpDX.Win32.IStream"/></strong> can expose this interface to provide custom marshaling for interface references.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFObjectReferenceStream']/*"/>	
    /// <msdn-id>ms701609</msdn-id>	
    /// <unmanaged>IMFObjectReferenceStream</unmanaged>	
    /// <unmanaged-short>IMFObjectReferenceStream</unmanaged-short>	
    [Guid("09EF5BE3-C8A7-469e-8B70-73BF25BB193F")]
    public partial class ObjectReferenceStream : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ObjectReferenceStream"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ObjectReferenceStream(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ObjectReferenceStream"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ObjectReferenceStream(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ObjectReferenceStream(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Stores the data needed to marshal an interface across a process boundary.</p>	
        /// </summary>	
        /// <param name="riid"><dd> <p>Interface identifier of the interface to marshal.</p> </dd></param>	
        /// <param name="unkRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFObjectReferenceStream::SaveReference']/*"/>	
        /// <msdn-id>ms698988</msdn-id>	
        /// <unmanaged>HRESULT IMFObjectReferenceStream::SaveReference([In] const GUID&amp; riid,[In] IUnknown* pUnk)</unmanaged>	
        /// <unmanaged-short>IMFObjectReferenceStream::SaveReference</unmanaged-short>	
        public void SaveReference(System.Guid riid, SharpDX.ComObject unkRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &riid, (void*)((unkRef == null) ? IntPtr.Zero : unkRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Marshals an interface from data stored in the stream.</p>	
        /// </summary>	
        /// <param name="riid"><dd> <p>Interface identifier of the interface to marshal.</p> </dd></param>	
        /// <param name="vOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFObjectReferenceStream::LoadReference']/*"/>	
        /// <msdn-id>ms705636</msdn-id>	
        /// <unmanaged>HRESULT IMFObjectReferenceStream::LoadReference([In] const GUID&amp; riid,[In] void** ppv)</unmanaged>	
        /// <unmanaged-short>IMFObjectReferenceStream::LoadReference</unmanaged-short>	
        public void LoadReference(System.Guid riid, System.IntPtr vOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &riid, (void*)vOut, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Encapsulates a usage policy from an input trust authority (ITA). Output trust authorities (OTAs) use this interface to query which protection systems they are required to enforce by the ITA.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputPolicy']/*"/>	
    /// <msdn-id>ms698985</msdn-id>	
    /// <unmanaged>IMFOutputPolicy</unmanaged>	
    /// <unmanaged-short>IMFOutputPolicy</unmanaged-short>	
    [Guid("7F00F10A-DAED-41AF-AB26-5FDFA4DFBA3C")]
    public partial class OutputPolicy : SharpDX.MediaFoundation.MediaAttributes
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.OutputPolicy"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public OutputPolicy(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.OutputPolicy"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.OutputPolicy(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.OutputPolicy(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieives a <see cref="System.Guid"/> identifying the input trust authority (ITA) that created this output policy object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>All of the policy objects and output schemas from the same ITA should return the same originator identifier (including dynamic policy changes). This value enables the OTA to distinguish policies that originate from different ITAs, so that the OTA can update dynamic policies correctly.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputPolicy::GetOriginatorID']/*"/>	
        /// <msdn-id>bb970379</msdn-id>	
        /// <unmanaged>GetOriginatorID</unmanaged>	
        /// <unmanaged-short>GetOriginatorID</unmanaged-short>	
        /// <unmanaged>HRESULT IMFOutputPolicy::GetOriginatorID([Out] GUID* pguidOriginatorID)</unmanaged>
        public System.Guid OriginatorID
        {
            get { System.Guid __output__; GetOriginatorID(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the minimum version of the global revocation list (GRL) that must be enforced by the protected environment for this policy.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputPolicy::GetMinimumGRLVersion']/*"/>	
        /// <msdn-id>bb970389</msdn-id>	
        /// <unmanaged>GetMinimumGRLVersion</unmanaged>	
        /// <unmanaged-short>GetMinimumGRLVersion</unmanaged-short>	
        /// <unmanaged>HRESULT IMFOutputPolicy::GetMinimumGRLVersion([Out] unsigned int* pdwMinimumGRLVersion)</unmanaged>
        public int MinimumGRLVersion
        {
            get { int __output__; GetMinimumGRLVersion(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Retrieves a list of the output protection systems that the output trust authority (OTA) must enforce, along with configuration data for each protection system. </p>	
        /// </summary>	
        /// <param name="dwAttributes"><dd> <p> Describes the output that is represented by the OTA calling this method. This value is a bitwise OR of zero or more of the following flags. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MFOUTPUTATTRIBUTE_BUS</strong></dt> </dl> </td><td> <p> Hardware bus. </p> </td></tr> <tr><td><dl> <dt><strong>MFOUTPUTATTRIBUTE_COMPRESSED</strong></dt> </dl> </td><td> <p> The output sends compressed data. If this flag is absent, the output sends uncompressed data. </p> </td></tr> <tr><td><dl> <dt><strong>MFOUTPUTATTRIBUTE_BUSIMPLEMENTATION</strong></dt> </dl> </td><td> <p> Reserved. Do not use. </p> </td></tr> <tr><td><dl> <dt><strong>MFOUTPUTATTRIBUTE_DIGITAL</strong></dt> </dl> </td><td> <p> The output sends a digital signal. If this flag is absent, the output sends an analog signal. </p> </td></tr> <tr><td><dl> <dt><strong>MFOUTPUTATTRIBUTE_NONSTANDARDIMPLEMENTATION</strong></dt> </dl> </td><td> <p> Reserved. Do not use. </p> </td></tr> <tr><td><dl> <dt><strong>MFOUTPUTATTRIBUTE_SOFTWARE</strong></dt> </dl> </td><td> <p> Reserved. Do not use. </p> </td></tr> <tr><td><dl> <dt><strong>MFOUTPUTATTRIBUTE_VIDEO</strong></dt> </dl> </td><td> <p> The output sends video data. If this flag is absent, the output sends audio data. </p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="guidOutputSubType"><dd> <p> Indicates a specific family of output connectors that is represented by the OTA calling this method. Possible values include the following. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_AGP</strong></dt> </dl> </td><td> <p> AGP bus. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_COMPONENT</strong></dt> </dl> </td><td> <p> Component video. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_COMPOSITE</strong></dt> </dl> </td><td> <p> Composite video. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_D_JPN</strong></dt> </dl> </td><td> <p> Japanese D connector. (Connector conforming to the EIAJ RC-5237 standard.) </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_DISPLAYPORT_EMBEDDED</strong></dt> </dl> </td><td> <p> Embedded DisplayPort connector. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_DISPLAYPORT_EXTERNAL</strong></dt> </dl> </td><td> <p> External DisplayPort connector. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_DVI</strong></dt> </dl> </td><td> <p> Digital video interface (DVI) connector. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_HDMI</strong></dt> </dl> </td><td> <p> High-definition multimedia interface (HDMI) connector. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_LVDS</strong></dt> </dl> </td><td> <p> Low voltage differential signaling (LVDS) connector.</p> <p>A connector using the LVDS interface to connect internally to a display device. The connection between the graphics adapter and the display device is permanent and not accessible to the user. Applications should not enable High-Bandwidth Digital Content Protection (HDCP) for this connector.</p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_PCI</strong></dt> </dl> </td><td> <p> PCI bus. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_PCI_Express</strong></dt> </dl> </td><td> <p> PCI Express bus. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_PCIX</strong></dt> </dl> </td><td> <p> PCI-X bus. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_SDI</strong></dt> </dl> </td><td> <p> Audio data sent over a connector via S/PDIF. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_SPDIF</strong></dt> </dl> </td><td> <p> Serial digital interface connector. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_SVIDEO</strong></dt> </dl> </td><td> <p> S-Video connector. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_UDI_EMBEDDED</strong></dt> </dl> </td><td> <p> Embedded Unified Display Interface (UDI). </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_UDI_EXTERNAL</strong></dt> </dl> </td><td> <p> External UDI. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_UNKNOWN</strong></dt> </dl> </td><td> <p> Unknown connector type. See Remarks. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_VGA</strong></dt> </dl> </td><td> <p> VGA connector. </p> </td></tr> <tr><td><dl> <dt><strong> MFCONNECTOR_MIRACAST</strong></dt> </dl> </td><td> <p>Miracast wireless connector. </p> <p>Supported in Windows?8.1 and later.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="rgGuidProtectionSchemasSupported"><dd> <p> Pointer to an array of <see cref="System.Guid"/> values that specify which output protection systems are supported by the OTA that is calling this method. </p> </dd></param>	
        /// <param name="cProtectionSchemasSupported"><dd> <p> Number of elements in the <em>rgGuidProtectionSchemasSupported</em> array. </p> </dd></param>	
        /// <param name="requiredProtectionSchemasOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Collection"/></strong> interface of a collection object. The caller must release the interface. Each object in the collection is an <strong><see cref="SharpDX.MediaFoundation.OutputSchema"/></strong> reference. Each <strong><see cref="SharpDX.MediaFoundation.OutputSchema"/></strong> reference defines an output protection system that the OTA must enforce. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The video OTA returns  the <strong>MFCONNECTOR_UNKNOWN</strong> connector type unless the Direct3D device is in full-screen mode. (Direct3D windowed mode is not generally a secure video mode.) You can override this behavior by implementing a custom EVR presenter that implements the <strong><see cref="SharpDX.MediaFoundation.TrustedVideoPlugin"/></strong> interface.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputPolicy::GenerateRequiredSchemas']/*"/>	
        /// <msdn-id>bb970362</msdn-id>	
        /// <unmanaged>HRESULT IMFOutputPolicy::GenerateRequiredSchemas([In] unsigned int dwAttributes,[In] GUID guidOutputSubType,[In] GUID* rgGuidProtectionSchemasSupported,[In] unsigned int cProtectionSchemasSupported,[Out] IMFCollection** ppRequiredProtectionSchemas)</unmanaged>	
        /// <unmanaged-short>IMFOutputPolicy::GenerateRequiredSchemas</unmanaged-short>	
        public void GenerateRequiredSchemas(int dwAttributes, System.Guid guidOutputSubType, System.Guid rgGuidProtectionSchemasSupported, int cProtectionSchemasSupported, out SharpDX.MediaFoundation.Collection requiredProtectionSchemasOut)
        {
            unsafe
            {
                IntPtr requiredProtectionSchemasOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwAttributes, guidOutputSubType, &rgGuidProtectionSchemasSupported, cProtectionSchemasSupported, &requiredProtectionSchemasOut_, ((void**)(*(void**)_nativePointer))[33]);
                requiredProtectionSchemasOut = (requiredProtectionSchemasOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Collection(requiredProtectionSchemasOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieives a <see cref="System.Guid"/> identifying the input trust authority (ITA) that created this output policy object.</p>	
        /// </summary>	
        /// <param name="guidOriginatorIDRef"><dd> <p>Receives a <see cref="System.Guid"/> that identifies the originating ITA.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>All of the policy objects and output schemas from the same ITA should return the same originator identifier (including dynamic policy changes). This value enables the OTA to distinguish policies that originate from different ITAs, so that the OTA can update dynamic policies correctly.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputPolicy::GetOriginatorID']/*"/>	
        /// <msdn-id>bb970379</msdn-id>	
        /// <unmanaged>HRESULT IMFOutputPolicy::GetOriginatorID([Out] GUID* pguidOriginatorID)</unmanaged>	
        /// <unmanaged-short>IMFOutputPolicy::GetOriginatorID</unmanaged-short>	
        internal void GetOriginatorID(out System.Guid guidOriginatorIDRef)
        {
            unsafe
            {
                guidOriginatorIDRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* guidOriginatorIDRef_ = &guidOriginatorIDRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, guidOriginatorIDRef_, ((void**)(*(void**)_nativePointer))[34]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the minimum version of the global revocation list (GRL) that must be enforced by the protected environment for this policy.</p>	
        /// </summary>	
        /// <param name="dwMinimumGRLVersionRef"><dd> <p>Receives the minimum GRL version.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputPolicy::GetMinimumGRLVersion']/*"/>	
        /// <msdn-id>bb970389</msdn-id>	
        /// <unmanaged>HRESULT IMFOutputPolicy::GetMinimumGRLVersion([Out] unsigned int* pdwMinimumGRLVersion)</unmanaged>	
        /// <unmanaged-short>IMFOutputPolicy::GetMinimumGRLVersion</unmanaged-short>	
        internal void GetMinimumGRLVersion(out int dwMinimumGRLVersionRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwMinimumGRLVersionRef_ = &dwMinimumGRLVersionRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwMinimumGRLVersionRef_, ((void**)(*(void**)_nativePointer))[35]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Encapsulates information about an output protection system and its corresponding configuration data.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If the configuration information for the output protection system does not require more than a <strong>DWORD</strong> of space, the configuration information is retrieved in the <strong>GetConfigurationData</strong> method. If more than a <strong>DWORD</strong> of configuration information is needed, it is stored using the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputSchema']/*"/>	
    /// <msdn-id>ms703800</msdn-id>	
    /// <unmanaged>IMFOutputSchema</unmanaged>	
    /// <unmanaged-short>IMFOutputSchema</unmanaged-short>	
    [Guid("7BE0FC5B-ABD9-44FB-A5C8-F50136E71599")]
    public partial class OutputSchema : SharpDX.MediaFoundation.MediaAttributes
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.OutputSchema"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public OutputSchema(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.OutputSchema"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.OutputSchema(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.OutputSchema(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the output protection system that is represented by this object. Output protection systems are identified by <see cref="System.Guid"/> value.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputSchema::GetSchemaType']/*"/>	
        /// <msdn-id>bb970414</msdn-id>	
        /// <unmanaged>GetSchemaType</unmanaged>	
        /// <unmanaged-short>GetSchemaType</unmanaged-short>	
        /// <unmanaged>HRESULT IMFOutputSchema::GetSchemaType([Out] GUID* pguidSchemaType)</unmanaged>
        public System.Guid SchemaType
        {
            get { System.Guid __output__; GetSchemaType(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Returns configuration data for the output protection system. The configuration data is used to enable or disable the protection system, and to set the protection levels.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputSchema::GetConfigurationData']/*"/>	
        /// <msdn-id>bb970364</msdn-id>	
        /// <unmanaged>GetConfigurationData</unmanaged>	
        /// <unmanaged-short>GetConfigurationData</unmanaged-short>	
        /// <unmanaged>HRESULT IMFOutputSchema::GetConfigurationData([Out] unsigned int* pdwVal)</unmanaged>
        public int ConfigurationData
        {
            get { int __output__; GetConfigurationData(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a <see cref="System.Guid"/> identifying the input trust authority (ITA) that generated this output schema object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>All of the policy objects and output schemas from the same ITA should return the same originator identifier (including dynamic policy changes). This value enables the OTA to distinguish policies that originate from different ITAs, so that the OTA can update dynamic policies correctly.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputSchema::GetOriginatorID']/*"/>	
        /// <msdn-id>bb970483</msdn-id>	
        /// <unmanaged>GetOriginatorID</unmanaged>	
        /// <unmanaged-short>GetOriginatorID</unmanaged-short>	
        /// <unmanaged>HRESULT IMFOutputSchema::GetOriginatorID([Out] GUID* pguidOriginatorID)</unmanaged>
        public System.Guid OriginatorID
        {
            get { System.Guid __output__; GetOriginatorID(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the output protection system that is represented by this object. Output protection systems are identified by <see cref="System.Guid"/> value.</p>	
        /// </summary>	
        /// <param name="guidSchemaTypeRef"><dd> <p>Receives the <see cref="System.Guid"/> that identifies the output protection system.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputSchema::GetSchemaType']/*"/>	
        /// <msdn-id>bb970414</msdn-id>	
        /// <unmanaged>HRESULT IMFOutputSchema::GetSchemaType([Out] GUID* pguidSchemaType)</unmanaged>	
        /// <unmanaged-short>IMFOutputSchema::GetSchemaType</unmanaged-short>	
        internal void GetSchemaType(out System.Guid guidSchemaTypeRef)
        {
            unsafe
            {
                guidSchemaTypeRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* guidSchemaTypeRef_ = &guidSchemaTypeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, guidSchemaTypeRef_, ((void**)(*(void**)_nativePointer))[33]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Returns configuration data for the output protection system. The configuration data is used to enable or disable the protection system, and to set the protection levels.</p>	
        /// </summary>	
        /// <param name="dwValRef"><dd> <p>Receives the configuration data. The meaning of this data depends on the output protection system.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputSchema::GetConfigurationData']/*"/>	
        /// <msdn-id>bb970364</msdn-id>	
        /// <unmanaged>HRESULT IMFOutputSchema::GetConfigurationData([Out] unsigned int* pdwVal)</unmanaged>	
        /// <unmanaged-short>IMFOutputSchema::GetConfigurationData</unmanaged-short>	
        internal void GetConfigurationData(out int dwValRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwValRef_ = &dwValRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwValRef_, ((void**)(*(void**)_nativePointer))[34]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a <see cref="System.Guid"/> identifying the input trust authority (ITA) that generated this output schema object.</p>	
        /// </summary>	
        /// <param name="guidOriginatorIDRef"><dd> <p>Receives a <see cref="System.Guid"/> that identifies the originating ITA.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>All of the policy objects and output schemas from the same ITA should return the same originator identifier (including dynamic policy changes). This value enables the OTA to distinguish policies that originate from different ITAs, so that the OTA can update dynamic policies correctly.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputSchema::GetOriginatorID']/*"/>	
        /// <msdn-id>bb970483</msdn-id>	
        /// <unmanaged>HRESULT IMFOutputSchema::GetOriginatorID([Out] GUID* pguidOriginatorID)</unmanaged>	
        /// <unmanaged-short>IMFOutputSchema::GetOriginatorID</unmanaged-short>	
        internal void GetOriginatorID(out System.Guid guidOriginatorIDRef)
        {
            unsafe
            {
                guidOriginatorIDRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* guidOriginatorIDRef_ = &guidOriginatorIDRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, guidOriginatorIDRef_, ((void**)(*(void**)_nativePointer))[35]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Encapsulates the functionality of one or more output protection systems that a trusted output supports. This interface is exposed by output trust authority (OTA) objects. Each OTA represents a single action that the trusted output can perform, such as play, copy, or transcode. An OTA can represent more than one physical output if each output performs the same action.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputTrustAuthority']/*"/>	
    /// <msdn-id>ms695254</msdn-id>	
    /// <unmanaged>IMFOutputTrustAuthority</unmanaged>	
    /// <unmanaged-short>IMFOutputTrustAuthority</unmanaged-short>	
    [Guid("D19F8E94-B126-4446-890C-5DCB7AD71453")]
    public partial class OutputTrustAuthority : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.OutputTrustAuthority"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public OutputTrustAuthority(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.OutputTrustAuthority"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.OutputTrustAuthority(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.OutputTrustAuthority(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the action that is performed by this output trust authority (OTA).</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputTrustAuthority::GetAction']/*"/>	
        /// <msdn-id>bb970410</msdn-id>	
        /// <unmanaged>GetAction</unmanaged>	
        /// <unmanaged-short>GetAction</unmanaged-short>	
        /// <unmanaged>HRESULT IMFOutputTrustAuthority::GetAction([Out] MFPOLICYMANAGER_ACTION* pAction)</unmanaged>
        public SharpDX.MediaFoundation.PolicymanagerAction Action
        {
            get { SharpDX.MediaFoundation.PolicymanagerAction __output__; GetAction(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the action that is performed by this output trust authority (OTA).</p>	
        /// </summary>	
        /// <param name="actionRef"><dd> <p>Receives a member of the <see cref="SharpDX.MediaFoundation.PolicymanagerAction"/> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputTrustAuthority::GetAction']/*"/>	
        /// <msdn-id>bb970410</msdn-id>	
        /// <unmanaged>HRESULT IMFOutputTrustAuthority::GetAction([Out] MFPOLICYMANAGER_ACTION* pAction)</unmanaged>	
        /// <unmanaged-short>IMFOutputTrustAuthority::GetAction</unmanaged-short>	
        internal void GetAction(out SharpDX.MediaFoundation.PolicymanagerAction actionRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* actionRef_ = &actionRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, actionRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets one or more policy objects on the output trust authority (OTA). </p>	
        /// </summary>	
        /// <param name="policyOut"><dd> <p>The address of  an array of <strong><see cref="SharpDX.MediaFoundation.OutputPolicy"/></strong> references. </p> </dd></param>	
        /// <param name="nPolicy"><dd> <p> The number of elements in the <em>ppPolicy</em> array. </p> </dd></param>	
        /// <param name="bTicketOut"><dd> <p> Receives either a reference to a buffer allocated by the OTA, or the value <strong><c>null</c></strong>. If this parameter receives a non-<strong><c>null</c></strong> value, the caller must release the buffer by calling <strong>CoTaskMemFree</strong>. </p> <strong>Note</strong>??Currently this parameter is reserved. An OTA should set the reference to <strong><c>null</c></strong>. ? </dd></param>	
        /// <param name="cbTicketRef"><dd> <p> Receives the size of the <em>ppbTicket</em> buffer, in bytes. If <em>ppbTicket</em> receives the value <strong><c>null</c></strong>, <em>pcbTicket</em> receives the value zero.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>MF_S_WAIT_FOR_POLICY_SET</strong></dt> </dl> </td><td> <p> The policy was negotiated successfully, but the OTA will enforce it asynchronously. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.PolicyUnsupported"/></strong></dt> </dl> </td><td> <p> The OTA does not support the requirements of this policy. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the method returns <strong>MF_S_WAIT_FOR_POLICY_SET</strong>, the OTA sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.PolicySet"/> event when it enforces the policy.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputTrustAuthority::SetPolicy']/*"/>	
        /// <msdn-id>bb970572</msdn-id>	
        /// <unmanaged>HRESULT IMFOutputTrustAuthority::SetPolicy([In, Buffer, Optional] IMFOutputPolicy** ppPolicy,[In] unsigned int nPolicy,[Out, Buffer, Optional] unsigned char** ppbTicket,[Out, Optional] unsigned int* pcbTicket)</unmanaged>	
        /// <unmanaged-short>IMFOutputTrustAuthority::SetPolicy</unmanaged-short>	
        public void SetPolicy(SharpDX.MediaFoundation.OutputPolicy[] policyOut, int nPolicy, byte[] bTicketOut, out int cbTicketRef)
        {
            unsafe
            {
                IntPtr* policyOut_ = (IntPtr*)0;
                if (policyOut != null)
                {
                    IntPtr* policyOut__ = stackalloc IntPtr[policyOut.Length];
                    policyOut_ = policyOut__;
                    for (int i = 0; i < policyOut.Length; i++)
                        policyOut_[i] = (policyOut[i] == null) ? IntPtr.Zero : policyOut[i].NativePointer;
                }
                byte[] bTicketOut__ = bTicketOut;
                SharpDX.Result __result__;
                fixed (void* bTicketOut_ = bTicketOut__)
                fixed (void* cbTicketRef_ = &cbTicketRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, policyOut_, nPolicy, bTicketOut_, cbTicketRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets one or more policy objects on the output trust authority (OTA). </p>	
        /// </summary>	
        /// <param name="policyOut"><dd> <p>The address of  an array of <strong><see cref="SharpDX.MediaFoundation.OutputPolicy"/></strong> references. </p> </dd></param>	
        /// <param name="nPolicy"><dd> <p> The number of elements in the <em>ppPolicy</em> array. </p> </dd></param>	
        /// <param name="bTicketOut"><dd> <p> Receives either a reference to a buffer allocated by the OTA, or the value <strong><c>null</c></strong>. If this parameter receives a non-<strong><c>null</c></strong> value, the caller must release the buffer by calling <strong>CoTaskMemFree</strong>. </p> <strong>Note</strong>??Currently this parameter is reserved. An OTA should set the reference to <strong><c>null</c></strong>. ? </dd></param>	
        /// <param name="cbTicketRef"><dd> <p> Receives the size of the <em>ppbTicket</em> buffer, in bytes. If <em>ppbTicket</em> receives the value <strong><c>null</c></strong>, <em>pcbTicket</em> receives the value zero.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>MF_S_WAIT_FOR_POLICY_SET</strong></dt> </dl> </td><td> <p> The policy was negotiated successfully, but the OTA will enforce it asynchronously. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.PolicyUnsupported"/></strong></dt> </dl> </td><td> <p> The OTA does not support the requirements of this policy. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the method returns <strong>MF_S_WAIT_FOR_POLICY_SET</strong>, the OTA sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.PolicySet"/> event when it enforces the policy.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputTrustAuthority::SetPolicy']/*"/>	
        /// <msdn-id>bb970572</msdn-id>	
        /// <unmanaged>HRESULT IMFOutputTrustAuthority::SetPolicy([In, Buffer, Optional] IMFOutputPolicy** ppPolicy,[In] unsigned int nPolicy,[Out, Buffer, Optional] unsigned char** ppbTicket,[Out, Optional] unsigned int* pcbTicket)</unmanaged>	
        /// <unmanaged-short>IMFOutputTrustAuthority::SetPolicy</unmanaged-short>	
        public void SetPolicy(SharpDX.ComArray<SharpDX.MediaFoundation.OutputPolicy> policyOut, int nPolicy, byte[] bTicketOut, out int cbTicketRef)
        {
            unsafe
            {
                byte[] bTicketOut__ = bTicketOut;
                SharpDX.Result __result__;
                fixed (void* bTicketOut_ = bTicketOut__)
                fixed (void* cbTicketRef_ = &cbTicketRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((policyOut == null) ? IntPtr.Zero : policyOut.NativePointer), nPolicy, bTicketOut_, cbTicketRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets one or more policy objects on the output trust authority (OTA). </p>	
        /// </summary>	
        /// <param name="policyOut"><dd> <p>The address of  an array of <strong><see cref="SharpDX.MediaFoundation.OutputPolicy"/></strong> references. </p> </dd></param>	
        /// <param name="nPolicy"><dd> <p> The number of elements in the <em>ppPolicy</em> array. </p> </dd></param>	
        /// <param name="bTicketOut"><dd> <p> Receives either a reference to a buffer allocated by the OTA, or the value <strong><c>null</c></strong>. If this parameter receives a non-<strong><c>null</c></strong> value, the caller must release the buffer by calling <strong>CoTaskMemFree</strong>. </p> <strong>Note</strong>??Currently this parameter is reserved. An OTA should set the reference to <strong><c>null</c></strong>. ? </dd></param>	
        /// <param name="cbTicketRef"><dd> <p> Receives the size of the <em>ppbTicket</em> buffer, in bytes. If <em>ppbTicket</em> receives the value <strong><c>null</c></strong>, <em>pcbTicket</em> receives the value zero.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>MF_S_WAIT_FOR_POLICY_SET</strong></dt> </dl> </td><td> <p> The policy was negotiated successfully, but the OTA will enforce it asynchronously. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.PolicyUnsupported"/></strong></dt> </dl> </td><td> <p> The OTA does not support the requirements of this policy. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the method returns <strong>MF_S_WAIT_FOR_POLICY_SET</strong>, the OTA sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.PolicySet"/> event when it enforces the policy.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFOutputTrustAuthority::SetPolicy']/*"/>	
        /// <msdn-id>bb970572</msdn-id>	
        /// <unmanaged>HRESULT IMFOutputTrustAuthority::SetPolicy([In, Buffer, Optional] IMFOutputPolicy** ppPolicy,[In] unsigned int nPolicy,[Out, Buffer, Optional] unsigned char** ppbTicket,[Out, Optional] unsigned int* pcbTicket)</unmanaged>	
        /// <unmanaged-short>IMFOutputTrustAuthority::SetPolicy</unmanaged-short>	
        private void SetPolicy(System.IntPtr policyOut, int nPolicy, System.IntPtr bTicketOut, System.IntPtr cbTicketRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)policyOut, nPolicy, (void*)bTicketOut, (void*)cbTicketRef, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Controls how media sources and transforms are enumerated in Microsoft Media Foundation.</p><p>To get a reference to this interface, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.GetPluginControl"/></strong>.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Media Foundation provides a set of built-in media sources and decoders. Applications can enumerate them as follows: </p><ul> <li>Media sources are enumerated through the Source Resolver.</li> <li>Transforms, such as decoders, are enumerated through the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnum"/></strong> and <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnumEx"/></strong> functions.</li> </ul><p>Applications might also enumerate these objects indirectly. For example, if an application   uses the topology loader to resolve a partial topology, the topology loader calls <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TEnumEx"/></strong> to find the required decoders.</p><p>Third parties can implement their own custom media sources and decoders, and register them for enumeration so that other applications can use them.</p><p>To control the enumeration order, Media Foundation maintains two process-wide lists of CLSIDs: a preferred list and a blocked list.  An object whose CLSID appears in the preferred list appears first in the enumeration order. An object whose CLSID appears on the blocked list is not enumerated.</p><p>The lists are initially populated from the registry. Applications can use the <strong><see cref="SharpDX.MediaFoundation.PluginControl"/></strong> interface to modify the lists for the current process.</p><p>The preferred list contains a set of key/value pairs, where the keys are strings and the values are CLSIDs. These key/value pairs are defined as follows:</p><ul> <li>For media sources, the key name is a file name extension, protocol scheme, or MIME type. The value is the CLSID of a scheme handler or byte-stream handler for that media source.</li> <li>For decoders, the key name is a media subtype <see cref="System.Guid"/> in canonical string form. (For more information about media subtypes, see Media Types.) The value is the CLSID of the Media Foundation transform (MFT) that implements the decoder. </li> </ul><p>The following examples show the various types of key:</p><ul> <li>File extension: ".wmv"</li> <li>Scheme: "http:"</li> <li>MIME type: "video/mp4"</li> <li>Media subtype: "{47504A4D-0000-0010-8000-00AA00389B71}"</li> </ul><p>To search the preferred list by key name, call the <strong><see cref="SharpDX.MediaFoundation.PluginControl.GetPreferredClsid"/></strong> method. To enumerate the entire list, call the <strong><see cref="SharpDX.MediaFoundation.PluginControl.GetPreferredClsidByIndex"/></strong> method in a loop.</p><p>The blocked list contains a list of CLSIDs. To enumerate the entire list, call the <strong><see cref="SharpDX.MediaFoundation.PluginControl.GetDisabledByIndex"/></strong> method in a loop. To check whether a specific CLSID appears on the list, call the <strong><see cref="SharpDX.MediaFoundation.PluginControl.IsDisabled"/></strong> method.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPluginControl']/*"/>	
    /// <msdn-id>dd374302</msdn-id>	
    /// <unmanaged>IMFPluginControl</unmanaged>	
    /// <unmanaged-short>IMFPluginControl</unmanaged-short>	
    [Guid("5c6c44bf-1db6-435b-9249-e8cd10fdec96")]
    public partial class PluginControl : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.PluginControl"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PluginControl(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.PluginControl"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.PluginControl(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.PluginControl(nativePointer);
        }


        /// <summary>	
        /// <p>Searches the preferred list for a class identifier (CLSID) that matches a specified key name.</p>	
        /// </summary>	
        /// <param name="pluginType"><dd> <p>Member of the <strong><see cref="SharpDX.MediaFoundation.PluginType"/></strong> enumeration, specifying the type of object.</p> </dd></param>	
        /// <param name="selector"><dd> <p>The key name to match. For more information about the format of key names, see the Remarks section of <strong><see cref="SharpDX.MediaFoundation.PluginControl"/></strong>.</p> </dd></param>	
        /// <param name="clsid"><dd> <p>Receives a CLSID from the preferred list.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>HRESULT_FROM_WIN32(<see cref="SharpDX.Win32.ErrorCode.NotFound"/>)</strong></strong></dt> </dl> </td><td> <p>No CLSID matching this key was found.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPluginControl::GetPreferredClsid']/*"/>	
        /// <msdn-id>dd374304</msdn-id>	
        /// <unmanaged>HRESULT IMFPluginControl::GetPreferredClsid([In] unsigned int pluginType,[In] const wchar_t* selector,[Out] GUID* clsid)</unmanaged>	
        /// <unmanaged-short>IMFPluginControl::GetPreferredClsid</unmanaged-short>	
        public void GetPreferredClsid(int pluginType, string selector, out System.Guid clsid)
        {
            unsafe
            {
                clsid = new System.Guid();
                SharpDX.Result __result__;
                fixed (char* selector_ = selector)
                fixed (void* clsid_ = &clsid)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, pluginType, (void*)selector_, clsid_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a class identifier (CLSID) from the preferred list, specified by index value.</p>	
        /// </summary>	
        /// <param name="pluginType"><dd> <p>Member of the <strong><see cref="SharpDX.MediaFoundation.PluginType"/></strong> enumeration, specifying the type of object to enumerate.</p> </dd></param>	
        /// <param name="index"><dd> <p>The zero-based index of the CLSID to retrieve.</p> </dd></param>	
        /// <param name="selector"><dd> <p>Receives the key name associated with the CLSID. The caller must free the memory for the returned string by calling the <strong>CoTaskMemFree</strong> function. For more information about the format of key names, see the Remarks section of <strong><see cref="SharpDX.MediaFoundation.PluginControl"/></strong>.</p> </dd></param>	
        /// <param name="clsid"><dd> <p>Receives the CLSID at the specified index.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>HRESULT_FROM_WIN32(<see cref="SharpDX.Win32.ErrorCode.NoMoreItems"/>)</strong></strong></dt> </dl> </td><td> <p>The <em>index</em> parameter is out of range.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPluginControl::GetPreferredClsidByIndex']/*"/>	
        /// <msdn-id>dd374305</msdn-id>	
        /// <unmanaged>HRESULT IMFPluginControl::GetPreferredClsidByIndex([In] unsigned int pluginType,[In] unsigned int index,[Out] wchar_t** selector,[Out] GUID* clsid)</unmanaged>	
        /// <unmanaged-short>IMFPluginControl::GetPreferredClsidByIndex</unmanaged-short>	
        public void GetPreferredClsidByIndex(int pluginType, int index, System.IntPtr selector, out System.Guid clsid)
        {
            unsafe
            {
                clsid = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* clsid_ = &clsid)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, pluginType, index, (void*)selector, clsid_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Adds a class identifier (CLSID) to the preferred list or removes a CLSID from the list.</p>	
        /// </summary>	
        /// <param name="pluginType"><dd> <p>Member of the <strong><see cref="SharpDX.MediaFoundation.PluginType"/></strong> enumeration, specifying the type of object.</p> </dd></param>	
        /// <param name="selector"><dd> <p>The key name for the CLSID. For more information about the format of key names, see the Remarks section of <strong><see cref="SharpDX.MediaFoundation.PluginControl"/></strong>.</p> </dd></param>	
        /// <param name="clsid"><dd> <p>The CLSID to add to the list. If this parameter is <strong><c>null</c></strong>, the key/value entry specified by the <em>selector</em> parameter is removed from the list. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The preferred list is global to the caller's process. Calling this method does not affect the list in other process.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPluginControl::SetPreferredClsid']/*"/>	
        /// <msdn-id>dd374308</msdn-id>	
        /// <unmanaged>HRESULT IMFPluginControl::SetPreferredClsid([In] unsigned int pluginType,[In] const wchar_t* selector,[In, Optional] const GUID* clsid)</unmanaged>	
        /// <unmanaged-short>IMFPluginControl::SetPreferredClsid</unmanaged-short>	
        public void SetPreferredClsid(int pluginType, string selector, System.Guid? clsid)
        {
            unsafe
            {
                System.Guid clsid_;
                if (clsid.HasValue)
                    clsid_ = clsid.Value;
                SharpDX.Result __result__;
                fixed (char* selector_ = selector)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, pluginType, (void*)selector_, (clsid.HasValue) ? &clsid_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries whether a class identifier (CLSID) appears in the blocked list.</p>	
        /// </summary>	
        /// <param name="pluginType"><dd> <p>Member of the <strong><see cref="SharpDX.MediaFoundation.PluginType"/></strong> enumeration, specifying the type of object for the query.</p> </dd></param>	
        /// <param name="clsid"><dd> <p>The CLSID to search for.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The specified CLSID appears in the blocked list.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>HRESULT_FROM_WIN32(<see cref="SharpDX.Win32.ErrorCode.NotFound"/>)</strong></strong></dt> </dl> </td><td> <p>The specified CLSID is not in the blocked list.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPluginControl::IsDisabled']/*"/>	
        /// <msdn-id>dd374306</msdn-id>	
        /// <unmanaged>HRESULT IMFPluginControl::IsDisabled([In] unsigned int pluginType,[In] const GUID&amp; clsid)</unmanaged>	
        /// <unmanaged-short>IMFPluginControl::IsDisabled</unmanaged-short>	
        public void IsDisabled(int pluginType, System.Guid clsid)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, pluginType, &clsid, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a class identifier (CLSID) from the blocked list.</p>	
        /// </summary>	
        /// <param name="pluginType"><dd> <p>Member of the <strong><see cref="SharpDX.MediaFoundation.PluginType"/></strong> enumeration, specifying the type of object to enumerate.</p> </dd></param>	
        /// <param name="index"><dd> <p>The zero-based index of the CLSID to retrieve.</p> </dd></param>	
        /// <param name="clsid"><dd> <p>Receives the CLSID at the specified index.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>HRESULT_FROM_WIN32(<see cref="SharpDX.Win32.ErrorCode.NoMoreItems"/>)</strong></strong></dt> </dl> </td><td> <p>The <em>index</em> parameter is out of range.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPluginControl::GetDisabledByIndex']/*"/>	
        /// <msdn-id>dd374303</msdn-id>	
        /// <unmanaged>HRESULT IMFPluginControl::GetDisabledByIndex([In] unsigned int pluginType,[In] unsigned int index,[Out] GUID* clsid)</unmanaged>	
        /// <unmanaged-short>IMFPluginControl::GetDisabledByIndex</unmanaged-short>	
        public void GetDisabledByIndex(int pluginType, int index, out System.Guid clsid)
        {
            unsafe
            {
                clsid = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* clsid_ = &clsid)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, pluginType, index, clsid_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Adds a class identifier (CLSID) to the blocked list, or removes a CLSID from the list.</p>	
        /// </summary>	
        /// <param name="pluginType"><dd> <p>Member of the <strong><see cref="SharpDX.MediaFoundation.PluginType"/></strong> enumeration, specifying the type of object.</p> </dd></param>	
        /// <param name="clsid"><dd> <p>The CLSID to add or remove.</p> </dd></param>	
        /// <param name="disabled"><dd> <p>Specifies whether to add or remove the CSLID. If the value is <strong>TRUE</strong>, the method adds the CLSID to the blocked list. Otherwise, the method removes it from the list.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> The blocked list is global to the caller's process. Calling this method does not affect the list in other processes. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPluginControl::SetDisabled']/*"/>	
        /// <msdn-id>dd374307</msdn-id>	
        /// <unmanaged>HRESULT IMFPluginControl::SetDisabled([In] unsigned int pluginType,[In] const GUID&amp; clsid,[In] BOOL disabled)</unmanaged>	
        /// <unmanaged-short>IMFPluginControl::SetDisabled</unmanaged-short>	
        public void SetDisabled(int pluginType, System.Guid clsid, SharpDX.Mathematics.Interop.RawBool disabled)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint88(_nativePointer, pluginType, &clsid, disabled, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Controls how media sources and transforms are enumerated in Microsoft Media Foundation.</p><p>This interface extends the <strong><see cref="SharpDX.MediaFoundation.PluginControl"/></strong> interface.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To get a reference to this interface, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.GetPluginControl"/></strong> and query the returned reference for <strong><see cref="SharpDX.MediaFoundation.PluginControl2"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPluginControl2']/*"/>	
    /// <msdn-id>hh448043</msdn-id>	
    /// <unmanaged>IMFPluginControl2</unmanaged>	
    /// <unmanaged-short>IMFPluginControl2</unmanaged-short>	
    [Guid("C6982083-3DDC-45CB-AF5E-0F7A8CE4DE77")]
    public partial class PluginControl2 : SharpDX.MediaFoundation.PluginControl
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.PluginControl2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PluginControl2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.PluginControl2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.PluginControl2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.PluginControl2(nativePointer);
        }


        /// <summary>	
        /// <p>Sets the policy for which media sources and transforms are enumerated.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPluginControl2::SetPolicy']/*"/>	
        /// <msdn-id>hh448044</msdn-id>	
        /// <unmanaged>SetPolicy</unmanaged>	
        /// <unmanaged-short>SetPolicy</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPluginControl2::SetPolicy([In] MF_PLUGIN_CONTROL_POLICY policy)</unmanaged>
        public SharpDX.MediaFoundation.PluginControlPolicy Policy
        {
            set { SetPolicy(value); }
        }

        /// <summary>	
        /// <p>Sets the policy for which media sources and transforms are enumerated.</p>	
        /// </summary>	
        /// <param name="policy"><dd> <p>A value from the <strong><see cref="SharpDX.MediaFoundation.PluginControlPolicy"/></strong> enumeration that specifies the policy.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPluginControl2::SetPolicy']/*"/>	
        /// <msdn-id>hh448044</msdn-id>	
        /// <unmanaged>HRESULT IMFPluginControl2::SetPolicy([In] MF_PLUGIN_CONTROL_POLICY policy)</unmanaged>	
        /// <unmanaged-short>IMFPluginControl2::SetPolicy</unmanaged-short>	
        internal void SetPolicy(SharpDX.MediaFoundation.PluginControlPolicy policy)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)policy), ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><strong>Note</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p> Represents a media item. A <em>media item</em> is an abstraction for a source of media data, such as a video file. Use this interface to get information about the source, or to change certain playback settings, such as the start and stop times. To get a reference to this interface, call one of the following methods:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.CreateMediaItemFromObject"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.CreateMediaItemFromURL"/></strong> </li> </ul>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem']/*"/>	
    /// <msdn-id>dd374309</msdn-id>	
    /// <unmanaged>IMFPMediaItem</unmanaged>	
    /// <unmanaged-short>IMFPMediaItem</unmanaged-short>	
    [Guid("90EB3E6B-ECBF-45cc-B1DA-C6FE3EA70D57")]
    public partial class PMediaItem : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.PMediaItem"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PMediaItem(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.PMediaItem"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.PMediaItem(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.PMediaItem(nativePointer);
        }


        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets a reference to the MFPlay player object that created the media item.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetMediaPlayer']/*"/>	
        /// <msdn-id>dd374313</msdn-id>	
        /// <unmanaged>GetMediaPlayer</unmanaged>	
        /// <unmanaged-short>GetMediaPlayer</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetMediaPlayer([Out] IMFPMediaPlayer** ppMediaPlayer)</unmanaged>
        public SharpDX.MediaFoundation.PMediaPlayer MediaPlayer
        {
            get { SharpDX.MediaFoundation.PMediaPlayer __output__; GetMediaPlayer(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the object that was used to create the media item.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The object reference is set if the application uses <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.CreateMediaItemFromObject"/></strong> to create the media item. Otherwise, <strong>GetObject</strong> returns  MF_E_NOTFOUND.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetObjectW']/*"/>	
        /// <msdn-id>dd374315</msdn-id>	
        /// <unmanaged>GetObjectW</unmanaged>	
        /// <unmanaged-short>GetObjectW</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetObjectW([Out] IUnknown** ppIUnknown)</unmanaged>
        public SharpDX.ComObject ObjectW
        {
            get { SharpDX.ComObject __output__; GetObjectW(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the application-defined value stored in the media item.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>You can assign this value when you first create the media item, by specifying it in the <em>dwUserData</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.CreateMediaItemFromURL"/></strong> or <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.CreateMediaItemFromObject"/></strong> method. To update the value, call <strong><see cref="SharpDX.MediaFoundation.PMediaItem.SetUserData"/></strong>.</p><p>This method can be called after the player object is shut down.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetUserData']/*"/>	
        /// <msdn-id>dd374321</msdn-id>	
        /// <unmanaged>GetUserData / SetUserData</unmanaged>	
        /// <unmanaged-short>GetUserData</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetUserData([Out] ULONG_PTR* pdwUserData)</unmanaged>
        public System.IntPtr UserData
        {
            get { System.IntPtr __output__; GetUserData(out __output__); return __output__; }
            set { SetUserData(value); }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries whether the media item contains protected content.</p><strong>Note</strong>??Currently <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer"/></strong> does not support playing protected content.?	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::IsProtected']/*"/>	
        /// <msdn-id>dd374324</msdn-id>	
        /// <unmanaged>IsProtected</unmanaged>	
        /// <unmanaged-short>IsProtected</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaItem::IsProtected([Out] BOOL* pfProtected)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsProtected
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; IsProtected_(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the number of streams (audio, video, and other) in the media item.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetNumberOfStreams']/*"/>	
        /// <msdn-id>dd374314</msdn-id>	
        /// <unmanaged>GetNumberOfStreams</unmanaged>	
        /// <unmanaged-short>GetNumberOfStreams</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetNumberOfStreams([Out] unsigned int* pdwStreamCount)</unmanaged>
        public int NumberOfStreams
        {
            get { int __output__; GetNumberOfStreams(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets various flags that describe the media item.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetCharacteristics']/*"/>	
        /// <msdn-id>dd374311</msdn-id>	
        /// <unmanaged>GetCharacteristics</unmanaged>	
        /// <unmanaged-short>GetCharacteristics</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetCharacteristics([Out] unsigned int* pCharacteristics)</unmanaged>
        public int Characteristics
        {
            get { int __output__; GetCharacteristics(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets a property store that contains metadata for the source, such as author or title.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetMetadata']/*"/>	
        /// <msdn-id>dd798056</msdn-id>	
        /// <unmanaged>GetMetadata</unmanaged>	
        /// <unmanaged-short>GetMetadata</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetMetadata([Out] IPropertyStore** ppMetadataStore)</unmanaged>
        public SharpDX.ComObject Metadata
        {
            get { SharpDX.ComObject __output__; GetMetadata(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets a reference to the MFPlay player object that created the media item.</p>	
        /// </summary>	
        /// <param name="mediaPlayerOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetMediaPlayer']/*"/>	
        /// <msdn-id>dd374313</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetMediaPlayer([Out] IMFPMediaPlayer** ppMediaPlayer)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::GetMediaPlayer</unmanaged-short>	
        internal void GetMediaPlayer(out SharpDX.MediaFoundation.PMediaPlayer mediaPlayerOut)
        {
            unsafe
            {
                IntPtr mediaPlayerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &mediaPlayerOut_, ((void**)(*(void**)_nativePointer))[3]);
                mediaPlayerOut = (mediaPlayerOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PMediaPlayer(mediaPlayerOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the URL that was used to create the media item.</p>	
        /// </summary>	
        /// <param name="wszURLOut">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>MF_E_NOTFOUND</strong></dt> </dl> </td><td> <p>No URL is associated with this media item.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method applies when the application calls  <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.CreateMediaItemFromURL"/></strong> to create a media item. If the application calls <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.CreateMediaItemFromObject"/></strong> to create a media item, the  <strong>GetURL</strong> method for that media item returns  <strong>MF_E_NOTFOUND</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetURL']/*"/>	
        /// <msdn-id>dd374320</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetURL([Out] wchar_t** ppwszURL)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::GetURL</unmanaged-short>	
        public void GetURL(System.IntPtr wszURLOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)wszURLOut, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the object that was used to create the media item.</p>	
        /// </summary>	
        /// <param name="iUnknownOut">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>MF_E_NOTFOUND</strong></dt> </dl> </td><td> <p>The media item was created from a URL, not from an object.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The object reference is set if the application uses <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.CreateMediaItemFromObject"/></strong> to create the media item. Otherwise, <strong>GetObject</strong> returns  MF_E_NOTFOUND.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetObjectW']/*"/>	
        /// <msdn-id>dd374315</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetObjectW([Out] IUnknown** ppIUnknown)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::GetObjectW</unmanaged-short>	
        internal void GetObjectW(out SharpDX.ComObject iUnknownOut)
        {
            unsafe
            {
                IntPtr iUnknownOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &iUnknownOut_, ((void**)(*(void**)_nativePointer))[5]);
                iUnknownOut = (iUnknownOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(iUnknownOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the application-defined value stored in the media item.</p>	
        /// </summary>	
        /// <param name="dwUserDataRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>You can assign this value when you first create the media item, by specifying it in the <em>dwUserData</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.CreateMediaItemFromURL"/></strong> or <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.CreateMediaItemFromObject"/></strong> method. To update the value, call <strong><see cref="SharpDX.MediaFoundation.PMediaItem.SetUserData"/></strong>.</p><p>This method can be called after the player object is shut down.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetUserData']/*"/>	
        /// <msdn-id>dd374321</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetUserData([Out] ULONG_PTR* pdwUserData)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::GetUserData</unmanaged-short>	
        internal void GetUserData(out System.IntPtr dwUserDataRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwUserDataRef_ = &dwUserDataRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwUserDataRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Stores an application-defined value in the media item.</p>	
        /// </summary>	
        /// <param name="dwUserData">No documentation.</param>	
        /// <returns><p>This method can return one of these values.</p></returns>	
        /// <remarks>	
        /// <p>This method can be called after the player object is shut down.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::SetUserData']/*"/>	
        /// <msdn-id>dd374328</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::SetUserData([In] ULONG_PTR dwUserData)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::SetUserData</unmanaged-short>	
        internal void SetUserData(System.IntPtr dwUserData)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)dwUserData, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the start and stop times for the media item.</p>	
        /// </summary>	
        /// <param name="guidStartPositionTypeRef">No documentation.</param>	
        /// <param name="vStartValueRef">No documentation.</param>	
        /// <param name="guidStopPositionTypeRef">No documentation.</param>	
        /// <param name="vStopValueRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The <em>pguidStartPositionType</em> and <em>pguidStopPositionType</em> parameters receive the units of time that are used. Currently, the only supported value is <strong>MFP_POSITIONTYPE_100NS</strong>.</p><table> <tr><th>Value</th><th>Description</th></tr> <tr><td>MFP_POSITIONTYPE_100NS</td><td>100-nanosecond units. The time parameter (<em>pvStartValue</em> or <em>pvStopValue</em>) uses the following data type:<ul> <li>Variant type (<strong>vt</strong>): VT_I8</li> <li>Variant member: <strong>hVal</strong></li> </ul> </td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetStartStopPosition']/*"/>	
        /// <msdn-id>dd374317</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetStartStopPosition([Out, Optional] GUID* pguidStartPositionType,[Out, Optional] PROPVARIANT* pvStartValue,[Out, Optional] GUID* pguidStopPositionType,[Out, Optional] PROPVARIANT* pvStopValue)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::GetStartStopPosition</unmanaged-short>	
        public void GetStartStopPosition(out System.Guid guidStartPositionTypeRef, out SharpDX.Win32.Variant vStartValueRef, out System.Guid guidStopPositionTypeRef, out SharpDX.Win32.Variant vStopValueRef)
        {
            unsafe
            {
                guidStartPositionTypeRef = new System.Guid();
                vStartValueRef = new SharpDX.Win32.Variant();
                guidStopPositionTypeRef = new System.Guid();
                vStopValueRef = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* guidStartPositionTypeRef_ = &guidStartPositionTypeRef)
                fixed (void* vStartValueRef_ = &vStartValueRef)
                fixed (void* guidStopPositionTypeRef_ = &guidStopPositionTypeRef)
                fixed (void* vStopValueRef_ = &vStopValueRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, guidStartPositionTypeRef_, vStartValueRef_, guidStopPositionTypeRef_, vStopValueRef_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Sets the start and stop time for the media item.</p>	
        /// </summary>	
        /// <param name="guidStartPositionTypeRef">No documentation.</param>	
        /// <param name="vStartValueRef">No documentation.</param>	
        /// <param name="guidStopPositionTypeRef">No documentation.</param>	
        /// <param name="vStopValueRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.OutOfRange"/></strong></dt> </dl> </td><td> <p>Invalid start or stop time. Any of the following can cause this error:</p> <ul> <li>Time less than zero.</li> <li>Time greater than the total duration of the media item.</li> <li>Stop time less than start time.</li> </ul> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>By default, a media item plays from the beginning to the end of the file. This method adjusts the start time and/or  the stop time:</p><ul> <li>To set the start time, pass non-<strong><c>null</c></strong> values for <em>pguidStartPositionType</em> and <em>pvStartValue</em>.</li> <li>To set the stop time, pass non-<strong><c>null</c></strong> values for <em>pguidStopPositionType</em> and <em>pvStopValue</em>.</li> </ul><p>The <em>pguidStartPositionType</em> and <em>pguidStopPositionType</em> parameters give the units of time that are used. Currently, the only supported value is <strong>MFP_POSITIONTYPE_100NS</strong>.</p><table> <tr><th>Value</th><th>Description</th></tr> <tr><td><strong>MFP_POSITIONTYPE_100NS</strong></td><td>100-nanosecond units. The time parameter (<em>pvStartValue</em> or <em>pvStopValue</em>) uses the following data type:<ul> <li>Variant type (<strong>vt</strong>): <strong>VT_I8</strong></li> <li>Variant member: <strong>hVal</strong></li> </ul> <p>To clear a previously set time, use an empty <strong><see cref="SharpDX.Win32.Variant"/></strong> (<strong>VT_EMPTY</strong>).</p> </td></tr> </table><p>?</p><p>The adjusted start and stop times are used the next time that <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.SetMediaItem"/></strong> is called with this media item. If the media item is already set on the player, the change does not happen unless you call <strong>SetMediaItem</strong> again.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::SetStartStopPosition']/*"/>	
        /// <msdn-id>dd374325</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::SetStartStopPosition([In, Optional] const GUID* pguidStartPositionType,[In, Optional] const PROPVARIANT* pvStartValue,[In, Optional] const GUID* pguidStopPositionType,[In, Optional] const PROPVARIANT* pvStopValue)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::SetStartStopPosition</unmanaged-short>	
        public void SetStartStopPosition(System.Guid? guidStartPositionTypeRef, SharpDX.Win32.Variant? vStartValueRef, System.Guid? guidStopPositionTypeRef, SharpDX.Win32.Variant? vStopValueRef)
        {
            unsafe
            {
                System.Guid guidStartPositionTypeRef_;
                if (guidStartPositionTypeRef.HasValue)
                    guidStartPositionTypeRef_ = guidStartPositionTypeRef.Value;
                SharpDX.Win32.Variant vStartValueRef_;
                if (vStartValueRef.HasValue)
                    vStartValueRef_ = vStartValueRef.Value;
                System.Guid guidStopPositionTypeRef_;
                if (guidStopPositionTypeRef.HasValue)
                    guidStopPositionTypeRef_ = guidStopPositionTypeRef.Value;
                SharpDX.Win32.Variant vStopValueRef_;
                if (vStopValueRef.HasValue)
                    vStopValueRef_ = vStopValueRef.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (guidStartPositionTypeRef.HasValue) ? &guidStartPositionTypeRef_ : (void*)IntPtr.Zero, (vStartValueRef.HasValue) ? &vStartValueRef_ : (void*)IntPtr.Zero, (guidStopPositionTypeRef.HasValue) ? &guidStopPositionTypeRef_ : (void*)IntPtr.Zero, (vStopValueRef.HasValue) ? &vStopValueRef_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries whether the media item contains a video stream.</p>	
        /// </summary>	
        /// <param name="fHasVideoRef">No documentation.</param>	
        /// <param name="fSelectedRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> To select or deselect streams before playback starts, call <strong><see cref="SharpDX.MediaFoundation.PMediaItem.SetStreamSelection"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::HasVideo']/*"/>	
        /// <msdn-id>dd374323</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::HasVideo([Out, Optional] BOOL* pfHasVideo,[Out, Optional] BOOL* pfSelected)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::HasVideo</unmanaged-short>	
        public void HasVideo(out SharpDX.Mathematics.Interop.RawBool fHasVideoRef, out SharpDX.Mathematics.Interop.RawBool fSelectedRef)
        {
            unsafe
            {
                fHasVideoRef = new SharpDX.Mathematics.Interop.RawBool();
                fSelectedRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fHasVideoRef_ = &fHasVideoRef)
                fixed (void* fSelectedRef_ = &fSelectedRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fHasVideoRef_, fSelectedRef_, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries whether the media item contains an audio stream.</p>	
        /// </summary>	
        /// <param name="fHasAudioRef">No documentation.</param>	
        /// <param name="fSelectedRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> To select or deselect streams before playback starts, call <strong><see cref="SharpDX.MediaFoundation.PMediaItem.SetStreamSelection"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::HasAudio']/*"/>	
        /// <msdn-id>dd374322</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::HasAudio([Out, Optional] BOOL* pfHasAudio,[Out, Optional] BOOL* pfSelected)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::HasAudio</unmanaged-short>	
        public void HasAudio(out SharpDX.Mathematics.Interop.RawBool fHasAudioRef, out SharpDX.Mathematics.Interop.RawBool fSelectedRef)
        {
            unsafe
            {
                fHasAudioRef = new SharpDX.Mathematics.Interop.RawBool();
                fSelectedRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fHasAudioRef_ = &fHasAudioRef)
                fixed (void* fSelectedRef_ = &fSelectedRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fHasAudioRef_, fSelectedRef_, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries whether the media item contains protected content.</p><strong>Note</strong>??Currently <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer"/></strong> does not support playing protected content.?	
        /// </summary>	
        /// <param name="fProtectedRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::IsProtected']/*"/>	
        /// <msdn-id>dd374324</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::IsProtected([Out] BOOL* pfProtected)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::IsProtected</unmanaged-short>	
        internal void IsProtected_(out SharpDX.Mathematics.Interop.RawBool fProtectedRef)
        {
            unsafe
            {
                fProtectedRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fProtectedRef_ = &fProtectedRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fProtectedRef_, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the duration of the media item.</p>	
        /// </summary>	
        /// <param name="guidPositionType">No documentation.</param>	
        /// <param name="vDurationValueRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The method returns the total duration of the content, regardless of any values set through <strong><see cref="SharpDX.MediaFoundation.PMediaItem.SetStartStopPosition"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetDuration']/*"/>	
        /// <msdn-id>dd374312</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetDuration([In] const GUID&amp; guidPositionType,[Out] PROPVARIANT* pvDurationValue)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::GetDuration</unmanaged-short>	
        public void GetDuration(System.Guid guidPositionType, out SharpDX.Win32.Variant vDurationValueRef)
        {
            unsafe
            {
                vDurationValueRef = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* vDurationValueRef_ = &vDurationValueRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidPositionType, vDurationValueRef_, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the number of streams (audio, video, and other) in the media item.</p>	
        /// </summary>	
        /// <param name="dwStreamCountRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetNumberOfStreams']/*"/>	
        /// <msdn-id>dd374314</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetNumberOfStreams([Out] unsigned int* pdwStreamCount)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::GetNumberOfStreams</unmanaged-short>	
        internal void GetNumberOfStreams(out int dwStreamCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwStreamCountRef_ = &dwStreamCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamCountRef_, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries whether a stream is selected to play.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex">No documentation.</param>	
        /// <param name="fEnabledRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> To select or deselect a stream, call <strong><see cref="SharpDX.MediaFoundation.PMediaItem.SetStreamSelection"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetStreamSelection']/*"/>	
        /// <msdn-id>dd374319</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetStreamSelection([In] unsigned int dwStreamIndex,[Out] BOOL* pfEnabled)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::GetStreamSelection</unmanaged-short>	
        public void GetStreamSelection(int dwStreamIndex, out SharpDX.Mathematics.Interop.RawBool fEnabledRef)
        {
            unsafe
            {
                fEnabledRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fEnabledRef_ = &fEnabledRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, fEnabledRef_, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Selects or deselects a stream.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex">No documentation.</param>	
        /// <param name="fEnabled">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>You can use this method to change which streams are selected. The change goes into effect the next time that <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.SetMediaItem"/></strong> is called with this media item. If the media item is already set on the player, the change does not happen unless you call <strong>SetMediaItem</strong> again with this media item.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::SetStreamSelection']/*"/>	
        /// <msdn-id>dd374326</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::SetStreamSelection([In] unsigned int dwStreamIndex,[In] BOOL fEnabled)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::SetStreamSelection</unmanaged-short>	
        public void SetStreamSelection(int dwStreamIndex, SharpDX.Mathematics.Interop.RawBool fEnabled)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint19(_nativePointer, dwStreamIndex, fEnabled, ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries the media item for a stream attribute.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex">No documentation.</param>	
        /// <param name="guidMFAttribute">No documentation.</param>	
        /// <param name="vValueRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Stream attributes describe an individual stream (audio, video, or other) within the presentation. To get an attribute that applies to the entire presentation, call <strong><see cref="SharpDX.MediaFoundation.PMediaItem.GetPresentationAttribute"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetStreamAttribute']/*"/>	
        /// <msdn-id>dd374318</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetStreamAttribute([In] unsigned int dwStreamIndex,[In] const GUID&amp; guidMFAttribute,[Out] PROPVARIANT* pvValue)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::GetStreamAttribute</unmanaged-short>	
        public void GetStreamAttribute(int dwStreamIndex, System.Guid guidMFAttribute, out SharpDX.Win32.Variant vValueRef)
        {
            unsafe
            {
                vValueRef = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* vValueRef_ = &vValueRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, &guidMFAttribute, vValueRef_, ((void**)(*(void**)_nativePointer))[17]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries the media item for a presentation attribute.</p>	
        /// </summary>	
        /// <param name="guidMFAttribute">No documentation.</param>	
        /// <param name="vValueRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Presentation attributes describe the presentation as a whole. To get an attribute that applies to an individual stream within the presentation, call <strong><see cref="SharpDX.MediaFoundation.PMediaItem.GetStreamAttribute"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetPresentationAttribute']/*"/>	
        /// <msdn-id>dd374316</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetPresentationAttribute([In] const GUID&amp; guidMFAttribute,[Out] PROPVARIANT* pvValue)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::GetPresentationAttribute</unmanaged-short>	
        public void GetPresentationAttribute(System.Guid guidMFAttribute, out SharpDX.Win32.Variant vValueRef)
        {
            unsafe
            {
                vValueRef = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* vValueRef_ = &vValueRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidMFAttribute, vValueRef_, ((void**)(*(void**)_nativePointer))[18]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets various flags that describe the media item.</p>	
        /// </summary>	
        /// <param name="characteristicsRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetCharacteristics']/*"/>	
        /// <msdn-id>dd374311</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetCharacteristics([Out] unsigned int* pCharacteristics)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::GetCharacteristics</unmanaged-short>	
        internal void GetCharacteristics(out int characteristicsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* characteristicsRef_ = &characteristicsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, characteristicsRef_, ((void**)(*(void**)_nativePointer))[19]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p> Sets a media sink for the media item. A <em>media sink</em> is an object that consumes the data from one or more streams. </p>	
        /// </summary>	
        /// <param name="dwStreamIndex">No documentation.</param>	
        /// <param name="mediaSinkRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>By default, the MFPlay player object renders audio streams to the Streaming Audio Renderer (SAR) and video streams to the Enhanced Video Renderer (EVR). You can use the <strong>SetStreamSink</strong> method to provide a different media sink for an audio or video stream; or to support other stream types besides audio and video. You can also use it to configure the SAR or EVR before they are used.</p><p>Call this method before calling <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.SetMediaItem"/></strong>. Calling this method after <strong>SetMediaItem</strong> has no effect, unless you stop playback and call <strong>SetMediaItem</strong> again.</p><p>To reset the media item to use the default media sink, set <em>pMediaSink</em> to <strong><c>null</c></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::SetStreamSink']/*"/>	
        /// <msdn-id>dd374327</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::SetStreamSink([In] unsigned int dwStreamIndex,[In, Optional] IUnknown* pMediaSink)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::SetStreamSink</unmanaged-short>	
        public void SetStreamSink(int dwStreamIndex, SharpDX.ComObject mediaSinkRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, (void*)((mediaSinkRef == null) ? IntPtr.Zero : mediaSinkRef.NativePointer), ((void**)(*(void**)_nativePointer))[20]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets a property store that contains metadata for the source, such as author or title.</p>	
        /// </summary>	
        /// <param name="metadataStoreOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaItem::GetMetadata']/*"/>	
        /// <msdn-id>dd798056</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaItem::GetMetadata([Out] IPropertyStore** ppMetadataStore)</unmanaged>	
        /// <unmanaged-short>IMFPMediaItem::GetMetadata</unmanaged-short>	
        internal void GetMetadata(out SharpDX.ComObject metadataStoreOut)
        {
            unsafe
            {
                IntPtr metadataStoreOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &metadataStoreOut_, ((void**)(*(void**)_nativePointer))[21]);
                metadataStoreOut = (metadataStoreOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(metadataStoreOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p> Contains methods to play media files.</p><p>The MFPlay player object exposes this interface. To get a reference to this interface, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.PCreateMediaPlayer"/></strong>.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer']/*"/>	
    /// <msdn-id>dd374329</msdn-id>	
    /// <unmanaged>IMFPMediaPlayer</unmanaged>	
    /// <unmanaged-short>IMFPMediaPlayer</unmanaged-short>	
    [Guid("A714590A-58AF-430a-85BF-44F5EC838D85")]
    public partial class PMediaPlayer : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.PMediaPlayer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PMediaPlayer(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.PMediaPlayer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.PMediaPlayer(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.PMediaPlayer(nativePointer);
        }


        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current playback rate.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetRate']/*"/>	
        /// <msdn-id>dd374346</msdn-id>	
        /// <unmanaged>GetRate / SetRate</unmanaged>	
        /// <unmanaged-short>GetRate</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetRate([Out] float* pflRate)</unmanaged>
        public float Rate
        {
            get { float __output__; GetRate(out __output__); return __output__; }
            set { SetRate(value); }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current playback state of the MFPlay player object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method can be called after the player object has been shut down.</p><p>Many of the <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer"/></strong> methods complete asynchronously. While an asynchronous operation is pending, the current state is not updated until the operation completes. When the operation completes, the application receives an event callback, and the new state is given in the <strong><see cref="SharpDX.MediaFoundation.PEventHeader"/></strong> structure that is passed to the callback.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetState']/*"/>	
        /// <msdn-id>dd374347</msdn-id>	
        /// <unmanaged>GetState</unmanaged>	
        /// <unmanaged-short>GetState</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetState([Out] MFP_MEDIAPLAYER_STATE* peState)</unmanaged>
        public SharpDX.MediaFoundation.PMediaPlayerState State
        {
            get { SharpDX.MediaFoundation.PMediaPlayerState __output__; GetState(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets a reference to the current media item.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.SetMediaItem"/></strong> method is asynchronous. Therefore, while <strong>SetMediaItem</strong> is pending, <strong>GetMediaItem</strong> will not return the media item that was just set. Instead, the application should implement <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback"/></strong> interface and handle the <strong><see cref="SharpDX.MediaFoundation.PEventType.MediaItemSet"/></strong> event. For more information, see Receiving Events From the Player.</p><p>The previous remark also applies to setting the media item in the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.PCreateMediaPlayer"/></strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetMediaItem']/*"/>	
        /// <msdn-id>dd374342</msdn-id>	
        /// <unmanaged>GetMediaItem / SetMediaItem</unmanaged>	
        /// <unmanaged-short>GetMediaItem</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetMediaItem([Out] IMFPMediaItem** ppIMFPMediaItem)</unmanaged>
        public SharpDX.MediaFoundation.PMediaItem MediaItem
        {
            get { SharpDX.MediaFoundation.PMediaItem __output__; GetMediaItem(out __output__); return __output__; }
            set { SetMediaItem(value); }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current audio volume.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetVolume']/*"/>	
        /// <msdn-id>dd374351</msdn-id>	
        /// <unmanaged>GetVolume / SetVolume</unmanaged>	
        /// <unmanaged-short>GetVolume</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetVolume([Out] float* pflVolume)</unmanaged>
        public float Volume
        {
            get { float __output__; GetVolume(out __output__); return __output__; }
            set { SetVolume(value); }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current audio balance.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetBalance']/*"/>	
        /// <msdn-id>dd374338</msdn-id>	
        /// <unmanaged>GetBalance / SetBalance</unmanaged>	
        /// <unmanaged-short>GetBalance</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetBalance([Out] float* pflBalance)</unmanaged>
        public float Balance
        {
            get { float __output__; GetBalance(out __output__); return __output__; }
            set { SetBalance(value); }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries whether the audio is muted.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetMute']/*"/>	
        /// <msdn-id>dd374343</msdn-id>	
        /// <unmanaged>GetMute / SetMute</unmanaged>	
        /// <unmanaged-short>GetMute</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetMute([Out] BOOL* pfMute)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool Mute
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; GetMute(out __output__); return __output__; }
            set { SetMute(value); }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the video source rectangle.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetVideoSourceRect']/*"/>	
        /// <msdn-id>dd743246</msdn-id>	
        /// <unmanaged>GetVideoSourceRect / SetVideoSourceRect</unmanaged>	
        /// <unmanaged-short>GetVideoSourceRect</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetVideoSourceRect([Out] MFVideoNormalizedRect* pnrcSource)</unmanaged>
        public SharpDX.MediaFoundation.VideoNormalizedRect VideoSourceRect
        {
            get { SharpDX.MediaFoundation.VideoNormalizedRect __output__; GetVideoSourceRect(out __output__); return __output__; }
            set { SetVideoSourceRect(value); }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current aspect-ratio correction mode. This mode controls whether the aspect ratio of the video is preserved during playback.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetAspectRatioMode']/*"/>	
        /// <msdn-id>dd374337</msdn-id>	
        /// <unmanaged>GetAspectRatioMode / SetAspectRatioMode</unmanaged>	
        /// <unmanaged-short>GetAspectRatioMode</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetAspectRatioMode([Out] unsigned int* pdwAspectRatioMode)</unmanaged>
        public int AspectRatioMode
        {
            get { int __output__; GetAspectRatioMode(out __output__); return __output__; }
            set { SetAspectRatioMode(value); }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the window where the video is displayed.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The video window is specified when you first call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.PCreateMediaPlayer"/></strong> to create the MFPlay player object.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetVideoWindow']/*"/>	
        /// <msdn-id>dd374350</msdn-id>	
        /// <unmanaged>GetVideoWindow</unmanaged>	
        /// <unmanaged-short>GetVideoWindow</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetVideoWindow([Out] HWND* phwndVideo)</unmanaged>
        public System.IntPtr VideoWindow
        {
            get { System.IntPtr __output__; GetVideoWindow(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current color of the video border. The border color is used to letterbox the video.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetBorderColor']/*"/>	
        /// <msdn-id>dd374339</msdn-id>	
        /// <unmanaged>GetBorderColor / SetBorderColor</unmanaged>	
        /// <unmanaged-short>GetBorderColor</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetBorderColor([Out] COLORREF* pClr)</unmanaged>
        public int BorderColor
        {
            get { int __output__; GetBorderColor(out __output__); return __output__; }
            set { SetBorderColor(value); }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Starts playback.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method completes asynchronously.  When the operation completes, the application's <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback.OnMediaPlayerEvent"/></strong> callback method is invoked. The event type is <strong><see cref="SharpDX.MediaFoundation.PEventType.Play"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::Play']/*"/>	
        /// <msdn-id>dd374354</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::Play()</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::Play</unmanaged-short>	
        public void Play()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Pauses playback. While playback is paused, the most recent video frame is displayed, and audio is silent.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method completes asynchronously.  When the operation completes, the application's <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback.OnMediaPlayerEvent"/></strong> callback method is invoked. The event type is <strong><see cref="SharpDX.MediaFoundation.PEventType.Pause"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::Pause']/*"/>	
        /// <msdn-id>dd374353</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::Pause()</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::Pause</unmanaged-short>	
        public void Pause()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Stops playback.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method completes asynchronously.  When the operation completes, the application's <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback.OnMediaPlayerEvent"/></strong> callback method is invoked. The event type is <strong><see cref="SharpDX.MediaFoundation.PEventType.Stop"/></strong>.</p><p>The current media item is still valid. After playback stops, the playback position resets to the beginning of the current media item. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::Stop']/*"/>	
        /// <msdn-id>dd374368</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::Stop()</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::Stop</unmanaged-short>	
        public void Stop()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Steps forward one video frame.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>Cannot frame step. Reasons for this error code include:</p> <ul> <li>There is no media item queued for playback.</li> <li>The current media item does not contain video.</li> </ul> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedRate"/></strong></dt> </dl> </td><td> <p>The media source does not support frame stepping, or the current playback rate is negative.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> This method completes asynchronously.  When the operation completes, the application's <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback.OnMediaPlayerEvent"/></strong> callback method is invoked. The event type is <strong><see cref="SharpDX.MediaFoundation.PEventType.FrameStep"/></strong>.</p><p>The player object does not support frame stepping during reverse playback (that is, while the playback rate is negative).</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::FrameStep']/*"/>	
        /// <msdn-id>dd374336</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::FrameStep()</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::FrameStep</unmanaged-short>	
        public void FrameStep()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Sets the playback position.</p>	
        /// </summary>	
        /// <param name="guidPositionType">No documentation.</param>	
        /// <param name="vPositionValueRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>HRESULT_FROM_WIN32( <see cref="SharpDX.Win32.ErrorCode.Seek"/> )</strong></strong></dt> </dl> </td><td> <p>The value of <em>pvPositionValue</em> is not valid.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>No media item has been queued.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If you call this method while playback is stopped, the new position takes effect after playback resumes.</p><p>This method completes asynchronously. When the operation completes, the application's <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback.OnMediaPlayerEvent"/></strong> callback method is invoked. The event type is <strong><see cref="SharpDX.MediaFoundation.PEventType.PositionSet"/></strong>.</p><p>If playback was started before <strong>SetPosition</strong> is called, playback resumes at the new position. If playback was paused, the video is refreshed to display the current frame at the new position. </p><p>If you make two consecutive calls to <strong>SetPosition</strong> with <em>guidPositionType</em> equal to <strong>MFP_POSITIONTYPE_100NS</strong>, and the second call is made before the first call has completed, the second call supersedes the first. The status code for the superseded call is set to <strong>S_FALSE</strong> in the event data for that call. This behavior prevents excessive latency from repeated calls to <strong>SetPosition</strong>, as each call may force the media source to perform a relatively lengthy seek operation. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::SetPosition']/*"/>	
        /// <msdn-id>dd374363</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::SetPosition([In] const GUID&amp; guidPositionType,[In] const PROPVARIANT* pvPositionValue)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::SetPosition</unmanaged-short>	
        public void SetPosition(System.Guid guidPositionType, SharpDX.Win32.Variant vPositionValueRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidPositionType, &vPositionValueRef, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current playback position.</p>	
        /// </summary>	
        /// <param name="guidPositionType">No documentation.</param>	
        /// <param name="vPositionValueRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>No media item has been queued.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The playback position is calculated relative to the start time of the media item, which can be specified by calling <strong><see cref="SharpDX.MediaFoundation.PMediaItem.SetStartStopPosition"/></strong>. For example, if you set the start time to 20 seconds and the source duration is 60 seconds, the range of values returned by <strong>GetPosition</strong> is 0?40 seconds.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetPosition']/*"/>	
        /// <msdn-id>dd374345</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetPosition([In] const GUID&amp; guidPositionType,[Out] PROPVARIANT* pvPositionValue)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::GetPosition</unmanaged-short>	
        public void GetPosition(System.Guid guidPositionType, out SharpDX.Win32.Variant vPositionValueRef)
        {
            unsafe
            {
                vPositionValueRef = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* vPositionValueRef_ = &vPositionValueRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidPositionType, vPositionValueRef_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the playback duration of the current media item.</p>	
        /// </summary>	
        /// <param name="guidPositionType">No documentation.</param>	
        /// <param name="vDurationValueRef">No documentation.</param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Attributenotfound"/></strong></dt> </dl> </td><td> <p>The media source does not have a duration. This error can occur with a live source, such as a video camera.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>There is no current media item.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method calculates the playback duration, taking into account the start and stop times for the media item. To set the start and stop times, call <strong><see cref="SharpDX.MediaFoundation.PMediaItem.SetStartStopPosition"/></strong> on the media item. To get the actual duration of the underlying media file, regardless of start and stop times, call <strong><see cref="SharpDX.MediaFoundation.PMediaItem.GetDuration"/></strong>.</p><p>For example, suppose that you load a 30-second audio file and set the start time equal to 2 seconds and stop time equal to 10 seconds. The <strong><see cref="SharpDX.MediaFoundation.PMediaItem.GetDuration"/></strong> method will return 30 seconds, but the <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.GetDuration"/></strong> method will return 8 seconds.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetDuration']/*"/>	
        /// <msdn-id>dd374340</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetDuration([In] const GUID&amp; guidPositionType,[Out] PROPVARIANT* pvDurationValue)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::GetDuration</unmanaged-short>	
        public void GetDuration(System.Guid guidPositionType, out SharpDX.Win32.Variant vDurationValueRef)
        {
            unsafe
            {
                vDurationValueRef = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* vDurationValueRef_ = &vDurationValueRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidPositionType, vDurationValueRef_, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Sets the playback rate.</p>	
        /// </summary>	
        /// <param name="flRate">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.OutOfRange"/></strong></strong></dt> </dl> </td><td> <p>The <em>flRate</em> parameter is zero.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method completes asynchronously.  When the operation completes, the application's <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback.OnMediaPlayerEvent"/></strong> callback method is invoked. The event type is <strong><see cref="SharpDX.MediaFoundation.PEventType.RateSet"/></strong>.</p><p>The method sets the nearest supported rate, which will depend on the underlying media source. For example, if <em>flRate</em> is 50 and the source's maximum rate is 8? normal rate, the method will set the rate to 8.0.  The actual rate is indicated in the event data for the <strong><see cref="SharpDX.MediaFoundation.PEventType.RateSet"/></strong> event.</p><p>To find the range of supported rates, call <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.GetSupportedRates"/></strong>.</p><p>This method does not support playback rates of zero, although Media Foundation defines a meaning for zero rates in some other contexts.</p><p>The new rate applies only to the current media item. Setting a new media item resets the playback rate to 1.0.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::SetRate']/*"/>	
        /// <msdn-id>dd374364</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::SetRate([In] float flRate)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::SetRate</unmanaged-short>	
        internal void SetRate(float flRate)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, flRate, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current playback rate.</p>	
        /// </summary>	
        /// <param name="flRateRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetRate']/*"/>	
        /// <msdn-id>dd374346</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetRate([Out] float* pflRate)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::GetRate</unmanaged-short>	
        internal void GetRate(out float flRateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* flRateRef_ = &flRateRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, flRateRef_, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the range of supported playback rates.</p>	
        /// </summary>	
        /// <param name="fForwardDirection">No documentation.</param>	
        /// <param name="flSlowestRateRef">No documentation.</param>	
        /// <param name="flFastestRateRef">No documentation.</param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedRate"/></strong></strong></dt> </dl> </td><td> <p>The current media item does not support playback in the requested direction (either forward or reverse).</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Playback rates are expressed as a ratio of the current rate to the normal rate. For example, 1.0 indicates normal playback speed, 0.5 indicates half speed, and 2.0 indicates twice speed. Positive values indicate forward playback, and negative values indicate reverse playback.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetSupportedRates']/*"/>	
        /// <msdn-id>dd374348</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetSupportedRates([In] BOOL fForwardDirection,[Out] float* pflSlowestRate,[Out] float* pflFastestRate)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::GetSupportedRates</unmanaged-short>	
        public void GetSupportedRates(SharpDX.Mathematics.Interop.RawBool fForwardDirection, out float flSlowestRateRef, out float flFastestRateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* flSlowestRateRef_ = &flSlowestRateRef)
                fixed (void* flFastestRateRef_ = &flFastestRateRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint17(_nativePointer, fForwardDirection, flSlowestRateRef_, flFastestRateRef_, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current playback state of the MFPlay player object.</p>	
        /// </summary>	
        /// <param name="eStateRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method can be called after the player object has been shut down.</p><p>Many of the <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer"/></strong> methods complete asynchronously. While an asynchronous operation is pending, the current state is not updated until the operation completes. When the operation completes, the application receives an event callback, and the new state is given in the <strong><see cref="SharpDX.MediaFoundation.PEventHeader"/></strong> structure that is passed to the callback.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetState']/*"/>	
        /// <msdn-id>dd374347</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetState([Out] MFP_MEDIAPLAYER_STATE* peState)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::GetState</unmanaged-short>	
        internal void GetState(out SharpDX.MediaFoundation.PMediaPlayerState eStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* eStateRef_ = &eStateRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, eStateRef_, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Creates a media item from a URL.</p>	
        /// </summary>	
        /// <param name="wszURLRef">No documentation.</param>	
        /// <param name="fSync">No documentation.</param>	
        /// <param name="dwUserData">No documentation.</param>	
        /// <param name="mediaItemOut">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>Invalid request. This error can occur when <em>fSync</em> is <strong><see cref="SharpDX.Result.False"/></strong> and the application did not provide a callback interface. See Remarks.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedScheme"/></strong></strong></dt> </dl> </td><td> <p>Unsupported protocol. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method does not queue the media item for playback. To queue the item for playback, call <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.SetMediaItem"/></strong>.</p><p>The <strong>CreateMediaItemFromURL</strong> method can be called either synchronously or asynchronously: </p><ul> <li>If <em>fSync</em> is <strong>TRUE</strong>, the method completes synchronously. The <strong><see cref="SharpDX.MediaFoundation.PMediaItem"/></strong> reference is returned in the <em>ppMediaItem</em> parameter. </li> <li>If <em>fSync</em> is <strong><see cref="SharpDX.Result.False"/></strong>, the method completes asynchronously. When the operation completes, the application's <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback.OnMediaPlayerEvent"/></strong> callback method is invoked. The event type is <strong><see cref="SharpDX.MediaFoundation.PEventType.MediaItemCreateD"/></strong>. The event data contains the <strong><see cref="SharpDX.MediaFoundation.PMediaItem"/></strong> reference for the new media item.</li> </ul><p>The callback interface is set when you first call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.PCreateMediaPlayer"/></strong> to create the MFPlay player object. If you do not provide a callback interface, the <em>fSync</em> parameter must be <strong>TRUE</strong>. Otherwise, <strong>CreateMediaItemFromURL</strong> returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong>. </p><p>If you make multiple asynchronous calls to <strong>CreateMediaItemFromURL</strong>, they are not guaranteed to complete in the same order. Use the <em>dwUserData</em> parameter to match created media items with pending requests.</p><p>Currently, this method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedScheme"/></strong> if the URL specifies any of the following protocols: rtsp*, mms*, or mcast. If you want to use the Media Foundation network source with MFPlay, first use the Source Resolver to create the source, and then call <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.CreateMediaItemFromObject"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::CreateMediaItemFromURL']/*"/>	
        /// <msdn-id>dd374335</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::CreateMediaItemFromURL([In] const wchar_t* pwszURL,[In] BOOL fSync,[In] ULONG_PTR dwUserData,[Out, Optional] IMFPMediaItem** ppMediaItem)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::CreateMediaItemFromURL</unmanaged-short>	
        public void CreateMediaItemFromURL(string wszURLRef, SharpDX.Mathematics.Interop.RawBool fSync, System.IntPtr dwUserData, out SharpDX.MediaFoundation.PMediaItem mediaItemOut)
        {
            unsafe
            {
                IntPtr mediaItemOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* wszURLRef_ = wszURLRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint18(_nativePointer, (void*)wszURLRef_, fSync, (void*)dwUserData, &mediaItemOut_, ((void**)(*(void**)_nativePointer))[14]);
                mediaItemOut = (mediaItemOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PMediaItem(mediaItemOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Creates a media item from an object.</p>	
        /// </summary>	
        /// <param name="iUnknownObjRef">No documentation.</param>	
        /// <param name="fSync">No documentation.</param>	
        /// <param name="dwUserData">No documentation.</param>	
        /// <param name="mediaItemOut">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>Invalid request. This error can occur when <em>fSync</em> is <strong><see cref="SharpDX.Result.False"/></strong> and the application did not provide a callback interface. See Remarks.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The <em>pIUnknownObj</em> parameter must specify one of the following:</p><ul> <li>A reference to a media source. Media sources expose the <strong><see cref="SharpDX.MediaFoundation.MediaSource"/></strong> interface. It is the caller's responsibility to call <strong><see cref="SharpDX.MediaFoundation.MediaSource.Shutdown"/></strong> on the media source.</li> <li>A reference to a byte stream. Byte streams expose the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface. Internally, the method calls the <strong><see cref="SharpDX.MediaFoundation.SourceResolver.CreateObjectFromByteStream_"/></strong> method to create a media source from the byte stream. Therefore, a byte-stream handler must be registered for the byte stream. For more information about byte-stream handlers, see Scheme Handlers and Byte-Stream Handlers. </li> </ul><p>This method does not queue the media item for playback. To queue the item for playback, call <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.SetMediaItem"/></strong>.</p><p>The <strong>CreateMediaItemFromObject</strong> method can be called either synchronously or asynchronously: </p><ul> <li>If <em>fSync</em> is <strong>TRUE</strong>, the method completes synchronously. The <strong><see cref="SharpDX.MediaFoundation.PMediaItem"/></strong> reference is returned in the <em>ppMediaItem</em> parameter. </li> <li>If <em>fSync</em> is <strong><see cref="SharpDX.Result.False"/></strong>, the method completes asynchronously. When the operation completes, the application's <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback.OnMediaPlayerEvent"/></strong> callback method is invoked. The event type is <strong><see cref="SharpDX.MediaFoundation.PEventType.MediaItemCreateD"/></strong>. The event data contains the <strong><see cref="SharpDX.MediaFoundation.PMediaItem"/></strong> reference for the new media item.</li> </ul><p>The callback interface is set when you first call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.PCreateMediaPlayer"/></strong> to create the MFPlay player object. If you do not provide a callback interface, the <em>fSync</em> parameter must be <strong>TRUE</strong>. Otherwise, <strong>CreateMediaItemFromObject</strong> returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong>. </p><p>If you make multiple asynchronous calls to <strong>CreateMediaItemFromObject</strong>, they are not guaranteed to complete in the same order. Use the <em>dwUserData</em> parameter to match created media items with pending requests.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::CreateMediaItemFromObject']/*"/>	
        /// <msdn-id>dd374334</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::CreateMediaItemFromObject([In] IUnknown* pIUnknownObj,[In] BOOL fSync,[In] ULONG_PTR dwUserData,[Out, Optional] IMFPMediaItem** ppMediaItem)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::CreateMediaItemFromObject</unmanaged-short>	
        public void CreateMediaItemFromObject(SharpDX.ComObject iUnknownObjRef, SharpDX.Mathematics.Interop.RawBool fSync, System.IntPtr dwUserData, out SharpDX.MediaFoundation.PMediaItem mediaItemOut)
        {
            unsafe
            {
                IntPtr mediaItemOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint18(_nativePointer, (void*)((iUnknownObjRef == null) ? IntPtr.Zero : iUnknownObjRef.NativePointer), fSync, (void*)dwUserData, &mediaItemOut_, ((void**)(*(void**)_nativePointer))[15]);
                mediaItemOut = (mediaItemOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PMediaItem(mediaItemOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queues a media item for playback.</p>	
        /// </summary>	
        /// <param name="iMFPMediaItemRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.DrmUnsupported"/></strong></strong></dt> </dl> </td><td> <p>The media item contains protected content. MFPlay currently does not support protected content.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoAudioPlaybackDevice"/></strong></strong></dt> </dl> </td><td> <p>No audio playback device was found. This error can occur if the media source contains audio, but no audio playback devices are available on the system.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method completes asynchronously.  When the operation completes, the application's <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback.OnMediaPlayerEvent"/></strong> callback method is invoked. The event type is <strong><see cref="SharpDX.MediaFoundation.PEventType.MediaItemSet"/></strong>.</p><p>To create a media item, call <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.CreateMediaItemFromObject"/></strong> or <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.CreateMediaItemFromURL"/></strong>. A media item must be used with the same MFPlay player object that created that item. If the media item was created by a different instance of the player object, <strong>SetMediaItem</strong> returns <strong>E_INVALIDARG</strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::SetMediaItem']/*"/>	
        /// <msdn-id>dd374361</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::SetMediaItem([In] IMFPMediaItem* pIMFPMediaItem)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::SetMediaItem</unmanaged-short>	
        internal void SetMediaItem(SharpDX.MediaFoundation.PMediaItem iMFPMediaItemRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iMFPMediaItemRef == null) ? IntPtr.Zero : iMFPMediaItemRef.NativePointer), ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Clears the current media item.</p><strong>Note</strong>??This method is currently not implemented.?	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method stops playback and releases the player object's references to the current media item.</p><p>This method completes asynchronously.  When the operation completes, the application's <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback.OnMediaPlayerEvent"/></strong> callback method is invoked. The event type is <strong><see cref="SharpDX.MediaFoundation.PEventType.MediaItemCleared"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::ClearMediaItem']/*"/>	
        /// <msdn-id>dd374332</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::ClearMediaItem()</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::ClearMediaItem</unmanaged-short>	
        public void ClearMediaItem()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[17]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets a reference to the current media item.</p>	
        /// </summary>	
        /// <param name="iMFPMediaItemOut">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_FAIL</strong></strong></dt> </dl> </td><td> <p>There is no current media item.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotFound"/></strong></strong></dt> </dl> </td><td> <p>There is no current media item.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.SetMediaItem"/></strong> method is asynchronous. Therefore, while <strong>SetMediaItem</strong> is pending, <strong>GetMediaItem</strong> will not return the media item that was just set. Instead, the application should implement <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback"/></strong> interface and handle the <strong><see cref="SharpDX.MediaFoundation.PEventType.MediaItemSet"/></strong> event. For more information, see Receiving Events From the Player.</p><p>The previous remark also applies to setting the media item in the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.PCreateMediaPlayer"/></strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetMediaItem']/*"/>	
        /// <msdn-id>dd374342</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetMediaItem([Out] IMFPMediaItem** ppIMFPMediaItem)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::GetMediaItem</unmanaged-short>	
        internal void GetMediaItem(out SharpDX.MediaFoundation.PMediaItem iMFPMediaItemOut)
        {
            unsafe
            {
                IntPtr iMFPMediaItemOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &iMFPMediaItemOut_, ((void**)(*(void**)_nativePointer))[18]);
                iMFPMediaItemOut = (iMFPMediaItemOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PMediaItem(iMFPMediaItemOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current audio volume.</p>	
        /// </summary>	
        /// <param name="flVolumeRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetVolume']/*"/>	
        /// <msdn-id>dd374351</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetVolume([Out] float* pflVolume)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::GetVolume</unmanaged-short>	
        internal void GetVolume(out float flVolumeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* flVolumeRef_ = &flVolumeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, flVolumeRef_, ((void**)(*(void**)_nativePointer))[19]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Sets the audio volume.</p>	
        /// </summary>	
        /// <param name="flVolume">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.OutOfRange"/></strong></dt> </dl> </td><td> <p>The <em>flVolume</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If you call this method before playback starts, the setting is applied after playback starts.</p><p>This method does not change the master volume level for the player's audio session. Instead, it adjusts the per-channel volume levels for audio stream(s) that belong to the current media item. Other streams in the audio session are not affected. For more information, see Managing the Audio Session.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::SetVolume']/*"/>	
        /// <msdn-id>dd374366</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::SetVolume([In] float flVolume)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::SetVolume</unmanaged-short>	
        internal void SetVolume(float flVolume)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, flVolume, ((void**)(*(void**)_nativePointer))[20]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current audio balance.</p>	
        /// </summary>	
        /// <param name="flBalanceRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetBalance']/*"/>	
        /// <msdn-id>dd374338</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetBalance([Out] float* pflBalance)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::GetBalance</unmanaged-short>	
        internal void GetBalance(out float flBalanceRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* flBalanceRef_ = &flBalanceRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, flBalanceRef_, ((void**)(*(void**)_nativePointer))[21]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Sets the audio balance.</p>	
        /// </summary>	
        /// <param name="flBalance">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.OutOfRange"/></strong></strong></dt> </dl> </td><td> <p>The <em>flBalance</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If you call this method before playback starts, the setting is applied when playback starts.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::SetBalance']/*"/>	
        /// <msdn-id>dd374359</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::SetBalance([In] float flBalance)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::SetBalance</unmanaged-short>	
        internal void SetBalance(float flBalance)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, flBalance, ((void**)(*(void**)_nativePointer))[22]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries whether the audio is muted.</p>	
        /// </summary>	
        /// <param name="fMuteRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetMute']/*"/>	
        /// <msdn-id>dd374343</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetMute([Out] BOOL* pfMute)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::GetMute</unmanaged-short>	
        internal void GetMute(out SharpDX.Mathematics.Interop.RawBool fMuteRef)
        {
            unsafe
            {
                fMuteRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fMuteRef_ = &fMuteRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fMuteRef_, ((void**)(*(void**)_nativePointer))[23]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Mutes or unmutes the audio.</p>	
        /// </summary>	
        /// <param name="fMute">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If you call this method before playback starts, the setting is applied after playback starts.</p><p> This method does not mute the entire audio session to which the player belongs. It mutes only the streams from the current media item. Other streams in the audio session are not affected. For more information, see Managing the Audio Session. 	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::SetMute']/*"/>	
        /// <msdn-id>dd374362</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::SetMute([In] BOOL fMute)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::SetMute</unmanaged-short>	
        internal void SetMute(SharpDX.Mathematics.Interop.RawBool fMute)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint6(_nativePointer, fMute, ((void**)(*(void**)_nativePointer))[24]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the size and aspect ratio of the video. These values are computed before any scaling is done to fit the video into the destination window.</p>	
        /// </summary>	
        /// <param name="szVideoRef">No documentation.</param>	
        /// <param name="szARVideoRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>At least one parameter must be non-<strong><c>null</c></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetNativeVideoSize']/*"/>	
        /// <msdn-id>dd374344</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetNativeVideoSize([Out, Optional] SIZE* pszVideo,[Out, Optional] SIZE* pszARVideo)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::GetNativeVideoSize</unmanaged-short>	
        public void GetNativeVideoSize(out SharpDX.Size2 szVideoRef, out SharpDX.Size2 szARVideoRef)
        {
            unsafe
            {
                szVideoRef = new SharpDX.Size2();
                szARVideoRef = new SharpDX.Size2();
                SharpDX.Result __result__;
                fixed (void* szVideoRef_ = &szVideoRef)
                fixed (void* szARVideoRef_ = &szARVideoRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, szVideoRef_, szARVideoRef_, ((void**)(*(void**)_nativePointer))[25]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the range of video sizes that can be displayed without significantly degrading performance or image quality.</p>	
        /// </summary>	
        /// <param name="szMinRef">No documentation.</param>	
        /// <param name="szMaxRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>At least one parameter must be non-<strong><c>null</c></strong>. Sizes are given in pixels.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetIdealVideoSize']/*"/>	
        /// <msdn-id>dd374341</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetIdealVideoSize([Out, Optional] SIZE* pszMin,[Out, Optional] SIZE* pszMax)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::GetIdealVideoSize</unmanaged-short>	
        public void GetIdealVideoSize(out SharpDX.Size2 szMinRef, out SharpDX.Size2 szMaxRef)
        {
            unsafe
            {
                szMinRef = new SharpDX.Size2();
                szMaxRef = new SharpDX.Size2();
                SharpDX.Result __result__;
                fixed (void* szMinRef_ = &szMinRef)
                fixed (void* szMaxRef_ = &szMaxRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, szMinRef_, szMaxRef_, ((void**)(*(void**)_nativePointer))[26]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Sets the video source rectangle.</p><p>MFPlay clips the video to this rectangle and stretches the rectangle to fill the video window.</p>	
        /// </summary>	
        /// <param name="nrcSourceRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>MFPlay stretches the source rectangle to fill the entire video window. By default, MFPlay maintains the source's correct aspect ratio, letterboxing if needed. The letterbox color is controlled by the <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.SetBorderColor"/></strong> method.</p><p>This method fails if no media item is currently set, or if the current media item does not contain video.</p><p> To set the video position before playback starts, call this method inside your event handler for the <strong><see cref="SharpDX.MediaFoundation.PEventType.MediaItemSet"/></strong> event. For more information, see <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback.OnMediaPlayerEvent"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::SetVideoSourceRect']/*"/>	
        /// <msdn-id>dd743247</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::SetVideoSourceRect([In] const MFVideoNormalizedRect* pnrcSource)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::SetVideoSourceRect</unmanaged-short>	
        internal void SetVideoSourceRect(SharpDX.MediaFoundation.VideoNormalizedRect nrcSourceRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &nrcSourceRef, ((void**)(*(void**)_nativePointer))[27]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the video source rectangle.</p>	
        /// </summary>	
        /// <param name="nrcSourceRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetVideoSourceRect']/*"/>	
        /// <msdn-id>dd743246</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetVideoSourceRect([Out] MFVideoNormalizedRect* pnrcSource)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::GetVideoSourceRect</unmanaged-short>	
        internal void GetVideoSourceRect(out SharpDX.MediaFoundation.VideoNormalizedRect nrcSourceRef)
        {
            unsafe
            {
                nrcSourceRef = new SharpDX.MediaFoundation.VideoNormalizedRect();
                SharpDX.Result __result__;
                fixed (void* nrcSourceRef_ = &nrcSourceRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, nrcSourceRef_, ((void**)(*(void**)_nativePointer))[28]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Specifies whether the aspect ratio of the video is preserved during playback.</p>	
        /// </summary>	
        /// <param name="dwAspectRatioMode">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method fails if no media item is currently set, or if the current media item does not contain video.</p><p>To set the aspect-ratio mode before playback starts, call this method inside your event handler for the <strong><see cref="SharpDX.MediaFoundation.PEventType.MediaItemSet"/></strong> event. For more information, see <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback.OnMediaPlayerEvent"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::SetAspectRatioMode']/*"/>	
        /// <msdn-id>dd374358</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::SetAspectRatioMode([In] unsigned int dwAspectRatioMode)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::SetAspectRatioMode</unmanaged-short>	
        internal void SetAspectRatioMode(int dwAspectRatioMode)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwAspectRatioMode, ((void**)(*(void**)_nativePointer))[29]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current aspect-ratio correction mode. This mode controls whether the aspect ratio of the video is preserved during playback.</p>	
        /// </summary>	
        /// <param name="dwAspectRatioModeRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetAspectRatioMode']/*"/>	
        /// <msdn-id>dd374337</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetAspectRatioMode([Out] unsigned int* pdwAspectRatioMode)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::GetAspectRatioMode</unmanaged-short>	
        internal void GetAspectRatioMode(out int dwAspectRatioModeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwAspectRatioModeRef_ = &dwAspectRatioModeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwAspectRatioModeRef_, ((void**)(*(void**)_nativePointer))[30]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the window where the video is displayed.</p>	
        /// </summary>	
        /// <param name="hwndVideoRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The video window is specified when you first call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.PCreateMediaPlayer"/></strong> to create the MFPlay player object.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetVideoWindow']/*"/>	
        /// <msdn-id>dd374350</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetVideoWindow([Out] HWND* phwndVideo)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::GetVideoWindow</unmanaged-short>	
        internal void GetVideoWindow(out System.IntPtr hwndVideoRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* hwndVideoRef_ = &hwndVideoRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, hwndVideoRef_, ((void**)(*(void**)_nativePointer))[31]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Updates the video frame.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method when your application's video playback window receives either a <strong>WM_PAINT</strong> or <strong>WM_SIZE</strong> message. This method performs two functions: </p><ul> <li>Ensures that the video frame is repainted while playback is paused or stopped.  </li> <li>Adjusts the displayed video to match the current size of the video window.</li> </ul><strong>Important</strong>??Call the GDI <strong>BeginPaint</strong> function before calling  <strong>UpdateVideo</strong>.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::UpdateVideo']/*"/>	
        /// <msdn-id>dd743248</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::UpdateVideo()</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::UpdateVideo</unmanaged-short>	
        public void UpdateVideo()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[32]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Sets the color for the video border. The border color is used to letterbox the video.</p>	
        /// </summary>	
        /// <param name="clr">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong>M<strong>F_E_SHUTDOWN</strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method fails if no media item is currently set, or if the current media item does not contain video.</p><p>To set the border color before playback starts, call this method inside your event handler for the <strong><see cref="SharpDX.MediaFoundation.PEventType.MediaItemSet"/></strong> event. For more information, see <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback.OnMediaPlayerEvent"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::SetBorderColor']/*"/>	
        /// <msdn-id>dd374360</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::SetBorderColor([In] COLORREF Clr)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::SetBorderColor</unmanaged-short>	
        internal void SetBorderColor(int clr)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, clr, ((void**)(*(void**)_nativePointer))[33]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current color of the video border. The border color is used to letterbox the video.</p>	
        /// </summary>	
        /// <param name="clrRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::GetBorderColor']/*"/>	
        /// <msdn-id>dd374339</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::GetBorderColor([Out] COLORREF* pClr)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::GetBorderColor</unmanaged-short>	
        internal void GetBorderColor(out int clrRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* clrRef_ = &clrRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, clrRef_, ((void**)(*(void**)_nativePointer))[34]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Applies an audio or video effect to playback.</p>	
        /// </summary>	
        /// <param name="effectRef">No documentation.</param>	
        /// <param name="fOptional">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidIndex"/></strong></strong></dt> </dl> </td><td> <p>This effect was already added.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The object specified in the <em>pEffect</em> parameter can implement either a video effect or an audio effect. The effect is applied to any media items set after the method is called. It is not applied to the current media item. </p><p>For each media item, the effect is applied to the first selected stream of the matching type (audio or video). If a media item has two selected streams of the same type, the second stream does not receive the effect. The effect is ignored if the media item does not contain a stream that matches the effect type. For example, if you set a video effect and play a file that contains just audio, the video effect is ignored, although no error is raised.</p><p>The effect is applied to all subsequent media items, until the application removes the effect. To remove an effect, call <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.RemoveEffect"/></strong> or <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.RemoveAllEffects"/></strong>.</p><p>If you set multiple effects of the same type (audio or video), they are applied in the same order in which you call <strong>InsertEffect</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::InsertEffect']/*"/>	
        /// <msdn-id>dd374352</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::InsertEffect([In] IUnknown* pEffect,[In] BOOL fOptional)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::InsertEffect</unmanaged-short>	
        public void InsertEffect(SharpDX.ComObject effectRef, SharpDX.Mathematics.Interop.RawBool fOptional)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint15(_nativePointer, (void*)((effectRef == null) ? IntPtr.Zero : effectRef.NativePointer), fOptional, ((void**)(*(void**)_nativePointer))[35]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Removes an effect that was added with the <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.InsertEffect"/></strong> method.</p>	
        /// </summary>	
        /// <param name="effectRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotFound"/></strong></dt> </dl> </td><td> <p>The effect was not found.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The change applies to the next media item that is set on the player. The effect is not removed from the current media item.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::RemoveEffect']/*"/>	
        /// <msdn-id>dd374356</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::RemoveEffect([In] IUnknown* pEffect)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::RemoveEffect</unmanaged-short>	
        public void RemoveEffect(SharpDX.ComObject effectRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((effectRef == null) ? IntPtr.Zero : effectRef.NativePointer), ((void**)(*(void**)_nativePointer))[36]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Removes all effects that were added with the <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer.InsertEffect"/></strong> method.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The change applies to the next media item that is set on the player. The effects are not removed from the current media item.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::RemoveAllEffects']/*"/>	
        /// <msdn-id>dd374355</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::RemoveAllEffects()</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::RemoveAllEffects</unmanaged-short>	
        public void RemoveAllEffects()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[37]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Shuts down the MFPlay player object and releases any resources the object is using.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>After this method is called, most <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer"/></strong> methods return <strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong>. Also, any media items created from this instance of the player object are invalidated and most <strong><see cref="SharpDX.MediaFoundation.PMediaItem"/></strong> methods also return <strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong>.</p><p>The player object automatically shuts itself down when its reference count reaches zero. You can use the <strong>Shutdown</strong> method to shut down the player before all of the references have been released.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayer::Shutdown']/*"/>	
        /// <msdn-id>dd374367</msdn-id>	
        /// <unmanaged>HRESULT IMFPMediaPlayer::Shutdown()</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayer::Shutdown</unmanaged-short>	
        public void Shutdown()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[38]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Callback interface for the <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer"/></strong> interface.</p><p>To set the callback, pass an <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback"/></strong> reference to the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.PCreateMediaPlayer"/></strong> function in the  <em>pCallback</em> parameter. The application implements the <strong><see cref="SharpDX.MediaFoundation.PMediaPlayerCallback"/></strong> interface.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayerCallback']/*"/>	
    /// <msdn-id>dd374330</msdn-id>	
    /// <unmanaged>IMFPMediaPlayerCallback</unmanaged>	
    /// <unmanaged-short>IMFPMediaPlayerCallback</unmanaged-short>	
    [Guid("766C8FFB-5FDB-4fea-A28D-B912996F51BD")]
    public partial class PMediaPlayerCallback : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.PMediaPlayerCallback"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PMediaPlayerCallback(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.PMediaPlayerCallback"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.PMediaPlayerCallback(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.PMediaPlayerCallback(nativePointer);
        }


        /// <summary>	
        /// <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Called by the MFPlay player object to notify the application of a playback event.</p>	
        /// </summary>	
        /// <param name="eventHeaderRef">No documentation.</param>	
        /// <remarks>	
        /// <p> The specific type of playback event is given in the <strong>eEventType</strong> member of the <strong><see cref="SharpDX.MediaFoundation.PEventHeader"/></strong> structure. This structure contains information that is common to all of the event types. Some event types use extended structures. A set of macros is defined for casting the <em>pEventHeader</em> reference to the correct structure type. For more information, see <strong><see cref="SharpDX.MediaFoundation.PEventType"/></strong>. </p><p>It is safe to call <strong><see cref="SharpDX.MediaFoundation.PMediaPlayer"/></strong> and <strong><see cref="SharpDX.MediaFoundation.PMediaItem"/></strong> methods inside the <strong>OnMediaPlayer</strong> method. MFPlay is guaranteed not to reenter the <strong>OnMediaPlayer</strong> method. That is, calls to <strong>OnMediaPlayer</strong> are serialized, and the method will not be invoked again from inside <strong>OnMediaPlayer</strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMediaPlayerCallback::OnMediaPlayerEvent']/*"/>	
        /// <msdn-id>dd374331</msdn-id>	
        /// <unmanaged>void IMFPMediaPlayerCallback::OnMediaPlayerEvent([In] MFP_EVENT_HEADER* pEventHeader)</unmanaged>	
        /// <unmanaged-short>IMFPMediaPlayerCallback::OnMediaPlayerEvent</unmanaged-short>	
        public void OnMediaPlayerEvent(ref SharpDX.MediaFoundation.PEventHeader eventHeaderRef)
        {
            unsafe
            {
                fixed (void* eventHeaderRef_ = &eventHeaderRef)
                    SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, eventHeaderRef_, ((void**)(*(void**)_nativePointer))[3]);
            }
        }
    }
    /// <summary>	
    /// <p> Enables a media source to receive a reference to the <strong><see cref="SharpDX.MediaFoundation.PMPHost"/></strong> interface. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If a media source exposes this interface, the Protected Media Path (PMP) Media Session calls <strong>SetPMPHost</strong> with a reference to the <strong><see cref="SharpDX.MediaFoundation.PMPHost"/></strong> interface. The media source can use the <strong><see cref="SharpDX.MediaFoundation.PMPHost"/></strong> interface to create objects in the PMP process.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPClient']/*"/>	
    /// <msdn-id>ms702104</msdn-id>	
    /// <unmanaged>IMFPMPClient</unmanaged>	
    /// <unmanaged-short>IMFPMPClient</unmanaged-short>	
    [Guid("6C4E655D-EAD8-4421-B6B9-54DCDBBDF820")]
    public partial class PMPClient : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.PMPClient"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PMPClient(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.PMPClient"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.PMPClient(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.PMPClient(nativePointer);
        }


        /// <summary>	
        /// <p> Provides a reference to the <strong><see cref="SharpDX.MediaFoundation.PMPHost"/></strong> interface. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.MediaFoundation.PMPHost"/></strong> reference is apartment threaded. The media source must add the reference to the global interface table (GIT) before using it.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPClient::SetPMPHost']/*"/>	
        /// <msdn-id>ms703915</msdn-id>	
        /// <unmanaged>SetPMPHost</unmanaged>	
        /// <unmanaged-short>SetPMPHost</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMPClient::SetPMPHost([In] IMFPMPHost* pPMPHost)</unmanaged>
        public SharpDX.MediaFoundation.PMPHost PMPHost
        {
            set { SetPMPHost(value); }
        }

        /// <summary>	
        /// <p> Provides a reference to the <strong><see cref="SharpDX.MediaFoundation.PMPHost"/></strong> interface. </p>	
        /// </summary>	
        /// <param name="pMPHostRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.MediaFoundation.PMPHost"/></strong> reference is apartment threaded. The media source must add the reference to the global interface table (GIT) before using it.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPClient::SetPMPHost']/*"/>	
        /// <msdn-id>ms703915</msdn-id>	
        /// <unmanaged>HRESULT IMFPMPClient::SetPMPHost([In] IMFPMPHost* pPMPHost)</unmanaged>	
        /// <unmanaged-short>IMFPMPClient::SetPMPHost</unmanaged-short>	
        internal void SetPMPHost(SharpDX.MediaFoundation.PMPHost pMPHostRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((pMPHostRef == null) ? IntPtr.Zero : pMPHostRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides a mechanism for a media source to implement content protection functionality in a Windows Store apps.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><strong>When to implement:</strong> A media source implements <strong><see cref="SharpDX.MediaFoundation.PMPClientApp"/></strong> in order to implement content protection functionality for Windows Store apps. </p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPClientApp']/*"/>	
    /// <msdn-id>jj128316</msdn-id>	
    /// <unmanaged>IMFPMPClientApp</unmanaged>	
    /// <unmanaged-short>IMFPMPClientApp</unmanaged-short>	
    [Guid("c004f646-be2c-48f3-93a2-a0983eba1108")]
    public partial class PMPClientApp : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.PMPClientApp"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PMPClientApp(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.PMPClientApp"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.PMPClientApp(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.PMPClientApp(nativePointer);
        }


        /// <summary>	
        /// <p>Sets a reference to the <strong><see cref="SharpDX.MediaFoundation.PMPHostApp"/></strong> interface allowing a media source to create objects in the PMP process.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPClientApp::SetPMPHost']/*"/>	
        /// <msdn-id>jj128317</msdn-id>	
        /// <unmanaged>SetPMPHost</unmanaged>	
        /// <unmanaged-short>SetPMPHost</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPMPClientApp::SetPMPHost([In] IMFPMPHostApp* pPMPHost)</unmanaged>
        public SharpDX.MediaFoundation.PMPHostApp PMPHost
        {
            set { SetPMPHost(value); }
        }

        /// <summary>	
        /// <p>Sets a reference to the <strong><see cref="SharpDX.MediaFoundation.PMPHostApp"/></strong> interface allowing a media source to create objects in the PMP process.</p>	
        /// </summary>	
        /// <param name="pMPHostRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPClientApp::SetPMPHost']/*"/>	
        /// <msdn-id>jj128317</msdn-id>	
        /// <unmanaged>HRESULT IMFPMPClientApp::SetPMPHost([In] IMFPMPHostApp* pPMPHost)</unmanaged>	
        /// <unmanaged-short>IMFPMPClientApp::SetPMPHost</unmanaged-short>	
        internal void SetPMPHost(SharpDX.MediaFoundation.PMPHostApp pMPHostRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((pMPHostRef == null) ? IntPtr.Zero : pMPHostRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables a media source in the application process to create objects in the protected media path (PMP) process.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is used when a media source resides in the application process but the Media Session resides in a PMP process. The media source can use this interface to create objects in the PMP process. For example, to play DRM-protected content, the media source typically must create an input trust authority (ITA) in the PMP process. </p><p>To use this interface, the media source implements the <strong><see cref="SharpDX.MediaFoundation.PMPClient"/></strong> interface. The PMP Media Session calls <strong><see cref="SharpDX.MediaFoundation.PMPClient.SetPMPHost"/></strong> on the media source, passing in a reference to the <strong><see cref="SharpDX.MediaFoundation.PMPHost"/></strong> interface.</p><p>You can also get a reference to this interface by calling <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> on the PMP Media Session, using the service identifier <strong>MF_PMP_SERVICE</strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPHost']/*"/>	
    /// <msdn-id>ms705635</msdn-id>	
    /// <unmanaged>IMFPMPHost</unmanaged>	
    /// <unmanaged-short>IMFPMPHost</unmanaged-short>	
    [Guid("F70CA1A9-FDC7-4782-B994-ADFFB1C98606")]
    public partial class PMPHost : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.PMPHost"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PMPHost(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.PMPHost"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.PMPHost(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.PMPHost(nativePointer);
        }


        /// <summary>	
        /// <p> Blocks the protected media path (PMP) process from ending. </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>When this method is called, it increments the lock count on the PMP process. For every call to this method, the application should make a corresponding call to <strong><see cref="SharpDX.MediaFoundation.PMPHost.UnlockProcess"/></strong>, which decrements the lock count. When the PMP process is ready to exit, it waits for about 3 seconds, or until the lock count reaches zero, before exiting.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPHost::LockProcess']/*"/>	
        /// <msdn-id>ms697003</msdn-id>	
        /// <unmanaged>HRESULT IMFPMPHost::LockProcess()</unmanaged>	
        /// <unmanaged-short>IMFPMPHost::LockProcess</unmanaged-short>	
        public void LockProcess()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Decrements the lock count on the protected media path (PMP) process. Call this method once for each call to <strong><see cref="SharpDX.MediaFoundation.PMPHost.LockProcess"/></strong>. </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPHost::UnlockProcess']/*"/>	
        /// <msdn-id>ms698984</msdn-id>	
        /// <unmanaged>HRESULT IMFPMPHost::UnlockProcess()</unmanaged>	
        /// <unmanaged-short>IMFPMPHost::UnlockProcess</unmanaged-short>	
        public void UnlockProcess()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates an object in the protect media path (PMP) process, from a CLSID. </p>	
        /// </summary>	
        /// <param name="clsid"><dd> <p> The CLSID of the object to create. </p> </dd></param>	
        /// <param name="streamRef"><dd> <p>A reference to the <strong><see cref="SharpDX.Win32.IStream"/></strong> interface. This parameter can be <strong><c>null</c></strong>. If this parameter is not <strong><c>null</c></strong>, the PMP host queries the created object for the <strong>IPersistStream</strong> interface and calls <strong>IPersistStream::Load</strong>, passing in the <em>pStream</em> reference. </p> </dd></param>	
        /// <param name="riid"><dd> <p> The interface identifier (IID) of the interface to retrieve. </p> </dd></param>	
        /// <param name="vOut"><dd> <p> Receives a reference to the requested interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> You can use the <em>pStream</em> parameter to initialize the object after it is created. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPHost::CreateObjectByCLSID']/*"/>	
        /// <msdn-id>ms698995</msdn-id>	
        /// <unmanaged>HRESULT IMFPMPHost::CreateObjectByCLSID([In] const GUID&amp; clsid,[In] IStream* pStream,[In] const GUID&amp; riid,[In] void** ppv)</unmanaged>	
        /// <unmanaged-short>IMFPMPHost::CreateObjectByCLSID</unmanaged-short>	
        internal void CreateObjectByCLSID_(System.Guid clsid, System.IntPtr streamRef, System.Guid riid, System.IntPtr vOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &clsid, (void*)streamRef, &riid, (void*)vOut, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Allows a media source to create a Windows Runtime object in the Protected Media Path (PMP) process. </p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPHostApp']/*"/>	
    /// <msdn-id>jj128318</msdn-id>	
    /// <unmanaged>IMFPMPHostApp</unmanaged>	
    /// <unmanaged-short>IMFPMPHostApp</unmanaged-short>	
    [Guid("84d2054a-3aa1-4728-a3b0-440a418cf49c")]
    public partial class PMPHostApp : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.PMPHostApp"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PMPHostApp(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.PMPHostApp"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.PMPHostApp(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.PMPHostApp(nativePointer);
        }


        /// <summary>	
        /// <p> Blocks the protected media path (PMP) process from ending. </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>When this method is called, it increments the lock count on the PMP process. For every call to this method, the application should make a corresponding call to <strong><see cref="SharpDX.MediaFoundation.PMPHostApp.UnlockProcess"/></strong>, which decrements the lock count. When the PMP process is ready to exit, it waits for about 3 seconds, or until the lock count reaches zero, before exiting.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPHostApp::LockProcess']/*"/>	
        /// <msdn-id>jj128320</msdn-id>	
        /// <unmanaged>HRESULT IMFPMPHostApp::LockProcess()</unmanaged>	
        /// <unmanaged-short>IMFPMPHostApp::LockProcess</unmanaged-short>	
        public void LockProcess()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Decrements the lock count on the protected media path (PMP) process. Call this method once for each call to <strong><see cref="SharpDX.MediaFoundation.PMPHostApp.LockProcess"/></strong>. </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPHostApp::UnlockProcess']/*"/>	
        /// <msdn-id>jj128321</msdn-id>	
        /// <unmanaged>HRESULT IMFPMPHostApp::UnlockProcess()</unmanaged>	
        /// <unmanaged-short>IMFPMPHostApp::UnlockProcess</unmanaged-short>	
        public void UnlockProcess()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates a Windows Runtime object in the protected media path (PMP) process. </p>	
        /// </summary>	
        /// <param name="id"><dd> <p>Id of object to create.</p> </dd></param>	
        /// <param name="streamRef"><dd> <p>Data to be passed to the object by way of a <strong>IPersistStream</strong>.</p> </dd></param>	
        /// <param name="riid"><dd> <p> The interface identifier (IID) of the interface to retrieve. </p> </dd></param>	
        /// <param name="vOut"><dd> <p> Receives a reference to the created object. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPHostApp::ActivateClassById']/*"/>	
        /// <msdn-id>jj128319</msdn-id>	
        /// <unmanaged>HRESULT IMFPMPHostApp::ActivateClassById([In] const wchar_t* id,[In, Optional] IStream* pStream,[In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>	
        /// <unmanaged-short>IMFPMPHostApp::ActivateClassById</unmanaged-short>	
        internal void ActivateClassById_(string id, System.IntPtr streamRef, System.Guid riid, out System.IntPtr vOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* id_ = id)
                fixed (void* vOut_ = &vOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)id_, (void*)streamRef, &riid, vOut_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Enables two instances of the Media Session to share the same protected media path (PMP) process. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If your application creates more than one instance of the Media Session, you can use this interface to share the same PMP process among several instances. This can be more efficient than re-creating the PMP process each time.</p><p>Use this interface as follows:</p><ol> <li> Create the first instance of the PMP Media Session by calling <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreatePMPMediaSession"/></strong>. </li> <li> Retrieve an <strong><see cref="SharpDX.MediaFoundation.PMPServer"/></strong> reference from the first Media Session by calling <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> with the service identifier <strong><see cref="SharpDX.MediaFoundation.MediaServiceKeys.PMPServer"/></strong>. </li> <li> Create the second instance of the PMP Media Session. Set the <see cref="SharpDX.MediaFoundation.MediaSessionAttributeKeys.ServerContext"/> attribute on the <em>pConfiguration</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreatePMPMediaSession"/></strong> function. The attribute value is the <strong><see cref="SharpDX.MediaFoundation.PMPServer"/></strong> reference retrieved in step 2. </li> </ol>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPServer']/*"/>	
    /// <msdn-id>ms702977</msdn-id>	
    /// <unmanaged>IMFPMPServer</unmanaged>	
    /// <unmanaged-short>IMFPMPServer</unmanaged-short>	
    [Guid("994e23af-1cc2-493c-b9fa-46f1cb040fa4")]
    public partial class PMPServer : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.PMPServer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PMPServer(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.PMPServer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.PMPServer(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.PMPServer(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Blocks the protected media path (PMP) process from ending.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When this method is called, it increments the lock count on the PMP process. For every call to this method, the application should make a corresponding call to <see cref="SharpDX.MediaFoundation.PMPServer.UnlockProcess"/>, which decrements the lock count. When the PMP process is ready to exit, it waits for about 3 seconds, or until the lock count reaches zero, before exiting.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPServer::LockProcess']/*"/>	
        /// <msdn-id>ms701590</msdn-id>	
        /// <unmanaged>HRESULT IMFPMPServer::LockProcess()</unmanaged>	
        /// <unmanaged-short>IMFPMPServer::LockProcess</unmanaged-short>	
        public void LockProcess()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Decrements the lock count on the protected media path (PMP) process. Call this method once for each call to <see cref="SharpDX.MediaFoundation.PMPServer.LockProcess"/>.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPServer::UnlockProcess']/*"/>	
        /// <msdn-id>ms696204</msdn-id>	
        /// <unmanaged>HRESULT IMFPMPServer::UnlockProcess()</unmanaged>	
        /// <unmanaged-short>IMFPMPServer::UnlockProcess</unmanaged-short>	
        public void UnlockProcess()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Creates an object in the protected media path (PMP) process.</p>	
        /// </summary>	
        /// <param name="clsid"><dd> <p>CLSID of the object to create.</p> </dd></param>	
        /// <param name="riid"><dd> <p>Interface identifier of the interface to retrieve.</p> </dd></param>	
        /// <param name="objectOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPMPServer::CreateObjectByCLSID']/*"/>	
        /// <msdn-id>ms704806</msdn-id>	
        /// <unmanaged>HRESULT IMFPMPServer::CreateObjectByCLSID([In] const GUID&amp; clsid,[In] const GUID&amp; riid,[Out] void** ppObject)</unmanaged>	
        /// <unmanaged-short>IMFPMPServer::CreateObjectByCLSID</unmanaged-short>	
        public void CreateObjectByCLSID(System.Guid clsid, System.Guid riid, out System.IntPtr objectOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* objectOut_ = &objectOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &clsid, &riid, objectOut_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a presentation clock, which is used to schedule when samples are rendered and to synchronize multiple streams.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To create a new instance of the presentation clock, call the <see cref="SharpDX.MediaFoundation.MediaFactory.CreatePresentationClock"/> function. The presentation clock must have a time source, which is an object that provides the clock times. For example, the audio renderer is a time source that uses the sound card to drive the clock. Time sources expose the <see cref="SharpDX.MediaFoundation.PresentationTimeSource"/> interface. To set the time source, call <strong>SetTimeSource</strong>. The presentation clock does not begin running until the <strong>Start</strong> method is called.</p><p>To get the presentation clock from the Media Session, call <see cref="SharpDX.MediaFoundation.MediaSession.GetClock"/>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationClock']/*"/>	
    /// <msdn-id>ms701581</msdn-id>	
    /// <unmanaged>IMFPresentationClock</unmanaged>	
    /// <unmanaged-short>IMFPresentationClock</unmanaged-short>	
    [Guid("868CE85C-8EA9-4f55-AB82-B009A910A805")]
    public partial class PresentationClock : SharpDX.MediaFoundation.Clock
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.PresentationClock"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PresentationClock(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.PresentationClock"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.PresentationClock(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.PresentationClock(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the clock's presentation time source.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationClock::GetTimeSource']/*"/>	
        /// <msdn-id>ms704730</msdn-id>	
        /// <unmanaged>GetTimeSource / SetTimeSource</unmanaged>	
        /// <unmanaged-short>GetTimeSource</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPresentationClock::GetTimeSource([Out] IMFPresentationTimeSource** ppTimeSource)</unmanaged>
        public SharpDX.MediaFoundation.PresentationTimeSource TimeSource
        {
            get { SharpDX.MediaFoundation.PresentationTimeSource __output__; GetTimeSource(out __output__); return __output__; }
            set { SetTimeSource(value); }
        }

        /// <summary>	
        /// <p> Retrieves the latest clock time. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method does not attempt to smooth out jitter or otherwise account for any inaccuracies in the clock time.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationClock::GetTime']/*"/>	
        /// <msdn-id>ms696209</msdn-id>	
        /// <unmanaged>GetTime</unmanaged>	
        /// <unmanaged-short>GetTime</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPresentationClock::GetTime([Out] longlong* phnsClockTime)</unmanaged>
        public long Time
        {
            get { long __output__; GetTime(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Sets the time source for the presentation clock. The time source is the object that drives the clock by providing the current time.</p>	
        /// </summary>	
        /// <param name="timeSourceRef"><dd> <p>Pointer to the <see cref="SharpDX.MediaFoundation.PresentationTimeSource"/> interface of the time source.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ClockNotSimple"/></strong></dt> </dl> </td><td> <p>The time source does not have a frequency of 10 MHz.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotInitializeD"/></strong></dt> </dl> </td><td> <p>The time source has not been initialized.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The presentation clock cannot start until it has a time source.</p><p>The time source is automatically registered to receive state change notifications from the clock, through the time source's <see cref="SharpDX.MediaFoundation.ClockStateSink"/> interface, which all time sources must implement.</p><p>This time source have a frequency of 10 MHz. See <see cref="SharpDX.MediaFoundation.Clock.GetClockCharacteristics"/>. If not, the method returns <see cref="SharpDX.MediaFoundation.ResultCode.ClockNotSimple"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationClock::SetTimeSource']/*"/>	
        /// <msdn-id>ms694835</msdn-id>	
        /// <unmanaged>HRESULT IMFPresentationClock::SetTimeSource([In, Optional] IMFPresentationTimeSource* pTimeSource)</unmanaged>	
        /// <unmanaged-short>IMFPresentationClock::SetTimeSource</unmanaged-short>	
        internal void SetTimeSource(SharpDX.MediaFoundation.PresentationTimeSource timeSourceRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((timeSourceRef == null) ? IntPtr.Zero : timeSourceRef.NativePointer), ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the clock's presentation time source.</p>	
        /// </summary>	
        /// <param name="timeSourceOut"><dd> <p>Receives a reference to the time source's <see cref="SharpDX.MediaFoundation.PresentationTimeSource"/> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ClockNoTimeSource"/></strong></dt> </dl> </td><td> <p>No time source was set on this clock.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationClock::GetTimeSource']/*"/>	
        /// <msdn-id>ms704730</msdn-id>	
        /// <unmanaged>HRESULT IMFPresentationClock::GetTimeSource([Out] IMFPresentationTimeSource** ppTimeSource)</unmanaged>	
        /// <unmanaged-short>IMFPresentationClock::GetTimeSource</unmanaged-short>	
        internal void GetTimeSource(out SharpDX.MediaFoundation.PresentationTimeSource timeSourceOut)
        {
            unsafe
            {
                IntPtr timeSourceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &timeSourceOut_, ((void**)(*(void**)_nativePointer))[9]);
                timeSourceOut = (timeSourceOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PresentationTimeSource(timeSourceOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Retrieves the latest clock time. </p>	
        /// </summary>	
        /// <param name="hnsClockTimeRef"><dd> <p> Receives the latest clock time, in 100-nanosecond units. The time is relative to when the clock was last started. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ClockNoTimeSource"/></strong></dt> </dl> </td><td> <p> The clock does not have a presentation time source. Call <strong><see cref="SharpDX.MediaFoundation.PresentationClock.SetTimeSource"/></strong>. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method does not attempt to smooth out jitter or otherwise account for any inaccuracies in the clock time.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationClock::GetTime']/*"/>	
        /// <msdn-id>ms696209</msdn-id>	
        /// <unmanaged>HRESULT IMFPresentationClock::GetTime([Out] longlong* phnsClockTime)</unmanaged>	
        /// <unmanaged-short>IMFPresentationClock::GetTime</unmanaged-short>	
        internal void GetTime(out long hnsClockTimeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* hnsClockTimeRef_ = &hnsClockTimeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, hnsClockTimeRef_, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Registers an object to be notified whenever the clock starts, stops, or pauses, or changes rate.</p>	
        /// </summary>	
        /// <param name="stateSinkRef"><dd> <p>Pointer to the object's <see cref="SharpDX.MediaFoundation.ClockStateSink"/> interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Before releasing the object, call <see cref="SharpDX.MediaFoundation.PresentationClock.RemoveClockStateSink_"/> to unregister the object for state-change notifications.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationClock::AddClockStateSink']/*"/>	
        /// <msdn-id>ms703129</msdn-id>	
        /// <unmanaged>HRESULT IMFPresentationClock::AddClockStateSink([In, Optional] IMFClockStateSink* pStateSink)</unmanaged>	
        /// <unmanaged-short>IMFPresentationClock::AddClockStateSink</unmanaged-short>	
        internal void AddClockStateSink_(System.IntPtr stateSinkRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)stateSinkRef, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Unregisters an object that is receiving state-change notifications from the clock.</p>	
        /// </summary>	
        /// <param name="stateSinkRef"><dd> <p>Pointer to the object's <see cref="SharpDX.MediaFoundation.ClockStateSink"/> interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationClock::RemoveClockStateSink']/*"/>	
        /// <msdn-id>ms703032</msdn-id>	
        /// <unmanaged>HRESULT IMFPresentationClock::RemoveClockStateSink([In, Optional] IMFClockStateSink* pStateSink)</unmanaged>	
        /// <unmanaged-short>IMFPresentationClock::RemoveClockStateSink</unmanaged-short>	
        internal void RemoveClockStateSink_(System.IntPtr stateSinkRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)stateSinkRef, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Starts the presentation clock.</p>	
        /// </summary>	
        /// <param name="llClockStartOffset"><dd> <p>Initial starting time, in 100-nanosecond units. At the time the <strong>Start</strong> method is called, the clock's <see cref="SharpDX.MediaFoundation.PresentationClock.GetTime"/> method returns this value, and the clock time increments from there. If the value is PRESENTATION_CURRENT_POSITION, the clock starts from its current position. Use this value if the clock is paused and you want to restart it from the same position.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ClockNoTimeSource"/></strong></dt> </dl> </td><td> <p>No time source was set on this clock.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is valid in all states (stopped, paused, or running).</p><p>If the clock is paused and restarted from the same position (<em>llClockStartOffset</em> is PRESENTATION_CURRENT_POSITION), the presentation clock sends an <see cref="SharpDX.MediaFoundation.ClockStateSink.OnClockRestart"/> notification. Otherwise, the clock sends an <see cref="SharpDX.MediaFoundation.ClockStateSink.OnClockStart"/> notification.</p><p>The presentation clock initiates the state change by calling <strong>OnClockStart</strong> or <strong>OnClockRestart</strong> on the clock's time source. This call is made synchronously. If it fails, the state change does not occur. If the call succeeds, the state changes, and the clock notifies the other state-change subscribers by calling their <strong>OnClockStart</strong> or <strong>OnClockRestart</strong> methods. These calls are made asynchronously.</p><p>If the clock is already running, calling <strong>Start</strong> again has the effect of seeking the clock to the new <em>StartOffset</em> position.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationClock::Start']/*"/>	
        /// <msdn-id>ms702290</msdn-id>	
        /// <unmanaged>HRESULT IMFPresentationClock::Start([In] longlong llClockStartOffset)</unmanaged>	
        /// <unmanaged-short>IMFPresentationClock::Start</unmanaged-short>	
        public void Start(long llClockStartOffset)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, llClockStartOffset, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Stops the presentation clock. While the clock is stopped, the clock time does not advance, and the clock's <see cref="SharpDX.MediaFoundation.PresentationClock.GetTime"/> method returns zero.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ClockNoTimeSource"/></strong></dt> </dl> </td><td> <p>No time source was set on this clock.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ClockStateAlreadySet"/></strong></dt> </dl> </td><td> <p>The clock is already stopped.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is valid when the clock is running or paused.</p><p>The presentation clock initiates the state change by calling <see cref="SharpDX.MediaFoundation.ClockStateSink.OnClockStop"/> on the clock's time source. This call is made synchronously. If it fails, the state change does not occur. If the call succeeds, the state changes, and the clock notifies the other state-change subscribers by calling their <strong>OnClockStop</strong> methods. These calls are made asynchronously.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationClock::Stop']/*"/>	
        /// <msdn-id>ms697195</msdn-id>	
        /// <unmanaged>HRESULT IMFPresentationClock::Stop()</unmanaged>	
        /// <unmanaged-short>IMFPresentationClock::Stop</unmanaged-short>	
        public void Stop()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Pauses the presentation clock. While the clock is paused, the clock time does not advance, and the clock's <see cref="SharpDX.MediaFoundation.PresentationClock.GetTime"/> returns the time at which the clock was paused.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ClockNoTimeSource"/></strong></dt> </dl> </td><td> <p>No time source was set on this clock.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ClockStateAlreadySet"/></strong></dt> </dl> </td><td> <p>The clock is already paused.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The clock is stopped. This request is not valid when the clock is stopped.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is valid when the clock is running. It is not valid when the clock is paused or stopped.</p><p>The presentation clock initiates the state change by calling <see cref="SharpDX.MediaFoundation.ClockStateSink.OnClockPause"/> on the clock's time source. This call is made synchronously. If it fails, the state change does not occur. If the call succeeds, the state changes, and the clock notifies the other state-change subscribers by calling their <strong>OnClockPause</strong> methods. These calls are made asynchronously.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationClock::Pause']/*"/>	
        /// <msdn-id>ms696201</msdn-id>	
        /// <unmanaged>HRESULT IMFPresentationClock::Pause()</unmanaged>	
        /// <unmanaged-short>IMFPresentationClock::Pause</unmanaged-short>	
        public void Pause()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Describes the details of a presentation. A <em>presentation</em> is a set of related media streams that share a common presentation time. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Presentation descriptors are used to configure media sources and some media sinks. To get the presentation descriptor from a media source, call <strong><see cref="SharpDX.MediaFoundation.MediaSource.CreatePresentationDescriptor"/></strong>. To create a new presentation descriptor, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreatePresentationDescriptor"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationDescriptor']/*"/>	
    /// <msdn-id>ms703990</msdn-id>	
    /// <unmanaged>IMFPresentationDescriptor</unmanaged>	
    /// <unmanaged-short>IMFPresentationDescriptor</unmanaged-short>	
    [Guid("03cb2711-24d7-4db6-a17f-f3a7a479a536")]
    public partial class PresentationDescriptor : SharpDX.MediaFoundation.MediaAttributes
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.PresentationDescriptor"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PresentationDescriptor(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.PresentationDescriptor"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.PresentationDescriptor(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.PresentationDescriptor(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the number of stream descriptors in the presentation. Each stream descriptor contains information about one stream in the media source. To retrieve a stream descriptor, call the <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor.GetStreamDescriptorByIndex"/></strong> method.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationDescriptor::GetStreamDescriptorCount']/*"/>	
        /// <msdn-id>ms701621</msdn-id>	
        /// <unmanaged>GetStreamDescriptorCount</unmanaged>	
        /// <unmanaged-short>GetStreamDescriptorCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPresentationDescriptor::GetStreamDescriptorCount([Out] unsigned int* pdwDescriptorCount)</unmanaged>
        public int StreamDescriptorCount
        {
            get { int __output__; GetStreamDescriptorCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of stream descriptors in the presentation. Each stream descriptor contains information about one stream in the media source. To retrieve a stream descriptor, call the <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor.GetStreamDescriptorByIndex"/></strong> method.</p>	
        /// </summary>	
        /// <param name="dwDescriptorCountRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationDescriptor::GetStreamDescriptorCount']/*"/>	
        /// <msdn-id>ms701621</msdn-id>	
        /// <unmanaged>HRESULT IMFPresentationDescriptor::GetStreamDescriptorCount([Out] unsigned int* pdwDescriptorCount)</unmanaged>	
        /// <unmanaged-short>IMFPresentationDescriptor::GetStreamDescriptorCount</unmanaged-short>	
        internal void GetStreamDescriptorCount(out int dwDescriptorCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwDescriptorCountRef_ = &dwDescriptorCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwDescriptorCountRef_, ((void**)(*(void**)_nativePointer))[33]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a stream descriptor for a stream in the presentation. The stream descriptor contains information about the stream.</p>	
        /// </summary>	
        /// <param name="dwIndex"><dd> <p>Zero-based index of the stream. To find the number of streams in the presentation, call the <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor.GetStreamDescriptorCount"/></strong> method.</p> </dd></param>	
        /// <param name="fSelectedRef"><dd> <p>Receives a Boolean value. The value is <strong>TRUE</strong> if the stream is currently selected, or <strong><see cref="SharpDX.Result.False"/></strong> if the stream is currently deselected. If a stream is selected, the media source generates data for that stream when <strong><see cref="SharpDX.MediaFoundation.MediaSource.Start"/></strong> is called. The media source will not generated data for deselected streams. To select a stream, call <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor.SelectStream"/></strong>.To deselect a stream, call <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor.DeselectStream"/></strong>.</p> </dd></param>	
        /// <param name="descriptorOut"><dd> <p>Receives a reference to the stream descriptor's <strong><see cref="SharpDX.MediaFoundation.StreamDescriptor"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationDescriptor::GetStreamDescriptorByIndex']/*"/>	
        /// <msdn-id>ms694924</msdn-id>	
        /// <unmanaged>HRESULT IMFPresentationDescriptor::GetStreamDescriptorByIndex([In] unsigned int dwIndex,[Out] BOOL* pfSelected,[Out] IMFStreamDescriptor** ppDescriptor)</unmanaged>	
        /// <unmanaged-short>IMFPresentationDescriptor::GetStreamDescriptorByIndex</unmanaged-short>	
        public void GetStreamDescriptorByIndex(int dwIndex, out SharpDX.Mathematics.Interop.RawBool fSelectedRef, out SharpDX.MediaFoundation.StreamDescriptor descriptorOut)
        {
            unsafe
            {
                fSelectedRef = new SharpDX.Mathematics.Interop.RawBool();
                IntPtr descriptorOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* fSelectedRef_ = &fSelectedRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwIndex, fSelectedRef_, &descriptorOut_, ((void**)(*(void**)_nativePointer))[34]);
                descriptorOut = (descriptorOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.StreamDescriptor(descriptorOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Selects a stream in the presentation.</p>	
        /// </summary>	
        /// <param name="dwDescriptorIndex"><dd> <p>The stream number to select, indexed from zero. To find the number of streams in the presentation, call <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor.GetStreamDescriptorCount"/></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>dwDescriptorIndex</em> is out of range.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If a stream is selected, the media source will generate data for that stream. The media source will not generated data for deselected streams. To deselect a stream, call <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor.DeselectStream"/></strong>. </p><p> To query whether a stream is selected, call <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor.GetStreamDescriptorByIndex"/></strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationDescriptor::SelectStream']/*"/>	
        /// <msdn-id>ms696272</msdn-id>	
        /// <unmanaged>HRESULT IMFPresentationDescriptor::SelectStream([In] unsigned int dwDescriptorIndex)</unmanaged>	
        /// <unmanaged-short>IMFPresentationDescriptor::SelectStream</unmanaged-short>	
        public void SelectStream(int dwDescriptorIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwDescriptorIndex, ((void**)(*(void**)_nativePointer))[35]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Deselects a stream in the presentation.</p>	
        /// </summary>	
        /// <param name="dwDescriptorIndex"><dd> <p> The stream number to deselect, indexed from zero. To find the number of streams in the presentation, call the <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor.GetStreamDescriptorCount"/></strong> method. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>dwDescriptorIndex</em> is out of range. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If a stream is deselected, no data is generated for that stream. To select the stream again, call <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor.SelectStream"/></strong>. </p><p> To query whether a stream is selected, call <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor.GetStreamDescriptorByIndex"/></strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationDescriptor::DeselectStream']/*"/>	
        /// <msdn-id>ms696266</msdn-id>	
        /// <unmanaged>HRESULT IMFPresentationDescriptor::DeselectStream([In] unsigned int dwDescriptorIndex)</unmanaged>	
        /// <unmanaged-short>IMFPresentationDescriptor::DeselectStream</unmanaged-short>	
        public void DeselectStream(int dwDescriptorIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwDescriptorIndex, ((void**)(*(void**)_nativePointer))[36]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Creates a copy of this presentation descriptor.</p>	
        /// </summary>	
        /// <param name="presentationDescriptorOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the new presentation descriptor. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This method performs a shallow copy of the presentation descriptor. The stream descriptors are not cloned. Therefore, use caution when modifying the presentation presentation descriptor or its stream descriptors. </p><p> If the original presentation descriptor is from a media source, do not modify the presentation descriptor unless the source is stopped. If you use the presentation descriptor to configure a media sink, do not modify the presentation descriptor after the sink is configured. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationDescriptor::Clone']/*"/>	
        /// <msdn-id>ms694028</msdn-id>	
        /// <unmanaged>HRESULT IMFPresentationDescriptor::Clone([Out] IMFPresentationDescriptor** ppPresentationDescriptor)</unmanaged>	
        /// <unmanaged-short>IMFPresentationDescriptor::Clone</unmanaged-short>	
        public void Clone(out SharpDX.MediaFoundation.PresentationDescriptor presentationDescriptorOut)
        {
            unsafe
            {
                IntPtr presentationDescriptorOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &presentationDescriptorOut_, ((void**)(*(void**)_nativePointer))[37]);
                presentationDescriptorOut = (presentationDescriptorOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.PresentationDescriptor(presentationDescriptorOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Provides the clock times for the presentation clock. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is implemented by presentation time sources. A presentation time source is an object that provides the clock time for the presentation clock. For example, the audio renderer is a presentation time source. The rate at which the audio renderer consumes audio samples determines the clock time. If the audio format is 44100 samples per second, the audio renderer will report that one second has passed for every 44100 audio samples it plays. In this case, the timing is provided by the sound card.</p><p>To set the presentation time source on the presentation clock, call <strong><see cref="SharpDX.MediaFoundation.PresentationClock.SetTimeSource"/></strong> with a reference to the time source's <strong><see cref="SharpDX.MediaFoundation.PresentationTimeSource"/></strong> interface.</p><p>A presentation time source must also implement the <strong><see cref="SharpDX.MediaFoundation.ClockStateSink"/></strong> interface. The presentaton clock uses this interface to notify the time source when the clock state changes.</p><p>Media Foundation provides a presentation time source that is based on the system clock. To create this object, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSystemTimeSource"/></strong> function.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationTimeSource']/*"/>	
    /// <msdn-id>ms704711</msdn-id>	
    /// <unmanaged>IMFPresentationTimeSource</unmanaged>	
    /// <unmanaged-short>IMFPresentationTimeSource</unmanaged-short>	
    [Guid("7FF12CCE-F76F-41c2-863B-1666C8E5E139")]
    public partial class PresentationTimeSource : SharpDX.MediaFoundation.Clock
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.PresentationTimeSource"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PresentationTimeSource(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.PresentationTimeSource"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.PresentationTimeSource(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.PresentationTimeSource(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the underlying clock that the presentation time source uses to generate its clock times.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>A presentation time source must support stopping, starting, pausing, and rate changes. However, in many cases the time source derives its clock times from a hardware clock or other device. The underlying clock is always running, and might not support rate changes.</p><p>Optionally, a time source can expose the underlying clock by implementing this method. The underlying clock is always running, even when the presentation time source is paused or stopped. (Therefore, the underlying clock returns the <see cref="SharpDX.MediaFoundation.ClockCharacteristicsFlags.AlwaysRunning"/> flag in the <strong><see cref="SharpDX.MediaFoundation.Clock.GetClockCharacteristics"/></strong> method).</p><p>The underlying clock is useful if you want to make decisions based on the clock times while the presentation clock is stopped or paused.</p><p>If the time source does not expose an underlying clock, the method returns <see cref="SharpDX.MediaFoundation.ResultCode.NoClock"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationTimeSource::GetUnderlyingClock']/*"/>	
        /// <msdn-id>ms694071</msdn-id>	
        /// <unmanaged>GetUnderlyingClock</unmanaged>	
        /// <unmanaged-short>GetUnderlyingClock</unmanaged-short>	
        /// <unmanaged>HRESULT IMFPresentationTimeSource::GetUnderlyingClock([Out] IMFClock** ppClock)</unmanaged>
        public SharpDX.MediaFoundation.Clock UnderlyingClock
        {
            get { SharpDX.MediaFoundation.Clock __output__; GetUnderlyingClock(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the underlying clock that the presentation time source uses to generate its clock times.</p>	
        /// </summary>	
        /// <param name="clockOut"><dd> <p>Receives a reference to the clock's <strong><see cref="SharpDX.MediaFoundation.Clock"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoClock"/></strong></dt> </dl> </td><td> <p>This time source does not expose an underlying clock.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>A presentation time source must support stopping, starting, pausing, and rate changes. However, in many cases the time source derives its clock times from a hardware clock or other device. The underlying clock is always running, and might not support rate changes.</p><p>Optionally, a time source can expose the underlying clock by implementing this method. The underlying clock is always running, even when the presentation time source is paused or stopped. (Therefore, the underlying clock returns the <see cref="SharpDX.MediaFoundation.ClockCharacteristicsFlags.AlwaysRunning"/> flag in the <strong><see cref="SharpDX.MediaFoundation.Clock.GetClockCharacteristics"/></strong> method).</p><p>The underlying clock is useful if you want to make decisions based on the clock times while the presentation clock is stopped or paused.</p><p>If the time source does not expose an underlying clock, the method returns <see cref="SharpDX.MediaFoundation.ResultCode.NoClock"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFPresentationTimeSource::GetUnderlyingClock']/*"/>	
        /// <msdn-id>ms694071</msdn-id>	
        /// <unmanaged>HRESULT IMFPresentationTimeSource::GetUnderlyingClock([Out] IMFClock** ppClock)</unmanaged>	
        /// <unmanaged-short>IMFPresentationTimeSource::GetUnderlyingClock</unmanaged-short>	
        internal void GetUnderlyingClock(out SharpDX.MediaFoundation.Clock clockOut)
        {
            unsafe
            {
                IntPtr clockOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &clockOut_, ((void**)(*(void**)_nativePointer))[8]);
                clockOut = (clockOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Clock(clockOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides a method that allows content protection systems to perform a handshake with the protected environment. This is needed because the <strong>CreateFile</strong> and <strong>DeviceIoControl</strong> APIs are not available to Windows Store apps.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>See  <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateProtectedEnvironmentAccess"/></strong> for an example of how to create and use an <strong><see cref="SharpDX.MediaFoundation.ProtectedEnvironmentAccess"/></strong> object.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFProtectedEnvironmentAccess']/*"/>	
    /// <msdn-id>hh448045</msdn-id>	
    /// <unmanaged>IMFProtectedEnvironmentAccess</unmanaged>	
    /// <unmanaged-short>IMFProtectedEnvironmentAccess</unmanaged-short>	
    [Guid("ef5dc845-f0d9-4ec9-b00c-cb5183d38434")]
    public partial class ProtectedEnvironmentAccess : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ProtectedEnvironmentAccess"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ProtectedEnvironmentAccess(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ProtectedEnvironmentAccess"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ProtectedEnvironmentAccess(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ProtectedEnvironmentAccess(nativePointer);
        }


        /// <summary>	
        /// <p>Allows content protection systems to access the protected environment.</p>	
        /// </summary>	
        /// <param name="inputLength"><dd> <p>The length in bytes of the input data.</p> </dd></param>	
        /// <param name="input"><dd> <p>A reference to the input data.</p> </dd></param>	
        /// <param name="outputLength"><dd> <p>The length in bytes of the output data.</p> </dd></param>	
        /// <param name="output"><dd> <p>A reference to the output data.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>See  <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateProtectedEnvironmentAccess"/></strong> for an example of how to create an <strong><see cref="SharpDX.MediaFoundation.ProtectedEnvironmentAccess"/></strong> object and use the <strong>Call</strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFProtectedEnvironmentAccess::Call']/*"/>	
        /// <msdn-id>hh448046</msdn-id>	
        /// <unmanaged>HRESULT IMFProtectedEnvironmentAccess::Call([In] unsigned int inputLength,[In, Buffer] const unsigned char* input,[In] unsigned int outputLength,[Out, Buffer] unsigned char* output)</unmanaged>	
        /// <unmanaged-short>IMFProtectedEnvironmentAccess::Call</unmanaged-short>	
        public void Call(int inputLength, byte[] input, int outputLength, byte[] output)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* input_ = input)
                fixed (void* output_ = output)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, inputLength, input_, outputLength, output_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the Global Revocation List (GLR).</p>	
        /// </summary>	
        /// <param name="outputLength"><dd> <p>The length of the data returned in <strong>output</strong>.</p> </dd></param>	
        /// <param name="output"><dd> <p>Receives the contents of the global revocation list file.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Allows reading of the system Global Revocation List (GRL).  </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFProtectedEnvironmentAccess::ReadGRL']/*"/>	
        /// <msdn-id>jj128322</msdn-id>	
        /// <unmanaged>HRESULT IMFProtectedEnvironmentAccess::ReadGRL([Out] unsigned int* outputLength,[Out, Buffer] unsigned char** output)</unmanaged>	
        /// <unmanaged-short>IMFProtectedEnvironmentAccess::ReadGRL</unmanaged-short>	
        public void ReadGRL(out int outputLength, byte[] output)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* outputLength_ = &outputLength)
                fixed (void* output_ = output)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, outputLength_, output_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables the quality manager to adjust the audio or video quality of a component in the pipeline.</p><p>This interface is exposed by pipeline components that can adjust their quality. Typically it is exposed by decoders and stream sinks. For example, the enhanced video renderer (EVR) implements this interface. However, media sources can also implement this interface.</p><p>To get a reference to this interface from a media source, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> with the service identifier <see cref="SharpDX.MediaFoundation.MediaServiceKeys.Qualiy"/>. For all other pipeline objects (transforms and media sinks), call <strong>QueryInterface</strong>.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The quality manager typically obtains this interface when the quality manager's <strong><see cref="SharpDX.MediaFoundation.QualityManager.NotifyTopology"/></strong> method is called.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityAdvise']/*"/>	
    /// <msdn-id>ms695241</msdn-id>	
    /// <unmanaged>IMFQualityAdvise</unmanaged>	
    /// <unmanaged-short>IMFQualityAdvise</unmanaged-short>	
    [Guid("EC15E2E9-E36B-4f7c-8758-77D452EF4CE7")]
    public partial class QualityAdvise : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.QualityAdvise"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public QualityAdvise(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.QualityAdvise"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.QualityAdvise(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.QualityAdvise(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the current drop mode.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityAdvise::GetDropMode']/*"/>	
        /// <msdn-id>ms702987</msdn-id>	
        /// <unmanaged>GetDropMode / SetDropMode</unmanaged>	
        /// <unmanaged-short>GetDropMode</unmanaged-short>	
        /// <unmanaged>HRESULT IMFQualityAdvise::GetDropMode([Out] MF_QUALITY_DROP_MODE* peDropMode)</unmanaged>
        public SharpDX.MediaFoundation.QualityDropMode DropMode
        {
            get { SharpDX.MediaFoundation.QualityDropMode __output__; GetDropMode(out __output__); return __output__; }
            set { SetDropMode(value); }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the current quality level.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityAdvise::GetQualityLevel']/*"/>	
        /// <msdn-id>ms701591</msdn-id>	
        /// <unmanaged>GetQualityLevel / SetQualityLevel</unmanaged>	
        /// <unmanaged-short>GetQualityLevel</unmanaged-short>	
        /// <unmanaged>HRESULT IMFQualityAdvise::GetQualityLevel([Out] MF_QUALITY_LEVEL* peQualityLevel)</unmanaged>
        public SharpDX.MediaFoundation.QualityLevel QualityLevel
        {
            get { SharpDX.MediaFoundation.QualityLevel __output__; GetQualityLevel(out __output__); return __output__; }
            set { SetQualityLevel(value); }
        }

        /// <summary>	
        /// <p> </p><p>Sets the drop mode. In drop mode, a component drops samples, more or less aggressively depending on the level of the drop mode.</p>	
        /// </summary>	
        /// <param name="eDropMode"><dd> <p>Requested drop mode, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.QualityDropMode"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoMoreDropModes"/></strong></dt> </dl> </td><td> <p>The component does not support the specified mode or any higher modes.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If this method is called on a media source, the media source might switch between thinned and non-thinned output. If that occurs, the affected streams will send an <see cref="SharpDX.MediaFoundation.MediaEventTypes.StreamThinMode"/> event to indicate the transition. The operation is asynchronous; after <strong>SetDropMode</strong> returns, you might receive samples that were queued before the transition. The <see cref="SharpDX.MediaFoundation.MediaEventTypes.StreamThinMode"/> event marks the exact point in the stream where the transition occurs.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityAdvise::SetDropMode']/*"/>	
        /// <msdn-id>ms694861</msdn-id>	
        /// <unmanaged>HRESULT IMFQualityAdvise::SetDropMode([In] MF_QUALITY_DROP_MODE eDropMode)</unmanaged>	
        /// <unmanaged-short>IMFQualityAdvise::SetDropMode</unmanaged-short>	
        internal void SetDropMode(SharpDX.MediaFoundation.QualityDropMode eDropMode)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)eDropMode), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the quality level. The quality level determines how the component consumes or produces samples.</p>	
        /// </summary>	
        /// <param name="eQualityLevel"><dd> <p>Requested quality level, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.QualityLevel"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoMoreQualityLevels"/></strong></dt> </dl> </td><td> <p>The component does not support the specified quality level or any levels below it.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityAdvise::SetQualityLevel']/*"/>	
        /// <msdn-id>ms705619</msdn-id>	
        /// <unmanaged>HRESULT IMFQualityAdvise::SetQualityLevel([In] MF_QUALITY_LEVEL eQualityLevel)</unmanaged>	
        /// <unmanaged-short>IMFQualityAdvise::SetQualityLevel</unmanaged-short>	
        internal void SetQualityLevel(SharpDX.MediaFoundation.QualityLevel eQualityLevel)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)eQualityLevel), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the current drop mode.</p>	
        /// </summary>	
        /// <param name="eDropModeRef"><dd> <p>Receives the drop mode, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.QualityDropMode"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityAdvise::GetDropMode']/*"/>	
        /// <msdn-id>ms702987</msdn-id>	
        /// <unmanaged>HRESULT IMFQualityAdvise::GetDropMode([Out] MF_QUALITY_DROP_MODE* peDropMode)</unmanaged>	
        /// <unmanaged-short>IMFQualityAdvise::GetDropMode</unmanaged-short>	
        internal void GetDropMode(out SharpDX.MediaFoundation.QualityDropMode eDropModeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* eDropModeRef_ = &eDropModeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, eDropModeRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the current quality level.</p>	
        /// </summary>	
        /// <param name="eQualityLevelRef"><dd> <p>Receives the quality level, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.QualityLevel"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityAdvise::GetQualityLevel']/*"/>	
        /// <msdn-id>ms701591</msdn-id>	
        /// <unmanaged>HRESULT IMFQualityAdvise::GetQualityLevel([Out] MF_QUALITY_LEVEL* peQualityLevel)</unmanaged>	
        /// <unmanaged-short>IMFQualityAdvise::GetQualityLevel</unmanaged-short>	
        internal void GetQualityLevel(out SharpDX.MediaFoundation.QualityLevel eQualityLevelRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* eQualityLevelRef_ = &eQualityLevelRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, eQualityLevelRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Drops samples over a specified interval of time.</p>	
        /// </summary>	
        /// <param name="hnsAmountToDrop"><dd> <p>Amount of time to drop, in 100-nanosecond units. This value is always absolute. If the method is called multiple times, do not add the times from previous calls.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.DroptimeNotSupported"/></strong></dt> </dl> </td><td> <p>The object does not support this method.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Ideally the quality manager can prevent a renderer from falling behind. But if this does occur, then simply lowering quality does not guarantee the renderer will ever catch up. As a result, audio and video might fall out of sync. To correct this problem, the quality manager can call <strong>DropTime</strong> to request that the renderer drop samples quickly over a specified time interval. After that period, the renderer stops dropping samples.</p><p>This method is primarily intended for the video renderer. Dropped audio samples cause audio glitching, which is not desirable.</p><p>If a component does not support this method, it should return <see cref="SharpDX.MediaFoundation.ResultCode.DroptimeNotSupported"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityAdvise::DropTime']/*"/>	
        /// <msdn-id>ms697431</msdn-id>	
        /// <unmanaged>HRESULT IMFQualityAdvise::DropTime([In] longlong hnsAmountToDrop)</unmanaged>	
        /// <unmanaged-short>IMFQualityAdvise::DropTime</unmanaged-short>	
        public void DropTime(long hnsAmountToDrop)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, hnsAmountToDrop, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables a pipeline object to adjust its own audio or video quality, in response to quality messages.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface enables a pipeline object to respond to quality messages from the media sink. Currently, it is supported only for video decoders.</p><p>If a video decoder exposes <strong><see cref="SharpDX.MediaFoundation.QualityAdvise"/></strong> but not <strong><see cref="SharpDX.MediaFoundation.QualityAdvise2"/></strong>, the quality manager controls quality adjustments for the decoder. In this case, the quality manager responds to <see cref="SharpDX.MediaFoundation.MediaEventTypes.QualityNotify"/> events from the Enhanced Video Renderer (EVR) by calling <strong><see cref="SharpDX.MediaFoundation.QualityAdvise"/></strong> methods on the decoder.</p><p>If the decoder exposes <strong><see cref="SharpDX.MediaFoundation.QualityAdvise2"/></strong>, the quality manager forwards the <see cref="SharpDX.MediaFoundation.MediaEventTypes.QualityNotify"/> events to the decoder and does not adjust the decoder's quality settings. The decoder should respond to these events by adjusting its own quality settings internally.</p><p>The preceding remarks apply to the default implementation of the quality manager; custom quality managers can implement other behaviors.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityAdvise2']/*"/>	
    /// <msdn-id>dd743249</msdn-id>	
    /// <unmanaged>IMFQualityAdvise2</unmanaged>	
    /// <unmanaged-short>IMFQualityAdvise2</unmanaged-short>	
    [Guid("F3706F0D-8EA2-4886-8000-7155E9EC2EAE")]
    public partial class QualityAdvise2 : SharpDX.MediaFoundation.QualityAdvise
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.QualityAdvise2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public QualityAdvise2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.QualityAdvise2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.QualityAdvise2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.QualityAdvise2(nativePointer);
        }


        /// <summary>	
        /// <p>Forwards an <see cref="SharpDX.MediaFoundation.MediaEventTypes.QualityNotify"/> event from the media sink.</p>	
        /// </summary>	
        /// <param name="eventRef">No documentation.</param>	
        /// <param name="dwFlagsRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityAdvise2::NotifyQualityEvent']/*"/>	
        /// <msdn-id>dd743250</msdn-id>	
        /// <unmanaged>HRESULT IMFQualityAdvise2::NotifyQualityEvent([In, Optional] IMFMediaEvent* pEvent,[Out] unsigned int* pdwFlags)</unmanaged>	
        /// <unmanaged-short>IMFQualityAdvise2::NotifyQualityEvent</unmanaged-short>	
        public void NotifyQualityEvent(SharpDX.MediaFoundation.MediaEvent eventRef, out int dwFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwFlagsRef_ = &dwFlagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((eventRef == null) ? IntPtr.Zero : eventRef.NativePointer), dwFlagsRef_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Queries an object for the number of <em>quality modes</em> it supports. Quality modes are used to adjust the trade-off between quality and speed when rendering audio or video.</p><p>The default presenter for the <em>enhanced video renderer</em> (EVR) implements this interface. The EVR uses the interface to respond to quality messages from the quality manager.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityAdviseLimits']/*"/>	
    /// <msdn-id>dd374511</msdn-id>	
    /// <unmanaged>IMFQualityAdviseLimits</unmanaged>	
    /// <unmanaged-short>IMFQualityAdviseLimits</unmanaged-short>	
    [Guid("dfcd8e4d-30b5-4567-acaa-8eb5b7853dc9")]
    public partial class QualityAdviseLimits : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.QualityAdviseLimits"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public QualityAdviseLimits(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.QualityAdviseLimits"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.QualityAdviseLimits(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.QualityAdviseLimits(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the maximum <em>drop mode</em>. A higher drop mode means that the object will, if needed, drop samples more aggressively to match the presentation clock.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>To get the current drop mode, call the <strong><see cref="SharpDX.MediaFoundation.QualityAdvise.GetDropMode"/></strong> method. To set the drop mode, call the <strong><see cref="SharpDX.MediaFoundation.QualityAdvise.SetDropMode"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityAdviseLimits::GetMaximumDropMode']/*"/>	
        /// <msdn-id>dd374512</msdn-id>	
        /// <unmanaged>GetMaximumDropMode</unmanaged>	
        /// <unmanaged-short>GetMaximumDropMode</unmanaged-short>	
        /// <unmanaged>HRESULT IMFQualityAdviseLimits::GetMaximumDropMode([Out] MF_QUALITY_DROP_MODE* peDropMode)</unmanaged>
        public SharpDX.MediaFoundation.QualityDropMode MaximumDropMode
        {
            get { SharpDX.MediaFoundation.QualityDropMode __output__; GetMaximumDropMode(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets the minimum quality level that is supported by the component.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>To get the current quality level, call the <strong><see cref="SharpDX.MediaFoundation.QualityAdvise.GetQualityLevel"/></strong> method. To set the quality level, call the <strong><see cref="SharpDX.MediaFoundation.QualityAdvise.SetQualityLevel"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityAdviseLimits::GetMinimumQualityLevel']/*"/>	
        /// <msdn-id>dd374513</msdn-id>	
        /// <unmanaged>GetMinimumQualityLevel</unmanaged>	
        /// <unmanaged-short>GetMinimumQualityLevel</unmanaged-short>	
        /// <unmanaged>HRESULT IMFQualityAdviseLimits::GetMinimumQualityLevel([Out] MF_QUALITY_LEVEL* peQualityLevel)</unmanaged>
        public SharpDX.MediaFoundation.QualityLevel MinimumQualityLevel
        {
            get { SharpDX.MediaFoundation.QualityLevel __output__; GetMinimumQualityLevel(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets the maximum <em>drop mode</em>. A higher drop mode means that the object will, if needed, drop samples more aggressively to match the presentation clock.</p>	
        /// </summary>	
        /// <param name="eDropModeRef"><dd> <p>Receives the maximum drop mode, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.QualityDropMode"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To get the current drop mode, call the <strong><see cref="SharpDX.MediaFoundation.QualityAdvise.GetDropMode"/></strong> method. To set the drop mode, call the <strong><see cref="SharpDX.MediaFoundation.QualityAdvise.SetDropMode"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityAdviseLimits::GetMaximumDropMode']/*"/>	
        /// <msdn-id>dd374512</msdn-id>	
        /// <unmanaged>HRESULT IMFQualityAdviseLimits::GetMaximumDropMode([Out] MF_QUALITY_DROP_MODE* peDropMode)</unmanaged>	
        /// <unmanaged-short>IMFQualityAdviseLimits::GetMaximumDropMode</unmanaged-short>	
        internal void GetMaximumDropMode(out SharpDX.MediaFoundation.QualityDropMode eDropModeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* eDropModeRef_ = &eDropModeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, eDropModeRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the minimum quality level that is supported by the component.</p>	
        /// </summary>	
        /// <param name="eQualityLevelRef"><dd> <p>Receives the minimum quality level, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.QualityLevel"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To get the current quality level, call the <strong><see cref="SharpDX.MediaFoundation.QualityAdvise.GetQualityLevel"/></strong> method. To set the quality level, call the <strong><see cref="SharpDX.MediaFoundation.QualityAdvise.SetQualityLevel"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityAdviseLimits::GetMinimumQualityLevel']/*"/>	
        /// <msdn-id>dd374513</msdn-id>	
        /// <unmanaged>HRESULT IMFQualityAdviseLimits::GetMinimumQualityLevel([Out] MF_QUALITY_LEVEL* peQualityLevel)</unmanaged>	
        /// <unmanaged-short>IMFQualityAdviseLimits::GetMinimumQualityLevel</unmanaged-short>	
        internal void GetMinimumQualityLevel(out SharpDX.MediaFoundation.QualityLevel eQualityLevelRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* eQualityLevelRef_ = &eQualityLevelRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, eQualityLevelRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Adjusts playback quality. This interface is exposed by the quality manager. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Media Foundation provides a default quality manager that is tuned for playback. Applications can provide a custom quality manager to the Media Session by setting the <strong><see cref="SharpDX.MediaFoundation.MediaSessionAttributeKeys.QualityManager"/></strong> attribute when creating the Media Session.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityManager']/*"/>	
    /// <msdn-id>ms697558</msdn-id>	
    /// <unmanaged>IMFQualityManager</unmanaged>	
    /// <unmanaged-short>IMFQualityManager</unmanaged-short>	
    [Guid("8D009D86-5B9F-4115-B1FC-9F80D52AB8AB")]
    public partial class QualityManager : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.QualityManager"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public QualityManager(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.QualityManager"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.QualityManager(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.QualityManager(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Called when the Media Session is about to start playing a new topology.</p>	
        /// </summary>	
        /// <param name="topologyRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.Topology"/></strong> interface of the new topology. If this parameter is <strong><c>null</c></strong>, the quality manager should release any references to the previous topology.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>In a typical quality manager this method does the following:</p><ol> <li> <p>Enumerates the nodes in the topology.</p> </li> <li> <p>Calls <strong><see cref="SharpDX.MediaFoundation.TopologyNode.GetObjectW"/></strong> to get the node's underlying object.</p> </li> <li> <p>Queries for the <strong><see cref="SharpDX.MediaFoundation.QualityAdvise"/></strong> interface.</p> </li> </ol><p>The quality manager can then use the <strong><see cref="SharpDX.MediaFoundation.QualityAdvise"/></strong> references to adjust audio-video quality as needed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityManager::NotifyTopology']/*"/>	
        /// <msdn-id>ms697409</msdn-id>	
        /// <unmanaged>HRESULT IMFQualityManager::NotifyTopology([In] IMFTopology* pTopology)</unmanaged>	
        /// <unmanaged-short>IMFQualityManager::NotifyTopology</unmanaged-short>	
        public void NotifyTopology(SharpDX.MediaFoundation.Topology topologyRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((topologyRef == null) ? IntPtr.Zero : topologyRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Called when the Media Session selects a presentation clock.</p>	
        /// </summary>	
        /// <param name="clockRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.PresentationClock"/></strong> interface of the presentation clock. If this parameter is <strong><c>null</c></strong>, the quality manager should release any references to the presentation clock.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityManager::NotifyPresentationClock']/*"/>	
        /// <msdn-id>ms702211</msdn-id>	
        /// <unmanaged>HRESULT IMFQualityManager::NotifyPresentationClock([In] IMFPresentationClock* pClock)</unmanaged>	
        /// <unmanaged-short>IMFQualityManager::NotifyPresentationClock</unmanaged-short>	
        public void NotifyPresentationClock(SharpDX.MediaFoundation.PresentationClock clockRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((clockRef == null) ? IntPtr.Zero : clockRef.NativePointer), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Called when the media processor is about to deliver an input sample to a pipeline component.</p>	
        /// </summary>	
        /// <param name="nodeRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.TopologyNode"/></strong> interface of the topology node that represents the pipeline component.</p> </dd></param>	
        /// <param name="lInputIndex"><dd> <p>Index of the input stream on the topology node.</p> </dd></param>	
        /// <param name="sampleRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface of the input sample.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is called for every sample passing through every pipeline component. Therefore, the method must return quickly to avoid introducing too much latency into the pipeline.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityManager::NotifyProcessInput']/*"/>	
        /// <msdn-id>ms703097</msdn-id>	
        /// <unmanaged>HRESULT IMFQualityManager::NotifyProcessInput([In] IMFTopologyNode* pNode,[In] int lInputIndex,[In] IMFSample* pSample)</unmanaged>	
        /// <unmanaged-short>IMFQualityManager::NotifyProcessInput</unmanaged-short>	
        public void NotifyProcessInput(SharpDX.MediaFoundation.TopologyNode nodeRef, int lInputIndex, SharpDX.MediaFoundation.Sample sampleRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((nodeRef == null) ? IntPtr.Zero : nodeRef.NativePointer), lInputIndex, (void*)((sampleRef == null) ? IntPtr.Zero : sampleRef.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Called after the media processor gets an output sample from a pipeline component.</p>	
        /// </summary>	
        /// <param name="nodeRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.TopologyNode"/></strong> interface of the topology node that represents the pipeline component.</p> </dd></param>	
        /// <param name="lOutputIndex"><dd> <p>Index of the output stream on the topology node.</p> </dd></param>	
        /// <param name="sampleRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface of the output sample.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is called for every sample passing through every pipeline component. Therefore, the method must return quickly to avoid introducing too much latency into the pipeline.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityManager::NotifyProcessOutput']/*"/>	
        /// <msdn-id>ms700792</msdn-id>	
        /// <unmanaged>HRESULT IMFQualityManager::NotifyProcessOutput([In] IMFTopologyNode* pNode,[In] int lOutputIndex,[In] IMFSample* pSample)</unmanaged>	
        /// <unmanaged-short>IMFQualityManager::NotifyProcessOutput</unmanaged-short>	
        public void NotifyProcessOutput(SharpDX.MediaFoundation.TopologyNode nodeRef, int lOutputIndex, SharpDX.MediaFoundation.Sample sampleRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((nodeRef == null) ? IntPtr.Zero : nodeRef.NativePointer), lOutputIndex, (void*)((sampleRef == null) ? IntPtr.Zero : sampleRef.NativePointer), ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Called when a pipeline component sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.QualityNotify"/> event.</p>	
        /// </summary>	
        /// <param name="objectRef">No documentation.</param>	
        /// <param name="eventRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityManager::NotifyQualityEvent']/*"/>	
        /// <msdn-id>ms704768</msdn-id>	
        /// <unmanaged>HRESULT IMFQualityManager::NotifyQualityEvent([In] IUnknown* pObject,[In] IMFMediaEvent* pEvent)</unmanaged>	
        /// <unmanaged-short>IMFQualityManager::NotifyQualityEvent</unmanaged-short>	
        public void NotifyQualityEvent(SharpDX.ComObject objectRef, SharpDX.MediaFoundation.MediaEvent eventRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((objectRef == null) ? IntPtr.Zero : objectRef.NativePointer), (void*)((eventRef == null) ? IntPtr.Zero : eventRef.NativePointer), ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Called when the Media Session is shutting down.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The quality manager should release all references to the Media Session when this method is called.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFQualityManager::Shutdown']/*"/>	
        /// <msdn-id>ms703099</msdn-id>	
        /// <unmanaged>HRESULT IMFQualityManager::Shutdown()</unmanaged>	
        /// <unmanaged-short>IMFQualityManager::Shutdown</unmanaged-short>	
        public void Shutdown()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Gets or sets the playback rate. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Objects can expose this interface as a service. To obtain a reference to the interface, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> with the service identifier <see cref="SharpDX.MediaFoundation.MediaServiceKeys.RateControl"/>. The Media Session supports this interface. Media sources and transforms support this interface if they support rate changes. Media sinks do not need to support this interface. Media sinks are notified of rate changes through the <strong><see cref="SharpDX.MediaFoundation.ClockStateSink.OnClockSetRate"/></strong> method.</p><p>For more information, see About Rate Control.</p><p>To discover the playback rates that an object supports, use the <strong><see cref="SharpDX.MediaFoundation.RateSupport"/></strong> interface</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRateControl']/*"/>	
    /// <msdn-id>ms697193</msdn-id>	
    /// <unmanaged>IMFRateControl</unmanaged>	
    /// <unmanaged-short>IMFRateControl</unmanaged-short>	
    [Guid("88ddcd21-03c3-4275-91ed-55ee3929328f")]
    public partial class RateControl : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.RateControl"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RateControl(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.RateControl"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.RateControl(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.RateControl(nativePointer);
        }


        /// <summary>	
        /// <p> Sets the playback rate. </p>	
        /// </summary>	
        /// <param name="fThin"><dd> <p> If <strong>TRUE</strong>, the media streams are thinned. Otherwise, the stream is not thinned. For media sources and demultiplexers, the object must thin the streams when this parameter is <strong>TRUE</strong>. For downstream transforms, such as decoders and multiplexers, this parameter is informative; it notifies the object that the input streams are thinned. For information, see About Rate Control. </p> </dd></param>	
        /// <param name="flRate"><dd> <p> The requested playback rate. Postive values indicate forward playback, negative values indicate reverse playback, and zero indicates scrubbing (the source delivers a single frame). </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ReverseUnsupported"/></strong></dt> </dl> </td><td> <p> The object does not support reverse playback. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ThinningUnsupported"/></strong></dt> </dl> </td><td> <p> The object does not support thinning. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedRate"/></strong></dt> </dl> </td><td> <p> The object does not support the requested playback rate. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedRateTransition"/></strong></dt> </dl> </td><td> <p> The object cannot change to the new rate while in the running state. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The Media Session prevents some transitions between rate boundaries, depending on the current playback state:</p><table> <tr><th>Playback State</th><th>Forward/Reverse</th><th>Forward/Zero</th><th>Reverse/Zero</th></tr> <tr><td>Running</td><td>No</td><td>No</td><td>No</td></tr> <tr><td>Paused</td><td>No</td><td>Yes</td><td>No</td></tr> <tr><td>Stopped</td><td>Yes</td><td>Yes</td><td>Yes</td></tr> </table><p>?</p><p>If the transition is not supported, the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedRateTransition"/></strong>.</p><p>When a media source completes a call to <strong>SetRate</strong>, it sends the <see cref="SharpDX.MediaFoundation.MediaEventTypes.SourceRateChanged"/> event. Other pipeline components do not send this event.</p><p>If a media source switches between thinned and non-thinned playback, the streams send an <see cref="SharpDX.MediaFoundation.MediaEventTypes.StreamThinMode"/> event to indicate the transition. Events from the media source are not synchronized with events from the media streams. After you receive the <see cref="SharpDX.MediaFoundation.MediaEventTypes.SourceRateChanged"/> event, you can still receive samples that were queued before the stream switched to thinned or non-thinned mode. The <see cref="SharpDX.MediaFoundation.MediaEventTypes.StreamThinMode"/> event marks the exact point in the stream where the transition occurs.</p><p>When the Media Session completes a call to <strong>SetRate</strong>, it sends the <see cref="SharpDX.MediaFoundation.MediaEventTypes.SessionRateChanged"/> event.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRateControl::SetRate']/*"/>	
        /// <msdn-id>ms696979</msdn-id>	
        /// <unmanaged>HRESULT IMFRateControl::SetRate([In] BOOL fThin,[In] float flRate)</unmanaged>	
        /// <unmanaged-short>IMFRateControl::SetRate</unmanaged-short>	
        public void SetRate(SharpDX.Mathematics.Interop.RawBool fThin, float flRate)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint59(_nativePointer, fThin, flRate, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Gets the current playback rate.</p>	
        /// </summary>	
        /// <param name="flRateRef"><dd> <p>Receives the current playback rate.</p> </dd></param>	
        /// <returns><dd> <p>Receives the value <strong>TRUE</strong> if the stream is currently being thinned. If the object does not support thinning, this parameter always receives the value <strong><see cref="SharpDX.Result.False"/></strong>. This parameter can be <strong><c>null</c></strong>. For more information, see About Rate Control.</p> </dd></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRateControl::GetRate']/*"/>	
        /// <msdn-id>ms705641</msdn-id>	
        /// <unmanaged>HRESULT IMFRateControl::GetRate([Out] BOOL* pfThin,[Out] float* pflRate)</unmanaged>	
        /// <unmanaged-short>IMFRateControl::GetRate</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool GetRate(out float flRateRef)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool fThinRef;
                fThinRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* flRateRef_ = &flRateRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &fThinRef, flRateRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
                return fThinRef;
            }
        }
    }
    /// <summary>	
    /// <p>Queries the range of playback rates that are supported, including reverse playback.</p><p>To get a reference to this interface, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> with the service identifier <see cref="SharpDX.MediaFoundation.MediaServiceKeys.RateControl"/>.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Applications can use this interface to discover the fastest and slowest playback rates that are possible, and to query whether a given playback rate is supported. Applications obtain this interface from the Media Session. Internally, the Media Session queries the objects in the pipeline. For more information, see How to Determine Supported Rates.</p><p>To get the current playback rate and to change the playback rate, use the <strong><see cref="SharpDX.MediaFoundation.RateControl"/></strong> interface.</p><p>Playback rates are expressed as a ratio the normal playback rate. Reverse playback is expressed as a negative rate. Playback is either <em>thinned</em> or <em>non-thinned</em>. In thinned playback, some of the source data is skipped (typically delta frames). In non-thinned playback, all of the source data is rendered.</p><p>You might need to implement this interface if you are writing a pipeline object (media source, transform, or media sink). For more information, see Implementing Rate Control.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRateSupport']/*"/>	
    /// <msdn-id>ms701858</msdn-id>	
    /// <unmanaged>IMFRateSupport</unmanaged>	
    /// <unmanaged-short>IMFRateSupport</unmanaged-short>	
    [Guid("0a9ccdbc-d797-4563-9667-94ec5d79292d")]
    public partial class RateSupport : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.RateSupport"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RateSupport(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.RateSupport"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.RateSupport(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.RateSupport(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the slowest playback rate supported by the object.</p>	
        /// </summary>	
        /// <param name="eDirection"><dd> <p>Specifies whether to query to the slowest forward playback rate or reverse playback rate. The value is a member of the <strong><see cref="SharpDX.MediaFoundation.RateDirection"/></strong> enumeration.</p> </dd></param>	
        /// <param name="fThin"><dd> <p>If <strong>TRUE</strong>, the method retrieves the slowest thinned playback rate. Otherwise, the method retrieves the slowest non-thinned playback rate. For information about thinning, see About Rate Control.</p> </dd></param>	
        /// <param name="flRateRef"><dd> <p>Receives the slowest playback rate that the object supports.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ReverseUnsupported"/></strong></dt> </dl> </td><td> <p>The object does not support reverse playback.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ThinningUnsupported"/></strong></dt> </dl> </td><td> <p>The object does not support thinning.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The value returned in <em>plfRate</em> represents a lower bound. Playback at this rate is not guaranteed. Call <strong><see cref="SharpDX.MediaFoundation.RateSupport.IsRateSupported"/></strong> to check whether the boundary rate is supported. For example, a component that supports arbitrarily slow rates will return zero in <em>pflRate</em>, and applications should call <strong>IsRateSupported</strong> separately to determine whether the component supports rate 0.</p><p>If <em>eDirection</em> is <see cref="SharpDX.MediaFoundation.RateDirection.Reverse"/>, the method retrieves the slowest reverse playback rate. This is a negative value, assuming the object supports reverse playback.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRateSupport::GetSlowestRate']/*"/>	
        /// <msdn-id>ms704596</msdn-id>	
        /// <unmanaged>HRESULT IMFRateSupport::GetSlowestRate([In] MFRATE_DIRECTION eDirection,[In] BOOL fThin,[Out] float* pflRate)</unmanaged>	
        /// <unmanaged-short>IMFRateSupport::GetSlowestRate</unmanaged-short>	
        public void GetSlowestRate(SharpDX.MediaFoundation.RateDirection eDirection, SharpDX.Mathematics.Interop.RawBool fThin, out float flRateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* flRateRef_ = &flRateRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint57(_nativePointer, unchecked((int)eDirection), fThin, flRateRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Gets the fastest playback rate supported by the object.</p>	
        /// </summary>	
        /// <param name="eDirection"><dd> <p>Specifies whether to query to the fastest forward playback rate or reverse playback rate. The value is a member of the <strong><see cref="SharpDX.MediaFoundation.RateDirection"/></strong> enumeration.</p> </dd></param>	
        /// <param name="fThin"><dd> <p>If <strong>TRUE</strong>, the method retrieves the fastest thinned playback rate. Otherwise, the method retrieves the fastest non-thinned playback rate. For information about thinning, see About Rate Control.</p> </dd></param>	
        /// <param name="flRateRef"><dd> <p>Receives the fastest playback rate that the object supports.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ReverseUnsupported"/></strong></dt> </dl> </td><td> <p>The object does not support reverse playback.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ThinningUnsupported"/></strong></dt> </dl> </td><td> <p>The object does not support thinning.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>For some formats (such as ASF), thinning means dropping all frames that are not I-frames. If a component produces stream data, such as a media source or a demultiplexer, it should pay attention to the <em>fThin</em> parameter and return <see cref="SharpDX.MediaFoundation.ResultCode.ThinningUnsupported"/> if it cannot thin the stream.</p><p>If the component processes or receives a stream (most transforms or media sinks), it may ignore this parameter if it does not care whether the stream is thinned. In the Media Session's implementation of rate support, if the transforms do not explicitly support reverse playback, the Media Session will attempt to playback in reverse with thinning but not without thinning. Therefore, most applications will set <em>fThin</em> to <strong>TRUE</strong> when using the Media Session for reverse playback.</p><p>If <em>eDirection</em> is <see cref="SharpDX.MediaFoundation.RateDirection.Reverse"/>, the method retrieves the fastest reverse playback rate. This is a negative value, assuming the object supports reverse playback.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRateSupport::GetFastestRate']/*"/>	
        /// <msdn-id>ms693505</msdn-id>	
        /// <unmanaged>HRESULT IMFRateSupport::GetFastestRate([In] MFRATE_DIRECTION eDirection,[In] BOOL fThin,[Out] float* pflRate)</unmanaged>	
        /// <unmanaged-short>IMFRateSupport::GetFastestRate</unmanaged-short>	
        public void GetFastestRate(SharpDX.MediaFoundation.RateDirection eDirection, SharpDX.Mathematics.Interop.RawBool fThin, out float flRateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* flRateRef_ = &flRateRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint57(_nativePointer, unchecked((int)eDirection), fThin, flRateRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Queries whether the object supports a specified playback rate.</p>	
        /// </summary>	
        /// <param name="fThin"><dd> <p>If <strong>TRUE</strong>, the method queries whether the object supports the playback rate with thinning. Otherwise, the method queries whether the object supports the playback rate without thinning. For information about thinning, see About Rate Control.</p> </dd></param>	
        /// <param name="flRate"><dd> <p>The playback rate to query.</p> </dd></param>	
        /// <param name="flNearestSupportedRateRef"><dd> <p>If the object does not support the playback rate given in <em>flRate</em>, this parameter receives the closest supported playback rate. If the method returns <see cref="SharpDX.Result.Ok"/>, this parameter receives the value given in <em>flRate</em>. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The object supports the specified rate.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ReverseUnsupported"/></strong></dt> </dl> </td><td> <p>The object does not support reverse playback.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ThinningUnsupported"/></strong></dt> </dl> </td><td> <p>The object does not support thinning.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedRate"/></strong></dt> </dl> </td><td> <p>The object does not support the specified rate.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRateSupport::IsRateSupported']/*"/>	
        /// <msdn-id>ms696250</msdn-id>	
        /// <unmanaged>HRESULT IMFRateSupport::IsRateSupported([In] BOOL fThin,[In] float flRate,[InOut, Optional] float* pflNearestSupportedRate)</unmanaged>	
        /// <unmanaged-short>IMFRateSupport::IsRateSupported</unmanaged-short>	
        public void IsRateSupported(SharpDX.Mathematics.Interop.RawBool fThin, float flRate, System.IntPtr flNearestSupportedRateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint58(_nativePointer, fThin, flRate, (void*)flNearestSupportedRateRef, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Creates an instance of either the sink writer or the source reader.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To get a reference to this interface, call the <strong>CoCreateInstance</strong> function. The CLSID is <strong>CLSID_MFReadWriteClassFactory</strong>. Call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Startup"/></strong> function before using  the interface.</p><p>As an alternative to using this interface, you can call any of the following functions:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSinkWriterFromMediaSink"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSinkWriterFromURL"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSourceReaderFromByteStream"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSourceReaderFromMediaSource"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSourceReaderFromURL"/></strong> </li> </ul><p>Internally, these functions use the <strong><see cref="SharpDX.MediaFoundation.ReadWriteClassFactory"/></strong> interface.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFReadWriteClassFactory']/*"/>	
    /// <msdn-id>dd374514</msdn-id>	
    /// <unmanaged>IMFReadWriteClassFactory</unmanaged>	
    /// <unmanaged-short>IMFReadWriteClassFactory</unmanaged-short>	
    [Guid("E7FE2E12-661C-40DA-92F9-4F002AB67627")]
    public partial class ReadWriteClassFactory : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ReadWriteClassFactory"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ReadWriteClassFactory(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ReadWriteClassFactory"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ReadWriteClassFactory(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ReadWriteClassFactory(nativePointer);
        }


        /// <summary>	
        /// <p>Creates an instance of the sink writer or source reader, given a URL.</p>	
        /// </summary>	
        /// <param name="clsid"><dd> <p>The CLSID of the object to create.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>CLSID_MFSinkWriter</strong></strong></dt> </dl> </td><td> <p>Create the sink writer. The <em>ppvObject</em> parameter receives an <strong><see cref="SharpDX.MediaFoundation.SinkWriter"/></strong> interface reference.</p> </td></tr> <tr><td><dl> <dt><strong><strong>CLSID_MFSourceReader</strong></strong></dt> </dl> </td><td> <p>Create the source reader. The <em>ppvObject</em> parameter receives an <strong><see cref="SharpDX.MediaFoundation.SourceReader"/></strong> interface reference.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="wszURLRef"><dd> <p>A null-terminated string that contains a URL. If <em>clsid</em> is CLSID_<strong>MFSinkWriter</strong>, the URL specifies the name of the output file. The sink writer creates a new file with this name. If <em>clsid</em> is <strong>CLSID_MFSourceReader</strong>, the URL specifies the input file for the source reader.</p> </dd></param>	
        /// <param name="attributesRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the sink writer or source reader. For more information, see the following topics:</p> <ul> <li> Sink Writer Attributes </li> <li> Source Reader Attributes </li> </ul> <p>This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="riid"><dd> <p>The IID of the requested interface.</p> </dd></param>	
        /// <param name="vObjectOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFReadWriteClassFactory::CreateInstanceFromURL']/*"/>	
        /// <msdn-id>dd374516</msdn-id>	
        /// <unmanaged>HRESULT IMFReadWriteClassFactory::CreateInstanceFromURL([In] const GUID&amp; clsid,[In] const wchar_t* pwszURL,[In, Optional] IMFAttributes* pAttributes,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>	
        /// <unmanaged-short>IMFReadWriteClassFactory::CreateInstanceFromURL</unmanaged-short>	
        public void CreateInstanceFromURL(System.Guid clsid, string wszURLRef, SharpDX.MediaFoundation.MediaAttributes attributesRef, System.Guid riid, out System.IntPtr vObjectOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* wszURLRef_ = wszURLRef)
                fixed (void* vObjectOut_ = &vObjectOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &clsid, (void*)wszURLRef_, (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), &riid, vObjectOut_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an instance of the sink writer or source reader, given an <strong><see cref="SharpDX.ComObject"/></strong> reference. </p>	
        /// </summary>	
        /// <param name="clsid"><dd> <p>The CLSID of the object to create.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>CLSID_MFSinkWriter</strong></strong></dt> </dl> </td><td> <p>Create the sink writer. The <em>ppvObject</em> parameter receives an <strong><see cref="SharpDX.MediaFoundation.SinkWriter"/></strong> interface reference.</p> </td></tr> <tr><td><dl> <dt><strong><strong>CLSID_MFSourceReader</strong></strong></dt> </dl> </td><td> <p>Create the source reader. The <em>ppvObject</em> parameter receives an <strong><see cref="SharpDX.MediaFoundation.SourceReader"/></strong> interface reference.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="unkObjectRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of an object that is used to initialize the source reader or sink writer. The method queries this reference for one of the following interfaces.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong></strong></dt> </dl> </td><td> <p>Pointer to a byte stream. </p> <p>If <em>clsid</em> is <strong>CLSID_MFSinkWriter</strong>, the sink writer writes data to this byte stream.</p> <p>If <em>clsid</em> is <strong>CLSID_MFSourceReader</strong>, this byte stream provides the source data for the source reader.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.MediaSink"/></strong></strong></dt> </dl> </td><td> <p>Pointer to a media sink. Applies only when <em>clsid</em> is <strong>CLSID_MFSinkWriter</strong>. </p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.MediaSource"/></strong></strong></dt> </dl> </td><td> <p>Pointer to a media source. Applies only when <em>clsid</em> is <strong>CLSID_MFSourceReader</strong>.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="attributesRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the sink writer or source reader. For more information, see the following topics:</p> <ul> <li> Sink Writer Attributes </li> <li> Source Reader Attributes </li> </ul> <p>This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="riid"><dd> <p>The IID of the requested interface.</p> </dd></param>	
        /// <param name="vObjectOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFReadWriteClassFactory::CreateInstanceFromObject']/*"/>	
        /// <msdn-id>dd374515</msdn-id>	
        /// <unmanaged>HRESULT IMFReadWriteClassFactory::CreateInstanceFromObject([In] const GUID&amp; clsid,[In] IUnknown* punkObject,[In, Optional] IMFAttributes* pAttributes,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>	
        /// <unmanaged-short>IMFReadWriteClassFactory::CreateInstanceFromObject</unmanaged-short>	
        public void CreateInstanceFromObject(System.Guid clsid, SharpDX.ComObject unkObjectRef, SharpDX.MediaFoundation.MediaAttributes attributesRef, System.Guid riid, out System.IntPtr vObjectOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vObjectOut_ = &vObjectOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &clsid, (void*)((unkObjectRef == null) ? IntPtr.Zero : unkObjectRef.NativePointer), (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), &riid, vObjectOut_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Notifies a pipeline object to register itself with the Multimedia Class Scheduler Service (MMCSS).</p><p>Any pipeline object that creates worker threads should implement this interface.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Media Foundation provides a mechanism for applications to associate branches in the topology with MMCSS tasks. A topology branch is defined by a source node in the topology and all of the nodes downstream from it. An application registers a topology branch with MMCSS by setting the <strong><see cref="SharpDX.MediaFoundation.TopologyNodeAttributeKeys.WorkqueueId"/></strong> attribute on the source node and then calling <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices.BeginRegisterTopologyWorkQueuesWithMMCSS_"/></strong>.</p><p>When the application registers a topology branch with MMCSS, the Media Session queries every pipeline object in that branch for the <strong><see cref="SharpDX.MediaFoundation.RealTimeClient"/></strong> interface. If the object exposes the interface, the Media Session calls <strong>RegisterThreads</strong>.</p><p>When the application unregisters the topology branch, the Media Session calls <strong>UnregisterThreads</strong>.</p><p>If a pipeline object creates its own worker threads but does not implement this interface, it can cause priority inversions in the Media Foundation pipeline, because high-priority processing threads might be blocked while waiting for the component to process data on a thread with lower priority.</p><p>Pipeline objects that do not create worker threads do not need to implement this interface.</p><p>In Windows?8, this interface is extended with <strong><see cref="SharpDX.MediaFoundation.RealTimeClientEx"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRealTimeClient']/*"/>	
    /// <msdn-id>aa372146</msdn-id>	
    /// <unmanaged>IMFRealTimeClient</unmanaged>	
    /// <unmanaged-short>IMFRealTimeClient</unmanaged-short>	
    [Guid("2347D60B-3FB5-480c-8803-8DF3ADCD3EF0")]
    public partial class RealTimeClient : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.RealTimeClient"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RealTimeClient(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.RealTimeClient"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.RealTimeClient(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.RealTimeClient(nativePointer);
        }


        /// <summary>	
        /// <p>Specifies the work queue for the topology branch that contains this object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> An application can register a branch of the topology to use a private work queue. The Media Session notifies any pipeline object that supports <strong><see cref="SharpDX.MediaFoundation.RealTimeClient"/></strong> by calling <strong>SetWorkQueue</strong> with the application's work queue identifier. </p><p>When the application unregisters the topology branch, the Media Session calls <strong>SetWorkQueue</strong> again with the value <strong><see cref="SharpDX.MediaFoundation.WorkQueueType.Undefined"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRealTimeClient::SetWorkQueue']/*"/>	
        /// <msdn-id>aa367678</msdn-id>	
        /// <unmanaged>SetWorkQueue</unmanaged>	
        /// <unmanaged-short>SetWorkQueue</unmanaged-short>	
        /// <unmanaged>HRESULT IMFRealTimeClient::SetWorkQueue([In] unsigned int dwWorkQueueId)</unmanaged>
        public int WorkQueue
        {
            set { SetWorkQueue(value); }
        }

        /// <summary>	
        /// <p>Notifies the object to register its worker threads with the Multimedia Class Scheduler Service (MMCSS).</p>	
        /// </summary>	
        /// <param name="dwTaskIndex"><dd> <p> The MMCSS task identifier. </p> </dd></param>	
        /// <param name="wszClass"><dd> <p>The name of the MMCSS task. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The object's worker threads should register themselves with MMCSS by calling <strong>AvSetMmThreadCharacteristics</strong>, using the task name and identifier specified in this method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRealTimeClient::RegisterThreads']/*"/>	
        /// <msdn-id>aa367059</msdn-id>	
        /// <unmanaged>HRESULT IMFRealTimeClient::RegisterThreads([In] unsigned int dwTaskIndex,[In] const wchar_t* wszClass)</unmanaged>	
        /// <unmanaged-short>IMFRealTimeClient::RegisterThreads</unmanaged-short>	
        public void RegisterThreads(int dwTaskIndex, string wszClass)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* wszClass_ = wszClass)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwTaskIndex, (void*)wszClass_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Notifies the object to unregister its worker threads from the Multimedia Class Scheduler Service (MMCSS). </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The object's worker threads should unregister themselves from MMCSS by calling <strong>AvRevertMmThreadCharacteristics</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRealTimeClient::UnregisterThreads']/*"/>	
        /// <msdn-id>aa371717</msdn-id>	
        /// <unmanaged>HRESULT IMFRealTimeClient::UnregisterThreads()</unmanaged>	
        /// <unmanaged-short>IMFRealTimeClient::UnregisterThreads</unmanaged-short>	
        public void UnregisterThreads()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Specifies the work queue for the topology branch that contains this object.</p>	
        /// </summary>	
        /// <param name="dwWorkQueueId"><dd> <p>The identifier of the work queue, or the value <strong><see cref="SharpDX.MediaFoundation.WorkQueueType.Undefined"/></strong>. See Remarks. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> An application can register a branch of the topology to use a private work queue. The Media Session notifies any pipeline object that supports <strong><see cref="SharpDX.MediaFoundation.RealTimeClient"/></strong> by calling <strong>SetWorkQueue</strong> with the application's work queue identifier. </p><p>When the application unregisters the topology branch, the Media Session calls <strong>SetWorkQueue</strong> again with the value <strong><see cref="SharpDX.MediaFoundation.WorkQueueType.Undefined"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRealTimeClient::SetWorkQueue']/*"/>	
        /// <msdn-id>aa367678</msdn-id>	
        /// <unmanaged>HRESULT IMFRealTimeClient::SetWorkQueue([In] unsigned int dwWorkQueueId)</unmanaged>	
        /// <unmanaged-short>IMFRealTimeClient::SetWorkQueue</unmanaged-short>	
        internal void SetWorkQueue(int dwWorkQueueId)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwWorkQueueId, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Notifies a pipeline object to register itself with the Multimedia Class Scheduler Service (MMCSS). </p><p>This interface is a replacement for the <strong><see cref="SharpDX.MediaFoundation.RealTimeClient"/></strong> interface.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRealTimeClientEx']/*"/>	
    /// <msdn-id>hh448047</msdn-id>	
    /// <unmanaged>IMFRealTimeClientEx</unmanaged>	
    /// <unmanaged-short>IMFRealTimeClientEx</unmanaged-short>	
    [Guid("03910848-AB16-4611-B100-17B88AE2F248")]
    public partial class RealTimeClientEx : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.RealTimeClientEx"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RealTimeClientEx(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.RealTimeClientEx"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.RealTimeClientEx(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.RealTimeClientEx(nativePointer);
        }


        /// <summary>	
        /// <p>Notifies the object to register its worker threads with the Multimedia Class Scheduler Service (MMCSS).</p>	
        /// </summary>	
        /// <param name="dwTaskIndexRef"><dd> <p>The MMCSS task identifier. If the value is zero on input,  the object should create a new MCCSS task group. See Remarks.</p> </dd></param>	
        /// <param name="wszClassName"><dd> <p>The name of the MMCSS task.</p> </dd></param>	
        /// <param name="lBasePriority"><dd> <p>The base priority of the thread.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If the object does not create worker threads, the method should simply return <see cref="SharpDX.Result.Ok"/> and take no further action. </p><p>Otherwise, if the value of <code>*pdwTaskIndex</code> is zero on input, the object should perform the following steps:</p><ol> <li>A single worker thread calls <strong>AvSetMmThreadCharacteristics</strong> to create a new MMCSS task identifier. Store this value.</li> <li>Any additional worker threads call <strong>AvSetMmThreadCharacteristics</strong> using the new task identifier.</li> <li>Return the new task identifier to the caller, by setting <code>*pdwTaskIndex</code> equal to the task identifier.</li> </ol><p>If the value of <code>*pdwTaskIndex</code> is nonzero on input, the parameter contains an existing MMCSS task identifer. In that case, all worker threads of the object should register themselves for that task by calling <strong>AvSetMmThreadCharacteristics</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRealTimeClientEx::RegisterThreadsEx']/*"/>	
        /// <msdn-id>hh448048</msdn-id>	
        /// <unmanaged>HRESULT IMFRealTimeClientEx::RegisterThreadsEx([InOut] unsigned int* pdwTaskIndex,[In] const wchar_t* wszClassName,[In] int lBasePriority)</unmanaged>	
        /// <unmanaged-short>IMFRealTimeClientEx::RegisterThreadsEx</unmanaged-short>	
        public void RegisterThreadsEx(ref int dwTaskIndexRef, string wszClassName, int lBasePriority)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwTaskIndexRef_ = &dwTaskIndexRef)
                fixed (char* wszClassName_ = wszClassName)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwTaskIndexRef_, (void*)wszClassName_, lBasePriority, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Notifies the object to unregister its worker threads from the Multimedia Class Scheduler Service (MMCSS). </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRealTimeClientEx::UnregisterThreads']/*"/>	
        /// <msdn-id>hh448050</msdn-id>	
        /// <unmanaged>HRESULT IMFRealTimeClientEx::UnregisterThreads()</unmanaged>	
        /// <unmanaged-short>IMFRealTimeClientEx::UnregisterThreads</unmanaged-short>	
        public void UnregisterThreads()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Specifies the work queue that this object should use for asynchronous work items. </p>	
        /// </summary>	
        /// <param name="dwMultithreadedWorkQueueId"><dd> <p>The work queue identifier.</p> </dd></param>	
        /// <param name="lWorkItemBasePriority"><dd> <p>The base priority for work items.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The object should use the values of <em>dwMultithreadedWorkQueueId</em> and <em>lWorkItemBasePriority</em> when it queues new work items. Use the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.PutWorkItem2"/></strong> or <strong><see cref="SharpDX.MediaFoundation.MediaFactory.PutWorkItemEx2"/></strong> function to queue the work item.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRealTimeClientEx::SetWorkQueueEx']/*"/>	
        /// <msdn-id>hh448049</msdn-id>	
        /// <unmanaged>HRESULT IMFRealTimeClientEx::SetWorkQueueEx([In] unsigned int dwMultithreadedWorkQueueId,[In] int lWorkItemBasePriority)</unmanaged>	
        /// <unmanaged-short>IMFRealTimeClientEx::SetWorkQueueEx</unmanaged-short>	
        public void SetWorkQueueEx(int dwMultithreadedWorkQueueId, int lWorkItemBasePriority)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwMultithreadedWorkQueueId, lWorkItemBasePriority, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Used by the Microsoft Media Foundation proxy/stub DLL to marshal certain asynchronous method calls across process boundaries.</p><p>Applications do not use or implement this interface.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRemoteAsyncCallback']/*"/>	
    /// <msdn-id>bb970408</msdn-id>	
    /// <unmanaged>IMFRemoteAsyncCallback</unmanaged>	
    /// <unmanaged-short>IMFRemoteAsyncCallback</unmanaged-short>	
    [Guid("a27003d0-2354-4f2a-8d6a-ab7cff15437e")]
    public partial class RemoteAsyncCallback : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.RemoteAsyncCallback"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RemoteAsyncCallback(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.RemoteAsyncCallback"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.RemoteAsyncCallback(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.RemoteAsyncCallback(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="hr">No documentation.</param>	
        /// <param name="remoteResultRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRemoteAsyncCallback::Invoke']/*"/>	
        /// <unmanaged>HRESULT IMFRemoteAsyncCallback::Invoke([In] HRESULT hr,[In, Optional] IUnknown* pRemoteResult)</unmanaged>	
        /// <unmanaged-short>IMFRemoteAsyncCallback::Invoke</unmanaged-short>	
        public void Invoke(SharpDX.Result hr, SharpDX.ComObject remoteResultRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint86(_nativePointer, hr, (void*)((remoteResultRef == null) ? IntPtr.Zero : remoteResultRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Modifies a topology for use in a Terminal Services environment. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To use this interface, do the following:</p><ol> <li> Call <strong>GetSystemMetrics</strong> with the <strong>SM_REMOTESESSION</strong> flag. The function returns <strong>TRUE</strong> if the calling process is associated with a Terminal Services client session. </li> <li> If <strong>GetSystemMetrics</strong> returns <strong>TRUE</strong>, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateRemoteDesktopPlugin"/></strong>. This function returns a reference to the <strong><see cref="SharpDX.MediaFoundation.RemoteDesktopPlugin"/></strong> interface. </li> <li> Call <strong>UpdateTopology</strong> with a reference to the topology. </li> </ol><p>The application must call <strong>UpdateTopology</strong> before calling <strong><see cref="SharpDX.MediaFoundation.MediaSession.SetTopology"/></strong> on the Media Session.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRemoteDesktopPlugin']/*"/>	
    /// <msdn-id>ms698979</msdn-id>	
    /// <unmanaged>IMFRemoteDesktopPlugin</unmanaged>	
    /// <unmanaged-short>IMFRemoteDesktopPlugin</unmanaged-short>	
    [Guid("1cde6309-cae0-4940-907e-c1ec9c3d1d4a")]
    public partial class RemoteDesktopPlugin : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.RemoteDesktopPlugin"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RemoteDesktopPlugin(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.RemoteDesktopPlugin"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.RemoteDesktopPlugin(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.RemoteDesktopPlugin(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Modifies a topology for use in a Terminal Services environment.</p>	
        /// </summary>	
        /// <param name="topologyRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.Topology"/></strong> interface of the topology.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the application is running in a Terminal Services client session, call this method before calling <strong><see cref="SharpDX.MediaFoundation.MediaSession.SetTopology"/></strong> on the Media Session.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRemoteDesktopPlugin::UpdateTopology']/*"/>	
        /// <msdn-id>ms699001</msdn-id>	
        /// <unmanaged>HRESULT IMFRemoteDesktopPlugin::UpdateTopology([In] IMFTopology* pTopology)</unmanaged>	
        /// <unmanaged-short>IMFRemoteDesktopPlugin::UpdateTopology</unmanaged-short>	
        public void UpdateTopology(SharpDX.MediaFoundation.Topology topologyRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((topologyRef == null) ? IntPtr.Zero : topologyRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Retrieves a reference to the remote object for which this object is a proxy.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRemoteProxy']/*"/>	
    /// <msdn-id>bb970370</msdn-id>	
    /// <unmanaged>IMFRemoteProxy</unmanaged>	
    /// <unmanaged-short>IMFRemoteProxy</unmanaged-short>	
    [Guid("994e23ad-1cc2-493c-b9fa-46f1cb040fa4")]
    public partial class RemoteProxy : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.RemoteProxy"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RemoteProxy(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.RemoteProxy"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.RemoteProxy(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.RemoteProxy(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves a reference to the remote object for which this object is a proxy.</p>	
        /// </summary>	
        /// <param name="riid"><dd> <p>Interface identifier (IID) of the requested interface.</p> </dd></param>	
        /// <param name="vOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRemoteProxy::GetRemoteObject']/*"/>	
        /// <msdn-id>bb970370</msdn-id>	
        /// <unmanaged>HRESULT IMFRemoteProxy::GetRemoteObject([In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>	
        /// <unmanaged-short>IMFRemoteProxy::GetRemoteObject</unmanaged-short>	
        public void GetRemoteObject(System.Guid riid, out System.IntPtr vOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vOut_ = &vOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &riid, vOut_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a reference to the object that is hosting this proxy.</p>	
        /// </summary>	
        /// <param name="riid"><dd> <p>Interface identifier (IID) of the requested interface.</p> </dd></param>	
        /// <param name="vOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFRemoteProxy::GetRemoteHost']/*"/>	
        /// <msdn-id>bb970549</msdn-id>	
        /// <unmanaged>HRESULT IMFRemoteProxy::GetRemoteHost([In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>	
        /// <unmanaged-short>IMFRemoteProxy::GetRemoteHost</unmanaged-short>	
        public void GetRemoteHost(System.Guid riid, out System.IntPtr vOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vOut_ = &vOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &riid, vOut_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Sets and retrieves Synchronized Accessible Media Interchange (SAMI) styles on the SAMI Media Source. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p> To get a reference to this interface, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong>. The service identifier is <strong><see cref="SharpDX.MediaFoundation.MediaServiceKeys.Sami"/></strong>. Call <strong>GetService</strong> either directly on the SAMI media source, or on the Media Session (if you are using the SAMI source with the Media Session).</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSAMIStyle']/*"/>	
    /// <msdn-id>aa473825</msdn-id>	
    /// <unmanaged>IMFSAMIStyle</unmanaged>	
    /// <unmanaged-short>IMFSAMIStyle</unmanaged-short>	
    [Guid("A7E025DD-5303-4a62-89D6-E747E1EFAC73")]
    public partial class SAMIStyle : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SAMIStyle"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SAMIStyle(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SAMIStyle"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SAMIStyle(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SAMIStyle(nativePointer);
        }


        /// <summary>	
        /// <p> Gets the number of styles defined in the SAMI file. </p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSAMIStyle::GetStyleCount']/*"/>	
        /// <msdn-id>bb970341</msdn-id>	
        /// <unmanaged>GetStyleCount</unmanaged>	
        /// <unmanaged-short>GetStyleCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSAMIStyle::GetStyleCount([Out] unsigned int* pdwCount)</unmanaged>
        public int StyleCount
        {
            get { int __output__; GetStyleCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Gets a list of the style names defined in the SAMI file. </p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSAMIStyle::GetStyles']/*"/>	
        /// <msdn-id>bb970547</msdn-id>	
        /// <unmanaged>GetStyles</unmanaged>	
        /// <unmanaged-short>GetStyles</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSAMIStyle::GetStyles([Out] PROPVARIANT* pPropVarStyleArray)</unmanaged>
        public SharpDX.Win32.Variant Styles
        {
            get { SharpDX.Win32.Variant __output__; GetStyles(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Gets the number of styles defined in the SAMI file. </p>	
        /// </summary>	
        /// <param name="dwCountRef"><dd> <p> Receives the number of SAMI styles in the file. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSAMIStyle::GetStyleCount']/*"/>	
        /// <msdn-id>bb970341</msdn-id>	
        /// <unmanaged>HRESULT IMFSAMIStyle::GetStyleCount([Out] unsigned int* pdwCount)</unmanaged>	
        /// <unmanaged-short>IMFSAMIStyle::GetStyleCount</unmanaged-short>	
        internal void GetStyleCount(out int dwCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwCountRef_ = &dwCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwCountRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets a list of the style names defined in the SAMI file. </p>	
        /// </summary>	
        /// <param name="propVarStyleArrayRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that receives an array of null-terminated wide-character strings. The <strong><see cref="SharpDX.Win32.Variant"/></strong> type is VT_VECTOR | VT_LPWSTR. The caller must clear the <strong><see cref="SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSAMIStyle::GetStyles']/*"/>	
        /// <msdn-id>bb970547</msdn-id>	
        /// <unmanaged>HRESULT IMFSAMIStyle::GetStyles([Out] PROPVARIANT* pPropVarStyleArray)</unmanaged>	
        /// <unmanaged-short>IMFSAMIStyle::GetStyles</unmanaged-short>	
        internal void GetStyles(out SharpDX.Win32.Variant propVarStyleArrayRef)
        {
            unsafe
            {
                propVarStyleArrayRef = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* propVarStyleArrayRef_ = &propVarStyleArrayRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, propVarStyleArrayRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the current style on the SAMI media source.</p>	
        /// </summary>	
        /// <param name="wszStyleRef"><dd> <p>Pointer to a null-terminated string containing the name of the style. To clear the current style, pass an empty string ("").  To get the list of style names, call <strong><see cref="SharpDX.MediaFoundation.SAMIStyle.GetStyles"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSAMIStyle::SetSelectedStyle']/*"/>	
        /// <msdn-id>bb970574</msdn-id>	
        /// <unmanaged>HRESULT IMFSAMIStyle::SetSelectedStyle([In] const wchar_t* pwszStyle)</unmanaged>	
        /// <unmanaged-short>IMFSAMIStyle::SetSelectedStyle</unmanaged-short>	
        public void SetSelectedStyle(string wszStyleRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* wszStyleRef_ = wszStyleRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)wszStyleRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the current style from the SAMI media source. </p>	
        /// </summary>	
        /// <param name="wszStyleOut"><dd> <p> Receives a reference to a null-terminated string that contains the name of the style. If no style is currently set, the method returns an empty string. The caller must free the memory for the string by calling <strong>CoTaskMemFree</strong>.  </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSAMIStyle::GetSelectedStyle']/*"/>	
        /// <msdn-id>bb970429</msdn-id>	
        /// <unmanaged>HRESULT IMFSAMIStyle::GetSelectedStyle([Out] wchar_t** ppwszStyle)</unmanaged>	
        /// <unmanaged-short>IMFSAMIStyle::GetSelectedStyle</unmanaged-short>	
        public void GetSelectedStyle(System.IntPtr wszStyleOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)wszStyleOut, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a media sample, which is a container object for media data. For video, a sample typically contains one video frame. For audio data, a sample typically contains multiple audio samples, rather than a single sample of audio.</p><p>A media sample contains zero or more buffers. Each buffer manages a block of memory, and is represented by the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface. A sample can have multiple buffers. The buffers are kept in an ordered list and accessed by index value. It is also valid to have an empty sample with no buffers.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To create a new media sample, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSample"/></strong>.</p><strong>Note</strong>??<p>When you call <strong>CopyAllItems</strong>, inherited from the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface, on an <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong>, the sample time, duration, and flags are not copied to the destination sample. You must copy these values to the new sample manually.</p>?<p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample']/*"/>	
    /// <msdn-id>ms702192</msdn-id>	
    /// <unmanaged>IMFSample</unmanaged>	
    /// <unmanaged-short>IMFSample</unmanaged-short>	
    [Guid("c40a00f2-b93a-4d80-ae8c-5a1c634f58e4")]
    public partial class Sample : SharpDX.MediaFoundation.MediaAttributes
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.Sample"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Sample(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.Sample"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.Sample(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.Sample(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves flags associated with the sample.</p><p>Currently no flags are defined. Instead, metadata for samples is defined using attributes. To get attibutes from a sample, use the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface, which <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> inherits. For a list of sample attributes, see Sample Attributes.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::GetSampleFlags']/*"/>	
        /// <msdn-id>ms701587</msdn-id>	
        /// <unmanaged>GetSampleFlags / SetSampleFlags</unmanaged>	
        /// <unmanaged-short>GetSampleFlags</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSample::GetSampleFlags([Out] unsigned int* pdwSampleFlags)</unmanaged>
        public int SampleFlags
        {
            get { int __output__; GetSampleFlags(out __output__); return __output__; }
            set { SetSampleFlags(value); }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the presentation time of the sample.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::GetSampleTime']/*"/>	
        /// <msdn-id>ms705645</msdn-id>	
        /// <unmanaged>GetSampleTime / SetSampleTime</unmanaged>	
        /// <unmanaged-short>GetSampleTime</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSample::GetSampleTime([Out] longlong* phnsSampleTime)</unmanaged>
        public long SampleTime
        {
            get { long __output__; GetSampleTime(out __output__); return __output__; }
            set { SetSampleTime(value); }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the duration of the sample.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If the sample contains more than one buffer, the duration includes the data from all of the buffers.</p><p>If the retrieved duration is zero, or if the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.NoSampleDuration"/></strong>, the duration is unknown. In that case, it might be possible to calculate the duration from the media type?for example, by using the video frame rate or the audio sampling rate.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::GetSampleDuration']/*"/>	
        /// <msdn-id>ms703056</msdn-id>	
        /// <unmanaged>GetSampleDuration / SetSampleDuration</unmanaged>	
        /// <unmanaged-short>GetSampleDuration</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSample::GetSampleDuration([Out] longlong* phnsSampleDuration)</unmanaged>
        public long SampleDuration
        {
            get { long __output__; GetSampleDuration(out __output__); return __output__; }
            set { SetSampleDuration(value); }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of buffers in the sample.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::GetBufferCount']/*"/>	
        /// <msdn-id>ms705655</msdn-id>	
        /// <unmanaged>GetBufferCount</unmanaged>	
        /// <unmanaged-short>GetBufferCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSample::GetBufferCount([Out] unsigned int* pdwBufferCount)</unmanaged>
        public int BufferCount
        {
            get { int __output__; GetBufferCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the total length of the valid data in all of the buffers in the sample. The length is calculated as the sum of the values retrieved by the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.GetCurrentLength"/></strong> method.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::GetTotalLength']/*"/>	
        /// <msdn-id>ms704584</msdn-id>	
        /// <unmanaged>GetTotalLength</unmanaged>	
        /// <unmanaged-short>GetTotalLength</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSample::GetTotalLength([Out] unsigned int* pcbTotalLength)</unmanaged>
        public int TotalLength
        {
            get { int __output__; GetTotalLength(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves flags associated with the sample.</p><p>Currently no flags are defined. Instead, metadata for samples is defined using attributes. To get attibutes from a sample, use the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface, which <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> inherits. For a list of sample attributes, see Sample Attributes.</p>	
        /// </summary>	
        /// <param name="dwSampleFlagsRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::GetSampleFlags']/*"/>	
        /// <msdn-id>ms701587</msdn-id>	
        /// <unmanaged>HRESULT IMFSample::GetSampleFlags([Out] unsigned int* pdwSampleFlags)</unmanaged>	
        /// <unmanaged-short>IMFSample::GetSampleFlags</unmanaged-short>	
        internal void GetSampleFlags(out int dwSampleFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwSampleFlagsRef_ = &dwSampleFlagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwSampleFlagsRef_, ((void**)(*(void**)_nativePointer))[33]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets flags associated with the sample.</p><p>Currently no flags are defined. Instead, metadata for samples is defined using attributes. To set attibutes on a sample, use the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface, which <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> inherits. For a list of sample attributes, see Sample Attributes.</p>	
        /// </summary>	
        /// <param name="dwSampleFlags">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::SetSampleFlags']/*"/>	
        /// <msdn-id>ms696207</msdn-id>	
        /// <unmanaged>HRESULT IMFSample::SetSampleFlags([In] unsigned int dwSampleFlags)</unmanaged>	
        /// <unmanaged-short>IMFSample::SetSampleFlags</unmanaged-short>	
        internal void SetSampleFlags(int dwSampleFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwSampleFlags, ((void**)(*(void**)_nativePointer))[34]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the presentation time of the sample.</p>	
        /// </summary>	
        /// <param name="hnsSampleTimeRef"><dd> <p>Receives the presentation time, in 100-nanosecond units.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoSampleTimestamp"/></strong></dt> </dl> </td><td> <p>The sample does not have a presentation time.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::GetSampleTime']/*"/>	
        /// <msdn-id>ms705645</msdn-id>	
        /// <unmanaged>HRESULT IMFSample::GetSampleTime([Out] longlong* phnsSampleTime)</unmanaged>	
        /// <unmanaged-short>IMFSample::GetSampleTime</unmanaged-short>	
        internal void GetSampleTime(out long hnsSampleTimeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* hnsSampleTimeRef_ = &hnsSampleTimeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, hnsSampleTimeRef_, ((void**)(*(void**)_nativePointer))[35]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the presentation time of the sample.</p>	
        /// </summary>	
        /// <param name="hnsSampleTime"><dd> <p>The presentation time, in 100-nanosecond units.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Some pipeline components require samples that have time stamps. Generally the component that generates the data for the sample also sets the time stamp. The Media Session might modify the time stamps.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::SetSampleTime']/*"/>	
        /// <msdn-id>ms697282</msdn-id>	
        /// <unmanaged>HRESULT IMFSample::SetSampleTime([In] longlong hnsSampleTime)</unmanaged>	
        /// <unmanaged-short>IMFSample::SetSampleTime</unmanaged-short>	
        internal void SetSampleTime(long hnsSampleTime)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, hnsSampleTime, ((void**)(*(void**)_nativePointer))[36]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the duration of the sample.</p>	
        /// </summary>	
        /// <param name="hnsSampleDurationRef"><dd> <p>Receives the duration, in 100-nanosecond units.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoSampleDuration"/></strong></dt> </dl> </td><td> <p>The sample does not have a specified duration.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the sample contains more than one buffer, the duration includes the data from all of the buffers.</p><p>If the retrieved duration is zero, or if the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.NoSampleDuration"/></strong>, the duration is unknown. In that case, it might be possible to calculate the duration from the media type?for example, by using the video frame rate or the audio sampling rate.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::GetSampleDuration']/*"/>	
        /// <msdn-id>ms703056</msdn-id>	
        /// <unmanaged>HRESULT IMFSample::GetSampleDuration([Out] longlong* phnsSampleDuration)</unmanaged>	
        /// <unmanaged-short>IMFSample::GetSampleDuration</unmanaged-short>	
        internal void GetSampleDuration(out long hnsSampleDurationRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* hnsSampleDurationRef_ = &hnsSampleDurationRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, hnsSampleDurationRef_, ((void**)(*(void**)_nativePointer))[37]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the duration of the sample.</p>	
        /// </summary>	
        /// <param name="hnsSampleDuration"><dd> <p>Duration of the sample, in 100-nanosecond units.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method succeeds if the duration is negative, although negative durations are probably not valid for most types of data. It is the responsibility of the object that consumes the sample to validate the duration.</p><p>The duration can also be zero. This might be valid for some types of data. For example, the sample might contain stream metadata with no buffers.</p><p>Until this method is called, the <strong><see cref="SharpDX.MediaFoundation.Sample.GetSampleDuration"/></strong> method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.NoSampleDuration"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::SetSampleDuration']/*"/>	
        /// <msdn-id>ms705626</msdn-id>	
        /// <unmanaged>HRESULT IMFSample::SetSampleDuration([In] longlong hnsSampleDuration)</unmanaged>	
        /// <unmanaged-short>IMFSample::SetSampleDuration</unmanaged-short>	
        internal void SetSampleDuration(long hnsSampleDuration)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, hnsSampleDuration, ((void**)(*(void**)_nativePointer))[38]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of buffers in the sample.</p>	
        /// </summary>	
        /// <param name="dwBufferCountRef"><dd> <p>Receives the number of buffers in the sample. A sample might contain zero buffers.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::GetBufferCount']/*"/>	
        /// <msdn-id>ms705655</msdn-id>	
        /// <unmanaged>HRESULT IMFSample::GetBufferCount([Out] unsigned int* pdwBufferCount)</unmanaged>	
        /// <unmanaged-short>IMFSample::GetBufferCount</unmanaged-short>	
        internal void GetBufferCount(out int dwBufferCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwBufferCountRef_ = &dwBufferCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwBufferCountRef_, ((void**)(*(void**)_nativePointer))[39]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets a buffer from the sample, by index.</p><p> </p><strong>Note</strong>??In most cases, it is safer to use the <strong><see cref="SharpDX.MediaFoundation.Sample.ConvertToContiguousBuffer"/></strong> method.  If the sample contains more than one buffer, the <strong>ConvertToContiguousBuffer</strong> method replaces them with a single buffer, copies the original data into that buffer, and returns the new buffer to the caller. The copy operation occurs at most once. On subsequent calls, no data is copied.?	
        /// </summary>	
        /// <param name="dwIndex">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <remarks>	
        /// <p>A sample might contain more than one buffer. Use the <strong>GetBufferByIndex</strong> method to enumerate the individual buffers.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::GetBufferByIndex']/*"/>	
        /// <msdn-id>ms697014</msdn-id>	
        /// <unmanaged>HRESULT IMFSample::GetBufferByIndex([In] unsigned int dwIndex,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>	
        /// <unmanaged-short>IMFSample::GetBufferByIndex</unmanaged-short>	
        public SharpDX.MediaFoundation.MediaBuffer GetBufferByIndex(int dwIndex)
        {
            unsafe
            {
                SharpDX.MediaFoundation.MediaBuffer bufferOut;
                IntPtr bufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwIndex, &bufferOut_, ((void**)(*(void**)_nativePointer))[40]);
                bufferOut = (bufferOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaBuffer(bufferOut_);
                __result__.CheckError();
                return bufferOut;
            }
        }

        /// <summary>	
        /// <p> Converts a sample with multiple buffers into a sample with a single buffer. </p>	
        /// </summary>	
        /// <returns><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface. The caller must release the interface.</p> </dd></returns>	
        /// <remarks>	
        /// <p>If the sample contains more than one buffer, this method copies the data from the original buffers into a new buffer, and replaces the original buffer list with the new buffer. The new buffer is returned in the <em>ppBuffer</em> parameter.</p><p> If the sample contains a single buffer, this method returns a reference to the original buffer. In typical use, most samples do not contain multiple buffers.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::ConvertToContiguousBuffer']/*"/>	
        /// <msdn-id>ms698917</msdn-id>	
        /// <unmanaged>HRESULT IMFSample::ConvertToContiguousBuffer([Out] IMFMediaBuffer** ppBuffer)</unmanaged>	
        /// <unmanaged-short>IMFSample::ConvertToContiguousBuffer</unmanaged-short>	
        public SharpDX.MediaFoundation.MediaBuffer ConvertToContiguousBuffer()
        {
            unsafe
            {
                SharpDX.MediaFoundation.MediaBuffer bufferOut;
                IntPtr bufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &bufferOut_, ((void**)(*(void**)_nativePointer))[41]);
                bufferOut = (bufferOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaBuffer(bufferOut_);
                __result__.CheckError();
                return bufferOut;
            }
        }

        /// <summary>	
        /// <p> Adds a buffer to the end of the list of buffers in the sample. </p>	
        /// </summary>	
        /// <param name="bufferRef"><dd> <p>Pointer to the buffer's <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><c>null</c> reference argument.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>For uncompressed video data, each buffer should contain a single video frame, and samples should not contain multiple frames. In general, storing multiple buffers in a sample is discouraged.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::AddBuffer']/*"/>	
        /// <msdn-id>ms697465</msdn-id>	
        /// <unmanaged>HRESULT IMFSample::AddBuffer([In] IMFMediaBuffer* pBuffer)</unmanaged>	
        /// <unmanaged-short>IMFSample::AddBuffer</unmanaged-short>	
        public void AddBuffer(SharpDX.MediaFoundation.MediaBuffer bufferRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((bufferRef == null) ? IntPtr.Zero : bufferRef.NativePointer), ((void**)(*(void**)_nativePointer))[42]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Removes a buffer at a specified index from the sample.</p>	
        /// </summary>	
        /// <param name="dwIndex"><dd> <p>Index of the buffer. To find the number of buffers in the sample, call <strong><see cref="SharpDX.MediaFoundation.Sample.GetBufferCount"/></strong>. Buffers are indexed from zero.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::RemoveBufferByIndex']/*"/>	
        /// <msdn-id>ms705646</msdn-id>	
        /// <unmanaged>HRESULT IMFSample::RemoveBufferByIndex([In] unsigned int dwIndex)</unmanaged>	
        /// <unmanaged-short>IMFSample::RemoveBufferByIndex</unmanaged-short>	
        public void RemoveBufferByIndex(int dwIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwIndex, ((void**)(*(void**)_nativePointer))[43]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Removes all of the buffers from the sample.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::RemoveAllBuffers']/*"/>	
        /// <msdn-id>ms703108</msdn-id>	
        /// <unmanaged>HRESULT IMFSample::RemoveAllBuffers()</unmanaged>	
        /// <unmanaged-short>IMFSample::RemoveAllBuffers</unmanaged-short>	
        public void RemoveAllBuffers()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[44]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the total length of the valid data in all of the buffers in the sample. The length is calculated as the sum of the values retrieved by the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer.GetCurrentLength"/></strong> method.</p>	
        /// </summary>	
        /// <param name="cbTotalLengthRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::GetTotalLength']/*"/>	
        /// <msdn-id>ms704584</msdn-id>	
        /// <unmanaged>HRESULT IMFSample::GetTotalLength([Out] unsigned int* pcbTotalLength)</unmanaged>	
        /// <unmanaged-short>IMFSample::GetTotalLength</unmanaged-short>	
        internal void GetTotalLength(out int cbTotalLengthRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cbTotalLengthRef_ = &cbTotalLengthRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cbTotalLengthRef_, ((void**)(*(void**)_nativePointer))[45]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Copies the sample data to a buffer. This method concatenates the valid data from all of the buffers of the sample, in order.</p>	
        /// </summary>	
        /// <param name="bufferRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of the destination buffer. The buffer must be large enough to hold the valid data in the sample. To get the size of the data in the sample, call <strong><see cref="SharpDX.MediaFoundation.Sample.GetTotalLength"/></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><c>null</c> reference argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.BufferTooSmall"/></strong></dt> </dl> </td><td> <p>The buffer is not large enough to contain the data.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSample::CopyToBuffer']/*"/>	
        /// <msdn-id>ms703119</msdn-id>	
        /// <unmanaged>HRESULT IMFSample::CopyToBuffer([In] IMFMediaBuffer* pBuffer)</unmanaged>	
        /// <unmanaged-short>IMFSample::CopyToBuffer</unmanaged-short>	
        public void CopyToBuffer(SharpDX.MediaFoundation.MediaBuffer bufferRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((bufferRef == null) ? IntPtr.Zero : bufferRef.NativePointer), ((void**)(*(void**)_nativePointer))[46]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Callback interface to get media data from the sample-grabber sink. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The sample-grabber sink enables an application to get data from the Media Foundation pipeline without implementing a custom media sink. To use the sample-grabber sink, the application must perform the following steps:</p><ol> <li> <p>Implement the <strong><see cref="SharpDX.MediaFoundation.SampleGrabberSinkCallback"/></strong> interface.</p> </li> <li> <p>Call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSampleGrabberSinkActivate"/></strong>, passing in the <strong><see cref="SharpDX.MediaFoundation.SampleGrabberSinkCallback"/></strong> interface reference. This function returns an <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> object.</p> </li> <li> <p>Create a topology that includes an output node with the sink's <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> object.</p> </li> <li> <p>Pass this topology to the Media Session.</p> </li> </ol><p>During playback, the sample-grabber sink calls methods on the application's callback.</p><p>You cannot use the sample-grabber sink to get protected content.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleGrabberSinkCallback']/*"/>	
    /// <msdn-id>ms697548</msdn-id>	
    /// <unmanaged>IMFSampleGrabberSinkCallback</unmanaged>	
    /// <unmanaged-short>IMFSampleGrabberSinkCallback</unmanaged-short>	
    [Guid("8C7B80BF-EE42-4b59-B1DF-55668E1BDCA8")]
    public partial interface SampleGrabberSinkCallback : SharpDX.MediaFoundation.ClockStateSink
    {


        /// <summary>	
        /// <p> </p><p>Called when the presentation clock is set on the sample-grabber sink.</p>	
        /// </summary>	
        /// <param name="presentationClockRef"><dd> <p>Pointer to the presentation clock's <strong><see cref="SharpDX.MediaFoundation.PresentationClock"/></strong> interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method should return quickly, or it might interfere with playback. Do not block the thread, wait on events, or perform other lengthy operations inside this method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleGrabberSinkCallback::OnSetPresentationClock']/*"/>	
        /// <msdn-id>bb970506</msdn-id>	
        /// <unmanaged>HRESULT IMFSampleGrabberSinkCallback::OnSetPresentationClock([In] IMFPresentationClock* pPresentationClock)</unmanaged>	
        /// <unmanaged-short>IMFSampleGrabberSinkCallback::OnSetPresentationClock</unmanaged-short>	
        /* public void OnSetPresentationClock(SharpDX.MediaFoundation.PresentationClock presentationClockRef) */

        /// <summary>	
        /// <p> </p><p>Called when the sample-grabber sink receives a new media sample.</p>	
        /// </summary>	
        /// <param name="guidMajorMediaType"><dd> <p>The major type that specifies the format of the data. For a list of possible values, see Major Media Types. </p> </dd></param>	
        /// <param name="dwSampleFlags"><dd> <p> Reserved. </p> </dd></param>	
        /// <param name="llSampleTime"><dd> <p>The presentation time for this sample, in 100-nanosecond units. If the sample does not have a presentation time, the value of this parameter is <strong>_I64_MAX</strong>.</p> </dd></param>	
        /// <param name="llSampleDuration"><dd> <p>The duration of the sample, in 100-nanosecond units. If the sample does not have a duration, the value of this parameter is <strong>_I64_MAX</strong>.</p> </dd></param>	
        /// <param name="sampleBufferRef"><dd> <p> A reference to a buffer that contains the sample data. </p> </dd></param>	
        /// <param name="dwSampleSize"><dd> <p> Size of the <em>pSampleBuffer</em> buffer, in bytes. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If you use the sample-grabber sink in a playback topology, this method should return quickly, or it might interfere with playback. Do not block the thread, wait on events, or perform other lengthy operations inside this method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleGrabberSinkCallback::OnProcessSample']/*"/>	
        /// <msdn-id>bb970326</msdn-id>	
        /// <unmanaged>HRESULT IMFSampleGrabberSinkCallback::OnProcessSample([In] const GUID&amp; guidMajorMediaType,[In] unsigned int dwSampleFlags,[In] longlong llSampleTime,[In] longlong llSampleDuration,[In, Buffer] const unsigned char* pSampleBuffer,[In] unsigned int dwSampleSize)</unmanaged>	
        /// <unmanaged-short>IMFSampleGrabberSinkCallback::OnProcessSample</unmanaged-short>	
        /* public void OnProcessSample(System.Guid guidMajorMediaType, int dwSampleFlags, long llSampleTime, long llSampleDuration, byte[] sampleBufferRef, int dwSampleSize) */

        /// <summary>	
        /// <p> </p><p>Called when the sample-grabber sink is shut down.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is called when the sink's <strong><see cref="SharpDX.MediaFoundation.MediaSink.Shutdown"/></strong> method is called.</p><p>The <strong>OnShutdown</strong> method should return quickly, or it might interfere with playback. Do not block the thread, wait on events, or perform other lengthy operations inside this method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleGrabberSinkCallback::OnShutdown']/*"/>	
        /// <msdn-id>ms703093</msdn-id>	
        /// <unmanaged>HRESULT IMFSampleGrabberSinkCallback::OnShutdown()</unmanaged>	
        /// <unmanaged-short>IMFSampleGrabberSinkCallback::OnShutdown</unmanaged-short>	
        /* public void OnShutdown() */
    }
    /// <summary>	
    /// <p>Extends the <strong><see cref="SharpDX.MediaFoundation.SampleGrabberSinkCallback"/></strong> interface.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This callback interface is used with the sample-grabber sink. It extends the <strong><see cref="SharpDX.MediaFoundation.SampleGrabberSinkCallback"/></strong> interface by adding the <strong>OnProcessSampleEx</strong> method, which supersedes the <strong><see cref="SharpDX.MediaFoundation.SampleGrabberSinkCallback.OnProcessSample"/></strong> method.</p><p> The <strong>OnProcessSampleEx</strong> method adds a parameter that contains the attributes for the media sample. You can use the attributes to get information about the sample, such as  field dominance and telecine flags. </p><p>To use this interface, do the following: </p><ol> <li>Implement  a callback object that exposes the interface.</li> <li>Create the sample-grabber sink by calling the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSampleGrabberSinkActivate"/></strong> function. Pass the callback reference in the <em>pIMFSampleGrabberSinkCallback</em> parameter.</li> <li>The sample-grabber sink will call <strong>QueryInterface</strong> on the callback object.</li> <li>If the callback object exposes the <strong><see cref="SharpDX.MediaFoundation.SampleGrabberSinkCallback2"/></strong> interface, the sample-grabber sink will use the <strong>OnProcessSampleEx</strong> callback method.  Otherwise, the sample-grabber sink will use the older <strong>OnProcessSample</strong> callback method.</li> </ol>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleGrabberSinkCallback2']/*"/>	
    /// <msdn-id>dd374517</msdn-id>	
    /// <unmanaged>IMFSampleGrabberSinkCallback2</unmanaged>	
    /// <unmanaged-short>IMFSampleGrabberSinkCallback2</unmanaged-short>	
    [Guid("ca86aa50-c46e-429e-ab27-16d6ac6844cb")]
    public partial interface SampleGrabberSinkCallback2 : SharpDX.MediaFoundation.SampleGrabberSinkCallback
    {


        /// <summary>	
        /// <p>Called when the sample-grabber sink receives a new media sample.</p>	
        /// </summary>	
        /// <param name="guidMajorMediaType"><dd> <p>The major type <see cref="System.Guid"/> that specifies the format of the data. For a list of possible values, see Major Media Types. </p> </dd></param>	
        /// <param name="dwSampleFlags"><dd> <p>Sample flags. The sample-grabber sink gets the value of this parameter by calling the <strong><see cref="SharpDX.MediaFoundation.Sample.GetSampleFlags"/></strong> method of the media sample.</p> </dd></param>	
        /// <param name="llSampleTime"><dd> <p>The presentation time for this sample, in 100-nanosecond units. If the sample does not have a presentation time, the value of this parameter is <strong>_I64_MAX</strong></p> </dd></param>	
        /// <param name="llSampleDuration"><dd> <p>The duration of the sample, in 100-nanosecond units. If the sample does not have a duration, the value of this parameter is <strong>_I64_MAX</strong>.</p> </dd></param>	
        /// <param name="sampleBufferRef"><dd> <p>A reference to a buffer that contains the sample data.</p> </dd></param>	
        /// <param name="dwSampleSize"><dd> <p>The size, in bytes, of the <em>pSampleBuffer</em> buffer.</p> </dd></param>	
        /// <param name="attributesRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. Use this interface to get the attributes for this sample (if any). For a list of sample attributes, see Sample Attributes.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If you use the sample-grabber sink in a playback topology, this method should return quickly, or it might interfere with playback. Do not block the thread, wait on events, or perform other lengthy operations inside this method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleGrabberSinkCallback2::OnProcessSampleEx']/*"/>	
        /// <msdn-id>dd374518</msdn-id>	
        /// <unmanaged>HRESULT IMFSampleGrabberSinkCallback2::OnProcessSampleEx([In] const GUID&amp; guidMajorMediaType,[In] unsigned int dwSampleFlags,[In] longlong llSampleTime,[In] longlong llSampleDuration,[In, Buffer] const unsigned char* pSampleBuffer,[In] unsigned int dwSampleSize,[In] IMFAttributes* pAttributes)</unmanaged>	
        /// <unmanaged-short>IMFSampleGrabberSinkCallback2::OnProcessSampleEx</unmanaged-short>	
        /* public void OnProcessSampleEx(System.Guid guidMajorMediaType, int dwSampleFlags, long llSampleTime, long llSampleDuration, byte[] sampleBufferRef, int dwSampleSize, SharpDX.MediaFoundation.MediaAttributes attributesRef) */
    }
    /// <summary>	
    /// <p>Begins an asynchronous request to write a media sample to the stream.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>When the sample has been written to the stream, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, the caller should call <strong><see cref="SharpDX.MediaFoundation.SampleOutputStream.EndWriteSample"/></strong> to complete the asynchronous request.  </p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleOutputStream']/*"/>	
    /// <msdn-id>hh448052</msdn-id>	
    /// <unmanaged>IMFSampleOutputStream</unmanaged>	
    /// <unmanaged-short>IMFSampleOutputStream</unmanaged-short>	
    [Guid("8feed468-6f7e-440d-869a-49bdd283ad0d")]
    public partial class SampleOutputStream : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SampleOutputStream"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SampleOutputStream(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SampleOutputStream"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SampleOutputStream(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SampleOutputStream(nativePointer);
        }


        /// <summary>	
        /// <p>Begins an asynchronous request to write a media sample to the stream.</p>	
        /// </summary>	
        /// <param name="sampleRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface of the sample.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.  </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>When the sample has been written to the stream, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, the caller should call <strong><see cref="SharpDX.MediaFoundation.SampleOutputStream.EndWriteSample"/></strong> to complete the asynchronous request.  </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleOutputStream::BeginWriteSample']/*"/>	
        /// <msdn-id>hh448052</msdn-id>	
        /// <unmanaged>HRESULT IMFSampleOutputStream::BeginWriteSample([In, Optional] IMFSample* pSample,[In, Optional] IMFAsyncCallback* pCallback,[In, Optional] IUnknown* punkState)</unmanaged>	
        /// <unmanaged-short>IMFSampleOutputStream::BeginWriteSample</unmanaged-short>	
        internal void BeginWriteSample_(SharpDX.MediaFoundation.Sample sampleRef, System.IntPtr callbackRef, SharpDX.ComObject unkStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((sampleRef == null) ? IntPtr.Zero : sampleRef.NativePointer), (void*)callbackRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Completes an asynchronous request to write a media sample to the stream.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Call this method when the <strong><see cref="SharpDX.MediaFoundation.SampleOutputStream.BeginWriteSample_"/></strong> method completes asynchronously.  </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleOutputStream::EndWriteSample']/*"/>	
        /// <msdn-id>hh448053</msdn-id>	
        /// <unmanaged>HRESULT IMFSampleOutputStream::EndWriteSample([In, Optional] IMFAsyncResult* pResult)</unmanaged>	
        /// <unmanaged-short>IMFSampleOutputStream::EndWriteSample</unmanaged-short>	
        public void EndWriteSample(SharpDX.MediaFoundation.AsyncResult resultRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleOutputStream::Close']/*"/>	
        /// <unmanaged>HRESULT IMFSampleOutputStream::Close()</unmanaged>	
        /// <unmanaged-short>IMFSampleOutputStream::Close</unmanaged-short>	
        public void Close()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Provides encryption for media data inside the protected media path (PMP). </p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleProtection']/*"/>	
    /// <msdn-id>ms703018</msdn-id>	
    /// <unmanaged>IMFSampleProtection</unmanaged>	
    /// <unmanaged-short>IMFSampleProtection</unmanaged-short>	
    [Guid("8e36395f-c7b9-43c4-a54d-512b4af63c95")]
    public partial class SampleProtection : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SampleProtection"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SampleProtection(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SampleProtection"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SampleProtection(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SampleProtection(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the version of sample protection that the component implements on input.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleProtection::GetInputProtectionVersion']/*"/>	
        /// <msdn-id>bb970365</msdn-id>	
        /// <unmanaged>GetInputProtectionVersion</unmanaged>	
        /// <unmanaged-short>GetInputProtectionVersion</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSampleProtection::GetInputProtectionVersion([Out] unsigned int* pdwVersion)</unmanaged>
        public int InputProtectionVersion
        {
            get { int __output__; GetInputProtectionVersion(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the version of sample protection that the component implements on output.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleProtection::GetOutputProtectionVersion']/*"/>	
        /// <msdn-id>bb970415</msdn-id>	
        /// <unmanaged>GetOutputProtectionVersion</unmanaged>	
        /// <unmanaged-short>GetOutputProtectionVersion</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSampleProtection::GetOutputProtectionVersion([Out] unsigned int* pdwVersion)</unmanaged>
        public int OutputProtectionVersion
        {
            get { int __output__; GetOutputProtectionVersion(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the version of sample protection that the component implements on input.</p>	
        /// </summary>	
        /// <param name="dwVersionRef"><dd> <p>Receives a member of the <strong><see cref="SharpDX.MediaFoundation.SampleProtectionVersion"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleProtection::GetInputProtectionVersion']/*"/>	
        /// <msdn-id>bb970365</msdn-id>	
        /// <unmanaged>HRESULT IMFSampleProtection::GetInputProtectionVersion([Out] unsigned int* pdwVersion)</unmanaged>	
        /// <unmanaged-short>IMFSampleProtection::GetInputProtectionVersion</unmanaged-short>	
        internal void GetInputProtectionVersion(out int dwVersionRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwVersionRef_ = &dwVersionRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwVersionRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the version of sample protection that the component implements on output.</p>	
        /// </summary>	
        /// <param name="dwVersionRef"><dd> <p>Receives a member of the <strong><see cref="SharpDX.MediaFoundation.SampleProtectionVersion"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleProtection::GetOutputProtectionVersion']/*"/>	
        /// <msdn-id>bb970415</msdn-id>	
        /// <unmanaged>HRESULT IMFSampleProtection::GetOutputProtectionVersion([Out] unsigned int* pdwVersion)</unmanaged>	
        /// <unmanaged-short>IMFSampleProtection::GetOutputProtectionVersion</unmanaged-short>	
        internal void GetOutputProtectionVersion(out int dwVersionRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwVersionRef_ = &dwVersionRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwVersionRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the sample protection certificate.</p>	
        /// </summary>	
        /// <param name="dwVersion"><dd> <p>Specifies the version number of the sample protection scheme for which to receive a certificate. The version number is specified as a <strong><see cref="SharpDX.MediaFoundation.SampleProtectionVersion"/></strong> enumeration value.</p> </dd></param>	
        /// <param name="certOut"><dd> <p>Receives a reference to a buffer containing the certificate. The caller must free the memory for the buffer by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <param name="cbCertRef"><dd> <p>Receives the size of the <em>ppCert</em> buffer, in bytes.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>Not implemented.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>For certain version numbers of sample protection, the downstream component must provide a certificate. Components that do not support these version numbers can return E_NOTIMPL.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleProtection::GetProtectionCertificate']/*"/>	
        /// <msdn-id>bb970503</msdn-id>	
        /// <unmanaged>HRESULT IMFSampleProtection::GetProtectionCertificate([In] unsigned int dwVersion,[Out, Buffer] unsigned char** ppCert,[Out] unsigned int* pcbCert)</unmanaged>	
        /// <unmanaged-short>IMFSampleProtection::GetProtectionCertificate</unmanaged-short>	
        public void GetProtectionCertificate(int dwVersion, byte[] certOut, out int cbCertRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* certOut_ = certOut)
                fixed (void* cbCertRef_ = &cbCertRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwVersion, certOut_, cbCertRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves initialization information for sample protection from the upstream component.</p>	
        /// </summary>	
        /// <param name="dwVersion"><dd> <p>Specifies the version number of the sample protection scheme. The version number is specified as a <strong><see cref="SharpDX.MediaFoundation.SampleProtectionVersion"/></strong> enumeration value.</p> </dd></param>	
        /// <param name="dwOutputId"><dd> <p>Identifier of the output stream. The identifier corresponds to the output stream identifier returned by the <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> interface.</p> </dd></param>	
        /// <param name="bCertRef"><dd> <p>Pointer to a certificate provided by the downstream component.</p> </dd></param>	
        /// <param name="cbCert"><dd> <p>Size of the certificate, in bytes.</p> </dd></param>	
        /// <param name="bSeedOut"><dd> <p>Receives a reference to a buffer that contains the initialization information for downstream component. The caller must free the memory for the buffer by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <param name="cbSeedRef"><dd> <p>Receives the size of the <em>ppbSeed</em> buffer, in bytes.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>Not implemented.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method must be implemented by the upstream component. The method fails if the component does not support the requested sample protection version. Downstream components do not implement this method and should return E_NOTIMPL.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleProtection::InitOutputProtection']/*"/>	
        /// <msdn-id>ms693577</msdn-id>	
        /// <unmanaged>HRESULT IMFSampleProtection::InitOutputProtection([In] unsigned int dwVersion,[In] unsigned int dwOutputId,[In] unsigned char* pbCert,[In] unsigned int cbCert,[In] unsigned char** ppbSeed,[In] unsigned int* pcbSeed)</unmanaged>	
        /// <unmanaged-short>IMFSampleProtection::InitOutputProtection</unmanaged-short>	
        public void InitOutputProtection(int dwVersion, int dwOutputId, byte bCertRef, int cbCert, byte bSeedOut, int cbSeedRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwVersion, dwOutputId, &bCertRef, cbCert, &bSeedOut, &cbSeedRef, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Initializes sample protection on the downstream component.</p>	
        /// </summary>	
        /// <param name="dwVersion"><dd> <p>Specifies the version number of the sample protection scheme. The version number is specified as a <strong><see cref="SharpDX.MediaFoundation.SampleProtectionVersion"/></strong> enumeration value.</p> </dd></param>	
        /// <param name="dwInputId"><dd> <p>Identifier of the input stream. The identifier corresponds to the output stream identifier returned by the <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> interface.</p> </dd></param>	
        /// <param name="bSeedRef"><dd> <p>Pointer to a buffer that contains the initialization data provided by the upstream component. To retrieve this buffer, call <strong><see cref="SharpDX.MediaFoundation.SampleProtection.InitOutputProtection"/></strong>.</p> </dd></param>	
        /// <param name="cbSeed"><dd> <p>Size of the <em>pbSeed</em> buffer, in bytes.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSampleProtection::InitInputProtection']/*"/>	
        /// <msdn-id>ms696181</msdn-id>	
        /// <unmanaged>HRESULT IMFSampleProtection::InitInputProtection([In] unsigned int dwVersion,[In] unsigned int dwInputId,[In] unsigned char* pbSeed,[In] unsigned int cbSeed)</unmanaged>	
        /// <unmanaged-short>IMFSampleProtection::InitInputProtection</unmanaged-short>	
        public void InitInputProtection(int dwVersion, int dwInputId, byte bSeedRef, int cbSeed)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwVersion, dwInputId, &bSeedRef, cbSeed, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Persists media data from a source byte stream to an application-provided byte stream.</p><p>The byte stream used for HTTP download implements this interface. To get a reference to this interface, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> on the byte stream, with the service identifier <see cref="SharpDX.MediaFoundation.MediaServiceKeys.SaveJob"/>.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSaveJob']/*"/>	
    /// <msdn-id>ms694247</msdn-id>	
    /// <unmanaged>IMFSaveJob</unmanaged>	
    /// <unmanaged-short>IMFSaveJob</unmanaged-short>	
    [Guid("e9931663-80bf-4c6e-98af-5dcf58747d1f")]
    public partial class SaveJob : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SaveJob"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SaveJob(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SaveJob"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SaveJob(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SaveJob(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the percentage of content saved to the provided byte stream.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSaveJob::GetProgress']/*"/>	
        /// <msdn-id>ms700176</msdn-id>	
        /// <unmanaged>GetProgress</unmanaged>	
        /// <unmanaged-short>GetProgress</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSaveJob::GetProgress([Out] unsigned int* pdwPercentComplete)</unmanaged>
        public int Progress
        {
            get { int __output__; GetProgress(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Begins saving a Windows Media file to the application's byte stream.</p>	
        /// </summary>	
        /// <param name="streamRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface of the application's byte stream. The data from the source byte stream is written to this byte stream.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface</p> </dd></param>	
        /// <param name="stateRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When the operation completes, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, the application should call <strong><see cref="SharpDX.MediaFoundation.SaveJob.EndSave"/></strong> to complete the asynchronous request.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSaveJob::BeginSave']/*"/>	
        /// <msdn-id>ms705664</msdn-id>	
        /// <unmanaged>HRESULT IMFSaveJob::BeginSave([In] IMFByteStream* pStream,[In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>	
        /// <unmanaged-short>IMFSaveJob::BeginSave</unmanaged-short>	
        internal void BeginSave__(System.IntPtr streamRef, System.IntPtr callbackRef, SharpDX.ComObject stateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)streamRef, (void*)callbackRef, (void*)((stateRef == null) ? IntPtr.Zero : stateRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Completes the operation started by <strong><see cref="SharpDX.MediaFoundation.SaveJob.BeginSave__"/></strong>.</p>	
        /// </summary>	
        /// <param name="resultRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSaveJob::EndSave']/*"/>	
        /// <msdn-id>ms701610</msdn-id>	
        /// <unmanaged>HRESULT IMFSaveJob::EndSave([In] IMFAsyncResult* pResult)</unmanaged>	
        /// <unmanaged-short>IMFSaveJob::EndSave</unmanaged-short>	
        public void EndSave(SharpDX.MediaFoundation.AsyncResult resultRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Cancels the operation started by <strong><see cref="SharpDX.MediaFoundation.SaveJob.BeginSave__"/></strong>.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSaveJob::CancelSave']/*"/>	
        /// <msdn-id>ms703196</msdn-id>	
        /// <unmanaged>HRESULT IMFSaveJob::CancelSave()</unmanaged>	
        /// <unmanaged-short>IMFSaveJob::CancelSave</unmanaged-short>	
        public void CancelSave()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the percentage of content saved to the provided byte stream.</p>	
        /// </summary>	
        /// <param name="dwPercentCompleteRef"><dd> <p>Receives the percentage of completion.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSaveJob::GetProgress']/*"/>	
        /// <msdn-id>ms700176</msdn-id>	
        /// <unmanaged>HRESULT IMFSaveJob::GetProgress([Out] unsigned int* pdwPercentComplete)</unmanaged>	
        /// <unmanaged-short>IMFSaveJob::GetProgress</unmanaged-short>	
        internal void GetProgress(out int dwPercentCompleteRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwPercentCompleteRef_ = &dwPercentCompleteRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwPercentCompleteRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Begins an asynchronous request to create an object from a URL.</p><p>When the Source Resolver creates a media source from a URL, it passes the request to a scheme handler. The scheme handler might create a media source directly from the URL, or it might return a byte stream. If it returns a byte stream, the source resolver use a byte-stream handler to create the media source from the byte stream.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <em>dwFlags</em> parameter must contain the <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong> flag or the <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong> flag. If the <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong> flag is set, the scheme handler might create the media source directly from the URL, or it might create a byte stream. The type of object is returned in the <em>pObjectType</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.SchemeHandler.EndCreateObject"/></strong> method. If the scheme handler returns a byte stream, the source resolver will pass the byte stream to a byte-stream handler, which will create the media source from the byte stream.</p><p>If the <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong> flag is set, the scheme handler will attempt to create a byte stream from the URL. However, if the scheme handler is designed to create a media source directly, rather than a byte stream, the method will fail.</p><p>The following table summarizes the behavior of these two flags when passed to this method:</p><table> <tr><th>Flag</th><th>Object created</th></tr> <tr><td><strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong></td><td>Media source or byte stream</td></tr> <tr><td><strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong></td><td>Byte stream</td></tr> </table><p>?</p><p>The <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong> and <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong> flags can be combined, although in this case it is redundant.</p><p>When the operation completes, the scheme handler calls the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method. The Invoke method should call <strong><see cref="SharpDX.MediaFoundation.SchemeHandler.EndCreateObject"/></strong> to get a reference to the created object.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSchemeHandler']/*"/>	
    /// <msdn-id>bb970433</msdn-id>	
    /// <unmanaged>IMFSchemeHandler</unmanaged>	
    /// <unmanaged-short>IMFSchemeHandler</unmanaged-short>	
    [Guid("6D4C7B74-52A0-4bb7-B0DB-55F29F47A668")]
    public partial class SchemeHandler : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SchemeHandler"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SchemeHandler(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SchemeHandler"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SchemeHandler(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SchemeHandler(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Begins an asynchronous request to create an object from a URL.</p><p>When the Source Resolver creates a media source from a URL, it passes the request to a scheme handler. The scheme handler might create a media source directly from the URL, or it might return a byte stream. If it returns a byte stream, the source resolver use a byte-stream handler to create the media source from the byte stream.</p>	
        /// </summary>	
        /// <param name="wszURLRef">No documentation.</param>	
        /// <param name="dwFlags">No documentation.</param>	
        /// <param name="propsRef">No documentation.</param>	
        /// <param name="iUnknownCancelCookieOut">No documentation.</param>	
        /// <param name="callbackRef">No documentation.</param>	
        /// <param name="unkStateRef">No documentation.</param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_ACCESSDENIED</strong></dt> </dl> </td><td> <p> Cannot open the URL with the requested access (read or write). </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedByteStreamType"/></strong></dt> </dl> </td><td> <p> Unsupported byte stream type. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The <em>dwFlags</em> parameter must contain the <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong> flag or the <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong> flag. If the <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong> flag is set, the scheme handler might create the media source directly from the URL, or it might create a byte stream. The type of object is returned in the <em>pObjectType</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.SchemeHandler.EndCreateObject"/></strong> method. If the scheme handler returns a byte stream, the source resolver will pass the byte stream to a byte-stream handler, which will create the media source from the byte stream.</p><p>If the <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong> flag is set, the scheme handler will attempt to create a byte stream from the URL. However, if the scheme handler is designed to create a media source directly, rather than a byte stream, the method will fail.</p><p>The following table summarizes the behavior of these two flags when passed to this method:</p><table> <tr><th>Flag</th><th>Object created</th></tr> <tr><td><strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong></td><td>Media source or byte stream</td></tr> <tr><td><strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong></td><td>Byte stream</td></tr> </table><p>?</p><p>The <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong> and <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong> flags can be combined, although in this case it is redundant.</p><p>When the operation completes, the scheme handler calls the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method. The Invoke method should call <strong><see cref="SharpDX.MediaFoundation.SchemeHandler.EndCreateObject"/></strong> to get a reference to the created object.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSchemeHandler::BeginCreateObject']/*"/>	
        /// <msdn-id>bb970433</msdn-id>	
        /// <unmanaged>HRESULT IMFSchemeHandler::BeginCreateObject([In] const wchar_t* pwszURL,[In] unsigned int dwFlags,[In] IPropertyStore* pProps,[Out, Optional] IUnknown** ppIUnknownCancelCookie,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>	
        /// <unmanaged-short>IMFSchemeHandler::BeginCreateObject</unmanaged-short>	
        internal void BeginCreateObject_(string wszURLRef, int dwFlags, SharpDX.ComObject propsRef, out SharpDX.ComObject iUnknownCancelCookieOut, System.IntPtr callbackRef, SharpDX.ComObject unkStateRef)
        {
            unsafe
            {
                IntPtr iUnknownCancelCookieOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* wszURLRef_ = wszURLRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)wszURLRef_, dwFlags, (void*)((propsRef == null) ? IntPtr.Zero : propsRef.NativePointer), &iUnknownCancelCookieOut_, (void*)callbackRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                iUnknownCancelCookieOut = (iUnknownCancelCookieOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(iUnknownCancelCookieOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Completes an asynchronous request to create an object from a URL.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the Invoke method.</p> </dd></param>	
        /// <param name="objectTypeRef"><dd> <p>Receives a member of the <strong><see cref="SharpDX.MediaFoundation.ObjectType"/></strong> enumeration, specifying the type of object that was created.</p> </dd></param>	
        /// <param name="objectOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of the object. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_ABORT</strong></dt> </dl> </td><td> <p>The operation was canceled.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method from inside the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSchemeHandler::EndCreateObject']/*"/>	
        /// <msdn-id>bb970550</msdn-id>	
        /// <unmanaged>HRESULT IMFSchemeHandler::EndCreateObject([In] IMFAsyncResult* pResult,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>	
        /// <unmanaged-short>IMFSchemeHandler::EndCreateObject</unmanaged-short>	
        public void EndCreateObject(SharpDX.MediaFoundation.AsyncResult resultRef, out SharpDX.MediaFoundation.ObjectType objectTypeRef, out SharpDX.ComObject objectOut)
        {
            unsafe
            {
                IntPtr objectOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* objectTypeRef_ = &objectTypeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), objectTypeRef_, &objectOut_, ((void**)(*(void**)_nativePointer))[4]);
                objectOut = (objectOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(objectOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Cancels the current request to create an object from a URL.</p>	
        /// </summary>	
        /// <param name="iUnknownCancelCookieRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface that was returned in the <em>ppIUnknownCancelCookie</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.SchemeHandler.BeginCreateObject_"/></strong> method.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You can use this method to cancel a previous call to <strong>BeginCreateObject</strong>. Because that method is asynchronous, however, it might be completed before the operation can be canceled. Therefore, your callback might still be invoked after you call this method.</p><p>The operation cannot be canceled if <strong>BeginCreateObject</strong> returns <strong><c>null</c></strong> in the <em>ppIUnknownCancelCookie</em> parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSchemeHandler::CancelObjectCreation']/*"/>	
        /// <msdn-id>bb970419</msdn-id>	
        /// <unmanaged>HRESULT IMFSchemeHandler::CancelObjectCreation([In] IUnknown* pIUnknownCancelCookie)</unmanaged>	
        /// <unmanaged-short>IMFSchemeHandler::CancelObjectCreation</unmanaged-short>	
        public void CancelObjectCreation(SharpDX.ComObject iUnknownCancelCookieRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iUnknownCancelCookieRef == null) ? IntPtr.Zero : iUnknownCancelCookieRef.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Establishes a one-way secure channel between two objects. </p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSecureChannel']/*"/>	
    /// <msdn-id>ms693872</msdn-id>	
    /// <unmanaged>IMFSecureChannel</unmanaged>	
    /// <unmanaged-short>IMFSecureChannel</unmanaged-short>	
    [Guid("d0ae555d-3b12-4d97-b060-0990bc5aeb67")]
    public partial class SecureChannel : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SecureChannel"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SecureChannel(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SecureChannel"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SecureChannel(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SecureChannel(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the client's certificate.</p>	
        /// </summary>	
        /// <param name="certOut"><dd> <p>Receives a reference to a buffer allocated by the object. The buffer contains the client's certificate. The caller must release the buffer by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <param name="cbCertRef"><dd> <p>Receives the size of the <em>ppCert</em> buffer, in bytes.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSecureChannel::GetCertificate']/*"/>	
        /// <msdn-id>bb970528</msdn-id>	
        /// <unmanaged>HRESULT IMFSecureChannel::GetCertificate([Out, Buffer] unsigned char** ppCert,[Out] unsigned int* pcbCert)</unmanaged>	
        /// <unmanaged-short>IMFSecureChannel::GetCertificate</unmanaged-short>	
        public void GetCertificate(byte[] certOut, out int cbCertRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* certOut_ = certOut)
                fixed (void* cbCertRef_ = &cbCertRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, certOut_, cbCertRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Passes the encrypted session key to the client.</p>	
        /// </summary>	
        /// <param name="bEncryptedSessionKeyRef"><dd> <p>Pointer to a buffer that contains the encrypted session key. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="cbSessionKey"><dd> <p>Size of the <em>pbEncryptedSessionKey</em> buffer, in bytes.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSecureChannel::SetupSession']/*"/>	
        /// <msdn-id>bb970477</msdn-id>	
        /// <unmanaged>HRESULT IMFSecureChannel::SetupSession([In, Buffer] unsigned char* pbEncryptedSessionKey,[In] unsigned int cbSessionKey)</unmanaged>	
        /// <unmanaged-short>IMFSecureChannel::SetupSession</unmanaged-short>	
        public void SetupSession(byte[] bEncryptedSessionKeyRef, int cbSessionKey)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* bEncryptedSessionKeyRef_ = bEncryptedSessionKeyRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bEncryptedSessionKeyRef_, cbSessionKey, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>For a particular seek position, gets the two nearest key frames.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If an application seeks to a non?key frame, the decoder must start decoding from the previous key frame. This can increase latency, because several frames might get decoded before the requested frame is reached. To reduce latency, an application can call this method to find the two key frames that are closest to the desired time, and then seek to one of those key frames. </p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSeekInfo']/*"/>	
    /// <msdn-id>hh448055</msdn-id>	
    /// <unmanaged>IMFSeekInfo</unmanaged>	
    /// <unmanaged-short>IMFSeekInfo</unmanaged-short>	
    [Guid("26AFEA53-D9ED-42B5-AB80-E64F9EE34779")]
    public partial class SeekInfo : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SeekInfo"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SeekInfo(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SeekInfo"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SeekInfo(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SeekInfo(nativePointer);
        }


        /// <summary>	
        /// <p>For a particular seek position, gets the two nearest key frames.</p>	
        /// </summary>	
        /// <param name="guidTimeFormatRef"><dd> <p>A reference to a <see cref="System.Guid"/> that specifies the time format. The time format defines the units for the other parameters of this method. If the value is <strong>GUID_NULL</strong>, the time format is 100-nanosecond units. Some media sources might support additional time format GUIDs. </p> </dd></param>	
        /// <param name="varStartPositionRef"><dd> <p>The seek position. The units for this parameter are specified by <em>pguidTimeFormat</em>.</p> </dd></param>	
        /// <param name="varPreviousKeyFrameRef"><dd> <p>Receives the position of the nearest key frame that appears earlier than <em>pvarStartPosition</em>. The units for this parameter are specified by <em>pguidTimeFormat</em>.</p> </dd></param>	
        /// <param name="varNextKeyFrameRef"><dd> <p>Receives the position of the nearest key frame that appears earlier than <em>pvarStartPosition</em>. The units for this parameter are specified by <em>pguidTimeFormat</em>.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedTimeFormat"/></strong></dt> </dl> </td><td> <p>The time format specified in <em>pguidTimeFormat</em> is not supported.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If an application seeks to a non?key frame, the decoder must start decoding from the previous key frame. This can increase latency, because several frames might get decoded before the requested frame is reached. To reduce latency, an application can call this method to find the two key frames that are closest to the desired time, and then seek to one of those key frames. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSeekInfo::GetNearestKeyFrames']/*"/>	
        /// <msdn-id>hh448055</msdn-id>	
        /// <unmanaged>HRESULT IMFSeekInfo::GetNearestKeyFrames([In] const GUID* pguidTimeFormat,[In] const PROPVARIANT* pvarStartPosition,[Out] PROPVARIANT* pvarPreviousKeyFrame,[Out] PROPVARIANT* pvarNextKeyFrame)</unmanaged>	
        /// <unmanaged-short>IMFSeekInfo::GetNearestKeyFrames</unmanaged-short>	
        public void GetNearestKeyFrames(System.Guid guidTimeFormatRef, SharpDX.Win32.Variant varStartPositionRef, out SharpDX.Win32.Variant varPreviousKeyFrameRef, out SharpDX.Win32.Variant varNextKeyFrameRef)
        {
            unsafe
            {
                varPreviousKeyFrameRef = new SharpDX.Win32.Variant();
                varNextKeyFrameRef = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                fixed (void* varPreviousKeyFrameRef_ = &varPreviousKeyFrameRef)
                fixed (void* varNextKeyFrameRef_ = &varNextKeyFrameRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidTimeFormatRef, &varStartPositionRef, varPreviousKeyFrameRef_, varNextKeyFrameRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Implemented by the Microsoft Media Foundation sink writer object.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To create the sink writer, call one of the following functions:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSinkWriterFromMediaSink"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSinkWriterFromURL"/></strong> </li> </ul><p>Alternatively, use the <strong><see cref="SharpDX.MediaFoundation.ReadWriteClassFactory"/></strong> interface.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p><p>In Windows?8, this interface is extended with <strong><see cref="SharpDX.MediaFoundation.SinkWriterEx"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorDevice']/*"/>	
    /// <msdn-id>dd374642</msdn-id>	
    /// <unmanaged>IMFSensorDevice</unmanaged>	
    /// <unmanaged-short>IMFSensorDevice</unmanaged-short>	
    [Guid("FB9F48F2-2A18-4E28-9730-786F30F04DC4")]
    public partial class SensorDevice : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SensorDevice"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SensorDevice(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SensorDevice"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SensorDevice(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SensorDevice(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorDevice::GetDeviceId']/*"/>	
        /// <unmanaged>GetDeviceId</unmanaged>	
        /// <unmanaged-short>GetDeviceId</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSensorDevice::GetDeviceId([Out] unsigned longlong* pDeviceId)</unmanaged>
        public long DeviceId
        {
            get { long __output__; GetDeviceId(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorDevice::GetDeviceType']/*"/>	
        /// <unmanaged>GetDeviceType</unmanaged>	
        /// <unmanaged-short>GetDeviceType</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSensorDevice::GetDeviceType([Out] MFSensorDeviceType* pType)</unmanaged>
        public SharpDX.MediaFoundation.SensorDeviceType DeviceType
        {
            get { SharpDX.MediaFoundation.SensorDeviceType __output__; GetDeviceType(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorDevice::GetFlags']/*"/>	
        /// <unmanaged>GetFlags</unmanaged>	
        /// <unmanaged-short>GetFlags</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSensorDevice::GetFlags([Out] unsigned longlong* pFlags)</unmanaged>
        public long Flags
        {
            get { long __output__; GetFlags(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorDevice::GetDeviceAttributes']/*"/>	
        /// <unmanaged>GetDeviceAttributes</unmanaged>	
        /// <unmanaged-short>GetDeviceAttributes</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSensorDevice::GetDeviceAttributes([Out, Optional] IMFAttributes** ppAttributes)</unmanaged>
        public SharpDX.MediaFoundation.MediaAttributes DeviceAttributes
        {
            get { SharpDX.MediaFoundation.MediaAttributes __output__; GetDeviceAttributes(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorDevice::GetSensorDeviceMode']/*"/>	
        /// <unmanaged>GetSensorDeviceMode / SetSensorDeviceMode</unmanaged>	
        /// <unmanaged-short>GetSensorDeviceMode</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSensorDevice::GetSensorDeviceMode([Out] MFSensorDeviceMode* peMode)</unmanaged>
        public SharpDX.MediaFoundation.SensorDeviceMode SensorDeviceMode
        {
            get { SharpDX.MediaFoundation.SensorDeviceMode __output__; GetSensorDeviceMode(out __output__); return __output__; }
            set { SetSensorDeviceMode(value); }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="deviceIdRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorDevice::GetDeviceId']/*"/>	
        /// <unmanaged>HRESULT IMFSensorDevice::GetDeviceId([Out] unsigned longlong* pDeviceId)</unmanaged>	
        /// <unmanaged-short>IMFSensorDevice::GetDeviceId</unmanaged-short>	
        internal void GetDeviceId(out long deviceIdRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* deviceIdRef_ = &deviceIdRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, deviceIdRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="typeRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorDevice::GetDeviceType']/*"/>	
        /// <unmanaged>HRESULT IMFSensorDevice::GetDeviceType([Out] MFSensorDeviceType* pType)</unmanaged>	
        /// <unmanaged-short>IMFSensorDevice::GetDeviceType</unmanaged-short>	
        internal void GetDeviceType(out SharpDX.MediaFoundation.SensorDeviceType typeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* typeRef_ = &typeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, typeRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="flagsRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorDevice::GetFlags']/*"/>	
        /// <unmanaged>HRESULT IMFSensorDevice::GetFlags([Out] unsigned longlong* pFlags)</unmanaged>	
        /// <unmanaged-short>IMFSensorDevice::GetFlags</unmanaged-short>	
        internal void GetFlags(out long flagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* flagsRef_ = &flagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, flagsRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="symbolicLink">No documentation.</param>	
        /// <param name="cchSymbolicLink">No documentation.</param>	
        /// <param name="cchWrittenRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorDevice::GetSymbolicLink']/*"/>	
        /// <unmanaged>HRESULT IMFSensorDevice::GetSymbolicLink([Out, Buffer] wchar_t* SymbolicLink,[In] int cchSymbolicLink,[Out] int* pcchWritten)</unmanaged>	
        /// <unmanaged-short>IMFSensorDevice::GetSymbolicLink</unmanaged-short>	
        public void GetSymbolicLink(System.IntPtr symbolicLink, int cchSymbolicLink, out int cchWrittenRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cchWrittenRef_ = &cchWrittenRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)symbolicLink, cchSymbolicLink, cchWrittenRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="attributesOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorDevice::GetDeviceAttributes']/*"/>	
        /// <unmanaged>HRESULT IMFSensorDevice::GetDeviceAttributes([Out, Optional] IMFAttributes** ppAttributes)</unmanaged>	
        /// <unmanaged-short>IMFSensorDevice::GetDeviceAttributes</unmanaged-short>	
        internal void GetDeviceAttributes(out SharpDX.MediaFoundation.MediaAttributes attributesOut)
        {
            unsafe
            {
                IntPtr attributesOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &attributesOut_, ((void**)(*(void**)_nativePointer))[7]);
                attributesOut = (attributesOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(attributesOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="eType">No documentation.</param>	
        /// <param name="dwCountRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorDevice::GetStreamAttributesCount']/*"/>	
        /// <unmanaged>HRESULT IMFSensorDevice::GetStreamAttributesCount([In] MFSensorStreamType eType,[Out] unsigned int* pdwCount)</unmanaged>	
        /// <unmanaged-short>IMFSensorDevice::GetStreamAttributesCount</unmanaged-short>	
        public void GetStreamAttributesCount(SharpDX.MediaFoundation.SensorStreamType eType, out int dwCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwCountRef_ = &dwCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)eType), dwCountRef_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="eType">No documentation.</param>	
        /// <param name="dwIndex">No documentation.</param>	
        /// <param name="attributesOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorDevice::GetStreamAttributes']/*"/>	
        /// <unmanaged>HRESULT IMFSensorDevice::GetStreamAttributes([In] MFSensorStreamType eType,[In] unsigned int dwIndex,[Out] IMFAttributes** ppAttributes)</unmanaged>	
        /// <unmanaged-short>IMFSensorDevice::GetStreamAttributes</unmanaged-short>	
        public void GetStreamAttributes(SharpDX.MediaFoundation.SensorStreamType eType, int dwIndex, out SharpDX.MediaFoundation.MediaAttributes attributesOut)
        {
            unsafe
            {
                IntPtr attributesOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)eType), dwIndex, &attributesOut_, ((void**)(*(void**)_nativePointer))[9]);
                attributesOut = (attributesOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(attributesOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="eMode">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorDevice::SetSensorDeviceMode']/*"/>	
        /// <unmanaged>HRESULT IMFSensorDevice::SetSensorDeviceMode([In] MFSensorDeviceMode eMode)</unmanaged>	
        /// <unmanaged-short>IMFSensorDevice::SetSensorDeviceMode</unmanaged-short>	
        internal void SetSensorDeviceMode(SharpDX.MediaFoundation.SensorDeviceMode eMode)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)eMode), ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="eModeRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorDevice::GetSensorDeviceMode']/*"/>	
        /// <unmanaged>HRESULT IMFSensorDevice::GetSensorDeviceMode([Out] MFSensorDeviceMode* peMode)</unmanaged>	
        /// <unmanaged-short>IMFSensorDevice::GetSensorDeviceMode</unmanaged-short>	
        internal void GetSensorDeviceMode(out SharpDX.MediaFoundation.SensorDeviceMode eModeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* eModeRef_ = &eModeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, eModeRef_, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Implemented by the Microsoft Media Foundation sink writer object.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To create the sink writer, call one of the following functions:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSinkWriterFromMediaSink"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSinkWriterFromURL"/></strong> </li> </ul><p>Alternatively, use the <strong><see cref="SharpDX.MediaFoundation.ReadWriteClassFactory"/></strong> interface.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p><p>In Windows?8, this interface is extended with <strong><see cref="SharpDX.MediaFoundation.SinkWriterEx"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorGroup']/*"/>	
    /// <msdn-id>dd374642</msdn-id>	
    /// <unmanaged>IMFSensorGroup</unmanaged>	
    /// <unmanaged-short>IMFSensorGroup</unmanaged-short>	
    [Guid("4110243A-9757-461F-89F1-F22345BCAB4E")]
    public partial class SensorGroup : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SensorGroup"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SensorGroup(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SensorGroup"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SensorGroup(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SensorGroup(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorGroup::GetFlags']/*"/>	
        /// <unmanaged>GetFlags</unmanaged>	
        /// <unmanaged-short>GetFlags</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSensorGroup::GetFlags([Out] unsigned longlong* pFlags)</unmanaged>
        public long Flags
        {
            get { long __output__; GetFlags(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorGroup::GetSensorGroupAttributes']/*"/>	
        /// <unmanaged>GetSensorGroupAttributes</unmanaged>	
        /// <unmanaged-short>GetSensorGroupAttributes</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSensorGroup::GetSensorGroupAttributes([Out, Optional] IMFAttributes** ppAttributes)</unmanaged>
        public SharpDX.MediaFoundation.MediaAttributes SensorGroupAttributes
        {
            get { SharpDX.MediaFoundation.MediaAttributes __output__; GetSensorGroupAttributes(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorGroup::GetSensorDeviceCount']/*"/>	
        /// <unmanaged>GetSensorDeviceCount</unmanaged>	
        /// <unmanaged-short>GetSensorDeviceCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSensorGroup::GetSensorDeviceCount([Out] unsigned int* pdwCount)</unmanaged>
        public int SensorDeviceCount
        {
            get { int __output__; GetSensorDeviceCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorGroup::GetDefaultSensorDeviceIndex']/*"/>	
        /// <unmanaged>GetDefaultSensorDeviceIndex / SetDefaultSensorDeviceIndex</unmanaged>	
        /// <unmanaged-short>GetDefaultSensorDeviceIndex</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSensorGroup::GetDefaultSensorDeviceIndex([Out] unsigned int* pdwIndex)</unmanaged>
        public int DefaultSensorDeviceIndex
        {
            get { int __output__; GetDefaultSensorDeviceIndex(out __output__); return __output__; }
            set { SetDefaultSensorDeviceIndex(value); }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="symbolicLink">No documentation.</param>	
        /// <param name="cchSymbolicLink">No documentation.</param>	
        /// <param name="cchWrittenRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorGroup::GetSymbolicLink']/*"/>	
        /// <unmanaged>HRESULT IMFSensorGroup::GetSymbolicLink([Out, Buffer] wchar_t* SymbolicLink,[In] int cchSymbolicLink,[Out] int* pcchWritten)</unmanaged>	
        /// <unmanaged-short>IMFSensorGroup::GetSymbolicLink</unmanaged-short>	
        public void GetSymbolicLink(System.IntPtr symbolicLink, int cchSymbolicLink, out int cchWrittenRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cchWrittenRef_ = &cchWrittenRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)symbolicLink, cchSymbolicLink, cchWrittenRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="flagsRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorGroup::GetFlags']/*"/>	
        /// <unmanaged>HRESULT IMFSensorGroup::GetFlags([Out] unsigned longlong* pFlags)</unmanaged>	
        /// <unmanaged-short>IMFSensorGroup::GetFlags</unmanaged-short>	
        internal void GetFlags(out long flagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* flagsRef_ = &flagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, flagsRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="attributesOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorGroup::GetSensorGroupAttributes']/*"/>	
        /// <unmanaged>HRESULT IMFSensorGroup::GetSensorGroupAttributes([Out, Optional] IMFAttributes** ppAttributes)</unmanaged>	
        /// <unmanaged-short>IMFSensorGroup::GetSensorGroupAttributes</unmanaged-short>	
        internal void GetSensorGroupAttributes(out SharpDX.MediaFoundation.MediaAttributes attributesOut)
        {
            unsafe
            {
                IntPtr attributesOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &attributesOut_, ((void**)(*(void**)_nativePointer))[5]);
                attributesOut = (attributesOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(attributesOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwCountRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorGroup::GetSensorDeviceCount']/*"/>	
        /// <unmanaged>HRESULT IMFSensorGroup::GetSensorDeviceCount([Out] unsigned int* pdwCount)</unmanaged>	
        /// <unmanaged-short>IMFSensorGroup::GetSensorDeviceCount</unmanaged-short>	
        internal void GetSensorDeviceCount(out int dwCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwCountRef_ = &dwCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwCountRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwIndex">No documentation.</param>	
        /// <param name="deviceOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorGroup::GetSensorDevice']/*"/>	
        /// <unmanaged>HRESULT IMFSensorGroup::GetSensorDevice([In] unsigned int dwIndex,[Out] IMFSensorDevice** ppDevice)</unmanaged>	
        /// <unmanaged-short>IMFSensorGroup::GetSensorDevice</unmanaged-short>	
        public void GetSensorDevice(int dwIndex, out SharpDX.MediaFoundation.SensorDevice deviceOut)
        {
            unsafe
            {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwIndex, &deviceOut_, ((void**)(*(void**)_nativePointer))[7]);
                deviceOut = (deviceOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.SensorDevice(deviceOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwIndex">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorGroup::SetDefaultSensorDeviceIndex']/*"/>	
        /// <unmanaged>HRESULT IMFSensorGroup::SetDefaultSensorDeviceIndex([In] unsigned int dwIndex)</unmanaged>	
        /// <unmanaged-short>IMFSensorGroup::SetDefaultSensorDeviceIndex</unmanaged-short>	
        internal void SetDefaultSensorDeviceIndex(int dwIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwIndex, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwIndexRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorGroup::GetDefaultSensorDeviceIndex']/*"/>	
        /// <unmanaged>HRESULT IMFSensorGroup::GetDefaultSensorDeviceIndex([Out] unsigned int* pdwIndex)</unmanaged>	
        /// <unmanaged-short>IMFSensorGroup::GetDefaultSensorDeviceIndex</unmanaged-short>	
        internal void GetDefaultSensorDeviceIndex(out int dwIndexRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwIndexRef_ = &dwIndexRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwIndexRef_, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="sourceOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorGroup::CreateMediaSource']/*"/>	
        /// <unmanaged>HRESULT IMFSensorGroup::CreateMediaSource([Out] IMFMediaSource** ppSource)</unmanaged>	
        /// <unmanaged-short>IMFSensorGroup::CreateMediaSource</unmanaged-short>	
        public void CreateMediaSource(out SharpDX.MediaFoundation.MediaSource sourceOut)
        {
            unsafe
            {
                IntPtr sourceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &sourceOut_, ((void**)(*(void**)_nativePointer))[10]);
                sourceOut = (sourceOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSource(sourceOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p></p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorStream']/*"/>	
    /// <msdn-id>mt797960</msdn-id>	
    /// <unmanaged>IMFSensorStream</unmanaged>	
    /// <unmanaged-short>IMFSensorStream</unmanaged-short>	
    [Guid("E9A42171-C56E-498A-8B39-EDA5A070B7FC")]
    public partial class SensorStream : SharpDX.MediaFoundation.MediaAttributes
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SensorStream"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SensorStream(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SensorStream"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SensorStream(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SensorStream(nativePointer);
        }


        /// <summary>	
        /// <p></p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorStream::GetMediaTypeCount']/*"/>	
        /// <msdn-id>mt797960</msdn-id>	
        /// <unmanaged>GetMediaTypeCount</unmanaged>	
        /// <unmanaged-short>GetMediaTypeCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSensorStream::GetMediaTypeCount([Out] unsigned int* pdwCount)</unmanaged>
        public int MediaTypeCount
        {
            get { int __output__; GetMediaTypeCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p></p>	
        /// </summary>	
        /// <param name="dwCountRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorStream::GetMediaTypeCount']/*"/>	
        /// <msdn-id>mt797960</msdn-id>	
        /// <unmanaged>HRESULT IMFSensorStream::GetMediaTypeCount([Out] unsigned int* pdwCount)</unmanaged>	
        /// <unmanaged-short>IMFSensorStream::GetMediaTypeCount</unmanaged-short>	
        internal void GetMediaTypeCount(out int dwCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwCountRef_ = &dwCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwCountRef_, ((void**)(*(void**)_nativePointer))[33]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p></p>	
        /// </summary>	
        /// <param name="dwIndex">No documentation.</param>	
        /// <param name="mediaTypeOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorStream::GetMediaType']/*"/>	
        /// <msdn-id>mt797960</msdn-id>	
        /// <unmanaged>HRESULT IMFSensorStream::GetMediaType([In] unsigned int dwIndex,[Out] IMFMediaType** ppMediaType)</unmanaged>	
        /// <unmanaged-short>IMFSensorStream::GetMediaType</unmanaged-short>	
        public void GetMediaType(int dwIndex, out SharpDX.MediaFoundation.MediaType mediaTypeOut)
        {
            unsafe
            {
                IntPtr mediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwIndex, &mediaTypeOut_, ((void**)(*(void**)_nativePointer))[34]);
                mediaTypeOut = (mediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(mediaTypeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="streamOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorStream::CloneSensorStream']/*"/>	
        /// <unmanaged>HRESULT IMFSensorStream::CloneSensorStream([Out] IMFSensorStream** ppStream)</unmanaged>	
        /// <unmanaged-short>IMFSensorStream::CloneSensorStream</unmanaged-short>	
        public void CloneSensorStream(out SharpDX.MediaFoundation.SensorStream streamOut)
        {
            unsafe
            {
                IntPtr streamOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &streamOut_, ((void**)(*(void**)_nativePointer))[35]);
                streamOut = (streamOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.SensorStream(streamOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Implemented by the Microsoft Media Foundation sink writer object.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To create the sink writer, call one of the following functions:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSinkWriterFromMediaSink"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSinkWriterFromURL"/></strong> </li> </ul><p>Alternatively, use the <strong><see cref="SharpDX.MediaFoundation.ReadWriteClassFactory"/></strong> interface.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p><p>In Windows?8, this interface is extended with <strong><see cref="SharpDX.MediaFoundation.SinkWriterEx"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorTransformFactory']/*"/>	
    /// <msdn-id>dd374642</msdn-id>	
    /// <unmanaged>IMFSensorTransformFactory</unmanaged>	
    /// <unmanaged-short>IMFSensorTransformFactory</unmanaged-short>	
    [Guid("EED9C2EE-66B4-4F18-A697-AC7D3960215C")]
    public partial class SensorTransformFactory : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SensorTransformFactory"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SensorTransformFactory(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SensorTransformFactory"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SensorTransformFactory(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SensorTransformFactory(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorTransformFactory::GetFactoryAttributes']/*"/>	
        /// <unmanaged>GetFactoryAttributes</unmanaged>	
        /// <unmanaged-short>GetFactoryAttributes</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSensorTransformFactory::GetFactoryAttributes([Out] IMFAttributes** ppAttributes)</unmanaged>
        public SharpDX.MediaFoundation.MediaAttributes FactoryAttributes
        {
            get { SharpDX.MediaFoundation.MediaAttributes __output__; GetFactoryAttributes(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorTransformFactory::GetTransformCount']/*"/>	
        /// <unmanaged>GetTransformCount</unmanaged>	
        /// <unmanaged-short>GetTransformCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSensorTransformFactory::GetTransformCount([Out] unsigned int* pdwCount)</unmanaged>
        public int TransformCount
        {
            get { int __output__; GetTransformCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="attributesOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorTransformFactory::GetFactoryAttributes']/*"/>	
        /// <unmanaged>HRESULT IMFSensorTransformFactory::GetFactoryAttributes([Out] IMFAttributes** ppAttributes)</unmanaged>	
        /// <unmanaged-short>IMFSensorTransformFactory::GetFactoryAttributes</unmanaged-short>	
        internal void GetFactoryAttributes(out SharpDX.MediaFoundation.MediaAttributes attributesOut)
        {
            unsafe
            {
                IntPtr attributesOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &attributesOut_, ((void**)(*(void**)_nativePointer))[3]);
                attributesOut = (attributesOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(attributesOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwMaxTransformCount">No documentation.</param>	
        /// <param name="sensorDevicesRef">No documentation.</param>	
        /// <param name="attributesRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorTransformFactory::InitializeFactory']/*"/>	
        /// <unmanaged>HRESULT IMFSensorTransformFactory::InitializeFactory([In] unsigned int dwMaxTransformCount,[In] IMFCollection* pSensorDevices,[In, Optional] IMFAttributes* pAttributes)</unmanaged>	
        /// <unmanaged-short>IMFSensorTransformFactory::InitializeFactory</unmanaged-short>	
        public void InitializeFactory(int dwMaxTransformCount, SharpDX.MediaFoundation.Collection sensorDevicesRef, SharpDX.MediaFoundation.MediaAttributes attributesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwMaxTransformCount, (void*)((sensorDevicesRef == null) ? IntPtr.Zero : sensorDevicesRef.NativePointer), (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwCountRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorTransformFactory::GetTransformCount']/*"/>	
        /// <unmanaged>HRESULT IMFSensorTransformFactory::GetTransformCount([Out] unsigned int* pdwCount)</unmanaged>	
        /// <unmanaged-short>IMFSensorTransformFactory::GetTransformCount</unmanaged-short>	
        internal void GetTransformCount(out int dwCountRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwCountRef_ = &dwCountRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwCountRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Called by the media pipeline to get information about a transform provided by the  sensor transform.</p>	
        /// </summary>	
        /// <param name="transformIndex"><dd> <p>The index of the transform for which information is being requested. In the current release, this value will always be 0.</p> </dd></param>	
        /// <param name="guidTransformIdRef"><dd> <p>Gets the identifier for the transform.</p> </dd></param>	
        /// <param name="attributesOut"><dd> <p>The attribute store to be populated.</p> </dd></param>	
        /// <param name="streamInformationOut"><dd> <p>A collection of <strong><see cref="SharpDX.MediaFoundation.SensorStream"/></strong> objects.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorTransformFactory::GetTransformInformation']/*"/>	
        /// <msdn-id>mt797967</msdn-id>	
        /// <unmanaged>HRESULT IMFSensorTransformFactory::GetTransformInformation([In] unsigned int TransformIndex,[Out] GUID* pguidTransformId,[Out, Optional] IMFAttributes** ppAttributes,[Out] IMFCollection** ppStreamInformation)</unmanaged>	
        /// <unmanaged-short>IMFSensorTransformFactory::GetTransformInformation</unmanaged-short>	
        public void GetTransformInformation(int transformIndex, out System.Guid guidTransformIdRef, out SharpDX.MediaFoundation.MediaAttributes attributesOut, out SharpDX.MediaFoundation.Collection streamInformationOut)
        {
            unsafe
            {
                guidTransformIdRef = new System.Guid();
                IntPtr attributesOut_ = IntPtr.Zero;
                IntPtr streamInformationOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* guidTransformIdRef_ = &guidTransformIdRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, transformIndex, guidTransformIdRef_, &attributesOut_, &streamInformationOut_, ((void**)(*(void**)_nativePointer))[6]);
                attributesOut = (attributesOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(attributesOut_);
                streamInformationOut = (streamInformationOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Collection(streamInformationOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="guidSensorTransformID">No documentation.</param>	
        /// <param name="attributesRef">No documentation.</param>	
        /// <param name="deviceMFTOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSensorTransformFactory::CreateTransform']/*"/>	
        /// <unmanaged>HRESULT IMFSensorTransformFactory::CreateTransform([In] const GUID&amp; guidSensorTransformID,[In, Optional] IMFAttributes* pAttributes,[Out] IMFDeviceTransform** ppDeviceMFT)</unmanaged>	
        /// <unmanaged-short>IMFSensorTransformFactory::CreateTransform</unmanaged-short>	
        public void CreateTransform(System.Guid guidSensorTransformID, SharpDX.MediaFoundation.MediaAttributes attributesRef, out SharpDX.MediaFoundation.DeviceTransform deviceMFTOut)
        {
            unsafe
            {
                IntPtr deviceMFTOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidSensorTransformID, (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), &deviceMFTOut_, ((void**)(*(void**)_nativePointer))[7]);
                deviceMFTOut = (deviceMFTOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.DeviceTransform(deviceMFTOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Implemented by the Sequencer Source. The sequencer source enables an application to create a sequence of topologies. To create the sequencer source, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSequencerSource"/></strong>. For step-by-step instructions about how to create a playlist, see How to Create a Playlist.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSequencerSource']/*"/>	
    /// <msdn-id>ms702972</msdn-id>	
    /// <unmanaged>IMFSequencerSource</unmanaged>	
    /// <unmanaged-short>IMFSequencerSource</unmanaged-short>	
    [Guid("197CD219-19CB-4de1-A64C-ACF2EDCBE59E")]
    public partial class SequencerSource : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SequencerSource"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SequencerSource(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SequencerSource"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SequencerSource(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SequencerSource(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Adds a topology to the end of the queue.</p>	
        /// </summary>	
        /// <param name="topologyRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.Topology"/></strong> interface of the topology. This reference cannot be <strong><c>null</c></strong>. If an application passes <strong><c>null</c></strong>, the call fails with an E_INVALIDARG error code.</p> </dd></param>	
        /// <param name="dwFlags"><dd> <p>A combination of flags from the <strong><see cref="SharpDX.MediaFoundation.SequencerTopologyFlags"/></strong> enumeration.</p> </dd></param>	
        /// <param name="dwIdRef"><dd> <p>Receives the sequencer element identifier for this topology.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Attributenotfound"/></strong></dt> </dl> </td><td> <p>The source topology node is missing one of the following attributes:</p> <ul> <li> <p> <strong><see cref="SharpDX.MediaFoundation.TopologyNodeAttributeKeys.StreamDescriptor"/></strong> </p> </li> <li> <p> <strong><see cref="SharpDX.MediaFoundation.TopologyNodeAttributeKeys.PresentationDescriptor"/></strong> </p> </li> <li> <p> <strong><see cref="SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Source"/></strong> </p> </li> </ul> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The sequencer plays topologies in the order they are queued. You can queue as many topologies as you want to preroll.</p><p>The application must indicate to the sequencer when it has queued the last topology on the Media Session. To specify the last topology, set the SequencerTopologyFlags_Last flag in the <em>dwFlags</em> parameter when you append the topology. The sequencer uses this information to end playback with the pipeline. Otherwise, the sequencer waits indefinitely for a new topology to be queued.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSequencerSource::AppendTopology']/*"/>	
        /// <msdn-id>ms697046</msdn-id>	
        /// <unmanaged>HRESULT IMFSequencerSource::AppendTopology([In] IMFTopology* pTopology,[In] unsigned int dwFlags,[Out] unsigned int* pdwId)</unmanaged>	
        /// <unmanaged-short>IMFSequencerSource::AppendTopology</unmanaged-short>	
        public void AppendTopology(SharpDX.MediaFoundation.Topology topologyRef, int dwFlags, out int dwIdRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwIdRef_ = &dwIdRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((topologyRef == null) ? IntPtr.Zero : topologyRef.NativePointer), dwFlags, dwIdRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Deletes a topology from the queue.</p>	
        /// </summary>	
        /// <param name="dwId"><dd> <p>The sequencer element identifier of the topology to delete.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSequencerSource::DeleteTopology']/*"/>	
        /// <msdn-id>bb970428</msdn-id>	
        /// <unmanaged>HRESULT IMFSequencerSource::DeleteTopology([In] unsigned int dwId)</unmanaged>	
        /// <unmanaged-short>IMFSequencerSource::DeleteTopology</unmanaged-short>	
        public void DeleteTopology(int dwId)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwId, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Maps a presentation descriptor to its associated sequencer element identifier and the topology it represents.</p>	
        /// </summary>	
        /// <param name="pDRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the presentation descriptor.</p> </dd></param>	
        /// <param name="idRef"><dd> <p>Receives the sequencer element identifier. This value is assigned by the sequencer source when the application calls <strong><see cref="SharpDX.MediaFoundation.SequencerSource.AppendTopology"/></strong>. This parameter is optional and can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="topologyOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Topology"/></strong> interface of the original topology that the application added to the sequencer source. The caller must release the interface. This parameter can receive the value <strong><c>null</c></strong> if the sequencer source has switched to the next presentation. This parameter is optional and can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The presentation descriptor is not valid.</p> </td></tr> <tr><td> <dl> <dt><strong>MF_S_SEQUENCER_CONTEXT_CANCELED</strong></dt> </dl> </td><td> <p>This segment was canceled.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The topology returned in <em>ppTopology</em> is the original topology that the application specified in <strong>AppendTopology</strong>. The source nodes in this topology contain references to the native sources. Do not queue this topology on the Media Session. Instead, call <strong><see cref="SharpDX.MediaFoundation.MediaSourceTopologyProvider.GetMediaSourceTopology"/></strong> to get the sequencer source's modified topology. The source nodes in the modified topology contain references to the sequencer source, rather than the native sources.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSequencerSource::GetPresentationContext']/*"/>	
        /// <msdn-id>bb970514</msdn-id>	
        /// <unmanaged>HRESULT IMFSequencerSource::GetPresentationContext([In] IMFPresentationDescriptor* pPD,[Out, Optional] unsigned int* pId,[Out, Optional] IMFTopology** ppTopology)</unmanaged>	
        /// <unmanaged-short>IMFSequencerSource::GetPresentationContext</unmanaged-short>	
        public void GetPresentationContext(SharpDX.MediaFoundation.PresentationDescriptor pDRef, out int idRef, out SharpDX.MediaFoundation.Topology topologyOut)
        {
            unsafe
            {
                IntPtr topologyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* idRef_ = &idRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((pDRef == null) ? IntPtr.Zero : pDRef.NativePointer), idRef_, &topologyOut_, ((void**)(*(void**)_nativePointer))[5]);
                topologyOut = (topologyOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Topology(topologyOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Updates a topology in the queue.</p>	
        /// </summary>	
        /// <param name="dwId"><dd> <p>Sequencer element identifier of the topology to update.</p> </dd></param>	
        /// <param name="topologyRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.Topology"/></strong> interface of the updated topology object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The sequencer source has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is asynchronous. When the operation is completed, the sequencer source sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.SequencerSourceTopologyUpdated"/> event.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSequencerSource::UpdateTopology']/*"/>	
        /// <msdn-id>bb970402</msdn-id>	
        /// <unmanaged>HRESULT IMFSequencerSource::UpdateTopology([In] unsigned int dwId,[In] IMFTopology* pTopology)</unmanaged>	
        /// <unmanaged-short>IMFSequencerSource::UpdateTopology</unmanaged-short>	
        public void UpdateTopology(int dwId, SharpDX.MediaFoundation.Topology topologyRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwId, (void*)((topologyRef == null) ? IntPtr.Zero : topologyRef.NativePointer), ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Updates the flags for a topology in the queue.</p>	
        /// </summary>	
        /// <param name="dwId"><dd> <p>Sequencer element identifier of the topology to update.</p> </dd></param>	
        /// <param name="dwFlags"><dd> <p>Bitwise <strong>OR</strong> of flags from the <strong><see cref="SharpDX.MediaFoundation.SequencerTopologyFlags"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSequencerSource::UpdateTopologyFlags']/*"/>	
        /// <msdn-id>bb970564</msdn-id>	
        /// <unmanaged>HRESULT IMFSequencerSource::UpdateTopologyFlags([In] unsigned int dwId,[In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IMFSequencerSource::UpdateTopologyFlags</unmanaged-short>	
        public void UpdateTopologyFlags(int dwId, int dwFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwId, dwFlags, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Queries an object for a specified service interface. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A service is an interface that is exposed by one object but might be implemented by another object. The <strong>GetService</strong> method is equivalent to <strong>QueryInterface</strong>, with the following difference: when <strong>QueryInterface</strong> retrieves a reference to an interface, it is guaranteed that you can query the returned interface and get back the original interface. The <strong>GetService</strong> method does not make this guarantee, because the retrieved interface might be implemented by a separate object.</p><p>The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.GetService"/></strong> function is a helper function that queries an object for <strong><see cref="SharpDX.MediaFoundation.ServiceProvider"/></strong> and calls the <strong>GetService</strong> method.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFGetService']/*"/>	
    /// <msdn-id>ms694261</msdn-id>	
    /// <unmanaged>IMFGetService</unmanaged>	
    /// <unmanaged-short>IMFGetService</unmanaged-short>	
    [Guid("fa993888-4383-415a-a930-dd472a8cf6f7")]
    public partial class ServiceProvider : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.ServiceProvider"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ServiceProvider(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.ServiceProvider"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.ServiceProvider(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.ServiceProvider(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves a service interface.</p>	
        /// </summary>	
        /// <param name="guidService"><dd> <p>The service identifier (SID) of the service. For a list of service identifiers, see Service Interfaces.</p> </dd></param>	
        /// <param name="riid"><dd> <p>The interface identifier (IID) of the interface being requested.</p> </dd></param>	
        /// <returns><dd> <p>Receives the interface reference. The caller must release the interface.</p> </dd></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFGetService::GetService']/*"/>	
        /// <msdn-id>ms696978</msdn-id>	
        /// <unmanaged>HRESULT IMFGetService::GetService([In] const GUID&amp; guidService,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>	
        /// <unmanaged-short>IMFGetService::GetService</unmanaged-short>	
        public System.IntPtr GetService(System.Guid guidService, System.Guid riid)
        {
            unsafe
            {
                System.IntPtr vObjectOut;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidService, &riid, &vObjectOut, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
                return vObjectOut;
            }
        }
    }
    /// <summary>	
    /// <p> Exposed by some Media Foundation objects that must be explicitly shut down. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The following types of object expose <strong><see cref="SharpDX.MediaFoundation.Shutdownable"/></strong>:</p><ul> <li> Content enablers (<strong><see cref="SharpDX.MediaFoundation.ContentEnabler"/></strong> interface) </li> <li> Input trust authorities (<strong><see cref="SharpDX.MediaFoundation.InputTrustAuthority"/></strong> interface) </li> <li> Presentation clocks (<strong><see cref="SharpDX.MediaFoundation.PresentationClock"/></strong> interface) </li> <li> Asynchronous MFTs </li> </ul><p> Any component that creates one of these objects is responsible for calling <strong>Shutdown</strong> on the object before releasing the object. Typically, applications do not create any of these objects directly, so it is not usually necessary to use this interface in an application. </p><p> To obtain a reference to this interface, call <strong>QueryInterface</strong> on the object. </p><p> If you are implementing a custom object, your object can expose this interface, but only if you can guarantee that your application will call <strong>Shutdown</strong>. </p><p>Media sources, media sinks, and <em>synchronous</em> MFTs should not implement this interface, because the Media Foundation pipeline will not call <strong>Shutdown</strong> on these objects. Asynchronous MFTs must implement this interface.</p><p> This interface is not related to the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> function, which shuts down the Media Foundation platform, as described in Initializing Media Foundation. </p><p> Some Media Foundation interfaces define a <strong>Shutdown</strong> method, which serves the same purpose as <strong><see cref="SharpDX.MediaFoundation.Shutdownable.Shutdown"/></strong> but is not directly related to it. </p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFShutdown']/*"/>	
    /// <msdn-id>ms703054</msdn-id>	
    /// <unmanaged>IMFShutdown</unmanaged>	
    /// <unmanaged-short>IMFShutdown</unmanaged-short>	
    [Guid("97ec2ea4-0e42-4937-97ac-9d6d328824e1")]
    public partial class Shutdownable : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.Shutdownable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Shutdownable(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.Shutdownable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.Shutdownable(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.Shutdownable(nativePointer);
        }


        /// <summary>	
        /// <p> Queries the status of an earlier call to the <strong><see cref="SharpDX.MediaFoundation.Shutdownable.Shutdown"/></strong> method. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Until <strong>Shutdown</strong> is called, the <strong>GetShutdownStatus</strong> method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong>.</p><p>If an object's <strong>Shutdown</strong> method is asynchronous, <em>pStatus</em> might receive the value <strong><see cref="SharpDX.MediaFoundation.ShutdownStatus.Initiated"/></strong>. When the object is completely shut down, <em>pStatus</em> receives the value <strong><see cref="SharpDX.MediaFoundation.ShutdownStatus.Completed"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFShutdown::GetShutdownStatus']/*"/>	
        /// <msdn-id>bb970451</msdn-id>	
        /// <unmanaged>GetShutdownStatus</unmanaged>	
        /// <unmanaged-short>GetShutdownStatus</unmanaged-short>	
        /// <unmanaged>HRESULT IMFShutdown::GetShutdownStatus([Out] MFSHUTDOWN_STATUS* pStatus)</unmanaged>
        public SharpDX.MediaFoundation.ShutdownStatus ShutdownStatus
        {
            get { SharpDX.MediaFoundation.ShutdownStatus __output__; GetShutdownStatus(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Shuts down a Media Foundation object and releases all resources associated with the object. </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.MediaFoundation.MediaFactory.ShutdownObject"/></strong> helper function is equivalent to calling this method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFShutdown::Shutdown']/*"/>	
        /// <msdn-id>ms701615</msdn-id>	
        /// <unmanaged>HRESULT IMFShutdown::Shutdown()</unmanaged>	
        /// <unmanaged-short>IMFShutdown::Shutdown</unmanaged-short>	
        public void Shutdown()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Queries the status of an earlier call to the <strong><see cref="SharpDX.MediaFoundation.Shutdownable.Shutdown"/></strong> method. </p>	
        /// </summary>	
        /// <param name="statusRef">No documentation.</param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p> The <strong>Shutdown</strong> method has not been called on this object. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Until <strong>Shutdown</strong> is called, the <strong>GetShutdownStatus</strong> method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong>.</p><p>If an object's <strong>Shutdown</strong> method is asynchronous, <em>pStatus</em> might receive the value <strong><see cref="SharpDX.MediaFoundation.ShutdownStatus.Initiated"/></strong>. When the object is completely shut down, <em>pStatus</em> receives the value <strong><see cref="SharpDX.MediaFoundation.ShutdownStatus.Completed"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFShutdown::GetShutdownStatus']/*"/>	
        /// <msdn-id>bb970451</msdn-id>	
        /// <unmanaged>HRESULT IMFShutdown::GetShutdownStatus([Out] MFSHUTDOWN_STATUS* pStatus)</unmanaged>	
        /// <unmanaged-short>IMFShutdown::GetShutdownStatus</unmanaged-short>	
        internal void GetShutdownStatus(out SharpDX.MediaFoundation.ShutdownStatus statusRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* statusRef_ = &statusRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, statusRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides a method that allows content protection systems to get the procedure address of a function in the signed library.  This method provides the same functionality as <strong>GetProcAddress</strong> which is not available to Windows Store apps.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>See  <strong><see cref="SharpDX.MediaFoundation.MediaFactory.LoadSignedLibrary"/></strong> for an example of how to create and use an <strong><see cref="SharpDX.MediaFoundation.SignedLibrary"/></strong> object.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSignedLibrary']/*"/>	
    /// <msdn-id>hh448058</msdn-id>	
    /// <unmanaged>IMFSignedLibrary</unmanaged>	
    /// <unmanaged-short>IMFSignedLibrary</unmanaged-short>	
    [Guid("4a724bca-ff6a-4c07-8e0d-7a358421cf06")]
    public partial class SignedLibrary : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SignedLibrary"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SignedLibrary(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SignedLibrary"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SignedLibrary(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SignedLibrary(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the procedure address of the specified function in the signed library.</p>	
        /// </summary>	
        /// <param name="name"><dd> <p>The entry point name in the DLL that specifies the function.</p> </dd></param>	
        /// <param name="address"><dd> <p>Receives the address of the entry point.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>See  <strong><see cref="SharpDX.MediaFoundation.MediaFactory.LoadSignedLibrary"/></strong> for an example of how to create an <strong><see cref="SharpDX.MediaFoundation.SignedLibrary"/></strong> object and call the <strong>GetProcedureAddress</strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSignedLibrary::GetProcedureAddress']/*"/>	
        /// <msdn-id>hh448059</msdn-id>	
        /// <unmanaged>HRESULT IMFSignedLibrary::GetProcedureAddress([In] const char* name,[Out] void** address)</unmanaged>	
        /// <unmanaged-short>IMFSignedLibrary::GetProcedureAddress</unmanaged-short>	
        public void GetProcedureAddress(string name, out System.IntPtr address)
        {
            unsafe
            {
                IntPtr name_ = Utilities.StringToHGlobalAnsi(name);
                SharpDX.Result __result__;
                fixed (void* address_ = &address)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)name_, address_, ((void**)(*(void**)_nativePointer))[3]);
                Marshal.FreeHGlobal(name_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Controls the master volume level of the audio session associated with the streaming audio renderer (SAR) and the audio capture source.</p><p>The SAR and the audio capture source expose this interface as a service. To get a reference to the interface, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong>. For the SAR, use the service identifier <see cref="SharpDX.MediaFoundation.MediaServiceKeys.PolicyVolume"/>. For the audio capture source, use the service identifier <see cref="SharpDX.MediaFoundation.MediaServiceKeys.CapturePolicyVolume"/>.  You can call <strong>GetService</strong> directly on the SAR or the audio capture source, or call it on the Media Session.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To control the volume levels of individual channels, use the <strong><see cref="SharpDX.MediaFoundation.AudioStreamVolume"/></strong> interface. The <strong><see cref="SharpDX.MediaFoundation.AudioStreamVolume"/></strong> interface is supported by the SAR only.</p><p>Volume is expressed as an attenuation level, where 0.0 indicates silence and 1.0 indicates full volume (no attenuation). For each channel, the attenuation level is the product of:</p><ul> <li> <p>The master volume level of the audio session.</p> </li> <li> <p>The volume level of the channel.</p> </li> </ul><p>For example, if the master volume is 0.8 and the channel volume is 0.5, the attenuaton for that channel is 0.8 ? 0.5 = 0.4. Volume levels can exceed 1.0 (positive gain), but the audio engine clips any audio samples that exceed zero decibels. To change the volume level of individual channels, use the <strong><see cref="SharpDX.MediaFoundation.AudioStreamVolume"/></strong> interface.</p><p>Use the following formula to convert the volume level to the decibel (dB) scale:</p><p> Attenuation (dB) = 20 * log10(<em>Level</em>) </p><p>For example, a volume level of 0.50 represents 6.02 dB of attenuation.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSimpleAudioVolume']/*"/>	
    /// <msdn-id>ms693496</msdn-id>	
    /// <unmanaged>IMFSimpleAudioVolume</unmanaged>	
    /// <unmanaged-short>IMFSimpleAudioVolume</unmanaged-short>	
    [Guid("089EDF13-CF71-4338-8D13-9E569DBDC319")]
    public partial class SimpleAudioVolume : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SimpleAudioVolume"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SimpleAudioVolume(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SimpleAudioVolume"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SimpleAudioVolume(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SimpleAudioVolume(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the master volume level.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If an external event changes the master volume, the audio renderer sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.AudioSessionVolumeChanged"/> event, which the Media Session forwards to the application.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSimpleAudioVolume::GetMasterVolume']/*"/>	
        /// <msdn-id>bb970319</msdn-id>	
        /// <unmanaged>GetMasterVolume / SetMasterVolume</unmanaged>	
        /// <unmanaged-short>GetMasterVolume</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSimpleAudioVolume::GetMasterVolume([Out] float* pfLevel)</unmanaged>
        public float MasterVolume
        {
            get { float __output__; GetMasterVolume(out __output__); return __output__; }
            set { SetMasterVolume(value); }
        }

        /// <summary>	
        /// <p> </p><p>Queries whether the audio is muted.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Calling <strong><see cref="SharpDX.MediaFoundation.SimpleAudioVolume.SetMasterVolume"/></strong> to set the volume does not change whether the audio is muted.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSimpleAudioVolume::GetMute']/*"/>	
        /// <msdn-id>bb970332</msdn-id>	
        /// <unmanaged>GetMute / SetMute</unmanaged>	
        /// <unmanaged-short>GetMute</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSimpleAudioVolume::GetMute([Out] BOOL* pbMute)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool Mute
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; GetMute(out __output__); return __output__; }
            set { SetMute(value); }
        }

        /// <summary>	
        /// <p> </p><p>Sets the master volume level.</p>	
        /// </summary>	
        /// <param name="fLevel"><dd> <p>Volume level. Volume is expressed as an attenuation level, where 0.0 indicates silence and 1.0 indicates full volume (no attenuation).</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotInitializeD"/></strong></dt> </dl> </td><td> <p>The audio renderer is not initialized.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.StreamsInkRemoved"/></strong></dt> </dl> </td><td> <p>The audio renderer was removed from the pipeline.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Events outside of the application can change the master volume level. For example, the user can change the volume from the system volume-control program (SndVol). If an external event changes the master volume, the audio renderer sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.AudioSessionVolumeChanged"/> event, which the Media Session forwards to the application.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSimpleAudioVolume::SetMasterVolume']/*"/>	
        /// <msdn-id>bb970391</msdn-id>	
        /// <unmanaged>HRESULT IMFSimpleAudioVolume::SetMasterVolume([In] float fLevel)</unmanaged>	
        /// <unmanaged-short>IMFSimpleAudioVolume::SetMasterVolume</unmanaged-short>	
        internal void SetMasterVolume(float fLevel)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fLevel, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the master volume level.</p>	
        /// </summary>	
        /// <param name="fLevelRef"><dd> <p>Receives the volume level. Volume is expressed as an attenuation level, where 0.0 indicates silence and 1.0 indicates full volume (no attenuation).</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotInitializeD"/></strong></dt> </dl> </td><td> <p>The audio renderer is not initialized.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.StreamsInkRemoved"/></strong></dt> </dl> </td><td> <p>The audio renderer was removed from the pipeline.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If an external event changes the master volume, the audio renderer sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.AudioSessionVolumeChanged"/> event, which the Media Session forwards to the application.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSimpleAudioVolume::GetMasterVolume']/*"/>	
        /// <msdn-id>bb970319</msdn-id>	
        /// <unmanaged>HRESULT IMFSimpleAudioVolume::GetMasterVolume([Out] float* pfLevel)</unmanaged>	
        /// <unmanaged-short>IMFSimpleAudioVolume::GetMasterVolume</unmanaged-short>	
        internal void GetMasterVolume(out float fLevelRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* fLevelRef_ = &fLevelRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fLevelRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Mutes or unmutes the audio.</p>	
        /// </summary>	
        /// <param name="bMute"><dd> <p>Specify <strong>TRUE</strong> to mute the audio, or <strong><see cref="SharpDX.Result.False"/></strong> to unmute the audio.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotInitializeD"/></strong></dt> </dl> </td><td> <p>The audio renderer is not initialized.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.StreamsInkRemoved"/></strong></dt> </dl> </td><td> <p>The audio renderer was removed from the pipeline.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method does not change the volume level returned by the <strong><see cref="SharpDX.MediaFoundation.SimpleAudioVolume.GetMasterVolume"/></strong> function.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSimpleAudioVolume::SetMute']/*"/>	
        /// <msdn-id>bb970531</msdn-id>	
        /// <unmanaged>HRESULT IMFSimpleAudioVolume::SetMute([In] const BOOL bMute)</unmanaged>	
        /// <unmanaged-short>IMFSimpleAudioVolume::SetMute</unmanaged-short>	
        internal void SetMute(SharpDX.Mathematics.Interop.RawBool bMute)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint6(_nativePointer, bMute, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Queries whether the audio is muted.</p>	
        /// </summary>	
        /// <param name="bMuteRef"><dd> <p>Receives a Boolean value. If <strong>TRUE</strong>, the audio is muted; otherwise, the audio is not muted.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotInitializeD"/></strong></dt> </dl> </td><td> <p>The audio renderer is not initialized.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.StreamsInkRemoved"/></strong></dt> </dl> </td><td> <p>The audio renderer was removed from the pipeline.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Calling <strong><see cref="SharpDX.MediaFoundation.SimpleAudioVolume.SetMasterVolume"/></strong> to set the volume does not change whether the audio is muted.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSimpleAudioVolume::GetMute']/*"/>	
        /// <msdn-id>bb970332</msdn-id>	
        /// <unmanaged>HRESULT IMFSimpleAudioVolume::GetMute([Out] BOOL* pbMute)</unmanaged>	
        /// <unmanaged-short>IMFSimpleAudioVolume::GetMute</unmanaged-short>	
        internal void GetMute(out SharpDX.Mathematics.Interop.RawBool bMuteRef)
        {
            unsafe
            {
                bMuteRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* bMuteRef_ = &bMuteRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bMuteRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Implemented by the Microsoft Media Foundation sink writer object.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To create the sink writer, call one of the following functions:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSinkWriterFromMediaSink"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSinkWriterFromURL"/></strong> </li> </ul><p>Alternatively, use the <strong><see cref="SharpDX.MediaFoundation.ReadWriteClassFactory"/></strong> interface.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p><p>In Windows?8, this interface is extended with <strong><see cref="SharpDX.MediaFoundation.SinkWriterEx"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriter']/*"/>	
    /// <msdn-id>dd374642</msdn-id>	
    /// <unmanaged>IMFSinkWriter</unmanaged>	
    /// <unmanaged-short>IMFSinkWriter</unmanaged-short>	
    [Guid("3137f1cd-fe5e-4805-a5d8-fb477448cb3d")]
    public partial class SinkWriter : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SinkWriter"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SinkWriter(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SinkWriter"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SinkWriter(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SinkWriter(nativePointer);
        }


        /// <summary>	
        /// <p>Adds a stream to the sink writer.</p>	
        /// </summary>	
        /// <param name="targetMediaTypeRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of a media type. This media type specifies the format of the samples that will be written to the file. It does not need to match the input format. To set the input format, call <strong><see cref="SharpDX.MediaFoundation.SinkWriter.SetInputMediaType"/></strong>.</p> </dd></param>	
        /// <param name="dwStreamIndexRef"><dd> <p>Receives the zero-based index of the new stream.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriter::AddStream']/*"/>	
        /// <msdn-id>dd374646</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriter::AddStream([In] IMFMediaType* pTargetMediaType,[Out] unsigned int* pdwStreamIndex)</unmanaged>	
        /// <unmanaged-short>IMFSinkWriter::AddStream</unmanaged-short>	
        public void AddStream(SharpDX.MediaFoundation.MediaType targetMediaTypeRef, out int dwStreamIndexRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwStreamIndexRef_ = &dwStreamIndexRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((targetMediaTypeRef == null) ? IntPtr.Zero : targetMediaTypeRef.NativePointer), dwStreamIndexRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the input format for a stream on the sink writer.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of the stream. The index is received by the <em>pdwStreamIndex</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.SinkWriter.AddStream"/></strong> method.</p> </dd></param>	
        /// <param name="inputMediaTypeRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of a media type. The media type specifies the input format.</p> </dd></param>	
        /// <param name="encodingParametersRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of an attribute store. Use the attribute store to configure the encoder. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidMediaType"/></strong></strong></dt> </dl> </td><td> <p>The underlying media sink does not support the format, no conversion is possible, or a dynamic format change is not possible.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></strong></dt> </dl> </td><td> <p>The <em>dwStreamIndex</em> parameter is invalid.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.TopoCodecNotFound"/></strong></strong></dt> </dl> </td><td> <p>Could not find an encoder for the encoded format.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The input format does not have to match the target format that is written to the media sink. If the formats do not match, the method attempts to load an encoder that can encode from the input format to the target format.</p><p>After streaming begins?that is, after the  first call to <strong><see cref="SharpDX.MediaFoundation.SinkWriter.WriteSample"/></strong>?you can call this method at any time to change the input format.  However, the underlying encoder and media sink must support dynamic format changes.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriter::SetInputMediaType']/*"/>	
        /// <msdn-id>dd374653</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriter::SetInputMediaType([In] unsigned int dwStreamIndex,[In] IMFMediaType* pInputMediaType,[In, Optional] IMFAttributes* pEncodingParameters)</unmanaged>	
        /// <unmanaged-short>IMFSinkWriter::SetInputMediaType</unmanaged-short>	
        public void SetInputMediaType(int dwStreamIndex, SharpDX.MediaFoundation.MediaType inputMediaTypeRef, SharpDX.MediaFoundation.MediaAttributes encodingParametersRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, (void*)((inputMediaTypeRef == null) ? IntPtr.Zero : inputMediaTypeRef.NativePointer), (void*)((encodingParametersRef == null) ? IntPtr.Zero : encodingParametersRef.NativePointer), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Initializes the sink writer for writing.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The request is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method after you configure the input streams and before you send any data to the sink writer. </p><p>You must call <strong>BeginWriting</strong> before calling any of the following methods:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.SinkWriter.Finalize"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.SinkWriter.Flush"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.SinkWriter.NotifyEndOfSegment"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.SinkWriter.PlaceMarker"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.SinkWriter.SendStreamTick"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.SinkWriter.WriteSample"/></strong> </li> </ul><p>The underlying media sink must have at least one input stream. Otherwise, <strong>BeginWriting</strong> returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong>. To add input streams, call the <strong><see cref="SharpDX.MediaFoundation.SinkWriter.AddStream"/></strong> method.</p><p>If <strong>BeginWriting</strong> succeeds, any further calls to <strong>BeginWriting</strong> return <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong>.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriter::BeginWriting']/*"/>	
        /// <msdn-id>dd374647</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriter::BeginWriting()</unmanaged>	
        /// <unmanaged-short>IMFSinkWriter::BeginWriting</unmanaged-short>	
        public void BeginWriting()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Delivers a sample to the sink writer.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of the stream for this sample.</p> </dd></param>	
        /// <param name="sampleRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface of the sample.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The request is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You must call <strong><see cref="SharpDX.MediaFoundation.SinkWriter.BeginWriting"/></strong> before calling this method. Otherwise, the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong>.</p><p>By default, the sink writer limits the rate of incoming data by blocking the calling thread inside the <strong>WriteSample</strong> method. This prevents the application from delivering samples too quickly. To disable this behavior, set the <see cref="SharpDX.MediaFoundation.SinkWriterAttributeKeys.DisableThrottling"/> attribute when you create the sink writer.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriter::WriteSample']/*"/>	
        /// <msdn-id>dd374654</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriter::WriteSample([In] unsigned int dwStreamIndex,[In] IMFSample* pSample)</unmanaged>	
        /// <unmanaged-short>IMFSinkWriter::WriteSample</unmanaged-short>	
        public void WriteSample(int dwStreamIndex, SharpDX.MediaFoundation.Sample sampleRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, (void*)((sampleRef == null) ? IntPtr.Zero : sampleRef.NativePointer), ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Indicates a gap in an input stream.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of the stream.</p> </dd></param>	
        /// <param name="llTimestamp"><dd> <p>The position in the stream where the gap in the data occurs. The value is given in 100-nanosecond units, relative to the start of the stream.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>For video, call this method once for each missing frame. For audio, call this method at least once per second during a gap in the audio. Set the <strong><see cref="SharpDX.MediaFoundation.SampleAttributeKeys.Discontinuity"/></strong> attribute on the first media sample after the gap.</p><p>Internally, this method calls <strong><see cref="SharpDX.MediaFoundation.StreamSink.PlaceMarker"/></strong> on the media sink.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriter::SendStreamTick']/*"/>	
        /// <msdn-id>dd374652</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriter::SendStreamTick([In] unsigned int dwStreamIndex,[In] longlong llTimestamp)</unmanaged>	
        /// <unmanaged-short>IMFSinkWriter::SendStreamTick</unmanaged-short>	
        public void SendStreamTick(int dwStreamIndex, long llTimestamp)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, llTimestamp, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Places a marker in the specified stream.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of the stream.</p> </dd></param>	
        /// <param name="vContextRef"><dd> <p>Pointer to an application-defined value. The value of this parameter is returned to the caller in the <em>pvContext</em> parameter of the caller's <strong><see cref="SharpDX.MediaFoundation.SinkWriterCallback.OnMarker"/></strong> callback method. The application is responsible for any memory allocation associated with this data. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The request is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To use this method, you must provide an asynchronous callback when you create the sink writer. Otherwise, the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong>. For more information, see <see cref="SharpDX.MediaFoundation.SinkWriterAttributeKeys.AsyncCallback"/>.</p><p>Markers provide a way to be notified when the media sink consumes all of the samples in a stream up to a certain point. The media sink does not process the marker until it has processed all of the samples that came before the marker. When the media sink processes the marker, the sink writer calls the application's <strong>OnMarker</strong> method. When the callback is invoked, you know that the sink has consumed all of the previous samples for that stream.</p><p>For example, to change the format midstream, call <strong>PlaceMarker</strong> at the point where the format changes. When <strong>OnMarker</strong> is called, it is safe to call <strong><see cref="SharpDX.MediaFoundation.SinkWriter.SetInputMediaType"/></strong> to change the input type (assuming that the media sink supports dynamic format changes).</p><p>Internally, this method calls <strong><see cref="SharpDX.MediaFoundation.StreamSink.PlaceMarker"/></strong> on the media sink.</p><p> </p><strong>Note</strong>??The <em>pvContext</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.SinkWriter.PlaceMarker"/></strong> method is not passed to the <em>pvarContextValue</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.StreamSink.PlaceMarker"/></strong> method. These two parameters are not directly related.?<p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriter::PlaceMarker']/*"/>	
        /// <msdn-id>dd374651</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriter::PlaceMarker([In] unsigned int dwStreamIndex,[In] void* pvContext)</unmanaged>	
        /// <unmanaged-short>IMFSinkWriter::PlaceMarker</unmanaged-short>	
        public void PlaceMarker(int dwStreamIndex, System.IntPtr vContextRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, (void*)vContextRef, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Notifies the media sink that a stream has reached the end of a segment.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of a stream, or <strong><see cref="SharpDX.MediaFoundation.SinkWriterIndex.AllStreams"/></strong> to signal that all streams have reached the end of a segment.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The request is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You must call <strong><see cref="SharpDX.MediaFoundation.SinkWriter.BeginWriting"/></strong> before calling this method. Otherwise, the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong>.</p><p>This method sends an <strong><see cref="SharpDX.MediaFoundation.StreamsInkMarkerType.Endofsegment"/></strong> marker to the media sink for the specified streams. For more information, see <strong><see cref="SharpDX.MediaFoundation.StreamSink.PlaceMarker"/></strong>.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriter::NotifyEndOfSegment']/*"/>	
        /// <msdn-id>dd743366</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriter::NotifyEndOfSegment([In] unsigned int dwStreamIndex)</unmanaged>	
        /// <unmanaged-short>IMFSinkWriter::NotifyEndOfSegment</unmanaged-short>	
        public void NotifyEndOfSegment(int dwStreamIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Flushes one or more streams.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of the stream to flush, or <strong><see cref="SharpDX.MediaFoundation.SinkWriterIndex.AllStreams"/></strong> to flush all of the streams.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The request is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You must call <strong><see cref="SharpDX.MediaFoundation.SinkWriter.BeginWriting"/></strong> before calling this method. Otherwise, the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong>.</p><p>For each stream that is flushed, the sink writer drops all pending samples, flushes the encoder, and sends an <strong><see cref="SharpDX.MediaFoundation.StreamsInkMarkerType.Endofsegment"/></strong> marker to the media sink.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriter::Flush']/*"/>	
        /// <msdn-id>dd743365</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriter::Flush([In] unsigned int dwStreamIndex)</unmanaged>	
        /// <unmanaged-short>IMFSinkWriter::Flush</unmanaged-short>	
        public void Flush(int dwStreamIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Completes all writing operations on the sink writer.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Call this method after you send all of the input samples to the sink writer. The method performs any operations needed to create the final output from the media sink.</p><p>If you provide a callback interface when you create the sink writer, this method completes asynchronously. When the operation completes, the <strong><see cref="SharpDX.MediaFoundation.SinkWriterCallback.OnFinalize"/></strong> method of your callback is called. For more information, see <see cref="SharpDX.MediaFoundation.SinkWriterAttributeKeys.AsyncCallback"/>.  Otherwise, if you do not provide a callback, the <strong>Finalize</strong> method blocks until the operation completes.</p><p>Internally, this method calls <strong><see cref="SharpDX.MediaFoundation.StreamSink.PlaceMarker"/></strong> to place end-of-segment markers for each stream on the media sink. It also calls <strong><see cref="SharpDX.MediaFoundation.FinalizableMediaSink.BeginFinalize_"/></strong> and <strong>EndFinalize</strong> if the media sink supports the <strong><see cref="SharpDX.MediaFoundation.FinalizableMediaSink"/></strong> interface.</p><p>After this method is called, the following methods will fail:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.SinkWriter.PlaceMarker"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.SinkWriter.SendStreamTick"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.SinkWriter.WriteSample"/></strong> </li> </ul><p>If you do not call <strong>Finalize</strong>, the output from the media sink might be incomplete or invalid. For example, required file headers might be missing from the output file.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriter::Finalize']/*"/>	
        /// <msdn-id>dd374648</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriter::Finalize()</unmanaged>	
        /// <unmanaged-short>IMFSinkWriter::Finalize</unmanaged-short>	
        public void Finalize()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries the underlying media sink or encoder for an interface.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of a stream to query, or <strong><see cref="SharpDX.MediaFoundation.SinkWriterIndex.MediaSink"/></strong> to query the media sink itself.</p> </dd></param>	
        /// <param name="guidService"><dd> <p>A service identifier <see cref="System.Guid"/>, or <strong>GUID_NULL</strong>.  If the value is <strong>GUID_NULL</strong>, the method calls <strong>QueryInterface</strong> to get the requested interface. Otherwise, the method calls <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong>. For a list of service identifiers, see Service Interfaces.</p> </dd></param>	
        /// <param name="riid"><dd> <p>The interface identifier (IID) of the interface being requested. </p> </dd></param>	
        /// <param name="vObjectOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If the <em>dwStreamIndex</em> parameter equals <strong><see cref="SharpDX.MediaFoundation.SinkWriterIndex.MediaSink"/></strong>, the method attempts to get the interface from the media sink. Otherwise, it attempts to get the interface from the encoder for the stream at the specified index. If that fails, or if no encoder is present, the method attempts to get the interface from the stream on the media sink.</p><p> If the input and output types of the sink are identical and compressed, it's possible that no encoding is required and the video encoder will not be instantiated. In that case, <strong>GetServiceForStream</strong> will return <see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedService"/>. </p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriter::GetServiceForStream']/*"/>	
        /// <msdn-id>dd374649</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriter::GetServiceForStream([In] unsigned int dwStreamIndex,[In] const GUID&amp; guidService,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>	
        /// <unmanaged-short>IMFSinkWriter::GetServiceForStream</unmanaged-short>	
        public void GetServiceForStream(int dwStreamIndex, System.Guid guidService, System.Guid riid, out System.IntPtr vObjectOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vObjectOut_ = &vObjectOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, &guidService, &riid, vObjectOut_, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets statistics about the performance of the sink writer.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of a stream to query, or <strong><see cref="SharpDX.MediaFoundation.SinkWriterIndex.AllStreams"/> </strong> to query the media sink itself.</p> </dd></param>	
        /// <param name="statsRef"><dd> <p>A reference to an <strong><see cref="SharpDX.MediaFoundation.SinkWriterStatistics"/></strong> structure. Before calling the method, set the <strong>cb</strong> member to the size of the structure in bytes. The method fills the structure with statistics from the sink writer.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>Invalid stream number.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriter::GetStatistics']/*"/>	
        /// <msdn-id>dd374650</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriter::GetStatistics([In] unsigned int dwStreamIndex,[Out] MF_SINK_WRITER_STATISTICS* pStats)</unmanaged>	
        /// <unmanaged-short>IMFSinkWriter::GetStatistics</unmanaged-short>	
        public void GetStatistics(int dwStreamIndex, out SharpDX.MediaFoundation.SinkWriterStatistics statsRef)
        {
            unsafe
            {
                statsRef = new SharpDX.MediaFoundation.SinkWriterStatistics();
                SharpDX.Result __result__;
                fixed (void* statsRef_ = &statsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, statsRef_, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Callback interface for the Microsoft Media Foundation sink writer. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Set the callback reference by setting the <see cref="SharpDX.MediaFoundation.SinkWriterAttributeKeys.AsyncCallback"/> attribute when you first create the sink writer. </p><p>The callback methods can be called from any thread, so an object that implements this interface must be thread-safe.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriterCallback']/*"/>	
    /// <msdn-id>dd374643</msdn-id>	
    /// <unmanaged>IMFSinkWriterCallback</unmanaged>	
    /// <unmanaged-short>IMFSinkWriterCallback</unmanaged-short>	
    [Guid("666f76de-33d2-41b9-a458-29ed0a972c58")]
    public partial class SinkWriterCallback : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SinkWriterCallback"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SinkWriterCallback(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SinkWriterCallback"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SinkWriterCallback(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SinkWriterCallback(nativePointer);
        }


        /// <summary>	
        /// <p>Called when the <strong><see cref="SharpDX.MediaFoundation.SinkWriter.Finalize"/></strong> method completes.</p>	
        /// </summary>	
        /// <param name="hrStatus">No documentation.</param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Currently, the sink writer ignores the return value.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriterCallback::OnFinalize']/*"/>	
        /// <msdn-id>dd374644</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriterCallback::OnFinalize([In] HRESULT hrStatus)</unmanaged>	
        /// <unmanaged-short>IMFSinkWriterCallback::OnFinalize</unmanaged-short>	
        public void OnFinalize(SharpDX.Result hrStatus)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint45(_nativePointer, hrStatus, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Called when the <strong><see cref="SharpDX.MediaFoundation.SinkWriter.PlaceMarker"/></strong> method completes.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex">No documentation.</param>	
        /// <param name="vContextRef">No documentation.</param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Currently, the sink writer ignores the return value.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriterCallback::OnMarker']/*"/>	
        /// <msdn-id>dd374645</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriterCallback::OnMarker([In] unsigned int dwStreamIndex,[In] void* pvContext)</unmanaged>	
        /// <unmanaged-short>IMFSinkWriterCallback::OnMarker</unmanaged-short>	
        public void OnMarker(int dwStreamIndex, System.IntPtr vContextRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, (void*)vContextRef, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Extends the <strong><see cref="SharpDX.MediaFoundation.SinkWriterCallback"/></strong> interface.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface provides a mechanism for apps that use <strong><see cref="SharpDX.MediaFoundation.SinkWriter"/></strong> to receive asynchronous notifications when the transform chain is complete and the system is ready for use or when an asynchronous error occurs.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriterCallback2']/*"/>	
    /// <msdn-id>dn949415</msdn-id>	
    /// <unmanaged>IMFSinkWriterCallback2</unmanaged>	
    /// <unmanaged-short>IMFSinkWriterCallback2</unmanaged-short>	
    [Guid("2456BD58-C067-4513-84FE-8D0C88FFDC61")]
    public partial class SinkWriterCallback2 : SharpDX.MediaFoundation.SinkWriterCallback
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SinkWriterCallback2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SinkWriterCallback2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SinkWriterCallback2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SinkWriterCallback2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SinkWriterCallback2(nativePointer);
        }


        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when the transform chain in the <strong><see cref="SharpDX.MediaFoundation.SourceReader"/></strong> is built or modified.</p>	
        /// </summary>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Currently, the sink writer ignores the return value.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriterCallback2::OnTransformChange']/*"/>	
        /// <msdn-id>dn949417</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriterCallback2::OnTransformChange()</unmanaged>	
        /// <unmanaged-short>IMFSinkWriterCallback2::OnTransformChange</unmanaged-short>	
        public void OnTransformChange()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when an asynchronous error occurs with the <strong><see cref="SharpDX.MediaFoundation.SinkWriter"/></strong>.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex">No documentation.</param>	
        /// <param name="hrStatus">No documentation.</param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Currently, the sink writer ignores the return value.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriterCallback2::OnStreamError']/*"/>	
        /// <msdn-id>dn949416</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriterCallback2::OnStreamError([In] unsigned int dwStreamIndex,[In] HRESULT hrStatus)</unmanaged>	
        /// <unmanaged-short>IMFSinkWriterCallback2::OnStreamError</unmanaged-short>	
        public void OnStreamError(int dwStreamIndex, SharpDX.Result hrStatus)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint79(_nativePointer, dwStreamIndex, hrStatus, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides additional functionality on the sink writer for dynamically changing the media type and encoder configuration. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The Sink Writer implements this interface in Windows?8.1. To get a reference to this interface, call <strong>QueryInterface</strong> on the <strong><see cref="SharpDX.MediaFoundation.SinkWriter"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriterEncoderConfig']/*"/>	
    /// <msdn-id>dn302046</msdn-id>	
    /// <unmanaged>IMFSinkWriterEncoderConfig</unmanaged>	
    /// <unmanaged-short>IMFSinkWriterEncoderConfig</unmanaged-short>	
    [Guid("17C3779E-3CDE-4EDE-8C60-3899F5F53AD6")]
    public partial class SinkWriterEncoderConfig : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SinkWriterEncoderConfig"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SinkWriterEncoderConfig(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SinkWriterEncoderConfig"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SinkWriterEncoderConfig(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SinkWriterEncoderConfig(nativePointer);
        }


        /// <summary>	
        /// <p>Dynamically changes the target media type that Sink Writer is encoding to.  </p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>Specifies the stream index.</p> </dd></param>	
        /// <param name="targetMediaTypeRef"><dd> <p>The new media format to encode to.</p> </dd></param>	
        /// <param name="encodingParametersRef"><dd> <p>The new set of encoding parameters to configure the encoder with. If not specified, previously provided parameters will be used.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The new media type must be supported by the media sink being used and by     the encoder MFTs installed on the system.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriterEncoderConfig::SetTargetMediaType']/*"/>	
        /// <msdn-id>dn302048</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriterEncoderConfig::SetTargetMediaType([In] unsigned int dwStreamIndex,[In] IMFMediaType* pTargetMediaType,[In, Optional] IMFAttributes* pEncodingParameters)</unmanaged>	
        /// <unmanaged-short>IMFSinkWriterEncoderConfig::SetTargetMediaType</unmanaged-short>	
        public void SetTargetMediaType(int dwStreamIndex, SharpDX.MediaFoundation.MediaType targetMediaTypeRef, SharpDX.MediaFoundation.MediaAttributes encodingParametersRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, (void*)((targetMediaTypeRef == null) ? IntPtr.Zero : targetMediaTypeRef.NativePointer), (void*)((encodingParametersRef == null) ? IntPtr.Zero : encodingParametersRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Dynamically updates the encoder configuration with a collection of new encoder settings.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>Specifies the stream index.</p> </dd></param>	
        /// <param name="encodingParametersRef"><dd> <p>A set of encoding parameters to configure the encoder with. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The encoder will be configured with these settings after all previously queued input media samples have been sent to it through <strong><see cref="SharpDX.MediaFoundation.Transform.ProcessInput"/></strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriterEncoderConfig::PlaceEncodingParameters']/*"/>	
        /// <msdn-id>dn302047</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriterEncoderConfig::PlaceEncodingParameters([In] unsigned int dwStreamIndex,[In] IMFAttributes* pEncodingParameters)</unmanaged>	
        /// <unmanaged-short>IMFSinkWriterEncoderConfig::PlaceEncodingParameters</unmanaged-short>	
        public void PlaceEncodingParameters(int dwStreamIndex, SharpDX.MediaFoundation.MediaAttributes encodingParametersRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, (void*)((encodingParametersRef == null) ? IntPtr.Zero : encodingParametersRef.NativePointer), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Extends the <strong><see cref="SharpDX.MediaFoundation.SinkWriter"/></strong> interface.</p><p>The Sink Writer implements this interface in Windows?8. To get a reference to this interface, call <strong>QueryInterface</strong> on the Sink Writer.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriterEx']/*"/>	
    /// <msdn-id>hh448060</msdn-id>	
    /// <unmanaged>IMFSinkWriterEx</unmanaged>	
    /// <unmanaged-short>IMFSinkWriterEx</unmanaged-short>	
    [Guid("588d72ab-5Bc1-496a-8714-b70617141b25")]
    public partial class SinkWriterEx : SharpDX.MediaFoundation.SinkWriter
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SinkWriterEx"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SinkWriterEx(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SinkWriterEx"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SinkWriterEx(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SinkWriterEx(nativePointer);
        }


        /// <summary>	
        /// <p>Gets a reference to a Media Foundation transform (MFT) for a specified stream.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The zero-based index of a stream.</p> </dd></param>	
        /// <param name="dwTransformIndex"><dd> <p>The zero-based index of the MFT to retreive.</p> </dd></param>	
        /// <param name="guidCategoryRef"><dd> <p>Receives a reference to a <see cref="System.Guid"/> that specifies the category of the MFT. For a list of possible values, see <strong>MFT_CATEGORY</strong>.</p> </dd></param>	
        /// <param name="transformOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> interface of the MFT. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSinkWriterEx::GetTransformForStream']/*"/>	
        /// <msdn-id>hh448061</msdn-id>	
        /// <unmanaged>HRESULT IMFSinkWriterEx::GetTransformForStream([In] unsigned int dwStreamIndex,[In] unsigned int dwTransformIndex,[Out, Optional] GUID* pGuidCategory,[Out] IMFTransform** ppTransform)</unmanaged>	
        /// <unmanaged-short>IMFSinkWriterEx::GetTransformForStream</unmanaged-short>	
        public void GetTransformForStream(int dwStreamIndex, int dwTransformIndex, out System.Guid guidCategoryRef, out SharpDX.MediaFoundation.Transform transformOut)
        {
            unsafe
            {
                guidCategoryRef = new System.Guid();
                IntPtr transformOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* guidCategoryRef_ = &guidCategoryRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, dwTransformIndex, guidCategoryRef_, &transformOut_, ((void**)(*(void**)_nativePointer))[14]);
                transformOut = (transformOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Transform(transformOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a buffer which contains media data for a <strong><see cref="SharpDX.MediaFoundation.MediaSourceExtension"/></strong>. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p><strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong> is used in conjunction with the <strong><see cref="SharpDX.MediaFoundation.MediaSourceExtension"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer']/*"/>	
    /// <msdn-id>dn302049</msdn-id>	
    /// <unmanaged>IMFSourceBuffer</unmanaged>	
    /// <unmanaged-short>IMFSourceBuffer</unmanaged-short>	
    [Guid("e2cd3a4b-af25-4d3d-9110-da0e6f8ee877")]
    public partial class SourceBuffer : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SourceBuffer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SourceBuffer(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SourceBuffer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SourceBuffer(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SourceBuffer(nativePointer);
        }


        /// <summary>	
        /// <p>Gets a value that indicates  if <strong>Append</strong>, <strong>AppendByteStream</strong>, or <strong>Remove</strong> is in process.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::GetUpdating']/*"/>	
        /// <msdn-id>dn302069</msdn-id>	
        /// <unmanaged>GetUpdating</unmanaged>	
        /// <unmanaged-short>GetUpdating</unmanaged-short>	
        /// <unmanaged>BOOL IMFSourceBuffer::GetUpdating()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool Updating
        {
            get { return GetUpdating(); }
        }

        /// <summary>	
        /// <p>Gets the buffered time range.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::GetBuffered']/*"/>	
        /// <msdn-id>dn302067</msdn-id>	
        /// <unmanaged>GetBuffered</unmanaged>	
        /// <unmanaged-short>GetBuffered</unmanaged-short>	
        /// <unmanaged>HRESULT IMFSourceBuffer::GetBuffered([Out] IMFMediaTimeRange** ppBuffered)</unmanaged>
        public SharpDX.MediaFoundation.MediaTimeRange Buffered
        {
            get { SharpDX.MediaFoundation.MediaTimeRange __output__; GetBuffered(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets or sets the timestamp offset for media segments appended to the <strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong>.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::GetTimeStampOffset']/*"/>	
        /// <msdn-id>dn302068</msdn-id>	
        /// <unmanaged>GetTimeStampOffset / SetTimeStampOffset</unmanaged>	
        /// <unmanaged-short>GetTimeStampOffset</unmanaged-short>	
        /// <unmanaged>double IMFSourceBuffer::GetTimeStampOffset()</unmanaged>
        public double TimeStampOffset
        {
            get { return GetTimeStampOffset(); }
            set { SetTimeStampOffset(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the timestamp for the start of the append window.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::GetAppendWindowStart']/*"/>	
        /// <msdn-id>dn302066</msdn-id>	
        /// <unmanaged>GetAppendWindowStart / SetAppendWindowStart</unmanaged>	
        /// <unmanaged-short>GetAppendWindowStart</unmanaged-short>	
        /// <unmanaged>double IMFSourceBuffer::GetAppendWindowStart()</unmanaged>
        public double AppendWindowStart
        {
            get { return GetAppendWindowStart(); }
            set { SetAppendWindowStart(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the timestamp for the end of the append window.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::GetAppendWindowEnd']/*"/>	
        /// <msdn-id>dn302065</msdn-id>	
        /// <unmanaged>GetAppendWindowEnd / SetAppendWindowEnd</unmanaged>	
        /// <unmanaged-short>GetAppendWindowEnd</unmanaged-short>	
        /// <unmanaged>double IMFSourceBuffer::GetAppendWindowEnd()</unmanaged>
        public double AppendWindowEnd
        {
            get { return GetAppendWindowEnd(); }
            set { SetAppendWindowEnd(value); }
        }

        /// <summary>	
        /// <p>Gets a value that indicates  if <strong>Append</strong>, <strong>AppendByteStream</strong>, or <strong>Remove</strong> is in process.</p>	
        /// </summary>	
        /// <returns><p><strong>true</strong> if <strong>Append</strong>, <strong>AppendByteStream</strong>, or <strong>Remove</strong>; otherwise, <strong>false</strong>.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::GetUpdating']/*"/>	
        /// <msdn-id>dn302069</msdn-id>	
        /// <unmanaged>BOOL IMFSourceBuffer::GetUpdating()</unmanaged>	
        /// <unmanaged-short>IMFSourceBuffer::GetUpdating</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool GetUpdating()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the buffered time range.</p>	
        /// </summary>	
        /// <param name="bufferedOut"><dd> <p>The buffered time range.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::GetBuffered']/*"/>	
        /// <msdn-id>dn302067</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceBuffer::GetBuffered([Out] IMFMediaTimeRange** ppBuffered)</unmanaged>	
        /// <unmanaged-short>IMFSourceBuffer::GetBuffered</unmanaged-short>	
        internal void GetBuffered(out SharpDX.MediaFoundation.MediaTimeRange bufferedOut)
        {
            unsafe
            {
                IntPtr bufferedOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &bufferedOut_, ((void**)(*(void**)_nativePointer))[4]);
                bufferedOut = (bufferedOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaTimeRange(bufferedOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the timestamp offset for media segments appended to the <strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong>.</p>	
        /// </summary>	
        /// <returns><p>The timestamp offset.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::GetTimeStampOffset']/*"/>	
        /// <msdn-id>dn302068</msdn-id>	
        /// <unmanaged>double IMFSourceBuffer::GetTimeStampOffset()</unmanaged>	
        /// <unmanaged-short>IMFSourceBuffer::GetTimeStampOffset</unmanaged-short>	
        internal double GetTimeStampOffset()
        {
            unsafe
            {
                double __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callidouble(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Sets the timestamp offset for media segments appended to the <strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong>.</p>	
        /// </summary>	
        /// <param name="offset">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::SetTimeStampOffset']/*"/>	
        /// <msdn-id>dn302073</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceBuffer::SetTimeStampOffset([In] double offset)</unmanaged>	
        /// <unmanaged-short>IMFSourceBuffer::SetTimeStampOffset</unmanaged-short>	
        internal void SetTimeStampOffset(double offset)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, offset, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the timestamp for the start of the append window.</p>	
        /// </summary>	
        /// <returns><p>The timestamp for the start of the append window.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::GetAppendWindowStart']/*"/>	
        /// <msdn-id>dn302066</msdn-id>	
        /// <unmanaged>double IMFSourceBuffer::GetAppendWindowStart()</unmanaged>	
        /// <unmanaged-short>IMFSourceBuffer::GetAppendWindowStart</unmanaged-short>	
        internal double GetAppendWindowStart()
        {
            unsafe
            {
                double __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callidouble(_nativePointer, ((void**)(*(void**)_nativePointer))[7]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Sets the timestamp for the start of the append window.</p>	
        /// </summary>	
        /// <param name="time"><dd> <p>The timestamp for the start of the append window.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::SetAppendWindowStart']/*"/>	
        /// <msdn-id>dn302072</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceBuffer::SetAppendWindowStart([In] double time)</unmanaged>	
        /// <unmanaged-short>IMFSourceBuffer::SetAppendWindowStart</unmanaged-short>	
        internal void SetAppendWindowStart(double time)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, time, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the timestamp for the end of the append window.</p>	
        /// </summary>	
        /// <returns><p>The timestamp for the end of the append window.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::GetAppendWindowEnd']/*"/>	
        /// <msdn-id>dn302065</msdn-id>	
        /// <unmanaged>double IMFSourceBuffer::GetAppendWindowEnd()</unmanaged>	
        /// <unmanaged-short>IMFSourceBuffer::GetAppendWindowEnd</unmanaged-short>	
        internal double GetAppendWindowEnd()
        {
            unsafe
            {
                double __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callidouble(_nativePointer, ((void**)(*(void**)_nativePointer))[9]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Sets the timestamp for the end of the append window.</p>	
        /// </summary>	
        /// <param name="time"><dd></dd></param>	
        /// <returns><p>The timestamp for the end of the append window.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::SetAppendWindowEnd']/*"/>	
        /// <msdn-id>dn302071</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceBuffer::SetAppendWindowEnd([In] double time)</unmanaged>	
        /// <unmanaged-short>IMFSourceBuffer::SetAppendWindowEnd</unmanaged-short>	
        internal void SetAppendWindowEnd(double time)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, time, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Appends the specified media segment to the <strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong>.</p>	
        /// </summary>	
        /// <param name="dataRef">No documentation.</param>	
        /// <param name="len">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::Append']/*"/>	
        /// <msdn-id>dn302063</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceBuffer::Append([In, Buffer] const unsigned char* pData,[In] unsigned int len)</unmanaged>	
        /// <unmanaged-short>IMFSourceBuffer::Append</unmanaged-short>	
        public void Append(byte[] dataRef, int len)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dataRef_, len, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Appends the media segment from the specified byte stream to the <strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong>.</p>	
        /// </summary>	
        /// <param name="streamRef">No documentation.</param>	
        /// <param name="maxLenRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::AppendByteStream']/*"/>	
        /// <msdn-id>dn302064</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceBuffer::AppendByteStream([In] IMFByteStream* pStream,[In, Optional] unsigned longlong* pMaxLen)</unmanaged>	
        /// <unmanaged-short>IMFSourceBuffer::AppendByteStream</unmanaged-short>	
        internal void AppendByteStream_(System.IntPtr streamRef, long? maxLenRef)
        {
            unsafe
            {
                long maxLenRef_;
                if (maxLenRef.HasValue)
                    maxLenRef_ = maxLenRef.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)streamRef, (maxLenRef.HasValue) ? &maxLenRef_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Aborts the processing of the current media segment. </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::Abort']/*"/>	
        /// <msdn-id>dn302062</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceBuffer::Abort()</unmanaged>	
        /// <unmanaged-short>IMFSourceBuffer::Abort</unmanaged-short>	
        public void Abort()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Removes the media segments defined by the specified time range from the <strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong>.</p>	
        /// </summary>	
        /// <param name="start">No documentation.</param>	
        /// <param name="end">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBuffer::Remove']/*"/>	
        /// <msdn-id>dn302070</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceBuffer::Remove([In] double start,[In] double end)</unmanaged>	
        /// <unmanaged-short>IMFSourceBuffer::Remove</unmanaged-short>	
        public void Remove(double start, double end)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, start, end, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBufferAppendMode']/*"/>	
    /// <unmanaged>IMFSourceBufferAppendMode</unmanaged>	
    /// <unmanaged-short>IMFSourceBufferAppendMode</unmanaged-short>	
    [Guid("19666fb4-babe-4c55-bc03-0a074da37e2a")]
    public partial class SourceBufferAppendMode : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SourceBufferAppendMode"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SourceBufferAppendMode(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SourceBufferAppendMode"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SourceBufferAppendMode(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SourceBufferAppendMode(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBufferAppendMode::GetAppendMode']/*"/>	
        /// <unmanaged>GetAppendMode / SetAppendMode</unmanaged>	
        /// <unmanaged-short>GetAppendMode</unmanaged-short>	
        /// <unmanaged>MF_MSE_APPEND_MODE IMFSourceBufferAppendMode::GetAppendMode()</unmanaged>
        public SharpDX.MediaFoundation.MultisampledEAppendMode AppendMode
        {
            get { return GetAppendMode(); }
            set { SetAppendMode(value); }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBufferAppendMode::GetAppendMode']/*"/>	
        /// <unmanaged>MF_MSE_APPEND_MODE IMFSourceBufferAppendMode::GetAppendMode()</unmanaged>	
        /// <unmanaged-short>IMFSourceBufferAppendMode::GetAppendMode</unmanaged-short>	
        internal SharpDX.MediaFoundation.MultisampledEAppendMode GetAppendMode()
        {
            unsafe
            {
                SharpDX.MediaFoundation.MultisampledEAppendMode __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMediaFoundationMultisampledEAppendMode(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="mode">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBufferAppendMode::SetAppendMode']/*"/>	
        /// <unmanaged>HRESULT IMFSourceBufferAppendMode::SetAppendMode([In] MF_MSE_APPEND_MODE mode)</unmanaged>	
        /// <unmanaged-short>IMFSourceBufferAppendMode::SetAppendMode</unmanaged-short>	
        internal void SetAppendMode(SharpDX.MediaFoundation.MultisampledEAppendMode mode)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)mode), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a collection of <strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong> objects.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBufferList']/*"/>	
    /// <msdn-id>dn302050</msdn-id>	
    /// <unmanaged>IMFSourceBufferList</unmanaged>	
    /// <unmanaged-short>IMFSourceBufferList</unmanaged-short>	
    [Guid("249981f8-8325-41f3-b80c-3b9e3aad0cbe")]
    public partial class SourceBufferList : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SourceBufferList"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SourceBufferList(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SourceBufferList"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SourceBufferList(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SourceBufferList(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the number of <strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong> objects  in the list.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBufferList::GetLength']/*"/>	
        /// <msdn-id>dn302051</msdn-id>	
        /// <unmanaged>GetLength</unmanaged>	
        /// <unmanaged-short>GetLength</unmanaged-short>	
        /// <unmanaged>unsigned int IMFSourceBufferList::GetLength()</unmanaged>
        public int Length
        {
            get { return GetLength(); }
        }

        /// <summary>	
        /// <p>Gets the number of <strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong> objects  in the list.</p>	
        /// </summary>	
        /// <returns><p>The number of source buffers in the list.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBufferList::GetLength']/*"/>	
        /// <msdn-id>dn302051</msdn-id>	
        /// <unmanaged>unsigned int IMFSourceBufferList::GetLength()</unmanaged>	
        /// <unmanaged-short>IMFSourceBufferList::GetLength</unmanaged-short>	
        internal int GetLength()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the <strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong> at the specified index in the list.</p>	
        /// </summary>	
        /// <param name="index">No documentation.</param>	
        /// <returns><p>The source buffer.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBufferList::GetSourceBuffer']/*"/>	
        /// <msdn-id>dn302052</msdn-id>	
        /// <unmanaged>IMFSourceBuffer* IMFSourceBufferList::GetSourceBuffer([In] unsigned int index)</unmanaged>	
        /// <unmanaged-short>IMFSourceBufferList::GetSourceBuffer</unmanaged-short>	
        public SharpDX.MediaFoundation.SourceBuffer GetSourceBuffer(int index)
        {
            unsafe
            {
                SharpDX.MediaFoundation.SourceBuffer __result__;
                __result__ =
                new SharpDX.MediaFoundation.SourceBuffer((IntPtr)SharpDX.MediaFoundation.LocalInterop.CalliSystemIntPtr(_nativePointer, index, ((void**)(*(void**)_nativePointer))[4]));
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Provides functionality for raising events associated with <strong><see cref="SharpDX.MediaFoundation.SourceBuffer"/></strong>.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBufferNotify']/*"/>	
    /// <msdn-id>dn302053</msdn-id>	
    /// <unmanaged>IMFSourceBufferNotify</unmanaged>	
    /// <unmanaged-short>IMFSourceBufferNotify</unmanaged-short>	
    [Guid("87e47623-2ceb-45d6-9b88-d8520c4dcbbc")]
    public partial class SourceBufferNotify : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SourceBufferNotify"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SourceBufferNotify(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SourceBufferNotify"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SourceBufferNotify(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SourceBufferNotify(nativePointer);
        }


        /// <summary>	
        /// <p>Used to indicate that the source buffer has started updating.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBufferNotify::OnUpdateStart']/*"/>	
        /// <msdn-id>dn302061</msdn-id>	
        /// <unmanaged>void IMFSourceBufferNotify::OnUpdateStart()</unmanaged>	
        /// <unmanaged-short>IMFSourceBufferNotify::OnUpdateStart</unmanaged-short>	
        public void OnUpdateStart()
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
            }
        }

        /// <summary>	
        /// <p>Used to indicate that the source buffer has been aborted.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBufferNotify::OnAbort']/*"/>	
        /// <msdn-id>dn302054</msdn-id>	
        /// <unmanaged>void IMFSourceBufferNotify::OnAbort()</unmanaged>	
        /// <unmanaged-short>IMFSourceBufferNotify::OnAbort</unmanaged-short>	
        public void OnAbort()
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
            }
        }

        /// <summary>	
        /// <p>Used to indicate that an error has occurred with the  source buffer.</p>	
        /// </summary>	
        /// <param name="hr"><dd></dd></param>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBufferNotify::OnError']/*"/>	
        /// <msdn-id>dn302055</msdn-id>	
        /// <unmanaged>void IMFSourceBufferNotify::OnError([In] HRESULT hr)</unmanaged>	
        /// <unmanaged-short>IMFSourceBufferNotify::OnError</unmanaged-short>	
        public void OnError(SharpDX.Result hr)
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid101(_nativePointer, hr, ((void**)(*(void**)_nativePointer))[5]);
            }
        }

        /// <summary>	
        /// <p>Used to indicate that the source buffer is updating.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBufferNotify::OnUpdate']/*"/>	
        /// <msdn-id>dn302056</msdn-id>	
        /// <unmanaged>void IMFSourceBufferNotify::OnUpdate()</unmanaged>	
        /// <unmanaged-short>IMFSourceBufferNotify::OnUpdate</unmanaged-short>	
        public void OnUpdate()
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[6]);
            }
        }

        /// <summary>	
        /// <p>Used to indicate that the source buffer has finished updating.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceBufferNotify::OnUpdateEnd']/*"/>	
        /// <msdn-id>dn302057</msdn-id>	
        /// <unmanaged>void IMFSourceBufferNotify::OnUpdateEnd()</unmanaged>	
        /// <unmanaged-short>IMFSourceBufferNotify::OnUpdateEnd</unmanaged-short>	
        public void OnUpdateEnd()
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[7]);
            }
        }
    }
    /// <summary>	
    /// <p>Callback interface to receive notifications from a network source on the progress of an asynchronous open operation.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceOpenMonitor']/*"/>	
    /// <msdn-id>ms700797</msdn-id>	
    /// <unmanaged>IMFSourceOpenMonitor</unmanaged>	
    /// <unmanaged-short>IMFSourceOpenMonitor</unmanaged-short>	
    [Guid("059054B3-027C-494C-A27D-9113291CF87F")]
    public partial class SourceOpenMonitor : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SourceOpenMonitor"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SourceOpenMonitor(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SourceOpenMonitor"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SourceOpenMonitor(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SourceOpenMonitor(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Called by the network source when the open operation begins or ends.</p>	
        /// </summary>	
        /// <param name="eventRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaEvent"/></strong> interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The networks source calls this method with the following event types.</p><ul> <li> <p> <see cref="SharpDX.MediaFoundation.MediaEventTypes.ConnectStart"/> </p> </li> <li> <p> <see cref="SharpDX.MediaFoundation.MediaEventTypes.ConnectEnd"/> </p> </li> </ul><p>For more information, see How to Get Events from the Network Source.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceOpenMonitor::OnSourceEvent']/*"/>	
        /// <msdn-id>ms694870</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceOpenMonitor::OnSourceEvent([In, Optional] IMFMediaEvent* pEvent)</unmanaged>	
        /// <unmanaged-short>IMFSourceOpenMonitor::OnSourceEvent</unmanaged-short>	
        public void OnSourceEvent(SharpDX.MediaFoundation.MediaEvent eventRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((eventRef == null) ? IntPtr.Zero : eventRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Implemented by the Microsoft Media Foundation source reader object.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To create the source reader, call one of the following functions:</p><ul> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSourceReaderFromByteStream"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSourceReaderFromMediaSource"/></strong> </li> <li> <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSourceReaderFromURL"/></strong> </li> </ul><p>Alternatively, use the <strong><see cref="SharpDX.MediaFoundation.ReadWriteClassFactory"/></strong> interface.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p><p>In Windows?8, this interface is extended with <strong><see cref="SharpDX.MediaFoundation.SourceReaderEx"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReader']/*"/>	
    /// <msdn-id>dd374655</msdn-id>	
    /// <unmanaged>IMFSourceReader</unmanaged>	
    /// <unmanaged-short>IMFSourceReader</unmanaged-short>	
    [Guid("70ae66f2-c809-4e4f-8915-bdcb406b7993")]
    public partial class SourceReader : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SourceReader"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SourceReader(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SourceReader"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SourceReader(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SourceReader(nativePointer);
        }


        /// <summary>	
        /// <p>Queries whether a stream is selected.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The stream to query. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="fSelectedRef"><dd> <p>Receives <strong>TRUE</strong> if the stream is selected and will generate data. Receives <strong><see cref="SharpDX.Result.False"/></strong> if the stream is not selected and will not generate data.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReader::GetStreamSelection']/*"/>	
        /// <msdn-id>dd374664</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReader::GetStreamSelection([In] unsigned int dwStreamIndex,[Out] BOOL* pfSelected)</unmanaged>	
        /// <unmanaged-short>IMFSourceReader::GetStreamSelection</unmanaged-short>	
        public void GetStreamSelection(int dwStreamIndex, out SharpDX.Mathematics.Interop.RawBool fSelectedRef)
        {
            unsafe
            {
                fSelectedRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fSelectedRef_ = &fSelectedRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, fSelectedRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Selects or deselects one or more streams.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The stream to set. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.AllStreams"/></strong></strong></dt> <dt>0xFFFFFFFE</dt> </dl> </td><td> <p>All streams.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="fSelected"><dd> <p>Specify <strong>TRUE</strong> to select streams or <strong><see cref="SharpDX.Result.False"/></strong> to deselect streams. If a stream is deselected, it will not generate data.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>There are two common uses for this method:</p><ul> <li>To change the default stream selection. Some media files contain multiple streams of the same type. For example, a file might include audio streams for multiple languages. You can use this method to change which of the streams is selected. To get information about each stream, call <strong><see cref="SharpDX.MediaFoundation.SourceReader.GetPresentationAttribute"/></strong> or <strong><see cref="SharpDX.MediaFoundation.SourceReader.GetNativeMediaType"/></strong>.</li> <li>If you will not need data from one of the streams, it is a good idea to deselect that stream. If the stream is selected, the media source might hold onto a queue of unread data, and the queue might grow indefinitely, consuming memory. </li> </ul><p>For an example of deselecting a stream, see Tutorial: Decoding Audio.</p><p>If a stream is deselected, the <strong><see cref="SharpDX.MediaFoundation.SourceReader.ReadSample"/></strong> method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong> for that stream. Other <strong><see cref="SharpDX.MediaFoundation.SourceReader"/></strong> methods are valid for deselected streams.</p><p>Stream selection does not affect how the source reader loads or unloads decoders in memory. In particular, deselecting a stream does not force the source reader to unload the decoder for that stream.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReader::SetStreamSelection']/*"/>	
        /// <msdn-id>dd374669</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReader::SetStreamSelection([In] unsigned int dwStreamIndex,[In] BOOL fSelected)</unmanaged>	
        /// <unmanaged-short>IMFSourceReader::SetStreamSelection</unmanaged-short>	
        public void SetStreamSelection(int dwStreamIndex, SharpDX.Mathematics.Interop.RawBool fSelected)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint19(_nativePointer, dwStreamIndex, fSelected, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a format that is supported natively by the media source.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>Specifies which stream to query. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="dwMediaTypeIndex"><dd> <p>The zero-based index of the media type to retrieve.</p> </dd></param>	
        /// <returns><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This method queries the underlying media source for its native output format. Potentially, each source stream can produce more than one output format. Use the <em>dwMediaTypeIndex</em> parameter to loop through the available formats. Generally, file sources offer just one format per stream, but capture devices might offer several formats.</p><p> The method returns a copy of the media type, so it is safe to modify the object received in the <em> ppMediaType</em> parameter.</p><p>To set  the output type for a stream, call the <strong><see cref="SharpDX.MediaFoundation.SourceReader.SetCurrentMediaType"/></strong> method.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReader::GetNativeMediaType']/*"/>	
        /// <msdn-id>dd374661</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReader::GetNativeMediaType([In] unsigned int dwStreamIndex,[In] unsigned int dwMediaTypeIndex,[Out] IMFMediaType** ppMediaType)</unmanaged>	
        /// <unmanaged-short>IMFSourceReader::GetNativeMediaType</unmanaged-short>	
        public SharpDX.MediaFoundation.MediaType GetNativeMediaType(int dwStreamIndex, int dwMediaTypeIndex)
        {
            unsafe
            {
                SharpDX.MediaFoundation.MediaType mediaTypeOut;
                IntPtr mediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, dwMediaTypeIndex, &mediaTypeOut_, ((void**)(*(void**)_nativePointer))[5]);
                mediaTypeOut = (mediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(mediaTypeOut_);
                __result__.CheckError();
                return mediaTypeOut;
            }
        }

        /// <summary>	
        /// <p>Gets the current media type for a stream.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The stream to query. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReader::GetCurrentMediaType']/*"/>	
        /// <msdn-id>dd374660</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReader::GetCurrentMediaType([In] unsigned int dwStreamIndex,[Out] IMFMediaType** ppMediaType)</unmanaged>	
        /// <unmanaged-short>IMFSourceReader::GetCurrentMediaType</unmanaged-short>	
        public SharpDX.MediaFoundation.MediaType GetCurrentMediaType(int dwStreamIndex)
        {
            unsafe
            {
                SharpDX.MediaFoundation.MediaType mediaTypeOut;
                IntPtr mediaTypeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, &mediaTypeOut_, ((void**)(*(void**)_nativePointer))[6]);
                mediaTypeOut = (mediaTypeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(mediaTypeOut_);
                __result__.CheckError();
                return mediaTypeOut;
            }
        }

        /// <summary>	
        /// <p>Sets the media type for a stream.</p><p>This media type defines that format that the Source Reader produces as output. It can differ from the native format provided by the media source. See Remarks for more information.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex">No documentation.</param>	
        /// <param name="dwReservedRef">No documentation.</param>	
        /// <param name="mediaTypeRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidMediaType"/></strong></strong></dt> </dl> </td><td> <p>At least one decoder was found for the native stream type, but the type specified by <em>pMediaType</em> was rejected.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>One or more sample requests are still pending.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></strong></dt> </dl> </td><td> <p>The <em>dwStreamIndex</em> parameter is invalid.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.TopoCodecNotFound"/></strong></strong></dt> </dl> </td><td> <p>Could not find a decoder for the native stream type.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>For each stream, you can set the media type to any of the following:</p><ul> <li>One of the native types offered by the media source. To enumerate the native types, call <strong><see cref="SharpDX.MediaFoundation.SourceReader.GetNativeMediaType"/></strong>.</li> <li>If the native media type is compressed, you can specify a corresponding uncompressed format. The Source Reader will search for a decoder that can decode from the native format to the specified uncompressed format.</li> </ul><p>Audio resampling support was added to the source reader with Windows?8.  In versions of Windows prior to  Windows?8, the source reader does not support audio resampling. If you need to resample the audio in versions of Windows earlier than Windows?8, you can use the <strong>Audio Resampler DSP</strong>.</p><p>If you set the <see cref="SharpDX.MediaFoundation.SourceReaderAttributeKeys.EnableVideoProcessing"/> attribute to <strong>TRUE</strong> when you create the Source Reader, the Source Reader will convert YUV video to RGB-32. This conversion is not optimized for real-time video playback.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReader::SetCurrentMediaType']/*"/>	
        /// <msdn-id>dd374667</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReader::SetCurrentMediaType([In] unsigned int dwStreamIndex,[In] void* pdwReserved,[In] IMFMediaType* pMediaType)</unmanaged>	
        /// <unmanaged-short>IMFSourceReader::SetCurrentMediaType</unmanaged-short>	
        internal void SetCurrentMediaType(int dwStreamIndex, System.IntPtr dwReservedRef, SharpDX.MediaFoundation.MediaType mediaTypeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, (void*)dwReservedRef, (void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Seeks to a new position in the media source.</p>	
        /// </summary>	
        /// <param name="guidTimeFormat"><dd> <p>A <see cref="System.Guid"/> that specifies the <em>time format</em>. The time format defines the units for the <em>varPosition</em> parameter. The following value is defined for all media sources:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>GUID_NULL</strong></dt> </dl> </td><td> <p>100-nanosecond units.</p> </td></tr> </table> <p>?</p> <p>Some media sources might support additional values. </p> </dd></param>	
        /// <param name="varPosition"><dd> <p>The position from which playback will be started. The units are specified by the <em>guidTimeFormat</em> parameter. If the <em>guidTimeFormat</em> parameter is <strong>GUID_NULL</strong>, set the variant type to <strong>VT_I8</strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>One or more sample requests are still pending.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The <strong>SetCurrentPosition</strong> method does not guarantee exact seeking. The accuracy of the seek depends on the media content. If the media content contains a video stream, the <strong>SetCurrentPosition</strong> method typically seeks to the nearest key frame before the desired position. The distance between key frames depends on several factors, including the encoder implementation, the video content, and the particular encoding settings used to encode the content. The distance between key frame can vary within a single video file (for example, depending on scene complexity).</p><p>After seeking, the application should call <strong><see cref="SharpDX.MediaFoundation.SourceReader.ReadSample"/></strong> and advance to the desired position. </p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReader::SetCurrentPosition']/*"/>	
        /// <msdn-id>dd374668</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReader::SetCurrentPosition([In] const GUID&amp; guidTimeFormat,[In] const PROPVARIANT&amp; varPosition)</unmanaged>	
        /// <unmanaged-short>IMFSourceReader::SetCurrentPosition</unmanaged-short>	
        internal void SetCurrentPosition(System.Guid guidTimeFormat, SharpDX.Win32.Variant varPosition)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &guidTimeFormat, &varPosition, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Reads the next sample from the media source.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The stream to pull data from. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.AnyStream"/></strong></strong></dt> <dt>0xFFFFFFFE</dt> </dl> </td><td> <p>Get the next available sample, regardless of which stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="dwControlFlags"><dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.SourceReaderControlFlags"/></strong> enumeration.</p> </dd></param>	
        /// <param name="dwActualStreamIndexRef"><dd> <p>Receives the zero-based index of the stream.</p> </dd></param>	
        /// <param name="dwStreamFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.SourceReaderFlags"/></strong> enumeration.</p> </dd></param>	
        /// <param name="llTimestampRef"><dd> <p>Receives the time stamp of the sample, or the time of the stream event indicated in <em>pdwStreamFlags</em>. The time is given in 100-nanosecond units.</p> </dd></param>	
        /// <returns><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface or the value <strong><c>null</c></strong> (see Remarks). If this parameter receives a non-<strong><c>null</c></strong> reference, the caller must release the interface.</p> </dd></returns>	
        /// <remarks>	
        /// <p>If the requested stream is not selected, the return code is <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong>. See <strong><see cref="SharpDX.MediaFoundation.SourceReader.SetStreamSelection"/></strong>.</p><p> This method can complete synchronously or asynchronously. If you provide a callback reference when you create the source reader, the method is asynchronous. Otherwise, the method is synchronous. For more information about setting the callback reference, see <see cref="SharpDX.MediaFoundation.SourceReaderAttributeKeys.AsyncCallback"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReader::ReadSample']/*"/>	
        /// <msdn-id>dd374665</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReader::ReadSample([In] unsigned int dwStreamIndex,[In] MF_SOURCE_READER_CONTROL_FLAG dwControlFlags,[Out, Optional] unsigned int* pdwActualStreamIndex,[Out, Optional] MF_SOURCE_READER_FLAG* pdwStreamFlags,[Out, Optional] longlong* pllTimestamp,[Out, Optional] IMFSample** ppSample)</unmanaged>	
        /// <unmanaged-short>IMFSourceReader::ReadSample</unmanaged-short>	
        public SharpDX.MediaFoundation.Sample ReadSample(int dwStreamIndex, SharpDX.MediaFoundation.SourceReaderControlFlags dwControlFlags, out int dwActualStreamIndexRef, out SharpDX.MediaFoundation.SourceReaderFlags dwStreamFlagsRef, out long llTimestampRef)
        {
            unsafe
            {
                SharpDX.MediaFoundation.Sample sampleOut;
                IntPtr sampleOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* dwActualStreamIndexRef_ = &dwActualStreamIndexRef)
                fixed (void* dwStreamFlagsRef_ = &dwStreamFlagsRef)
                fixed (void* llTimestampRef_ = &llTimestampRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, unchecked((int)dwControlFlags), dwActualStreamIndexRef_, dwStreamFlagsRef_, llTimestampRef_, &sampleOut_, ((void**)(*(void**)_nativePointer))[9]);
                sampleOut = (sampleOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Sample(sampleOut_);
                __result__.CheckError();
                return sampleOut;
            }
        }

        /// <summary>	
        /// <p>Flushes one or more streams.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The stream to flush. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.AllStreams"/></strong></strong></dt> <dt>0xFFFFFFFE</dt> </dl> </td><td> <p>All streams.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The <strong>Flush</strong> method discards all queued samples and cancels all pending sample requests.</p><p>This method can complete either synchronously or asynchronously. If you provide a callback reference when you create the source reader, the method is asynchronous. Otherwise, the method is synchronous. For more information about the setting the callback reference, see <see cref="SharpDX.MediaFoundation.SourceReaderAttributeKeys.AsyncCallback"/>.</p><p>In synchronous mode, the method blocks until the operation is complete.</p><p>In asynchronous mode, the application's <strong><see cref="SharpDX.MediaFoundation.SourceReaderCallback.OnFlush"/></strong> method is called when the flush operation completes. While a flush operation is pending, the <strong><see cref="SharpDX.MediaFoundation.SourceReader.ReadSample"/></strong> method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.NotAccepting"/></strong>.</p><strong>Note</strong>??In Windows?7, there was a bug in the implementation of this method, which causes <strong>OnFlush</strong> to be called before the flush operation completes. A hotfix is available that fixes this bug. For more information, see http://support.microsoft.com/kb/979567.?<p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReader::Flush']/*"/>	
        /// <msdn-id>dd374659</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReader::Flush([In] unsigned int dwStreamIndex)</unmanaged>	
        /// <unmanaged-short>IMFSourceReader::Flush</unmanaged-short>	
        public void Flush(int dwStreamIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Queries the underlying media source or decoder for an interface.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The stream or object to query. If the value is <strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.MediaSource"/></strong>, the method queries the media source. Otherwise, it queries the decoder that is associated with the specified stream. The following values are possible.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.MediaSource"/></strong></strong></dt> <dt>0xFFFFFFFF</dt> </dl> </td><td> <p>The media source.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="guidService"><dd> <p>A service identifier <see cref="System.Guid"/>.  If the value is <strong>GUID_NULL</strong>, the method calls <strong>QueryInterface</strong> to get the requested interface. Otherwise, the method calls the <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> method. For a list of service identifiers, see Service Interfaces.</p> </dd></param>	
        /// <param name="riid"><dd> <p>The interface identifier (IID) of the interface being requested. </p> </dd></param>	
        /// <returns><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReader::GetServiceForStream']/*"/>	
        /// <msdn-id>dd374663</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReader::GetServiceForStream([In] unsigned int dwStreamIndex,[In] const GUID&amp; guidService,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>	
        /// <unmanaged-short>IMFSourceReader::GetServiceForStream</unmanaged-short>	
        public System.IntPtr GetServiceForStream(int dwStreamIndex, System.Guid guidService, System.Guid riid)
        {
            unsafe
            {
                System.IntPtr vObjectOut;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, &guidService, &riid, &vObjectOut, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
                return vObjectOut;
            }
        }

        /// <summary>	
        /// <p>Gets an attribute from the underlying media source.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The stream or object to query. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.MediaSource"/></strong></strong></dt> <dt>0xFFFFFFFF</dt> </dl> </td><td> <p>The media source.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="guidAttribute"><dd> <p>A <see cref="System.Guid"/> that identifies the attribute to retrieve. If the <em>dwStreamIndex</em> parameter equals  <strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.MediaSource"/></strong>, <em>guidAttribute</em> can specify one of the following:</p> <ul> <li>A presentation descriptor attribute. For a list of values, see Presentation Descriptor Attributes.</li> <li> <see cref="SharpDX.MediaFoundation.SourceReaderAttributeKeys.MediaSourceCharacteristics"/>. Use this value to get characteristics flags from the media source.</li> </ul> <p>Otherwise, if the <em>dwStreamIndex</em> parameter specifies a stream, <em>guidAttribute</em> specifies a stream descriptor attribute. For a list of values, see Stream Descriptor Attributes.</p> </dd></param>	
        /// <returns><dd> <p>A reference to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that receives the value of the attribute. Call the <strong>PropVariantClear</strong> function to free the <strong><see cref="SharpDX.Win32.Variant"/></strong>. </p> </dd></returns>	
        /// <remarks>	
        /// <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReader::GetPresentationAttribute']/*"/>	
        /// <msdn-id>dd374662</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReader::GetPresentationAttribute([In] unsigned int dwStreamIndex,[In] const GUID&amp; guidAttribute,[Out] PROPVARIANT* pvarAttribute)</unmanaged>	
        /// <unmanaged-short>IMFSourceReader::GetPresentationAttribute</unmanaged-short>	
        public SharpDX.Win32.Variant GetPresentationAttribute(int dwStreamIndex, System.Guid guidAttribute)
        {
            unsafe
            {
                SharpDX.Win32.Variant varAttributeRef;
                varAttributeRef = new SharpDX.Win32.Variant();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, &guidAttribute, &varAttributeRef, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
                return varAttributeRef;
            }
        }
    }
    /// <summary>	
    /// <p>Callback interface for the Microsoft Media Foundation source reader.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Use the <see cref="SharpDX.MediaFoundation.SourceReaderAttributeKeys.AsyncCallback"/> attribute to set the callback reference when you first create the source reader object.</p><p>The callback methods can be called from any thread, so an object that implements this interface must be thread-safe.</p><p>If you do not specify a callback reference, the source reader operates synchronously.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReaderCallback']/*"/>	
    /// <msdn-id>dd374656</msdn-id>	
    /// <unmanaged>IMFSourceReaderCallback</unmanaged>	
    /// <unmanaged-short>IMFSourceReaderCallback</unmanaged-short>	
    [Guid("deec8d99-fa1d-4d82-84c2-2c8969944867")]
    public partial class SourceReaderCallback : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SourceReaderCallback"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SourceReaderCallback(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SourceReaderCallback"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SourceReaderCallback(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SourceReaderCallback(nativePointer);
        }


        /// <summary>	
        /// <p>Called when the <strong><see cref="SharpDX.MediaFoundation.SourceReader.ReadSample"/></strong> method completes.</p>	
        /// </summary>	
        /// <param name="hrStatus">No documentation.</param>	
        /// <param name="dwStreamIndex">No documentation.</param>	
        /// <param name="dwStreamFlags">No documentation.</param>	
        /// <param name="llTimestamp">No documentation.</param>	
        /// <param name="sampleRef">No documentation.</param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Currently, the source reader ignores the return value.</p></returns>	
        /// <remarks>	
        /// <p>The <em>pSample</em> parameter might be <strong><c>null</c></strong>. For example, when the source reader reaches the end of a stream, <em>dwStreamFlags</em> contains the <strong><see cref="SharpDX.MediaFoundation.SourceReaderFlags.Endofstream"/></strong> flag, and <em>pSample</em> is <strong><c>null</c></strong>. </p><p>If there is a gap in the stream, <em>dwStreamFlags</em> contains the <strong><see cref="SharpDX.MediaFoundation.SourceReaderFlags.StreamTick"/></strong> flag, <em>pSample</em> is <strong><c>null</c></strong>, and <em>llTimestamp</em> indicates the time when the gap occurred.  </p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReaderCallback::OnReadSample']/*"/>	
        /// <msdn-id>dd374658</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReaderCallback::OnReadSample([In] HRESULT hrStatus,[In] unsigned int dwStreamIndex,[In] unsigned int dwStreamFlags,[In] longlong llTimestamp,[In, Optional] IMFSample* pSample)</unmanaged>	
        /// <unmanaged-short>IMFSourceReaderCallback::OnReadSample</unmanaged-short>	
        public void OnReadSample(SharpDX.Result hrStatus, int dwStreamIndex, int dwStreamFlags, long llTimestamp, SharpDX.MediaFoundation.Sample sampleRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint78(_nativePointer, hrStatus, dwStreamIndex, dwStreamFlags, llTimestamp, (void*)((sampleRef == null) ? IntPtr.Zero : sampleRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Called when the <strong><see cref="SharpDX.MediaFoundation.SourceReader.Flush"/></strong> method completes.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex">No documentation.</param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Currently, the source reader ignores the return value.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReaderCallback::OnFlush']/*"/>	
        /// <msdn-id>dd374657</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReaderCallback::OnFlush([In] unsigned int dwStreamIndex)</unmanaged>	
        /// <unmanaged-short>IMFSourceReaderCallback::OnFlush</unmanaged-short>	
        public void OnFlush(int dwStreamIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Called when the source reader receives certain events from the media source.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>For stream events, the value is the zero-based index of the stream that sent the event. For source events, the value is <strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.MediaSource"/></strong>.</p> </dd></param>	
        /// <param name="eventRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaEvent"/></strong> interface of the event.</p> </dd></param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Currently, the source reader ignores the return value.</p></returns>	
        /// <remarks>	
        /// <p>In the current implementation,  the source reader uses this method to forward the following events to the application:</p><ul> <li> <see cref="SharpDX.MediaFoundation.MediaEventTypes.BufferingStarted"/> </li> <li> <see cref="SharpDX.MediaFoundation.MediaEventTypes.BufferingStopped"/> </li> <li> <see cref="SharpDX.MediaFoundation.MediaEventTypes.ConnectEnd"/> </li> <li> <see cref="SharpDX.MediaFoundation.MediaEventTypes.ConnectStart"/> </li> <li> <see cref="SharpDX.MediaFoundation.MediaEventTypes.ExtendedType"/> </li> <li> <see cref="SharpDX.MediaFoundation.MediaEventTypes.SourceCharacteristicsChanged"/> </li> <li> <see cref="SharpDX.MediaFoundation.MediaEventTypes.SourceMetadataChanged"/> </li> </ul><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReaderCallback::OnEvent']/*"/>	
        /// <msdn-id>dd743367</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReaderCallback::OnEvent([In] unsigned int dwStreamIndex,[In] IMFMediaEvent* pEvent)</unmanaged>	
        /// <unmanaged-short>IMFSourceReaderCallback::OnEvent</unmanaged-short>	
        public void OnEvent(int dwStreamIndex, SharpDX.MediaFoundation.MediaEvent eventRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, (void*)((eventRef == null) ? IntPtr.Zero : eventRef.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Extends the <strong><see cref="SharpDX.MediaFoundation.SourceReaderCallback"/></strong> interface.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface provides a mechanism for apps that use <strong><see cref="SharpDX.MediaFoundation.SourceReader"/></strong> to receive asynchronous notifications when the transform chain is complete and the system is ready for use or when an asynchronous error occurs.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReaderCallback2']/*"/>	
    /// <msdn-id>dn949418</msdn-id>	
    /// <unmanaged>IMFSourceReaderCallback2</unmanaged>	
    /// <unmanaged-short>IMFSourceReaderCallback2</unmanaged-short>	
    [Guid("CF839FE6-8C2A-4DD2-B6EA-C22D6961AF05")]
    public partial class SourceReaderCallback2 : SharpDX.MediaFoundation.SourceReaderCallback
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SourceReaderCallback2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SourceReaderCallback2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SourceReaderCallback2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SourceReaderCallback2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SourceReaderCallback2(nativePointer);
        }


        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when the transform chain in the <strong><see cref="SharpDX.MediaFoundation.SourceReader"/></strong> is built or modified.</p>	
        /// </summary>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Currently, the source reader ignores the return value.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReaderCallback2::OnTransformChange']/*"/>	
        /// <msdn-id>dn949420</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReaderCallback2::OnTransformChange()</unmanaged>	
        /// <unmanaged-short>IMFSourceReaderCallback2::OnTransformChange</unmanaged-short>	
        public void OnTransformChange()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when an asynchronous error occurs with the <strong><see cref="SharpDX.MediaFoundation.SourceReader"/></strong>.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex">No documentation.</param>	
        /// <param name="hrStatus">No documentation.</param>	
        /// <returns><p>Returns an <strong><see cref="SharpDX.Result"/></strong> value. Currently, the source reader ignores the return value.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReaderCallback2::OnStreamError']/*"/>	
        /// <msdn-id>dn949419</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReaderCallback2::OnStreamError([In] unsigned int dwStreamIndex,[In] HRESULT hrStatus)</unmanaged>	
        /// <unmanaged-short>IMFSourceReaderCallback2::OnStreamError</unmanaged-short>	
        public void OnStreamError(int dwStreamIndex, SharpDX.Result hrStatus)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint79(_nativePointer, dwStreamIndex, hrStatus, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Extends the <strong><see cref="SharpDX.MediaFoundation.SourceReader"/></strong> interface.</p><p>The Source Reader implements this interface in Windows?8. To get a reference to this interface, call <strong>QueryInterface</strong> on the Source Reader.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReaderEx']/*"/>	
    /// <msdn-id>hh448062</msdn-id>	
    /// <unmanaged>IMFSourceReaderEx</unmanaged>	
    /// <unmanaged-short>IMFSourceReaderEx</unmanaged-short>	
    [Guid("7b981cf0-560e-4116-9875-b099895f23d7")]
    public partial class SourceReaderEx : SharpDX.MediaFoundation.SourceReader
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SourceReaderEx"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SourceReaderEx(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SourceReaderEx"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SourceReaderEx(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SourceReaderEx(nativePointer);
        }


        /// <summary>	
        /// <p>Sets the native media type for a stream on the media source.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd></dd></param>	
        /// <param name="mediaTypeRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type.</p> </dd></param>	
        /// <param name="dwStreamFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more of the following flags.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.SourceReaderFlags.AllEffectsremoved"/></strong></dt> </dl> </td><td> <p>All effects were removed from the stream.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.MediaFoundation.SourceReaderFlags.Currentmediatypechanged"/></strong></dt> </dl> </td><td> <p>The current output type changed.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid request.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></strong></dt> </dl> </td><td> <p>The <em>dwStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method sets the output type that is produced by the media source. Unlike the <strong><see cref="SharpDX.MediaFoundation.SourceReader.SetCurrentMediaType"/></strong> method, this method does not insert any decoders, video processors, or other transforms. The media source must support the specified media type natively. To get a list of supported types from the media source, call <strong><see cref="SharpDX.MediaFoundation.SourceReader.GetNativeMediaType"/></strong>.</p><p>In asynchronous mode, this method fails if a sample request is pending. In that case, wait for the <strong>OnReadSample</strong> callback to be invoked before calling the method. For more information about using the Source Reader in asynchronous mode, see <strong><see cref="SharpDX.MediaFoundation.SourceReader.ReadSample"/></strong>.</p><p>This method can trigger a change in the output format for the stream. If so, the <strong><see cref="SharpDX.MediaFoundation.SourceReaderFlags.Currentmediatypechanged"/></strong> flag is returned in the  <em>pdwStreamFlags</em> parameter. The method might also cause the Source Reader to remove any effects that were added by the <strong><see cref="SharpDX.MediaFoundation.SourceReaderEx.AddTransformForStream"/></strong> method. If this occurs, the  <strong><see cref="SharpDX.MediaFoundation.SourceReaderFlags.AllEffectsremoved"/></strong> flag is returned in <em>pdwStreamFlags</em>. </p><p>This method is useful with audio and video capture devices, because a device might support several output formats. This method enables the application to choose the device format before decoders and other transforms are added.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReaderEx::SetNativeMediaType']/*"/>	
        /// <msdn-id>hh448066</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReaderEx::SetNativeMediaType([In] unsigned int dwStreamIndex,[In, Optional] IMFMediaType* pMediaType,[Out] unsigned int* pdwStreamFlags)</unmanaged>	
        /// <unmanaged-short>IMFSourceReaderEx::SetNativeMediaType</unmanaged-short>	
        public void SetNativeMediaType(int dwStreamIndex, SharpDX.MediaFoundation.MediaType mediaTypeRef, out int dwStreamFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwStreamFlagsRef_ = &dwStreamFlagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, (void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), dwStreamFlagsRef_, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Adds a transform, such as an audio or video effect, to a stream.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The stream to configure. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="transformOrActivateRef"><dd> <p>A reference to one of the following:</p> <ul> <li>A Media Foundation transform (MFT) that exposes the <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> interface.</li> <li>An MFT activation object that exposes the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface.</li> </ul> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidMediaType"/></strong></dt> </dl> </td><td> <p>The transform does not support the current stream format, and no conversion was possible. See Remarks for more information.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid request.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></strong></dt> </dl> </td><td> <p>The <em>dwStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method attempts to add the transform at the end of the current processing chain. </p><p>To use this method, make the following sequence of calls:</p><ol> <li>Call <strong><see cref="SharpDX.MediaFoundation.SourceReader.SetCurrentMediaType"/></strong> to set the output type that you want for the stream. In this step, you can specify a media type that contains only the major type and subtype GUIDs. For example, to get 32-bit RGB output, set a major type of <strong><see cref="SharpDX.MediaFoundation.MediaTypeGuids.Video"/></strong> and a subtype of <strong><see cref="SharpDX.MediaFoundation.VideoFormatGuids.Rgb32"/></strong>. (For more information, see Media Type GUIDs.)</li> <li>Call <strong>AddTransformForStream</strong>. If the Source Reader successfully connects the transform, it sets the output type on the transform.</li> <li>Call <strong><see cref="SharpDX.MediaFoundation.SourceReader.GetCurrentMediaType"/></strong> to get the output type from the transform. This method returns a media type with a complete format description.</li> <li>Optionally, if you want to modify the output type, call <strong><see cref="SharpDX.MediaFoundation.SourceReader.SetCurrentMediaType"/></strong> again to set a complete media type on the transform.</li> </ol><p>The <strong>AddTransformForStream</strong> method will not insert a decoder into the processing chain. If the native stream format is encoded, and the transform requires an uncompressed format, call <strong>SetCurrentMediaType</strong> to set the uncompressed format (step 1 in the previous list). However, the method will insert a video processor to convert between RGB and YUV formats, if required.</p><p>The method fails if the source reader was configured with the <see cref="SharpDX.MediaFoundation.SinkWriterAttributeKeys.ReadwriteDisableConverters"/> or <see cref="SharpDX.MediaFoundation.SourceReaderAttributeKeys.EnableVideoProcessing"/> attributes. </p><p>In asynchronous mode, the method also fails if a sample request is pending. In that case, wait for the <strong>OnReadSample</strong> callback to be invoked before calling the method. For more information about using the Source Reader in asynchronous mode, see <strong><see cref="SharpDX.MediaFoundation.SourceReader.ReadSample"/></strong>.</p><p>You can add a transform at any time during streaming. However, the method does not flush or drain the pipeline before inserting the transform. Therefore, if data is already in the pipeline, the next sample is not guaranteed to have the transform applied.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReaderEx::AddTransformForStream']/*"/>	
        /// <msdn-id>hh448063</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReaderEx::AddTransformForStream([In] unsigned int dwStreamIndex,[In] IUnknown* pTransformOrActivate)</unmanaged>	
        /// <unmanaged-short>IMFSourceReaderEx::AddTransformForStream</unmanaged-short>	
        public void AddTransformForStream(int dwStreamIndex, SharpDX.ComObject transformOrActivateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, (void*)((transformOrActivateRef == null) ? IntPtr.Zero : transformOrActivateRef.NativePointer), ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Removes all of the Media Foundation transforms (MFTs) for a specified stream, with the exception of the decoder.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The stream for which to remove the MFTs. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid request.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></strong></dt> </dl> </td><td> <p>The <em>dwStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Calling this method can reset the current output type for the stream. To get the new output type, call <strong><see cref="SharpDX.MediaFoundation.SourceReader.GetCurrentMediaType"/></strong>.</p><p>In asynchronous mode, this method fails if a sample request is pending. In that case, wait for the <strong>OnReadSample</strong> callback to be invoked before calling the method. For more information about using the Source Reader in asynchronous mode, see <strong><see cref="SharpDX.MediaFoundation.SourceReader.ReadSample"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReaderEx::RemoveAllTransformsForStream']/*"/>	
        /// <msdn-id>hh448065</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReaderEx::RemoveAllTransformsForStream([In] unsigned int dwStreamIndex)</unmanaged>	
        /// <unmanaged-short>IMFSourceReaderEx::RemoveAllTransformsForStream</unmanaged-short>	
        public void RemoveAllTransformsForStream(int dwStreamIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a reference to a Media Foundation transform (MFT) for a specified stream.</p>	
        /// </summary>	
        /// <param name="dwStreamIndex"><dd> <p>The stream to query for the MFT. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="dwTransformIndex"><dd> <p>The zero-based index of the MFT to retreive.</p> </dd></param>	
        /// <param name="guidCategoryRef"><dd> <p>Receives a <see cref="System.Guid"/> that specifies the category of the MFT. For a list of possible values, see <strong>MFT_CATEGORY</strong>.</p> </dd></param>	
        /// <param name="transformOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> interface of the MFT. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidIndex"/></strong></dt> </dl> </td><td> <p>The <em>dwTransformIndex</em> parameter is out of range.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></strong></dt> </dl> </td><td> <p>The <em>dwStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You can use this method to configure an MFT after it is inserted into the processing chain. Do not use the reference returned in <em>ppTransform</em> to set media types on the MFT or to process data. In particular, calling any of the following <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> methods could have unexpected results.</p><ul> <li> <strong>AddInputStreams</strong> </li> <li> <strong>DeleteInputStream</strong> </li> <li> <strong>ProcessEvent</strong> </li> <li> <strong>ProcessInput</strong> </li> <li> <strong>ProcessMessage</strong> </li> <li> <strong>ProcessOutput</strong> </li> <li> <strong>SetInputType</strong> </li> <li> <strong>SetOutputType</strong> </li> </ul><p>If a decoder is present, it appears at index position zero.</p><p>To avoid losing any data, you should drain the source reader before calling this method. For more information, see Draining the Data Pipeline.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceReaderEx::GetTransformForStream']/*"/>	
        /// <msdn-id>hh448064</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceReaderEx::GetTransformForStream([In] unsigned int dwStreamIndex,[In] unsigned int dwTransformIndex,[Out, Optional] GUID* pGuidCategory,[Out] IMFTransform** ppTransform)</unmanaged>	
        /// <unmanaged-short>IMFSourceReaderEx::GetTransformForStream</unmanaged-short>	
        public void GetTransformForStream(int dwStreamIndex, int dwTransformIndex, out System.Guid guidCategoryRef, out SharpDX.MediaFoundation.Transform transformOut)
        {
            unsafe
            {
                guidCategoryRef = new System.Guid();
                IntPtr transformOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* guidCategoryRef_ = &guidCategoryRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIndex, dwTransformIndex, guidCategoryRef_, &transformOut_, ((void**)(*(void**)_nativePointer))[16]);
                transformOut = (transformOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Transform(transformOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Creates a media source from a URL or a byte stream. The Source Resolver implements this interface. To create the source resolver, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateSourceResolver"/></strong> function.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceResolver']/*"/>	
    /// <msdn-id>ms694009</msdn-id>	
    /// <unmanaged>IMFSourceResolver</unmanaged>	
    /// <unmanaged-short>IMFSourceResolver</unmanaged-short>	
    [Guid("FBE5A32D-A497-4b61-BB85-97B1A848A6E3")]
    public partial class SourceResolver : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SourceResolver"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SourceResolver(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SourceResolver"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SourceResolver(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SourceResolver(nativePointer);
        }


        /// <summary>	
        /// <p> Creates a media source or a byte stream from a URL. This method is synchronous. </p>	
        /// </summary>	
        /// <param name="wszURLRef"><dd> <p> Null-terminated string that contains the URL to resolve. </p> </dd></param>	
        /// <param name="dwFlags"><dd> <p> Bitwise OR of one or more flags. See <strong>Source Resolver Flags</strong>. See remarks below.</p> </dd></param>	
        /// <param name="propsRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a property store. The method passes the property store to the scheme handler or byte-stream handler that creates the object. The handler can use the property store to configure the object. This parameter can be <strong><c>null</c></strong>. For more information, see Configuring a Media Source. </p> </dd></param>	
        /// <param name="objectTypeRef"><dd> <p> Receives a member of the <strong><see cref="SharpDX.MediaFoundation.ObjectType"/></strong> enumeration, specifying the type of object that was created. </p> </dd></param>	
        /// <param name="objectOut"><dd> <p> Receives a reference to the object's <strong><see cref="SharpDX.ComObject"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.SourceResolverMutuallyExclusiveFlags"/></strong></dt> </dl> </td><td> <p> The <em>dwFlags</em> parameter contains mutually exclusive flags. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedScheme"/></strong></dt> </dl> </td><td> <p> The URL scheme is not supported. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The <em>dwFlags</em> parameter must contain either the <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong> flag or the <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong> flag, but should not contain both.</p><p>It is recommended that you do not set <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.Write"/></strong> on the input argument <em>dwFlags</em> unless it is necessary for your scenario. For most use-cases, media sources do not need to be created with write capability. Creating a media source with write capability may have a lower probability of success than creating a media source without write capability. This is because there can be stricter checks on the content represented by the URL when creating a media source with write capability.</p><p>For local files, you can pass the file name in the <em>pwszURL</em> parameter; the <code>file:</code> scheme is not required.</p><strong>Note</strong>??This method cannot be called remotely.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceResolver::CreateObjectFromURL']/*"/>	
        /// <msdn-id>ms702279</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceResolver::CreateObjectFromURL([In] const wchar_t* pwszURL,[In] unsigned int dwFlags,[In] IPropertyStore* pProps,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>	
        /// <unmanaged-short>IMFSourceResolver::CreateObjectFromURL</unmanaged-short>	
        internal void CreateObjectFromURL(string wszURLRef, int dwFlags, SharpDX.ComObject propsRef, out SharpDX.MediaFoundation.ObjectType objectTypeRef, out SharpDX.ComObject objectOut)
        {
            unsafe
            {
                IntPtr objectOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* wszURLRef_ = wszURLRef)
                fixed (void* objectTypeRef_ = &objectTypeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)wszURLRef_, dwFlags, (void*)((propsRef == null) ? IntPtr.Zero : propsRef.NativePointer), objectTypeRef_, &objectOut_, ((void**)(*(void**)_nativePointer))[3]);
                objectOut = (objectOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(objectOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates a media source from a byte stream. This method is synchronous. </p>	
        /// </summary>	
        /// <param name="byteStreamRef"><dd> <p> Pointer to the byte stream's <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface. </p> </dd></param>	
        /// <param name="wszURLRef"><dd> <p> Null-terminated string that contains the URL of the byte stream. The URL is optional and can be <strong><c>null</c></strong>. See Remarks for more information. </p> </dd></param>	
        /// <param name="dwFlags"><dd> <p> Bitwise <strong>OR</strong> of flags. See <strong>Source Resolver Flags</strong>. </p> </dd></param>	
        /// <param name="propsRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a property store. The method passes the property store to the byte-stream handler. The byte-stream handler can use the property store to configure the media source. This parameter can be <strong><c>null</c></strong>. For more information, see Configuring a Media Source. </p> </dd></param>	
        /// <param name="objectTypeRef"><dd> <p> Receives a member of the <strong><see cref="SharpDX.MediaFoundation.ObjectType"/></strong> enumeration, specifying the type of object that was created. </p> </dd></param>	
        /// <param name="objectOut"><dd> <p> Receives a reference to the media source's <strong><see cref="SharpDX.ComObject"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.SourceResolverMutuallyExclusiveFlags"/></strong></dt> </dl> </td><td> <p> The <em>dwFlags</em> parameter contains mutually exclusive flags. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedByteStreamType"/></strong></dt> </dl> </td><td> <p> This byte stream is not supported. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The <em>dwFlags</em> parameter must contain the <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong> flag and should not contain the <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong> flag.</p><p>The source resolver attempts to find one or more byte-stream handlers for the byte stream, based on the file name extension of the URL, or the MIME type of the byte stream (or both). The URL is specified in the optional <em>pwszURL</em> parameter, and the MIME type may be specified in the <strong><see cref="SharpDX.MediaFoundation.ByteStreamAttributeKeys.ContentType"/></strong> attribute on the byte stream. Byte-stream handlers are registered by file name extension or MIME type, or both, as described in Scheme Handlers and Byte-Stream Handlers. The caller should specify at least one of these values (both if possible):</p><ul> <li> Specify the URL in the <em>pwszURL</em> parameter. </li> <li> Specify the MIME type by setting the <strong><see cref="SharpDX.MediaFoundation.ByteStreamAttributeKeys.ContentType"/></strong> attribute on the byte stream. (This attribute might be set already when you create the byte stream, depending on how the byte stream was created.) </li> </ul><strong>Note</strong>??This method cannot be called remotely.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceResolver::CreateObjectFromByteStream']/*"/>	
        /// <msdn-id>ms704671</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceResolver::CreateObjectFromByteStream([In] IMFByteStream* pByteStream,[In] const wchar_t* pwszURL,[In] unsigned int dwFlags,[In] IPropertyStore* pProps,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>	
        /// <unmanaged-short>IMFSourceResolver::CreateObjectFromByteStream</unmanaged-short>	
        internal void CreateObjectFromByteStream_(System.IntPtr byteStreamRef, string wszURLRef, int dwFlags, SharpDX.ComObject propsRef, out SharpDX.MediaFoundation.ObjectType objectTypeRef, out SharpDX.ComObject objectOut)
        {
            unsafe
            {
                IntPtr objectOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* wszURLRef_ = wszURLRef)
                fixed (void* objectTypeRef_ = &objectTypeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)byteStreamRef, (void*)wszURLRef_, dwFlags, (void*)((propsRef == null) ? IntPtr.Zero : propsRef.NativePointer), objectTypeRef_, &objectOut_, ((void**)(*(void**)_nativePointer))[4]);
                objectOut = (objectOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(objectOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Begins an asynchronous request to create a media source or a byte stream from a URL.</p>	
        /// </summary>	
        /// <param name="wszURLRef"><dd> <p>Null-terminated string that contains the URL to resolve.</p> </dd></param>	
        /// <param name="dwFlags"><dd> <p>Bitwise OR of flags. See <strong>Source Resolver Flags</strong>.</p> </dd></param>	
        /// <param name="propsRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a property store. The method passes the property store to the scheme handler or byte-stream handler that creates the object. The handler can use the property store to configure the object. This parameter can be <strong><c>null</c></strong>. For more information, see Configuring a Media Source.</p> </dd></param>	
        /// <param name="iUnknownCancelCookieOut"><dd> <p>Receives an <strong><see cref="SharpDX.ComObject"/></strong> reference or the value <strong><c>null</c></strong>. If the value is not <strong><c>null</c></strong>, you can cancel the asynchronous operation by passing this reference to the <strong><see cref="SharpDX.MediaFoundation.SourceResolver.CancelObjectCreation"/></strong> method. The caller must release the interface. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.SourceResolverMutuallyExclusiveFlags"/></strong></dt> </dl> </td><td> <p>The <em>dwFlags</em> parameter contains mutually exclusive flags.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedScheme"/></strong></dt> </dl> </td><td> <p>The URL scheme is not supported.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The <em>dwFlags</em> parameter must contain either the <see cref="SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/> flag or the <see cref="SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/> flag, but should not contain both.</p><p>For local files, you can pass the file name in the <em>pwszURL</em> parameter; the <code>file:</code> scheme is not required.</p><p>When the operation completes, the source resolver calls the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method. The <strong>Invoke</strong> method should call <strong><see cref="SharpDX.MediaFoundation.SourceResolver.EndCreateObjectFromURL"/></strong> to get a reference to the object that was created.</p><p>The usage of the <em>pProps</em> parameter depends on the implementation of the media source. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceResolver::BeginCreateObjectFromURL']/*"/>	
        /// <msdn-id>ms702995</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceResolver::BeginCreateObjectFromURL([In] const wchar_t* pwszURL,[In] unsigned int dwFlags,[In] IPropertyStore* pProps,[Out, Optional] IUnknown** ppIUnknownCancelCookie,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>	
        /// <unmanaged-short>IMFSourceResolver::BeginCreateObjectFromURL</unmanaged-short>	
        internal void BeginCreateObjectFromURL_(string wszURLRef, int dwFlags, SharpDX.ComObject propsRef, out SharpDX.ComObject iUnknownCancelCookieOut, System.IntPtr callbackRef, SharpDX.ComObject unkStateRef)
        {
            unsafe
            {
                IntPtr iUnknownCancelCookieOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* wszURLRef_ = wszURLRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)wszURLRef_, dwFlags, (void*)((propsRef == null) ? IntPtr.Zero : propsRef.NativePointer), &iUnknownCancelCookieOut_, (void*)callbackRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                iUnknownCancelCookieOut = (iUnknownCancelCookieOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(iUnknownCancelCookieOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Completes an asynchronous request to create an object from a URL. </p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>Invoke</strong> method. </p> </dd></param>	
        /// <param name="objectTypeRef"><dd> <p> Receives a member of the <strong><see cref="SharpDX.MediaFoundation.ObjectType"/></strong> enumeration, specifying the type of object that was created. </p> </dd></param>	
        /// <param name="objectOut"><dd> <p> Receives a reference to the media source's <strong><see cref="SharpDX.ComObject"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_ABORT</strong></dt> </dl> </td><td> <p> The operation was canceled. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method from inside your application's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceResolver::EndCreateObjectFromURL']/*"/>	
        /// <msdn-id>ms702134</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceResolver::EndCreateObjectFromURL([In] IMFAsyncResult* pResult,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>	
        /// <unmanaged-short>IMFSourceResolver::EndCreateObjectFromURL</unmanaged-short>	
        public void EndCreateObjectFromURL(SharpDX.MediaFoundation.AsyncResult resultRef, out SharpDX.MediaFoundation.ObjectType objectTypeRef, out SharpDX.ComObject objectOut)
        {
            unsafe
            {
                IntPtr objectOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* objectTypeRef_ = &objectTypeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), objectTypeRef_, &objectOut_, ((void**)(*(void**)_nativePointer))[6]);
                objectOut = (objectOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(objectOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Begins an asynchronous request to create a media source from a byte stream.</p>	
        /// </summary>	
        /// <param name="byteStreamRef"><dd> <p>A reference to the byte stream's <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface. </p> </dd></param>	
        /// <param name="wszURLRef"><dd> <p>A null-terminated string that contains the original URL of the byte stream. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="dwFlags"><dd> <p>A bitwise <strong>OR</strong> of one or more flags. See <strong>Source Resolver Flags</strong>. </p> </dd></param>	
        /// <param name="propsRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a property store. The method passes the property store to the byte-stream handler. The byte-stream handler can use the property store to configure the media source. This parameter can be <strong><c>null</c></strong>. For more information, see Configuring a Media Source. </p> </dd></param>	
        /// <param name="iUnknownCancelCookieOut"><dd> <p>Receives an <strong><see cref="SharpDX.ComObject"/></strong> reference or the value <strong><c>null</c></strong>. If the value is not <strong><c>null</c></strong>, you can cancel the asynchronous operation by passing this reference to the <strong><see cref="SharpDX.MediaFoundation.SourceResolver.CancelObjectCreation"/></strong> method. The caller must release the interface. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p>A oointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.SourceResolverMutuallyExclusiveFlags"/></strong></dt> </dl> </td><td> <p>The <em>dwFlags</em> parameter contains mutually exclusive flags.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedByteStreamType"/></strong></dt> </dl> </td><td> <p>The byte stream is not supported.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ByteStreamNotSeekable"/></strong></dt> </dl> </td><td> <p>The byte stream does not support seeking.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The <em>dwFlags</em> parameter must contain the <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong> flag and should not contain the <strong><see cref="SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong> flag.</p><p>The source resolver attempts to find one or more byte-stream handlers for the byte stream, based on the file name extension of the URL, or the MIME type of the byte stream (or both). The URL is specified in the optional <em>pwszURL</em> parameter, and the MIME type may be specified in the <strong><see cref="SharpDX.MediaFoundation.ByteStreamAttributeKeys.ContentType"/></strong> attribute on the byte stream. Byte-stream handlers are registered by file name extension or MIME type, or both, as described in Scheme Handlers and Byte-Stream Handlers. The caller should specify at least one of these values.</p><p>When the operation completes, the source resolver calls the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method. The <strong>Invoke</strong> method should call <strong><see cref="SharpDX.MediaFoundation.SourceResolver.EndCreateObjectFromByteStream"/></strong> to get a reference to the media source.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceResolver::BeginCreateObjectFromByteStream']/*"/>	
        /// <msdn-id>ms698915</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceResolver::BeginCreateObjectFromByteStream([In] IMFByteStream* pByteStream,[In] const wchar_t* pwszURL,[In] unsigned int dwFlags,[In] IPropertyStore* pProps,[Out, Optional] IUnknown** ppIUnknownCancelCookie,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>	
        /// <unmanaged-short>IMFSourceResolver::BeginCreateObjectFromByteStream</unmanaged-short>	
        internal void BeginCreateObjectFromByteStream__(System.IntPtr byteStreamRef, string wszURLRef, int dwFlags, SharpDX.ComObject propsRef, out SharpDX.ComObject iUnknownCancelCookieOut, System.IntPtr callbackRef, SharpDX.ComObject unkStateRef)
        {
            unsafe
            {
                IntPtr iUnknownCancelCookieOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* wszURLRef_ = wszURLRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)byteStreamRef, (void*)wszURLRef_, dwFlags, (void*)((propsRef == null) ? IntPtr.Zero : propsRef.NativePointer), &iUnknownCancelCookieOut_, (void*)callbackRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), ((void**)(*(void**)_nativePointer))[7]);
                iUnknownCancelCookieOut = (iUnknownCancelCookieOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(iUnknownCancelCookieOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Completes an asynchronous request to create a media source from a byte stream.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>Invoke</strong> method.</p> </dd></param>	
        /// <param name="objectTypeRef"><dd> <p>Receives a member of the <strong><see cref="SharpDX.MediaFoundation.ObjectType"/></strong> enumeration, specifying the type of object that was created.</p> </dd></param>	
        /// <param name="objectOut"><dd> <p>Receives a reference to the media source's <strong><see cref="SharpDX.ComObject"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_ABORT</strong></dt> </dl> </td><td> <p>The application canceled the operation.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method from inside your application's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceResolver::EndCreateObjectFromByteStream']/*"/>	
        /// <msdn-id>ms697199</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceResolver::EndCreateObjectFromByteStream([In] IMFAsyncResult* pResult,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>	
        /// <unmanaged-short>IMFSourceResolver::EndCreateObjectFromByteStream</unmanaged-short>	
        public void EndCreateObjectFromByteStream(SharpDX.MediaFoundation.AsyncResult resultRef, out SharpDX.MediaFoundation.ObjectType objectTypeRef, out SharpDX.ComObject objectOut)
        {
            unsafe
            {
                IntPtr objectOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* objectTypeRef_ = &objectTypeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), objectTypeRef_, &objectOut_, ((void**)(*(void**)_nativePointer))[8]);
                objectOut = (objectOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(objectOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Cancels an asynchronous request to create an object. </p>	
        /// </summary>	
        /// <param name="iUnknownCancelCookieRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface that was returned in the <em>ppIUnknownCancelCookie</em> parameter of the <strong><see cref="SharpDX.MediaFoundation.SourceResolver.BeginCreateObjectFromByteStream__"/></strong> or <strong><see cref="SharpDX.MediaFoundation.SourceResolver.BeginCreateObjectFromURL_"/></strong> method. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> You can use this method to cancel a previous call to <strong>BeginCreateObjectFromByteStream</strong> or <strong>BeginCreateObjectFromURL</strong>. Because these methods are asynchronous, however, they might be completed before the operation can be canceled. Therefore, your callback might still be invoked after you call this method. </p><strong>Note</strong>??This method cannot be called remotely.?	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSourceResolver::CancelObjectCreation']/*"/>	
        /// <msdn-id>ms698845</msdn-id>	
        /// <unmanaged>HRESULT IMFSourceResolver::CancelObjectCreation([In] IUnknown* pIUnknownCancelCookie)</unmanaged>	
        /// <unmanaged-short>IMFSourceResolver::CancelObjectCreation</unmanaged-short>	
        public void CancelObjectCreation(SharpDX.ComObject iUnknownCancelCookieRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((iUnknownCancelCookieRef == null) ? IntPtr.Zero : iUnknownCancelCookieRef.NativePointer), ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Implemented by a client and called by Microsoft Media Foundation to get the client Secure Sockets Layer (SSL) certificate requested by the server. </p><p>In most HTTPS connections the server provides a certificate so that the client can ensure the identity of the server. However, in certain cases the server might wants to verify the identity of the client by requesting the client to send a certificate. For this scenario,  a client application must provide a mechanism for Media Foundation to retrieve the client side certificate while opening an HTTPS URL with the source resolver or the scheme handler. The application must implement <strong><see cref="SharpDX.MediaFoundation.SSLCertificateManager"/></strong>, set the <strong><see cref="SharpDX.ComObject"/></strong> reference of the implemented object in the MFNETSOURCE_SSLCERTIFICATE_MANAGER property, and pass the property store to the source resolver. While opening the URL, Media Foundation calls the <strong><see cref="SharpDX.MediaFoundation.SSLCertificateManager"/></strong> methods to get the certificate information. If the application needs to connect to HTTPS URL that requires a client-side certificate, or the application  wants customized control over the type of server certificates to accept, then they can implement this interface. This interface can also be used by the application to validate the server SSL certificate.</p><p>If the <strong><see cref="SharpDX.ComObject"/></strong> reference is not provided by the application and the HTTPS URL does not require the client to provide a certificate,	
    /// Media Foundation uses the default implementation to open the URL.	
    /// </p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSSLCertificateManager']/*"/>	
    /// <msdn-id>dd374670</msdn-id>	
    /// <unmanaged>IMFSSLCertificateManager</unmanaged>	
    /// <unmanaged-short>IMFSSLCertificateManager</unmanaged-short>	
    [Guid("61f7d887-1230-4a8b-aeba-8ad434d1a64d")]
    public partial class SSLCertificateManager : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SSLCertificateManager"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SSLCertificateManager(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SSLCertificateManager"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SSLCertificateManager(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SSLCertificateManager(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the client SSL certificate synchronously.</p>	
        /// </summary>	
        /// <param name="szURLRef"><dd> <p>Pointer to a string that contains the URL for which a client-side SSL certificate is required. Media Foundation can resolve the scheme and send the request to the server.</p> </dd></param>	
        /// <param name="bDataOut"><dd> <p>Pointer to the buffer that stores the certificate.This caller must free the buffer by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <param name="cbDataRef"><dd> <p>Pointer to a <strong>DWORD</strong> variable that receives the number of bytes required to hold the certificate data in the buffer pointed by <em>*ppbData</em>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSSLCertificateManager::GetClientCertificate']/*"/>	
        /// <msdn-id>dd374674</msdn-id>	
        /// <unmanaged>HRESULT IMFSSLCertificateManager::GetClientCertificate([In] const wchar_t* pszURL,[Out, Buffer] unsigned char** ppbData,[Out] unsigned int* pcbData)</unmanaged>	
        /// <unmanaged-short>IMFSSLCertificateManager::GetClientCertificate</unmanaged-short>	
        public void GetClientCertificate(string szURLRef, byte[] bDataOut, out int cbDataRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* szURLRef_ = szURLRef)
                fixed (void* bDataOut_ = bDataOut)
                fixed (void* cbDataRef_ = &cbDataRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szURLRef_, bDataOut_, cbDataRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Starts an asynchronous call to get the client SSL certificate.</p>	
        /// </summary>	
        /// <param name="szURLRef"><dd> <p>A null-terminated string that contains the URL for which a client-side SSL certificate is required. Media Foundation can  resolve the scheme and send the request to the server.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>	
        /// <param name="stateRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.  </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>When the operation completes, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, the application should call <strong><see cref="SharpDX.MediaFoundation.SSLCertificateManager.EndGetClientCertificate"/></strong> to complete the asynchronous request.  </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSSLCertificateManager::BeginGetClientCertificate']/*"/>	
        /// <msdn-id>dd374671</msdn-id>	
        /// <unmanaged>HRESULT IMFSSLCertificateManager::BeginGetClientCertificate([In] const wchar_t* pszURL,[In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>	
        /// <unmanaged-short>IMFSSLCertificateManager::BeginGetClientCertificate</unmanaged-short>	
        internal void BeginGetClientCertificate_(string szURLRef, System.IntPtr callbackRef, SharpDX.ComObject stateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* szURLRef_ = szURLRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szURLRef_, (void*)callbackRef, (void*)((stateRef == null) ? IntPtr.Zero : stateRef.NativePointer), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Completes an asynchronous request to get the client SSL certificate. </p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.  </p> </dd></param>	
        /// <param name="bDataOut"><dd> <p>Receives a reference to the buffer that stores the certificate.The caller must free the buffer by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <param name="cbDataRef"><dd> <p>Receives the size of the <em>ppbData</em> buffer, in bytes.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Call this method after the <strong><see cref="SharpDX.MediaFoundation.SSLCertificateManager.BeginGetClientCertificate_"/></strong> method completes asynchronously. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSSLCertificateManager::EndGetClientCertificate']/*"/>	
        /// <msdn-id>dd374672</msdn-id>	
        /// <unmanaged>HRESULT IMFSSLCertificateManager::EndGetClientCertificate([In] IMFAsyncResult* pResult,[Out, Buffer] unsigned char** ppbData,[Out] unsigned int* pcbData)</unmanaged>	
        /// <unmanaged-short>IMFSSLCertificateManager::EndGetClientCertificate</unmanaged-short>	
        public void EndGetClientCertificate(SharpDX.MediaFoundation.AsyncResult resultRef, byte[] bDataOut, out int cbDataRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* bDataOut_ = bDataOut)
                fixed (void* cbDataRef_ = &cbDataRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), bDataOut_, cbDataRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Indicates whether the server SSL certificate must be verified by the caller, Media Foundation,  or the <strong><see cref="SharpDX.MediaFoundation.SSLCertificateManager"/></strong> implementation class.</p>	
        /// </summary>	
        /// <param name="szURLRef"><dd> <p> Pointer to a string that contains the URL that  is sent to the server.</p> </dd></param>	
        /// <param name="fOverrideAutomaticCheckRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawBool"/></strong> value. Set to <strong>TRUE</strong> if <strong><see cref="SharpDX.MediaFoundation.SSLCertificateManager.OnServerCertificate"/></strong> is used to verify the server certificate.Set to <strong><see cref="SharpDX.Result.False"/></strong> if Media Foundation verifies the server certificate  by using the certificates in the Windows certificate store.</p> </dd></param>	
        /// <param name="fClientCertificateAvailableRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawBool"/></strong> value. Set to <strong>TRUE</strong> if the SSL certificate for the client is available for immediate retrieval. Media Foundation  calls <strong><see cref="SharpDX.MediaFoundation.SSLCertificateManager.GetClientCertificate"/></strong> to obtain the client certificate synchronously. If the value is set to <strong><see cref="SharpDX.Result.False"/></strong>, Media Foundation obtains the client SSL certificate with an asynchronous call to <strong><see cref="SharpDX.MediaFoundation.SSLCertificateManager.BeginGetClientCertificate_"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSSLCertificateManager::GetCertificatePolicy']/*"/>	
        /// <msdn-id>dd374673</msdn-id>	
        /// <unmanaged>HRESULT IMFSSLCertificateManager::GetCertificatePolicy([In] const wchar_t* pszURL,[In] BOOL* pfOverrideAutomaticCheck,[In] BOOL* pfClientCertificateAvailable)</unmanaged>	
        /// <unmanaged-short>IMFSSLCertificateManager::GetCertificatePolicy</unmanaged-short>	
        public void GetCertificatePolicy(string szURLRef, SharpDX.Mathematics.Interop.RawBool fOverrideAutomaticCheckRef, SharpDX.Mathematics.Interop.RawBool fClientCertificateAvailableRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* szURLRef_ = szURLRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szURLRef_, &fOverrideAutomaticCheckRef, &fClientCertificateAvailableRef, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Called by Media Foundation when the server SSL certificate has been received; indicates whether the server certificate is accepted.</p>	
        /// </summary>	
        /// <param name="szURLRef"><dd> <p>Pointer to a string that contains the URL used to send the request to the server, and for which a server-side SSL certificate has been received.</p> </dd></param>	
        /// <param name="bDataRef"><dd> <p>Pointer to a buffer that contains the server SSL certificate.</p> </dd></param>	
        /// <param name="cbData"><dd> <p>Pointer to a <strong>DWORD</strong> variable that indicates the size of <em>pbData</em> in bytes.</p> </dd></param>	
        /// <param name="fIsGoodRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawBool"/></strong> variable that indicates whether the certificate is accepted.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSSLCertificateManager::OnServerCertificate']/*"/>	
        /// <msdn-id>dd374675</msdn-id>	
        /// <unmanaged>HRESULT IMFSSLCertificateManager::OnServerCertificate([In] const wchar_t* pszURL,[In, Buffer] unsigned char* pbData,[In] unsigned int cbData,[In] BOOL* pfIsGood)</unmanaged>	
        /// <unmanaged-short>IMFSSLCertificateManager::OnServerCertificate</unmanaged-short>	
        public void OnServerCertificate(string szURLRef, byte[] bDataRef, int cbData, SharpDX.Mathematics.Interop.RawBool fIsGoodRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* szURLRef_ = szURLRef)
                fixed (void* bDataRef_ = bDataRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szURLRef_, bDataRef_, cbData, &fIsGoodRef, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Gets information about one stream in a media source. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A presentation descriptor contains one or more stream descriptors. To get the stream descriptors from a presentation descriptor, call <strong><see cref="SharpDX.MediaFoundation.PresentationDescriptor.GetStreamDescriptorByIndex"/></strong>. To create a new stream descriptor, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateStreamDescriptor"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamDescriptor']/*"/>	
    /// <msdn-id>ms701622</msdn-id>	
    /// <unmanaged>IMFStreamDescriptor</unmanaged>	
    /// <unmanaged-short>IMFStreamDescriptor</unmanaged-short>	
    [Guid("56c03d9c-9dbb-45f5-ab4b-d80f47c05938")]
    public partial class StreamDescriptor : SharpDX.MediaFoundation.MediaAttributes
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.StreamDescriptor"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public StreamDescriptor(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.StreamDescriptor"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.StreamDescriptor(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.StreamDescriptor(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves an identifier for the stream.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The stream identifier uniquely identifies a stream within a presentation. It does not change throughout the lifetime of the stream. For example, if the presentation changes while the source is running, the index number of the stream may change, but the stream identifier does not.</p><p>In general, stream identifiers do not have a specific meaning, other than to identify the stream. Some media sources may assign stream identifiers based on meaningful values, such as packet identifiers, but this depends on the implementation.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamDescriptor::GetStreamIdentifier']/*"/>	
        /// <msdn-id>ms703852</msdn-id>	
        /// <unmanaged>GetStreamIdentifier</unmanaged>	
        /// <unmanaged-short>GetStreamIdentifier</unmanaged-short>	
        /// <unmanaged>HRESULT IMFStreamDescriptor::GetStreamIdentifier([Out] unsigned int* pdwStreamIdentifier)</unmanaged>
        public int StreamIdentifier
        {
            get { int __output__; GetStreamIdentifier(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a media type handler for the stream. The media type handler can be used to enumerate supported media types for the stream, get the current media type, and set the media type.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamDescriptor::GetMediaTypeHandler']/*"/>	
        /// <msdn-id>ms700210</msdn-id>	
        /// <unmanaged>GetMediaTypeHandler</unmanaged>	
        /// <unmanaged-short>GetMediaTypeHandler</unmanaged-short>	
        /// <unmanaged>HRESULT IMFStreamDescriptor::GetMediaTypeHandler([Out] IMFMediaTypeHandler** ppMediaTypeHandler)</unmanaged>
        public SharpDX.MediaFoundation.MediaTypeHandler MediaTypeHandler
        {
            get { SharpDX.MediaFoundation.MediaTypeHandler __output__; GetMediaTypeHandler(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves an identifier for the stream.</p>	
        /// </summary>	
        /// <param name="dwStreamIdentifierRef"><dd> <p>Receives the stream identifier.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The stream identifier uniquely identifies a stream within a presentation. It does not change throughout the lifetime of the stream. For example, if the presentation changes while the source is running, the index number of the stream may change, but the stream identifier does not.</p><p>In general, stream identifiers do not have a specific meaning, other than to identify the stream. Some media sources may assign stream identifiers based on meaningful values, such as packet identifiers, but this depends on the implementation.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamDescriptor::GetStreamIdentifier']/*"/>	
        /// <msdn-id>ms703852</msdn-id>	
        /// <unmanaged>HRESULT IMFStreamDescriptor::GetStreamIdentifier([Out] unsigned int* pdwStreamIdentifier)</unmanaged>	
        /// <unmanaged-short>IMFStreamDescriptor::GetStreamIdentifier</unmanaged-short>	
        internal void GetStreamIdentifier(out int dwStreamIdentifierRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwStreamIdentifierRef_ = &dwStreamIdentifierRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamIdentifierRef_, ((void**)(*(void**)_nativePointer))[33]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves a media type handler for the stream. The media type handler can be used to enumerate supported media types for the stream, get the current media type, and set the media type.</p>	
        /// </summary>	
        /// <param name="mediaTypeHandlerOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaTypeHandler"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamDescriptor::GetMediaTypeHandler']/*"/>	
        /// <msdn-id>ms700210</msdn-id>	
        /// <unmanaged>HRESULT IMFStreamDescriptor::GetMediaTypeHandler([Out] IMFMediaTypeHandler** ppMediaTypeHandler)</unmanaged>	
        /// <unmanaged-short>IMFStreamDescriptor::GetMediaTypeHandler</unmanaged-short>	
        internal void GetMediaTypeHandler(out SharpDX.MediaFoundation.MediaTypeHandler mediaTypeHandlerOut)
        {
            unsafe
            {
                IntPtr mediaTypeHandlerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &mediaTypeHandlerOut_, ((void**)(*(void**)_nativePointer))[34]);
                mediaTypeHandlerOut = (mediaTypeHandlerOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaTypeHandler(mediaTypeHandlerOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Passes configuration information to the media sinks that are used for streaming the content.  Optionally, this interface is supported by media sinks. The built-in ASF streaming media sink and the MP3 media sink implement this interface.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamingSinkConfig']/*"/>	
    /// <msdn-id>dd374676</msdn-id>	
    /// <unmanaged>IMFStreamingSinkConfig</unmanaged>	
    /// <unmanaged-short>IMFStreamingSinkConfig</unmanaged-short>	
    [Guid("9db7aa41-3cc5-40d4-8509-555804ad34cc")]
    public partial class StreamingSinkConfig : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.StreamingSinkConfig"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public StreamingSinkConfig(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.StreamingSinkConfig"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.StreamingSinkConfig(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.StreamingSinkConfig(nativePointer);
        }


        /// <summary>	
        /// <p>Called by the streaming media client before the Media Session starts streaming to specify the byte offset or the time offset.</p>	
        /// </summary>	
        /// <param name="fSeekOffsetIsByteOffset"><dd> <p> A Boolean value that specifies whether <em>qwSeekOffset</em> gives a byte offset of a time offset.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>TRUE</strong></dt> </dl> </td><td> <p>The <em>qwSeekOffset</em> parameter specifies a byte offset.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.Result.False"/></strong></dt> </dl> </td><td> <p>The <em>qwSeekOffset</em> parameter specifies the time position in 100-nanosecond units.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="qwSeekOffset"><dd> <p>A byte offset or a time offset, depending on the value passed in <em>fSeekOffsetIsByteOffset</em>.  Time offsets are specified in 100-nanosecond units.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamingSinkConfig::StartStreaming']/*"/>	
        /// <msdn-id>dd374677</msdn-id>	
        /// <unmanaged>HRESULT IMFStreamingSinkConfig::StartStreaming([In] BOOL fSeekOffsetIsByteOffset,[In] unsigned longlong qwSeekOffset)</unmanaged>	
        /// <unmanaged-short>IMFStreamingSinkConfig::StartStreaming</unmanaged-short>	
        public void StartStreaming(SharpDX.Mathematics.Interop.RawBool fSeekOffsetIsByteOffset, long qwSeekOffset)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint73(_nativePointer, fSeekOffsetIsByteOffset, qwSeekOffset, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a stream on a media sink object.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamSink']/*"/>	
    /// <msdn-id>ms705657</msdn-id>	
    /// <unmanaged>IMFStreamSink</unmanaged>	
    /// <unmanaged-short>IMFStreamSink</unmanaged-short>	
    [Guid("0A97B3CF-8E7C-4a3d-8F8C-0C843DC247FB")]
    public partial class StreamSink : SharpDX.MediaFoundation.MediaEventGenerator
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.StreamSink"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public StreamSink(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.StreamSink"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.StreamSink(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.StreamSink(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the media sink that owns this stream sink.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamSink::GetMediaSink']/*"/>	
        /// <msdn-id>ms699003</msdn-id>	
        /// <unmanaged>GetMediaSink</unmanaged>	
        /// <unmanaged-short>GetMediaSink</unmanaged-short>	
        /// <unmanaged>HRESULT IMFStreamSink::GetMediaSink([Out] IMFMediaSink** ppMediaSink)</unmanaged>
        public SharpDX.MediaFoundation.MediaSink MediaSink
        {
            get { SharpDX.MediaFoundation.MediaSink __output__; GetMediaSink(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the stream identifier for this stream sink.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamSink::GetIdentifier']/*"/>	
        /// <msdn-id>ms702129</msdn-id>	
        /// <unmanaged>GetIdentifier</unmanaged>	
        /// <unmanaged-short>GetIdentifier</unmanaged-short>	
        /// <unmanaged>HRESULT IMFStreamSink::GetIdentifier([Out] unsigned int* pdwIdentifier)</unmanaged>
        public int Identifier
        {
            get { int __output__; GetIdentifier(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamSink::GetMediaTypeHandler']/*"/>	
        /// <unmanaged>GetMediaTypeHandler</unmanaged>	
        /// <unmanaged-short>GetMediaTypeHandler</unmanaged-short>	
        /// <unmanaged>HRESULT IMFStreamSink::GetMediaTypeHandler([Out] IMFMediaTypeHandler** ppHandler)</unmanaged>
        public SharpDX.MediaFoundation.MediaTypeHandler MediaTypeHandler
        {
            get { SharpDX.MediaFoundation.MediaTypeHandler __output__; GetMediaTypeHandler(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the media sink that owns this stream sink.</p>	
        /// </summary>	
        /// <param name="mediaSinkOut"><dd> <p>Receives a reference to the media sink's <strong><see cref="SharpDX.MediaFoundation.MediaSink"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.StreamsInkRemoved"/></strong></dt> </dl> </td><td> <p>This stream was removed from the media sink and is no longer valid.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamSink::GetMediaSink']/*"/>	
        /// <msdn-id>ms699003</msdn-id>	
        /// <unmanaged>HRESULT IMFStreamSink::GetMediaSink([Out] IMFMediaSink** ppMediaSink)</unmanaged>	
        /// <unmanaged-short>IMFStreamSink::GetMediaSink</unmanaged-short>	
        internal void GetMediaSink(out SharpDX.MediaFoundation.MediaSink mediaSinkOut)
        {
            unsafe
            {
                IntPtr mediaSinkOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &mediaSinkOut_, ((void**)(*(void**)_nativePointer))[7]);
                mediaSinkOut = (mediaSinkOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaSink(mediaSinkOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the stream identifier for this stream sink.</p>	
        /// </summary>	
        /// <param name="dwIdentifierRef"><dd> <p>Receives the stream identifier. If this stream sink was added by calling <strong><see cref="SharpDX.MediaFoundation.MediaSink.AddStreamSink"/></strong>, the stream identifier is in the <em>dwStreamSinkIdentifier</em> parameter of that method. Otherwise, the media sink defines the identifier.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.StreamsInkRemoved"/></strong></dt> </dl> </td><td> <p>This stream was removed from the media sink and is no longer valid.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamSink::GetIdentifier']/*"/>	
        /// <msdn-id>ms702129</msdn-id>	
        /// <unmanaged>HRESULT IMFStreamSink::GetIdentifier([Out] unsigned int* pdwIdentifier)</unmanaged>	
        /// <unmanaged-short>IMFStreamSink::GetIdentifier</unmanaged-short>	
        internal void GetIdentifier(out int dwIdentifierRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwIdentifierRef_ = &dwIdentifierRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwIdentifierRef_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="handlerOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamSink::GetMediaTypeHandler']/*"/>	
        /// <unmanaged>HRESULT IMFStreamSink::GetMediaTypeHandler([Out] IMFMediaTypeHandler** ppHandler)</unmanaged>	
        /// <unmanaged-short>IMFStreamSink::GetMediaTypeHandler</unmanaged-short>	
        internal void GetMediaTypeHandler(out SharpDX.MediaFoundation.MediaTypeHandler handlerOut)
        {
            unsafe
            {
                IntPtr handlerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &handlerOut_, ((void**)(*(void**)_nativePointer))[9]);
                handlerOut = (handlerOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaTypeHandler(handlerOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Delivers a sample to the stream. The media sink processes the sample.</p>	
        /// </summary>	
        /// <param name="sampleRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface of a sample that contains valid data for the stream.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStateTransition"/></strong></dt> </dl> </td><td> <p>The media sink is in the wrong state to receive a sample. For example, preroll is complete but the presenation clock has not started yet.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidTimestamp"/></strong></dt> </dl> </td><td> <p>The sample has an invalid time stamp. See Remarks.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The media sink is paused or stopped and cannot process the sample.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoClock"/></strong></dt> </dl> </td><td> <p>The presentation clock was not set. Call <strong><see cref="SharpDX.MediaFoundation.MediaSink.SetPresentationClock"/></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoSampleTimestamp"/></strong></dt> </dl> </td><td> <p>The sample does not have a time stamp.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotInitializeD"/></strong></dt> </dl> </td><td> <p>The stream sink has not been initialized.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.StreamsInkRemoved"/></strong></dt> </dl> </td><td> <p>This stream was removed from the media sink and is no longer valid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method when the stream sink sends an <see cref="SharpDX.MediaFoundation.MediaEventTypes.StreamSinkRequestSample"/> event.</p><p>This method can return <see cref="SharpDX.MediaFoundation.ResultCode.InvalidTimestamp"/> for various reasons, depending on the implementation of the media sink:</p><ul> <li> <p>Negative time stamps.</p> </li> <li> <p>Time stamps that jump backward (within the same stream).</p> </li> <li> <p>The time stamps for one stream have drifted too far from the time stamps on another stream within the same media sink (for example, an archive sink that multiplexes the streams).</p> </li> </ul><p>Not every media sink returns an error code in these situations.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamSink::ProcessSample']/*"/>	
        /// <msdn-id>ms696208</msdn-id>	
        /// <unmanaged>HRESULT IMFStreamSink::ProcessSample([In, Optional] IMFSample* pSample)</unmanaged>	
        /// <unmanaged-short>IMFStreamSink::ProcessSample</unmanaged-short>	
        public void ProcessSample(SharpDX.MediaFoundation.Sample sampleRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((sampleRef == null) ? IntPtr.Zero : sampleRef.NativePointer), ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Places a marker in the stream. </p>	
        /// </summary>	
        /// <param name="eMarkerType"><dd> <p> Specifies the marker type, as a member of the <strong><see cref="SharpDX.MediaFoundation.StreamsInkMarkerType"/></strong> enumeration. </p> </dd></param>	
        /// <param name="varMarkerValueRef"><dd> <p> Optional reference to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that contains additional information related to the marker. The meaning of this value depends on the marker type. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="varContextValueRef"><dd> <p> Optional reference to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that is attached to the <see cref="SharpDX.MediaFoundation.MediaEventTypes.StreamSinkMarker"/> event. Call <strong><see cref="SharpDX.MediaFoundation.MediaEvent.GetValue"/></strong> to get this value from the event. The caller can use this information for any purpose. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></strong></dt> </dl> </td><td> <p> The media sink's <strong>Shutdown</strong> method has been called. </p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref="SharpDX.MediaFoundation.ResultCode.StreamsInkRemoved"/></strong></strong></dt> </dl> </td><td> <p> This stream was removed from the media sink and is no longer valid. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method causes the stream sink to send an <see cref="SharpDX.MediaFoundation.MediaEventTypes.StreamSinkMarker"/> event after the stream sink consumes all of the samples that were delivered up to this point (before the call to <strong>PlaceMarker</strong>).</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamSink::PlaceMarker']/*"/>	
        /// <msdn-id>ms703026</msdn-id>	
        /// <unmanaged>HRESULT IMFStreamSink::PlaceMarker([In] MFSTREAMSINK_MARKER_TYPE eMarkerType,[In] const PROPVARIANT* pvarMarkerValue,[In] const PROPVARIANT* pvarContextValue)</unmanaged>	
        /// <unmanaged-short>IMFStreamSink::PlaceMarker</unmanaged-short>	
        public void PlaceMarker(SharpDX.MediaFoundation.StreamsInkMarkerType eMarkerType, SharpDX.Win32.Variant varMarkerValueRef, SharpDX.Win32.Variant varContextValueRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)eMarkerType), &varMarkerValueRef, &varContextValueRef, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Causes the stream sink to drop any samples that it has received and has not rendered yet.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotInitializeD"/></strong></dt> </dl> </td><td> <p>The stream sink has not been initialized yet. You might need to set a media type.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.StreamsInkRemoved"/></strong></dt> </dl> </td><td> <p>This stream was removed from the media sink and is no longer valid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If any samples are still queued from previous calls to the <strong><see cref="SharpDX.MediaFoundation.StreamSink.ProcessSample"/></strong> method, the media sink immediately discards them, without processing them. This can cause a glitch in the rendered output. The running state of the sink (running, paused, or stopped) does not change.</p><p>Any pending marker events from the <strong><see cref="SharpDX.MediaFoundation.StreamSink.PlaceMarker"/></strong> method are dispatched immediately, with the status code E_ABORT.</p><p>This method is synchronous. It does not return until the sink has discarded all pending samples.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFStreamSink::Flush']/*"/>	
        /// <msdn-id>ms697054</msdn-id>	
        /// <unmanaged>HRESULT IMFStreamSink::Flush()</unmanaged>	
        /// <unmanaged-short>IMFStreamSink::Flush</unmanaged-short>	
        public void Flush()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides a method that retireves system id data.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSystemId']/*"/>	
    /// <msdn-id>hh448067</msdn-id>	
    /// <unmanaged>IMFSystemId</unmanaged>	
    /// <unmanaged-short>IMFSystemId</unmanaged-short>	
    [Guid("fff4af3a-1fc1-4ef9-a29b-d26c49e2f31a")]
    public partial class SystemId : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.SystemId"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SystemId(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.SystemId"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.SystemId(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.SystemId(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves system id data.</p>	
        /// </summary>	
        /// <param name="size"><dd> <p>The size in bytes of the returned data.</p> </dd></param>	
        /// <param name="data"><dd> <p>Receives the returned data.  The caller must free this buffer by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSystemId::GetData']/*"/>	
        /// <msdn-id>hh448068</msdn-id>	
        /// <unmanaged>HRESULT IMFSystemId::GetData([Out] unsigned int* size,[Out, Buffer] unsigned char** data)</unmanaged>	
        /// <unmanaged-short>IMFSystemId::GetData</unmanaged-short>	
        public void GetData(out int size, byte[] data)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* size_ = &size)
                fixed (void* data_ = data)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, size_, data_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets up the <strong><see cref="SharpDX.MediaFoundation.SystemId"/></strong>.</p>	
        /// </summary>	
        /// <param name="stage">No documentation.</param>	
        /// <param name="cbIn">No documentation.</param>	
        /// <param name="bInRef">No documentation.</param>	
        /// <param name="cbOutRef">No documentation.</param>	
        /// <param name="bOutOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFSystemId::Setup']/*"/>	
        /// <msdn-id>jj128323</msdn-id>	
        /// <unmanaged>HRESULT IMFSystemId::Setup([In] unsigned int stage,[In] unsigned int cbIn,[In, Buffer] const unsigned char* pbIn,[Out] unsigned int* pcbOut,[Out, Buffer] unsigned char** ppbOut)</unmanaged>	
        /// <unmanaged-short>IMFSystemId::Setup</unmanaged-short>	
        public void Setup(int stage, int cbIn, byte[] bInRef, out int cbOutRef, byte[] bOutOut)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* bInRef_ = bInRef)
                fixed (void* cbOutRef_ = &cbOutRef)
                fixed (void* bOutOut_ = bOutOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, stage, cbIn, bInRef_, cbOutRef_, bOutOut_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Converts between Society of Motion Picture and Television Engineers (SMPTE) time codes and 100-nanosecond time units.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If an object supports this interface, it must expose the interface as a service. To get a reference to the interface, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> with the service identifier <strong><see cref="SharpDX.MediaFoundation.MediaServiceKeys.TimeCode"/></strong>.</p><p>The Advanced Streaming Format (ASF) media source exposes this interface.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimecodeTranslate']/*"/>	
    /// <msdn-id>dd374678</msdn-id>	
    /// <unmanaged>IMFTimecodeTranslate</unmanaged>	
    /// <unmanaged-short>IMFTimecodeTranslate</unmanaged-short>	
    [Guid("ab9d8661-f7e8-4ef4-9861-89f334f94e74")]
    public partial class TimecodeTranslate : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TimecodeTranslate"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TimecodeTranslate(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TimecodeTranslate"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TimecodeTranslate(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TimecodeTranslate(nativePointer);
        }


        /// <summary>	
        /// <p>Starts an asynchronous call to convert Society of Motion Picture and Television Engineers (SMPTE) time code to 100-nanosecond units.</p>	
        /// </summary>	
        /// <param name="propVarTimecodeRef"><dd> <p>Time in SMPTE time code to convert. The <strong>vt</strong> member of the <strong><see cref="SharpDX.Win32.Variant"/></strong> structure is set to <strong>VT_I8</strong>. The <strong>hVal.QuadPart</strong> member contains the time in binary coded decimal (BCD) form. See Remarks.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p>PPointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pPropVarTimecode</em> is not <strong>VT_I8</strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ByteStreamNotSeekable"/></strong></dt> </dl> </td><td> <p>The byte stream is not seekable. The time code cannot be read from the end of the byte stream.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When the asynchronous method completes, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, the application must call <strong><see cref="SharpDX.MediaFoundation.TimecodeTranslate.EndConvertTimecodeToHNS"/></strong> to complete the asynchronous request.</p><p>The value of <em>pPropVarTimecode</em> is a 64-bit unsigned value typed as a <strong>LONGLONG</strong>. The upper <strong>DWORD</strong> contains the range. (A <em>range</em> is a continuous series of time codes.) The lower <strong>DWORD</strong> contains the time code in the form of a hexadecimal number <em>0xhhmmssff</em>,  where each 2-byte sequence is read as a decimal value.</p><pre>void CreateTimeCode( DWORD dwFrames, DWORD dwSeconds, DWORD dwMinutes, DWORD dwHours, DWORD dwRange, <see cref="SharpDX.Win32.Variant"/> *pvar )	
        /// { ULONGLONG ullTimecode = ((ULONGLONG)dwRange) &lt;&lt; 32; ullTimecode +=   dwFrames  % 10; ullTimecode += (( (ULONGLONG)dwFrames )  / 10) &lt;&lt; 4; ullTimecode += (( (ULONGLONG)dwSeconds ) % 10) &lt;&lt; 8; ullTimecode += (( (ULONGLONG)dwSeconds ) / 10) &lt;&lt; 12; ullTimecode += (( (ULONGLONG)dwMinutes ) % 10) &lt;&lt; 16; ullTimecode += (( (ULONGLONG)dwMinutes ) / 10) &lt;&lt; 20; ullTimecode += (( (ULONGLONG)dwHours )   % 10) &lt;&lt; 24; ullTimecode += (( (ULONGLONG)dwHours )   / 10) &lt;&lt; 28; pvar-&gt;vt = VT_I8; pvar-&gt;hVal.QuadPart = (LONGLONG)ullTimecode;	
        /// }	
        /// </pre>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimecodeTranslate::BeginConvertTimecodeToHNS']/*"/>	
        /// <msdn-id>dd374680</msdn-id>	
        /// <unmanaged>HRESULT IMFTimecodeTranslate::BeginConvertTimecodeToHNS([In] const PROPVARIANT* pPropVarTimecode,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>	
        /// <unmanaged-short>IMFTimecodeTranslate::BeginConvertTimecodeToHNS</unmanaged-short>	
        internal void BeginConvertTimecodeToHNS_(SharpDX.Win32.Variant propVarTimecodeRef, System.IntPtr callbackRef, SharpDX.ComObject unkStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &propVarTimecodeRef, (void*)callbackRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Completes an asynchronous request to convert time in Society of Motion Picture and Television Engineers (SMPTE) time code to 100-nanosecond units.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method. </p> </dd></param>	
        /// <param name="hnsTimeRef"><dd> <p>Receives the converted time.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Call this method after the <strong><see cref="SharpDX.MediaFoundation.TimecodeTranslate.BeginConvertTimecodeToHNS_"/></strong> method completes asynchronously.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimecodeTranslate::EndConvertTimecodeToHNS']/*"/>	
        /// <msdn-id>dd374682</msdn-id>	
        /// <unmanaged>HRESULT IMFTimecodeTranslate::EndConvertTimecodeToHNS([In] IMFAsyncResult* pResult,[In] longlong* phnsTime)</unmanaged>	
        /// <unmanaged-short>IMFTimecodeTranslate::EndConvertTimecodeToHNS</unmanaged-short>	
        public void EndConvertTimecodeToHNS(SharpDX.MediaFoundation.AsyncResult resultRef, long hnsTimeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), &hnsTimeRef, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Starts an asynchronous call to convert time in 100-nanosecond units to Society of Motion Picture and Television Engineers (SMPTE) time code.</p>	
        /// </summary>	
        /// <param name="hnsTime"><dd> <p>The time to convert, in 100-nanosecond units.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.ByteStreamNotSeekable"/></strong></dt> </dl> </td><td> <p>The byte stream is not seekable. The time code cannot be read from the end of the byte stream.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When the asynchronous method completes, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, the application must call <strong><see cref="SharpDX.MediaFoundation.TimecodeTranslate.EndConvertHNSToTimecode"/></strong> to complete the asynchronous request.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimecodeTranslate::BeginConvertHNSToTimecode']/*"/>	
        /// <msdn-id>dd374679</msdn-id>	
        /// <unmanaged>HRESULT IMFTimecodeTranslate::BeginConvertHNSToTimecode([In] longlong hnsTime,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>	
        /// <unmanaged-short>IMFTimecodeTranslate::BeginConvertHNSToTimecode</unmanaged-short>	
        internal void BeginConvertHNSToTimecode_(long hnsTime, System.IntPtr callbackRef, SharpDX.ComObject unkStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, hnsTime, (void*)callbackRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Completes an asynchronous request to convert time in 100-nanosecond units to Society of Motion Picture and Television Engineers (SMPTE) time code.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.</p> </dd></param>	
        /// <param name="propVarTimecodeRef"><dd> <p>A reference to a <strong><see cref="SharpDX.Win32.Variant"/></strong> that receives the converted time. The <strong>vt</strong> member of the <strong><see cref="SharpDX.Win32.Variant"/></strong> structure is set to VT_I8. The <strong>hVal.QuadPart</strong> member contains the converted time in binary coded decimal (BCD) form. See Remarks.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Call this method after the <strong><see cref="SharpDX.MediaFoundation.TimecodeTranslate.BeginConvertHNSToTimecode_"/></strong> method completes asynchronously.</p><p>The value of <em>pPropVarTimecode</em> is a 64-bit unsigned value typed as a <strong>LONGLONG</strong>. The upper <strong>DWORD</strong> contains the range. (A <em>range</em> is a continuous series of time codes.) The lower <strong>DWORD</strong> contains the time code in the form of a hexadecimal number <em>0xhhmmssff</em>,  where each 2-byte sequence is read as a decimal value.</p><pre><see cref="SharpDX.Result"/> ParseTimeCode( const <see cref="SharpDX.Win32.Variant"/>&amp; var, DWORD *pdwRange, DWORD *pdwFrames, DWORD *pdwSeconds, DWORD *pdwMinutes, DWORD *pdwHours )	
        /// { if (var.vt != VT_I8) { return E_INVALIDARG; } ULONGLONG ullTimeCode = (ULONGLONG)var.hVal.QuadPart; DWORD dwTimecode = (DWORD)(ullTimeCode &amp; 0xFFFFFFFF); *pdwRange   = (DWORD)(ullTimeCode &gt;&gt; 32); *pdwFrames  =     dwTimecode &amp; 0x0000000F; *pdwFrames  += (( dwTimecode &amp; 0x000000F0) &gt;&gt; 4 )  * 10; *pdwSeconds =   ( dwTimecode &amp; 0x00000F00) &gt;&gt; 8; *pdwSeconds += (( dwTimecode &amp; 0x0000F000) &gt;&gt; 12 ) * 10; *pdwMinutes =   ( dwTimecode &amp; 0x000F0000) &gt;&gt; 16; *pdwMinutes += (( dwTimecode &amp; 0x00F00000) &gt;&gt; 20 ) * 10; *pdwHours   =   ( dwTimecode &amp; 0x0F000000) &gt;&gt; 24; *pdwHours   += (( dwTimecode &amp; 0xF0000000) &gt;&gt; 28 ) * 10; return <see cref="SharpDX.Result.Ok"/>;	
        /// }	
        /// </pre>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimecodeTranslate::EndConvertHNSToTimecode']/*"/>	
        /// <msdn-id>dd374681</msdn-id>	
        /// <unmanaged>HRESULT IMFTimecodeTranslate::EndConvertHNSToTimecode([In] IMFAsyncResult* pResult,[In] PROPVARIANT* pPropVarTimecode)</unmanaged>	
        /// <unmanaged-short>IMFTimecodeTranslate::EndConvertHNSToTimecode</unmanaged-short>	
        public void EndConvertHNSToTimecode(SharpDX.MediaFoundation.AsyncResult resultRef, SharpDX.Win32.Variant propVarTimecodeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), &propVarTimecodeRef, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>A timed-text object represents a component of timed text.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText']/*"/>	
    /// <msdn-id>dn800287</msdn-id>	
    /// <unmanaged>IMFTimedText</unmanaged>	
    /// <unmanaged-short>IMFTimedText</unmanaged-short>	
    [Guid("1f2a94c9-a3df-430d-9d0f-acd85ddc29af")]
    public partial class TimedText : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TimedText"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TimedText(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TimedText"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TimedText(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TimedText(nativePointer);
        }


        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the offset to the cue time.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::GetCueTimeOffset']/*"/>	
        /// <msdn-id>dn800353</msdn-id>	
        /// <unmanaged>GetCueTimeOffset / SetCueTimeOffset</unmanaged>	
        /// <unmanaged-short>GetCueTimeOffset</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedText::GetCueTimeOffset([Out] double* offset)</unmanaged>
        public double CueTimeOffset
        {
            get { double __output__; GetCueTimeOffset(out __output__); return __output__; }
            set { SetCueTimeOffset(value); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Retrieves a list of all timed-text tracks registered with the <strong><see cref="SharpDX.MediaFoundation.TimedText"/></strong>.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::GetTracks']/*"/>	
        /// <msdn-id>dn859184</msdn-id>	
        /// <unmanaged>GetTracks</unmanaged>	
        /// <unmanaged-short>GetTracks</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedText::GetTracks([Out] IMFTimedTextTrackList** tracks)</unmanaged>
        public SharpDX.MediaFoundation.TimedTextTrackList Tracks
        {
            get { SharpDX.MediaFoundation.TimedTextTrackList __output__; GetTracks(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the list of active timed-text tracks in the timed-text component.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::GetActiveTracks']/*"/>	
        /// <msdn-id>dn800352</msdn-id>	
        /// <unmanaged>GetActiveTracks</unmanaged>	
        /// <unmanaged-short>GetActiveTracks</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedText::GetActiveTracks([Out] IMFTimedTextTrackList** activeTracks)</unmanaged>
        public SharpDX.MediaFoundation.TimedTextTrackList ActiveTracks
        {
            get { SharpDX.MediaFoundation.TimedTextTrackList __output__; GetActiveTracks(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the list of all the timed-text tracks in the timed-text component.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::GetTextTracks']/*"/>	
        /// <msdn-id>dn800355</msdn-id>	
        /// <unmanaged>GetTextTracks</unmanaged>	
        /// <unmanaged-short>GetTextTracks</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedText::GetTextTracks([Out] IMFTimedTextTrackList** textTracks)</unmanaged>
        public SharpDX.MediaFoundation.TimedTextTrackList TextTracks
        {
            get { SharpDX.MediaFoundation.TimedTextTrackList __output__; GetTextTracks(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the list of the timed-metadata tracks in the timed-text component.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::GetMetadataTracks']/*"/>	
        /// <msdn-id>dn800354</msdn-id>	
        /// <unmanaged>GetMetadataTracks</unmanaged>	
        /// <unmanaged-short>GetMetadataTracks</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedText::GetMetadataTracks([Out] IMFTimedTextTrackList** metadataTracks)</unmanaged>
        public SharpDX.MediaFoundation.TimedTextTrackList MetadataTracks
        {
            get { SharpDX.MediaFoundation.TimedTextTrackList __output__; GetMetadataTracks(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Enables or disables inband mode.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::SetInBandEnabled']/*"/>	
        /// <msdn-id>dn800360</msdn-id>	
        /// <unmanaged>SetInBandEnabled</unmanaged>	
        /// <unmanaged-short>SetInBandEnabled</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedText::SetInBandEnabled([In] BOOL enabled)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool InBandEnabled
        {
            set { SetInBandEnabled(value); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether inband mode is enabled.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::IsInBandEnabled']/*"/>	
        /// <msdn-id>dn800356</msdn-id>	
        /// <unmanaged>IsInBandEnabled</unmanaged>	
        /// <unmanaged-short>IsInBandEnabled</unmanaged-short>	
        /// <unmanaged>BOOL IMFTimedText::IsInBandEnabled()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsInBandEnabled
        {
            get { return IsInBandEnabled_(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Registers a timed-text notify object.</p>	
        /// </summary>	
        /// <param name="notify"><dd>  <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.TimedTextNotify"/></strong> interface for the timed-text notify object to register.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::RegisterNotifications']/*"/>	
        /// <msdn-id>dn800357</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedText::RegisterNotifications([In, Optional] IMFTimedTextNotify* notify)</unmanaged>	
        /// <unmanaged-short>IMFTimedText::RegisterNotifications</unmanaged-short>	
        public void RegisterNotifications(SharpDX.MediaFoundation.TimedTextNotify notify)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((notify == null) ? IntPtr.Zero : notify.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Selects or deselects a track of text in the timed-text component.</p>	
        /// </summary>	
        /// <param name="trackId"><dd>  <p>The identifier of the track to select. </p> </dd></param>	
        /// <param name="selected"><dd>  <p>Specifies whether to select or deselect a track of text. Specify <strong>TRUE</strong> to select the track or <strong><see cref="SharpDX.Result.False"/></strong> to deselect the track. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::SelectTrack']/*"/>	
        /// <msdn-id>dn800358</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedText::SelectTrack([In] unsigned int trackId,[In] BOOL selected)</unmanaged>	
        /// <unmanaged-short>IMFTimedText::SelectTrack</unmanaged-short>	
        public void SelectTrack(int trackId, SharpDX.Mathematics.Interop.RawBool selected)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint19(_nativePointer, trackId, selected, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Adds a timed-text data source.</p>	
        /// </summary>	
        /// <param name="byteStream"><dd>  <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IByteStream"/></strong> interface for the data source to add.</p> </dd></param>	
        /// <param name="label"><dd>  <p>Null-terminated wide-character string that contains the label of the data source.</p> </dd></param>	
        /// <param name="language"><dd>  <p>Null-terminated wide-character string that contains the language of the data source.</p> </dd></param>	
        /// <param name="kind"><dd>  <p>A <strong><see cref="SharpDX.MediaFoundation.TimedTextTrackKind"/></strong>-typed value that specifies the kind of timed-text track.</p> </dd></param>	
        /// <param name="isDefault"><dd>  <p>Specifies whether to add the default data source. Specify <strong>TRUE</strong> to add the default data source or <strong><see cref="SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>	
        /// <param name="trackId"><dd>  <p>Receives a reference to the unique identifier for the added track.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::AddDataSource']/*"/>	
        /// <msdn-id>dn800351</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedText::AddDataSource([In] IMFByteStream* byteStream,[In, Optional] const wchar_t* label,[In, Optional] const wchar_t* language,[In] MF_TIMED_TEXT_TRACK_KIND kind,[In] BOOL isDefault,[Out] unsigned int* trackId)</unmanaged>	
        /// <unmanaged-short>IMFTimedText::AddDataSource</unmanaged-short>	
        internal void AddDataSource_(System.IntPtr byteStream, string label, string language, SharpDX.MediaFoundation.TimedTextTrackKind kind, SharpDX.Mathematics.Interop.RawBool isDefault, out int trackId)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* label_ = label)
                fixed (char* language_ = language)
                fixed (void* trackId_ = &trackId)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint110(_nativePointer, (void*)byteStream, (void*)label_, (void*)language_, unchecked((int)kind), isDefault, trackId_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Adds a timed-text data source from the specified URL.</p>	
        /// </summary>	
        /// <param name="url"><dd>  <p>The URL of the timed-text data source.</p> </dd></param>	
        /// <param name="label"><dd>  <p>Null-terminated wide-character string that contains the label of the data source.</p> </dd></param>	
        /// <param name="language"><dd>  <p>Null-terminated wide-character string that contains the language of the data source.</p> </dd></param>	
        /// <param name="kind"><dd>  <p>A <strong><see cref="SharpDX.MediaFoundation.TimedTextTrackKind"/></strong>-typed value that specifies the kind of timed-text track.</p> </dd></param>	
        /// <param name="isDefault"><dd>  <p>Specifies whether to add the default data source. Specify <strong>TRUE</strong> to add the default data source or <strong><see cref="SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>	
        /// <param name="trackId"><dd>  <p>Receives a reference to the unique identifier for the added track.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::AddDataSourceFromUrl']/*"/>	
        /// <msdn-id>dn859183</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedText::AddDataSourceFromUrl([In] const wchar_t* url,[In, Optional] const wchar_t* label,[In, Optional] const wchar_t* language,[In] MF_TIMED_TEXT_TRACK_KIND kind,[In] BOOL isDefault,[Out] unsigned int* trackId)</unmanaged>	
        /// <unmanaged-short>IMFTimedText::AddDataSourceFromUrl</unmanaged-short>	
        public void AddDataSourceFromUrl(string url, string label, string language, SharpDX.MediaFoundation.TimedTextTrackKind kind, SharpDX.Mathematics.Interop.RawBool isDefault, out int trackId)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* url_ = url)
                fixed (char* label_ = label)
                fixed (char* language_ = language)
                fixed (void* trackId_ = &trackId)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint110(_nativePointer, (void*)url_, (void*)label_, (void*)language_, unchecked((int)kind), isDefault, trackId_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="label">No documentation.</param>	
        /// <param name="language">No documentation.</param>	
        /// <param name="kind">No documentation.</param>	
        /// <param name="track">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::AddTrack']/*"/>	
        /// <unmanaged>HRESULT IMFTimedText::AddTrack([In, Optional] const wchar_t* label,[In, Optional] const wchar_t* language,[In] MF_TIMED_TEXT_TRACK_KIND kind,[Out] IMFTimedTextTrack** track)</unmanaged>	
        /// <unmanaged-short>IMFTimedText::AddTrack</unmanaged-short>	
        public void AddTrack(string label, string language, SharpDX.MediaFoundation.TimedTextTrackKind kind, out SharpDX.MediaFoundation.TimedTextTrack track)
        {
            unsafe
            {
                IntPtr track_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* label_ = label)
                fixed (char* language_ = language)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)label_, (void*)language_, unchecked((int)kind), &track_, ((void**)(*(void**)_nativePointer))[7]);
                track = (track_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextTrack(track_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Removes the timed-text track with the specified identifier.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>The identifier of the track to remove.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Get the identifier for a track by calling <strong>GetId</strong>. </p><p>When a track is removed, all buffered data from the track is also removed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::RemoveTrack']/*"/>	
        /// <msdn-id>dn859185</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedText::RemoveTrack([In] IMFTimedTextTrack* track)</unmanaged>	
        /// <unmanaged-short>IMFTimedText::RemoveTrack</unmanaged-short>	
        public void RemoveTrack(SharpDX.MediaFoundation.TimedTextTrack track)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((track == null) ? IntPtr.Zero : track.NativePointer), ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the offset to the cue time.</p>	
        /// </summary>	
        /// <param name="offset"><dd>  <p>A reference to a variable that receives the offset to the cue time.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::GetCueTimeOffset']/*"/>	
        /// <msdn-id>dn800353</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedText::GetCueTimeOffset([Out] double* offset)</unmanaged>	
        /// <unmanaged-short>IMFTimedText::GetCueTimeOffset</unmanaged-short>	
        internal void GetCueTimeOffset(out double offset)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* offset_ = &offset)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, offset_, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Sets the offset to the cue time.</p>	
        /// </summary>	
        /// <param name="offset"><dd>  <p>The offset to the cue time.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::SetCueTimeOffset']/*"/>	
        /// <msdn-id>dn800359</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedText::SetCueTimeOffset([In] double offset)</unmanaged>	
        /// <unmanaged-short>IMFTimedText::SetCueTimeOffset</unmanaged-short>	
        internal void SetCueTimeOffset(double offset)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, offset, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Retrieves a list of all timed-text tracks registered with the <strong><see cref="SharpDX.MediaFoundation.TimedText"/></strong>.</p>	
        /// </summary>	
        /// <param name="tracks">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::GetTracks']/*"/>	
        /// <msdn-id>dn859184</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedText::GetTracks([Out] IMFTimedTextTrackList** tracks)</unmanaged>	
        /// <unmanaged-short>IMFTimedText::GetTracks</unmanaged-short>	
        internal void GetTracks(out SharpDX.MediaFoundation.TimedTextTrackList tracks)
        {
            unsafe
            {
                IntPtr tracks_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &tracks_, ((void**)(*(void**)_nativePointer))[11]);
                tracks = (tracks_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextTrackList(tracks_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the list of active timed-text tracks in the timed-text component.</p>	
        /// </summary>	
        /// <param name="activeTracks"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref="SharpDX.MediaFoundation.TimedTextTrackList"/></strong> interface that can enumerate the list of active timed-text tracks.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::GetActiveTracks']/*"/>	
        /// <msdn-id>dn800352</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedText::GetActiveTracks([Out] IMFTimedTextTrackList** activeTracks)</unmanaged>	
        /// <unmanaged-short>IMFTimedText::GetActiveTracks</unmanaged-short>	
        internal void GetActiveTracks(out SharpDX.MediaFoundation.TimedTextTrackList activeTracks)
        {
            unsafe
            {
                IntPtr activeTracks_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &activeTracks_, ((void**)(*(void**)_nativePointer))[12]);
                activeTracks = (activeTracks_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextTrackList(activeTracks_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the list of all the timed-text tracks in the timed-text component.</p>	
        /// </summary>	
        /// <param name="textTracks"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref="SharpDX.MediaFoundation.TimedTextTrackList"/></strong> interface that can enumerate the list of all of the timed-text tracks.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::GetTextTracks']/*"/>	
        /// <msdn-id>dn800355</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedText::GetTextTracks([Out] IMFTimedTextTrackList** textTracks)</unmanaged>	
        /// <unmanaged-short>IMFTimedText::GetTextTracks</unmanaged-short>	
        internal void GetTextTracks(out SharpDX.MediaFoundation.TimedTextTrackList textTracks)
        {
            unsafe
            {
                IntPtr textTracks_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &textTracks_, ((void**)(*(void**)_nativePointer))[13]);
                textTracks = (textTracks_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextTrackList(textTracks_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the list of the timed-metadata tracks in the timed-text component.</p>	
        /// </summary>	
        /// <param name="metadataTracks"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref="SharpDX.MediaFoundation.TimedTextTrackList"/></strong> interface that can enumerate the list of the timed-metadata tracks.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::GetMetadataTracks']/*"/>	
        /// <msdn-id>dn800354</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedText::GetMetadataTracks([Out] IMFTimedTextTrackList** metadataTracks)</unmanaged>	
        /// <unmanaged-short>IMFTimedText::GetMetadataTracks</unmanaged-short>	
        internal void GetMetadataTracks(out SharpDX.MediaFoundation.TimedTextTrackList metadataTracks)
        {
            unsafe
            {
                IntPtr metadataTracks_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &metadataTracks_, ((void**)(*(void**)_nativePointer))[14]);
                metadataTracks = (metadataTracks_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextTrackList(metadataTracks_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Enables or disables inband mode.</p>	
        /// </summary>	
        /// <param name="enabled"><dd>  <p> Specifies whether inband mode is enabled. If <strong>TRUE</strong>, inband mode is enabled. If <strong><see cref="SharpDX.Result.False"/></strong>, inband mode is disabled. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::SetInBandEnabled']/*"/>	
        /// <msdn-id>dn800360</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedText::SetInBandEnabled([In] BOOL enabled)</unmanaged>	
        /// <unmanaged-short>IMFTimedText::SetInBandEnabled</unmanaged-short>	
        internal void SetInBandEnabled(SharpDX.Mathematics.Interop.RawBool enabled)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint6(_nativePointer, enabled, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether inband mode is enabled.</p>	
        /// </summary>	
        /// <returns><p>Returns whether inband mode is enabled. If <strong>TRUE</strong>, inband mode is enabled. If <strong><see cref="SharpDX.Result.False"/></strong>, inband mode is disabled. </p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedText::IsInBandEnabled']/*"/>	
        /// <msdn-id>dn800356</msdn-id>	
        /// <unmanaged>BOOL IMFTimedText::IsInBandEnabled()</unmanaged>	
        /// <unmanaged-short>IMFTimedText::IsInBandEnabled</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsInBandEnabled_()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[16]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Represents the data content of a timed-text object.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextBinary']/*"/>	
    /// <msdn-id>dn800288</msdn-id>	
    /// <unmanaged>IMFTimedTextBinary</unmanaged>	
    /// <unmanaged-short>IMFTimedTextBinary</unmanaged-short>	
    [Guid("4ae3a412-0545-43c4-bf6f-6b97a5c6c432")]
    public partial class TimedTextBinary : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TimedTextBinary"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TimedTextBinary(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TimedTextBinary"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TimedTextBinary(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TimedTextBinary(nativePointer);
        }


        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the data content of the timed-text object.</p>	
        /// </summary>	
        /// <param name="data"><dd>  <p>A reference to a memory block that receives a reference to the data content of the timed-text object.</p> </dd></param>	
        /// <param name="length"><dd>  <p>A reference to a variable that receives the length in bytes of the data content.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextBinary::GetData']/*"/>	
        /// <msdn-id>dn800289</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextBinary::GetData([Out, Buffer] const unsigned char** data,[Out] unsigned int* length)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextBinary::GetData</unmanaged-short>	
        public void GetData(byte[] data, out int length)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* data_ = data)
                fixed (void* length_ = &length)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, data_, length_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the data content of the timed-text cue.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue']/*"/>	
    /// <msdn-id>dn800292</msdn-id>	
    /// <unmanaged>IMFTimedTextCue</unmanaged>	
    /// <unmanaged-short>IMFTimedTextCue</unmanaged-short>	
    [Guid("1e560447-9a2b-43e1-a94c-b0aaabfbfbc9")]
    public partial class TimedTextCue : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TimedTextCue"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TimedTextCue(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TimedTextCue"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TimedTextCue(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TimedTextCue(nativePointer);
        }


        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the identifier of a timed-text cue.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The identifier is retrieved by this method is dynamically generated by the system and is guaranteed to uniquely identify a cue within a single timed-text track. It is not guaranteed to be unique across tracks. If a cue already has an identifier that is provided in the text-track data format, this ID can be retrieved by calling <strong>GetOriginalId</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetId']/*"/>	
        /// <msdn-id>dn859177</msdn-id>	
        /// <unmanaged>GetId</unmanaged>	
        /// <unmanaged-short>GetId</unmanaged-short>	
        /// <unmanaged>unsigned int IMFTimedTextCue::GetId()</unmanaged>
        public int Id
        {
            get { return GetId(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the kind of timed-text cue.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetCueKind']/*"/>	
        /// <msdn-id>dn800291</msdn-id>	
        /// <unmanaged>GetCueKind</unmanaged>	
        /// <unmanaged-short>GetCueKind</unmanaged-short>	
        /// <unmanaged>MF_TIMED_TEXT_TRACK_KIND IMFTimedTextCue::GetCueKind()</unmanaged>
        public SharpDX.MediaFoundation.TimedTextTrackKind CueKind
        {
            get { return GetCueKind(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the start time of the cue in the track.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetStartTime']/*"/>	
        /// <msdn-id>dn800297</msdn-id>	
        /// <unmanaged>GetStartTime</unmanaged>	
        /// <unmanaged-short>GetStartTime</unmanaged-short>	
        /// <unmanaged>double IMFTimedTextCue::GetStartTime()</unmanaged>
        public double StartTime
        {
            get { return GetStartTime(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the duration time of the cue in the track.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetDuration']/*"/>	
        /// <msdn-id>dn800293</msdn-id>	
        /// <unmanaged>GetDuration</unmanaged>	
        /// <unmanaged-short>GetDuration</unmanaged-short>	
        /// <unmanaged>double IMFTimedTextCue::GetDuration()</unmanaged>
        public double Duration
        {
            get { return GetDuration(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the identifier of the timed-text cue.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetTrackId']/*"/>	
        /// <msdn-id>dn800299</msdn-id>	
        /// <unmanaged>GetTrackId</unmanaged>	
        /// <unmanaged-short>GetTrackId</unmanaged-short>	
        /// <unmanaged>unsigned int IMFTimedTextCue::GetTrackId()</unmanaged>
        public int TrackId
        {
            get { return GetTrackId(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the data content of the timed-text cue.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetData']/*"/>	
        /// <msdn-id>dn800292</msdn-id>	
        /// <unmanaged>GetData</unmanaged>	
        /// <unmanaged-short>GetData</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextCue::GetData([Out, Optional] IMFTimedTextBinary** data)</unmanaged>
        public SharpDX.MediaFoundation.TimedTextBinary Data
        {
            get { SharpDX.MediaFoundation.TimedTextBinary __output__; GetData(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets info about the display region  of the timed-text cue.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetRegion']/*"/>	
        /// <msdn-id>dn800296</msdn-id>	
        /// <unmanaged>GetRegion</unmanaged>	
        /// <unmanaged-short>GetRegion</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextCue::GetRegion([Out, Optional] IMFTimedTextRegion** region)</unmanaged>
        public SharpDX.MediaFoundation.TimedTextRegion Region
        {
            get { SharpDX.MediaFoundation.TimedTextRegion __output__; GetRegion(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets info about the style  of the timed-text cue.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetStyle']/*"/>	
        /// <msdn-id>dn800298</msdn-id>	
        /// <unmanaged>GetStyle</unmanaged>	
        /// <unmanaged-short>GetStyle</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextCue::GetStyle([Out, Optional] IMFTimedTextStyle** style)</unmanaged>
        public SharpDX.MediaFoundation.TimedTextStyle Style
        {
            get { SharpDX.MediaFoundation.TimedTextStyle __output__; GetStyle(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the number of lines of text in the timed-text cue.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetLineCount']/*"/>	
        /// <msdn-id>dn800295</msdn-id>	
        /// <unmanaged>GetLineCount</unmanaged>	
        /// <unmanaged-short>GetLineCount</unmanaged-short>	
        /// <unmanaged>unsigned int IMFTimedTextCue::GetLineCount()</unmanaged>
        public int LineCount
        {
            get { return GetLineCount(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the identifier of a timed-text cue.</p>	
        /// </summary>	
        /// <returns><p>The identifier of a timed-text cue.</p></returns>	
        /// <remarks>	
        /// <p>The identifier is retrieved by this method is dynamically generated by the system and is guaranteed to uniquely identify a cue within a single timed-text track. It is not guaranteed to be unique across tracks. If a cue already has an identifier that is provided in the text-track data format, this ID can be retrieved by calling <strong>GetOriginalId</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetId']/*"/>	
        /// <msdn-id>dn859177</msdn-id>	
        /// <unmanaged>unsigned int IMFTimedTextCue::GetId()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCue::GetId</unmanaged-short>	
        internal int GetId()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the cue identifier that is provided in the text-track data format, if available.</p>	
        /// </summary>	
        /// <param name="originalId"><dd>  <p>The cue identifier that is provided in the text-track data format.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method retrieves an identifier for the cue that is included in the source data, if one was specified. The system dynamically generates identifiers for cues that are guaranteed to be unique within a single time-text track. To obtain this system-generated ID, call <strong>GetId</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetOriginalId']/*"/>	
        /// <msdn-id>dn859178</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextCue::GetOriginalId([Out] wchar_t** originalId)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCue::GetOriginalId</unmanaged-short>	
        public void GetOriginalId(System.IntPtr originalId)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)originalId, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the kind of timed-text cue.</p>	
        /// </summary>	
        /// <returns><p>Returns a <strong><see cref="SharpDX.MediaFoundation.TimedTextTrackKind"/></strong>-typed value that specifies the kind of timed-text cue.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetCueKind']/*"/>	
        /// <msdn-id>dn800291</msdn-id>	
        /// <unmanaged>MF_TIMED_TEXT_TRACK_KIND IMFTimedTextCue::GetCueKind()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCue::GetCueKind</unmanaged-short>	
        internal SharpDX.MediaFoundation.TimedTextTrackKind GetCueKind()
        {
            unsafe
            {
                SharpDX.MediaFoundation.TimedTextTrackKind __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMediaFoundationTimedTextTrackKind(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the start time of the cue in the track.</p>	
        /// </summary>	
        /// <returns><p>Returns the start time of the cue in the track.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetStartTime']/*"/>	
        /// <msdn-id>dn800297</msdn-id>	
        /// <unmanaged>double IMFTimedTextCue::GetStartTime()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCue::GetStartTime</unmanaged-short>	
        internal double GetStartTime()
        {
            unsafe
            {
                double __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callidouble(_nativePointer, ((void**)(*(void**)_nativePointer))[6]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the duration time of the cue in the track.</p>	
        /// </summary>	
        /// <returns><p>Returns the duration time of the cue in the track.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetDuration']/*"/>	
        /// <msdn-id>dn800293</msdn-id>	
        /// <unmanaged>double IMFTimedTextCue::GetDuration()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCue::GetDuration</unmanaged-short>	
        internal double GetDuration()
        {
            unsafe
            {
                double __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Callidouble(_nativePointer, ((void**)(*(void**)_nativePointer))[7]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the identifier of the timed-text cue.</p>	
        /// </summary>	
        /// <returns><p>Returns the identifier of the timed-text cue.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetTrackId']/*"/>	
        /// <msdn-id>dn800299</msdn-id>	
        /// <unmanaged>unsigned int IMFTimedTextCue::GetTrackId()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCue::GetTrackId</unmanaged-short>	
        internal int GetTrackId()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[8]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the data content of the timed-text cue.</p>	
        /// </summary>	
        /// <param name="data"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref="SharpDX.MediaFoundation.TimedTextBinary"/></strong> interface for the data content of the timed-text cue. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetData']/*"/>	
        /// <msdn-id>dn800292</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextCue::GetData([Out, Optional] IMFTimedTextBinary** data)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCue::GetData</unmanaged-short>	
        internal void GetData(out SharpDX.MediaFoundation.TimedTextBinary data)
        {
            unsafe
            {
                IntPtr data_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &data_, ((void**)(*(void**)_nativePointer))[9]);
                data = (data_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextBinary(data_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets info about the display region  of the timed-text cue.</p>	
        /// </summary>	
        /// <param name="region"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref="SharpDX.MediaFoundation.TimedTextRegion"/></strong> interface for the timed-text region. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetRegion']/*"/>	
        /// <msdn-id>dn800296</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextCue::GetRegion([Out, Optional] IMFTimedTextRegion** region)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCue::GetRegion</unmanaged-short>	
        internal void GetRegion(out SharpDX.MediaFoundation.TimedTextRegion region)
        {
            unsafe
            {
                IntPtr region_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &region_, ((void**)(*(void**)_nativePointer))[10]);
                region = (region_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextRegion(region_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets info about the style  of the timed-text cue.</p>	
        /// </summary>	
        /// <param name="style"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref="SharpDX.MediaFoundation.TimedTextStyle"/></strong> interface for the timed-text style. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetStyle']/*"/>	
        /// <msdn-id>dn800298</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextCue::GetStyle([Out, Optional] IMFTimedTextStyle** style)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCue::GetStyle</unmanaged-short>	
        internal void GetStyle(out SharpDX.MediaFoundation.TimedTextStyle style)
        {
            unsafe
            {
                IntPtr style_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &style_, ((void**)(*(void**)_nativePointer))[11]);
                style = (style_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextStyle(style_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the number of lines of text in the timed-text cue.</p>	
        /// </summary>	
        /// <returns><p>Returns the number of lines of text.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetLineCount']/*"/>	
        /// <msdn-id>dn800295</msdn-id>	
        /// <unmanaged>unsigned int IMFTimedTextCue::GetLineCount()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCue::GetLineCount</unmanaged-short>	
        internal int GetLineCount()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[12]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a line of text in the cue from the index of the line.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the line of text in the cue to retrieve. </p> </dd></param>	
        /// <param name="line"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref="SharpDX.MediaFoundation.TimedTextFormattedText"/></strong> interface for the line of text in the cue.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCue::GetLine']/*"/>	
        /// <msdn-id>dn800294</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextCue::GetLine([In] unsigned int index,[Out] IMFTimedTextFormattedText** line)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCue::GetLine</unmanaged-short>	
        public void GetLine(int index, out SharpDX.MediaFoundation.TimedTextFormattedText line)
        {
            unsafe
            {
                IntPtr line_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, index, &line_, ((void**)(*(void**)_nativePointer))[13]);
                line = (line_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextFormattedText(line_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCueList']/*"/>	
    /// <unmanaged>IMFTimedTextCueList</unmanaged>	
    /// <unmanaged-short>IMFTimedTextCueList</unmanaged-short>	
    [Guid("ad128745-211b-40a0-9981-fe65f166d0fd")]
    public partial class TimedTextCueList : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TimedTextCueList"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TimedTextCueList(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TimedTextCueList"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TimedTextCueList(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TimedTextCueList(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCueList::GetLength']/*"/>	
        /// <unmanaged>GetLength</unmanaged>	
        /// <unmanaged-short>GetLength</unmanaged-short>	
        /// <unmanaged>unsigned int IMFTimedTextCueList::GetLength()</unmanaged>
        public int Length
        {
            get { return GetLength(); }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCueList::GetLength']/*"/>	
        /// <unmanaged>unsigned int IMFTimedTextCueList::GetLength()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCueList::GetLength</unmanaged-short>	
        internal int GetLength()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="index">No documentation.</param>	
        /// <param name="cue">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCueList::GetCueByIndex']/*"/>	
        /// <unmanaged>HRESULT IMFTimedTextCueList::GetCueByIndex([In] unsigned int index,[Out] IMFTimedTextCue** cue)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCueList::GetCueByIndex</unmanaged-short>	
        public void GetCueByIndex(int index, out SharpDX.MediaFoundation.TimedTextCue cue)
        {
            unsafe
            {
                IntPtr cue_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, index, &cue_, ((void**)(*(void**)_nativePointer))[4]);
                cue = (cue_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextCue(cue_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="id">No documentation.</param>	
        /// <param name="cue">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCueList::GetCueById']/*"/>	
        /// <unmanaged>HRESULT IMFTimedTextCueList::GetCueById([In] unsigned int id,[Out] IMFTimedTextCue** cue)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCueList::GetCueById</unmanaged-short>	
        public void GetCueById(int id, out SharpDX.MediaFoundation.TimedTextCue cue)
        {
            unsafe
            {
                IntPtr cue_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, id, &cue_, ((void**)(*(void**)_nativePointer))[5]);
                cue = (cue_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextCue(cue_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="originalId">No documentation.</param>	
        /// <param name="cue">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCueList::GetCueByOriginalId']/*"/>	
        /// <unmanaged>HRESULT IMFTimedTextCueList::GetCueByOriginalId([In] const wchar_t* originalId,[Out] IMFTimedTextCue** cue)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCueList::GetCueByOriginalId</unmanaged-short>	
        public void GetCueByOriginalId(string originalId, out SharpDX.MediaFoundation.TimedTextCue cue)
        {
            unsafe
            {
                IntPtr cue_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* originalId_ = originalId)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)originalId_, &cue_, ((void**)(*(void**)_nativePointer))[6]);
                cue = (cue_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextCue(cue_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="start">No documentation.</param>	
        /// <param name="duration">No documentation.</param>	
        /// <param name="text">No documentation.</param>	
        /// <param name="cue">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCueList::AddTextCue']/*"/>	
        /// <unmanaged>HRESULT IMFTimedTextCueList::AddTextCue([In] double start,[In] double duration,[In] const wchar_t* text,[Out, Optional] IMFTimedTextCue** cue)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCueList::AddTextCue</unmanaged-short>	
        public void AddTextCue(double start, double duration, string text, out SharpDX.MediaFoundation.TimedTextCue cue)
        {
            unsafe
            {
                IntPtr cue_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (char* text_ = text)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, start, duration, (void*)text_, &cue_, ((void**)(*(void**)_nativePointer))[7]);
                cue = (cue_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextCue(cue_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="start">No documentation.</param>	
        /// <param name="duration">No documentation.</param>	
        /// <param name="data">No documentation.</param>	
        /// <param name="dataSize">No documentation.</param>	
        /// <param name="cue">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCueList::AddDataCue']/*"/>	
        /// <unmanaged>HRESULT IMFTimedTextCueList::AddDataCue([In] double start,[In] double duration,[In, Buffer] const unsigned char* data,[In] unsigned int dataSize,[Out, Optional] IMFTimedTextCue** cue)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCueList::AddDataCue</unmanaged-short>	
        public void AddDataCue(double start, double duration, byte[] data, int dataSize, out SharpDX.MediaFoundation.TimedTextCue cue)
        {
            unsafe
            {
                IntPtr cue_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* data_ = data)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, start, duration, data_, dataSize, &cue_, ((void**)(*(void**)_nativePointer))[8]);
                cue = (cue_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextCue(cue_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="cue">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextCueList::RemoveCue']/*"/>	
        /// <unmanaged>HRESULT IMFTimedTextCueList::RemoveCue([In] IMFTimedTextCue* cue)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextCueList::RemoveCue</unmanaged-short>	
        public void RemoveCue(SharpDX.MediaFoundation.TimedTextCue cue)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((cue == null) ? IntPtr.Zero : cue.NativePointer), ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Represents a block of formatted timed-text.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextFormattedText']/*"/>	
    /// <msdn-id>dn800300</msdn-id>	
    /// <unmanaged>IMFTimedTextFormattedText</unmanaged>	
    /// <unmanaged-short>IMFTimedTextFormattedText</unmanaged-short>	
    [Guid("e13af3c1-4d47-4354-b1f5-e83ae0ecae60")]
    public partial class TimedTextFormattedText : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TimedTextFormattedText"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TimedTextFormattedText(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TimedTextFormattedText"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TimedTextFormattedText(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TimedTextFormattedText(nativePointer);
        }


        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the number of subformats in the formatted timed-text object.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextFormattedText::GetSubformattingCount']/*"/>	
        /// <msdn-id>dn800302</msdn-id>	
        /// <unmanaged>GetSubformattingCount</unmanaged>	
        /// <unmanaged-short>GetSubformattingCount</unmanaged-short>	
        /// <unmanaged>unsigned int IMFTimedTextFormattedText::GetSubformattingCount()</unmanaged>
        public int SubformattingCount
        {
            get { return GetSubformattingCount(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the text in the formatted timed-text object.</p>	
        /// </summary>	
        /// <param name="text"><dd>  <p>A reference to a variable that receives the null-terminated wide-character string that contains the text.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextFormattedText::GetText']/*"/>	
        /// <msdn-id>dn800303</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextFormattedText::GetText([Out, Optional] wchar_t** text)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextFormattedText::GetText</unmanaged-short>	
        public void GetText(System.IntPtr text)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)text, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the number of subformats in the formatted timed-text object.</p>	
        /// </summary>	
        /// <returns><p>Returns the number of subformats. </p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextFormattedText::GetSubformattingCount']/*"/>	
        /// <msdn-id>dn800302</msdn-id>	
        /// <unmanaged>unsigned int IMFTimedTextFormattedText::GetSubformattingCount()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextFormattedText::GetSubformattingCount</unmanaged-short>	
        internal int GetSubformattingCount()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a subformat in the formatted timed-text object.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the subformat in the formatted timed-text object.</p> </dd></param>	
        /// <param name="firstChar"><dd>  <p>A reference to a variable that receives the first character of the subformat. </p> </dd></param>	
        /// <param name="charLength"><dd>  <p>A reference to a variable that receives the length, in characters, of the subformat. </p> </dd></param>	
        /// <param name="style"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref="SharpDX.MediaFoundation.TimedTextStyle"/></strong> interface for the subformat's timed-text style. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextFormattedText::GetSubformatting']/*"/>	
        /// <msdn-id>dn800301</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextFormattedText::GetSubformatting([In] unsigned int index,[Out] unsigned int* firstChar,[Out] unsigned int* charLength,[Out, Optional] IMFTimedTextStyle** style)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextFormattedText::GetSubformatting</unmanaged-short>	
        public void GetSubformatting(int index, out int firstChar, out int charLength, out SharpDX.MediaFoundation.TimedTextStyle style)
        {
            unsafe
            {
                IntPtr style_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* firstChar_ = &firstChar)
                fixed (void* charLength_ = &charLength)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, index, firstChar_, charLength_, &style_, ((void**)(*(void**)_nativePointer))[5]);
                style = (style_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextStyle(style_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Interface that defines callbacks  for Microsoft Media Foundation Timed Text notifications.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextNotify']/*"/>	
    /// <msdn-id>dn800304</msdn-id>	
    /// <unmanaged>IMFTimedTextNotify</unmanaged>	
    /// <unmanaged-short>IMFTimedTextNotify</unmanaged-short>	
    [Guid("df6b87b6-ce12-45db-aba7-432fe054e57d")]
    public partial class TimedTextNotify : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TimedTextNotify"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TimedTextNotify(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TimedTextNotify"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TimedTextNotify(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TimedTextNotify(nativePointer);
        }


        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when a text track is added</p>	
        /// </summary>	
        /// <param name="trackId"><dd>  <p>The identifier of the track that was added. </p> </dd></param>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextNotify::TrackAdded']/*"/>	
        /// <msdn-id>dn800308</msdn-id>	
        /// <unmanaged>void IMFTimedTextNotify::TrackAdded([In] unsigned int trackId)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextNotify::TrackAdded</unmanaged-short>	
        public void TrackAdded(int trackId)
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, trackId, ((void**)(*(void**)_nativePointer))[3]);
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when a text track is removed.</p>	
        /// </summary>	
        /// <param name="trackId"><dd>  <p>The identifier of the track that was removed. </p> </dd></param>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextNotify::TrackRemoved']/*"/>	
        /// <msdn-id>dn800309</msdn-id>	
        /// <unmanaged>void IMFTimedTextNotify::TrackRemoved([In] unsigned int trackId)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextNotify::TrackRemoved</unmanaged-short>	
        public void TrackRemoved(int trackId)
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, trackId, ((void**)(*(void**)_nativePointer))[4]);
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when a track is selected or deselected.</p>	
        /// </summary>	
        /// <param name="trackId"><dd>  <p>The identifier of the track that was selected or deselected. </p> </dd></param>	
        /// <param name="selected"><dd>  <p><strong>TRUE</strong> if the track was selected. <strong><see cref="SharpDX.Result.False"/></strong> if the track was deselected. </p> </dd></param>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextNotify::TrackSelected']/*"/>	
        /// <msdn-id>dn800310</msdn-id>	
        /// <unmanaged>void IMFTimedTextNotify::TrackSelected([In] unsigned int trackId,[In] BOOL selected)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextNotify::TrackSelected</unmanaged-short>	
        public void TrackSelected(int trackId, SharpDX.Mathematics.Interop.RawBool selected)
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid112(_nativePointer, trackId, selected, ((void**)(*(void**)_nativePointer))[5]);
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="trackId">No documentation.</param>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextNotify::TrackReadyStateChanged']/*"/>	
        /// <unmanaged>void IMFTimedTextNotify::TrackReadyStateChanged([In] unsigned int trackId)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextNotify::TrackReadyStateChanged</unmanaged-short>	
        public void TrackReadyStateChanged(int trackId)
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, trackId, ((void**)(*(void**)_nativePointer))[6]);
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when an error occurs in a text track.</p>	
        /// </summary>	
        /// <param name="errorCode"><dd>  <p>An <see cref="SharpDX.MediaFoundation.TimedTextErrorCode"/> representing the last error.</p> </dd></param>	
        /// <param name="extendedErrorCode"><dd>  <p>The extended error code for the last error.</p> </dd></param>	
        /// <param name="sourceTrackId"><dd>  <p>The identifier of the track on which the error occurred.</p> </dd></param>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextNotify::Error']/*"/>	
        /// <msdn-id>dn800306</msdn-id>	
        /// <unmanaged>void IMFTimedTextNotify::Error([In] MF_TIMED_TEXT_ERROR_CODE errorCode,[In] HRESULT extendedErrorCode,[In] unsigned int sourceTrackId)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextNotify::Error</unmanaged-short>	
        public void Error(SharpDX.MediaFoundation.TimedTextErrorCode errorCode, SharpDX.Result extendedErrorCode, int sourceTrackId)
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid113(_nativePointer, unchecked((int)errorCode), extendedErrorCode, sourceTrackId, ((void**)(*(void**)_nativePointer))[7]);
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when a cue event occurs in a text track.</p>	
        /// </summary>	
        /// <param name="cueEvent"><dd>  <p>A value specifying the type of event that has occured.</p> </dd></param>	
        /// <param name="currentTime"><dd>  <p>The current time when the cue event occurred.</p> </dd></param>	
        /// <param name="cue"><dd>  <p>The <strong><see cref="SharpDX.MediaFoundation.TimedTextCue"/></strong> object representing the cue.</p> </dd></param>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextNotify::Cue']/*"/>	
        /// <msdn-id>dn800305</msdn-id>	
        /// <unmanaged>void IMFTimedTextNotify::Cue([In] MF_TIMED_TEXT_CUE_EVENT cueEvent,[In] double currentTime,[In, Optional] IMFTimedTextCue* cue)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextNotify::Cue</unmanaged-short>	
        public void Cue(SharpDX.MediaFoundation.TimedTextCueEvent cueEvent, double currentTime, SharpDX.MediaFoundation.TimedTextCue cue)
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, unchecked((int)cueEvent), currentTime, (void*)((cue == null) ? IntPtr.Zero : cue.NativePointer), ((void**)(*(void**)_nativePointer))[8]);
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Resets the timed-text-notify object.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextNotify::Reset']/*"/>	
        /// <msdn-id>dn800307</msdn-id>	
        /// <unmanaged>void IMFTimedTextNotify::Reset()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextNotify::Reset</unmanaged-short>	
        public void Reset()
        {
            unsafe
            {
                SharpDX.MediaFoundation.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[9]);
            }
        }
    }
    /// <summary>	
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Represents the display region  of a timed-text object.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion']/*"/>	
    /// <msdn-id>dn800311</msdn-id>	
    /// <unmanaged>IMFTimedTextRegion</unmanaged>	
    /// <unmanaged-short>IMFTimedTextRegion</unmanaged-short>	
    [Guid("c8d22afc-bc47-4bdf-9b04-787e49ce3f58")]
    public partial class TimedTextRegion : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TimedTextRegion"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TimedTextRegion(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TimedTextRegion"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TimedTextRegion(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TimedTextRegion(nativePointer);
        }


        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the background color of the region.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetBackgroundColor']/*"/>	
        /// <msdn-id>dn800312</msdn-id>	
        /// <unmanaged>GetBackgroundColor</unmanaged>	
        /// <unmanaged-short>GetBackgroundColor</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetBackgroundColor([Out] MFARGB* bgColor)</unmanaged>
        public SharpDX.Mathematics.Interop.RawColorBGRA BackgroundColor
        {
            get { SharpDX.Mathematics.Interop.RawColorBGRA __output__; GetBackgroundColor(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the writing mode of the region.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetWritingMode']/*"/>	
        /// <msdn-id>dn800322</msdn-id>	
        /// <unmanaged>GetWritingMode</unmanaged>	
        /// <unmanaged-short>GetWritingMode</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetWritingMode([Out] MF_TIMED_TEXT_WRITING_MODE* writingMode)</unmanaged>
        public SharpDX.MediaFoundation.TimedTextWritingMode WritingMode
        {
            get { SharpDX.MediaFoundation.TimedTextWritingMode __output__; GetWritingMode(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the display alignment of the region.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetDisplayAlignment']/*"/>	
        /// <msdn-id>dn800314</msdn-id>	
        /// <unmanaged>GetDisplayAlignment</unmanaged>	
        /// <unmanaged-short>GetDisplayAlignment</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetDisplayAlignment([Out] MF_TIMED_TEXT_DISPLAY_ALIGNMENT* displayAlign)</unmanaged>
        public SharpDX.MediaFoundation.TimedTextDisplayAlignment DisplayAlignment
        {
            get { SharpDX.MediaFoundation.TimedTextDisplayAlignment __output__; GetDisplayAlignment(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether a clip of text overflowed the region.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetClipOverflow']/*"/>	
        /// <msdn-id>dn800313</msdn-id>	
        /// <unmanaged>GetClipOverflow</unmanaged>	
        /// <unmanaged-short>GetClipOverflow</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetClipOverflow([Out] BOOL* clipOverflow)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool ClipOverflow
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; GetClipOverflow(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the word wrap feature is enabled in the region.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetWrap']/*"/>	
        /// <msdn-id>dn800321</msdn-id>	
        /// <unmanaged>GetWrap</unmanaged>	
        /// <unmanaged-short>GetWrap</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetWrap([Out] BOOL* wrap)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool Wrap
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; GetWrap(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the Z-index (depth) of the region.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetZIndex']/*"/>	
        /// <msdn-id>dn800323</msdn-id>	
        /// <unmanaged>GetZIndex</unmanaged>	
        /// <unmanaged-short>GetZIndex</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetZIndex([Out] int* zIndex)</unmanaged>
        public int ZIndex
        {
            get { int __output__; GetZIndex(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the scroll mode of the region.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetScrollMode']/*"/>	
        /// <msdn-id>dn800320</msdn-id>	
        /// <unmanaged>GetScrollMode</unmanaged>	
        /// <unmanaged-short>GetScrollMode</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetScrollMode([Out] MF_TIMED_TEXT_SCROLL_MODE* scrollMode)</unmanaged>
        public SharpDX.MediaFoundation.TimedTextScrollMode ScrollMode
        {
            get { SharpDX.MediaFoundation.TimedTextScrollMode __output__; GetScrollMode(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the name of the region.</p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>A reference to a variable that receives the null-terminated wide-character string that contains the name of the region.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetName']/*"/>	
        /// <msdn-id>dn800317</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetName([Out] wchar_t** name)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextRegion::GetName</unmanaged-short>	
        public void GetName(System.IntPtr name)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)name, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the position of the region.</p>	
        /// </summary>	
        /// <param name="xRef"><dd>  <p>A reference to a variable that receives the X-coordinate of the position.</p> </dd></param>	
        /// <param name="yRef"><dd>  <p>A reference to a variable that receives the Y-coordinate of the position.</p> </dd></param>	
        /// <param name="unitType"><dd>  <p>A reference to a variable that receives a <strong><see cref="SharpDX.MediaFoundation.TimedTextUnitType"/></strong>-typed value that specifies the units in which the timed-text region is measured.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetPosition']/*"/>	
        /// <msdn-id>dn800319</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetPosition([Out] double* pX,[Out] double* pY,[Out] MF_TIMED_TEXT_UNIT_TYPE* unitType)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextRegion::GetPosition</unmanaged-short>	
        public void GetPosition(out double xRef, out double yRef, out SharpDX.MediaFoundation.TimedTextUnitType unitType)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* xRef_ = &xRef)
                fixed (void* yRef_ = &yRef)
                fixed (void* unitType_ = &unitType)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, xRef_, yRef_, unitType_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the extent of the region.</p>	
        /// </summary>	
        /// <param name="widthRef"><dd>  <p>A reference to a variable that receives the width of the region.</p> </dd></param>	
        /// <param name="heightRef"><dd>  <p>A reference to a variable that receives the height of the region.</p> </dd></param>	
        /// <param name="unitType"><dd>  <p>A reference to a variable that receives a <strong><see cref="SharpDX.MediaFoundation.TimedTextUnitType"/></strong>-typed value that specifies the units in which the timed-text region is measured.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetExtent']/*"/>	
        /// <msdn-id>dn800315</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetExtent([Out] double* pWidth,[Out] double* pHeight,[Out] MF_TIMED_TEXT_UNIT_TYPE* unitType)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextRegion::GetExtent</unmanaged-short>	
        public void GetExtent(out double widthRef, out double heightRef, out SharpDX.MediaFoundation.TimedTextUnitType unitType)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* widthRef_ = &widthRef)
                fixed (void* heightRef_ = &heightRef)
                fixed (void* unitType_ = &unitType)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, widthRef_, heightRef_, unitType_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the background color of the region.</p>	
        /// </summary>	
        /// <param name="bgColor"><dd>  <p>A reference to a variable that receives a <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that describes the background color.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetBackgroundColor']/*"/>	
        /// <msdn-id>dn800312</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetBackgroundColor([Out] MFARGB* bgColor)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextRegion::GetBackgroundColor</unmanaged-short>	
        internal void GetBackgroundColor(out SharpDX.Mathematics.Interop.RawColorBGRA bgColor)
        {
            unsafe
            {
                bgColor = new SharpDX.Mathematics.Interop.RawColorBGRA();
                SharpDX.Result __result__;
                fixed (void* bgColor_ = &bgColor)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bgColor_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the writing mode of the region.</p>	
        /// </summary>	
        /// <param name="writingMode"><dd>  <p>A reference to a variable that receives a <strong><see cref="SharpDX.MediaFoundation.TimedTextWritingMode"/></strong>-typed value that specifies the writing mode of the region.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetWritingMode']/*"/>	
        /// <msdn-id>dn800322</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetWritingMode([Out] MF_TIMED_TEXT_WRITING_MODE* writingMode)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextRegion::GetWritingMode</unmanaged-short>	
        internal void GetWritingMode(out SharpDX.MediaFoundation.TimedTextWritingMode writingMode)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* writingMode_ = &writingMode)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, writingMode_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the display alignment of the region.</p>	
        /// </summary>	
        /// <param name="displayAlign"><dd>  <p>A reference to a variable that receives a <strong><see cref="SharpDX.MediaFoundation.TimedTextDisplayAlignment"/></strong>-typed value that specifies the display alignment of the region.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetDisplayAlignment']/*"/>	
        /// <msdn-id>dn800314</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetDisplayAlignment([Out] MF_TIMED_TEXT_DISPLAY_ALIGNMENT* displayAlign)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextRegion::GetDisplayAlignment</unmanaged-short>	
        internal void GetDisplayAlignment(out SharpDX.MediaFoundation.TimedTextDisplayAlignment displayAlign)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* displayAlign_ = &displayAlign)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, displayAlign_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the height of each line of text in the region.</p>	
        /// </summary>	
        /// <param name="lineHeightRef"><dd>  <p>A reference to a variable that receives the height of each line of text in the region.</p> </dd></param>	
        /// <param name="unitType"><dd>  <p>A reference to a variable that receives a <strong><see cref="SharpDX.MediaFoundation.TimedTextUnitType"/></strong>-typed value that specifies the units in which the timed-text region is measured.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetLineHeight']/*"/>	
        /// <msdn-id>dn800316</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetLineHeight([Out] double* pLineHeight,[Out] MF_TIMED_TEXT_UNIT_TYPE* unitType)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextRegion::GetLineHeight</unmanaged-short>	
        public void GetLineHeight(out double lineHeightRef, out SharpDX.MediaFoundation.TimedTextUnitType unitType)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* lineHeightRef_ = &lineHeightRef)
                fixed (void* unitType_ = &unitType)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, lineHeightRef_, unitType_, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether a clip of text overflowed the region.</p>	
        /// </summary>	
        /// <param name="clipOverflow"><dd>  <p>A reference to a variable that receives a value that specifies whether a clip of text overflowed the region. The variable specifies <strong>TRUE</strong> if the clip overflowed; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetClipOverflow']/*"/>	
        /// <msdn-id>dn800313</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetClipOverflow([Out] BOOL* clipOverflow)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextRegion::GetClipOverflow</unmanaged-short>	
        internal void GetClipOverflow(out SharpDX.Mathematics.Interop.RawBool clipOverflow)
        {
            unsafe
            {
                clipOverflow = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* clipOverflow_ = &clipOverflow)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, clipOverflow_, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the padding that surrounds the region.</p>	
        /// </summary>	
        /// <param name="before"><dd>  <p>A reference to a variable that receives the padding before the start of the region.</p> </dd></param>	
        /// <param name="start"><dd>  <p>A reference to a variable that receives the start of the region.</p> </dd></param>	
        /// <param name="after"><dd>  <p>A reference to a variable that receives the padding after the end of the region.</p> </dd></param>	
        /// <param name="end"><dd>  <p>A reference to a variable that receives the end of the region.</p> </dd></param>	
        /// <param name="unitType"><dd>  <p>A reference to a variable that receives a <strong><see cref="SharpDX.MediaFoundation.TimedTextUnitType"/></strong>-typed value that specifies the units in which the timed-text region is measured.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetPadding']/*"/>	
        /// <msdn-id>dn800318</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetPadding([Out] double* before,[Out] double* start,[Out] double* after,[Out] double* end,[Out] MF_TIMED_TEXT_UNIT_TYPE* unitType)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextRegion::GetPadding</unmanaged-short>	
        public void GetPadding(out double before, out double start, out double after, out double end, out SharpDX.MediaFoundation.TimedTextUnitType unitType)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* before_ = &before)
                fixed (void* start_ = &start)
                fixed (void* after_ = &after)
                fixed (void* end_ = &end)
                fixed (void* unitType_ = &unitType)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, before_, start_, after_, end_, unitType_, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the word wrap feature is enabled in the region.</p>	
        /// </summary>	
        /// <param name="wrap"><dd>  <p>A reference to a variable that receives a value that specifies whether the word wrap feature is enabled in the region. The variable specifies <strong>TRUE</strong> if word wrap is enabled; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetWrap']/*"/>	
        /// <msdn-id>dn800321</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetWrap([Out] BOOL* wrap)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextRegion::GetWrap</unmanaged-short>	
        internal void GetWrap(out SharpDX.Mathematics.Interop.RawBool wrap)
        {
            unsafe
            {
                wrap = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* wrap_ = &wrap)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, wrap_, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the Z-index (depth) of the region.</p>	
        /// </summary>	
        /// <param name="zIndex"><dd>  <p>A reference to a variable that receives the Z-index (depth) of the region.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetZIndex']/*"/>	
        /// <msdn-id>dn800323</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetZIndex([Out] int* zIndex)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextRegion::GetZIndex</unmanaged-short>	
        internal void GetZIndex(out int zIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* zIndex_ = &zIndex)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, zIndex_, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the scroll mode of the region.</p>	
        /// </summary>	
        /// <param name="scrollMode"><dd>  <p>A reference to a variable that receives a <strong><see cref="SharpDX.MediaFoundation.TimedTextScrollMode"/></strong>-typed value that specifies the scroll mode of the region.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextRegion::GetScrollMode']/*"/>	
        /// <msdn-id>dn800320</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextRegion::GetScrollMode([Out] MF_TIMED_TEXT_SCROLL_MODE* scrollMode)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextRegion::GetScrollMode</unmanaged-short>	
        internal void GetScrollMode(out SharpDX.MediaFoundation.TimedTextScrollMode scrollMode)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* scrollMode_ = &scrollMode)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, scrollMode_, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the color of the timed-text style.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle']/*"/>	
    /// <msdn-id>dn800327</msdn-id>	
    /// <unmanaged>IMFTimedTextStyle</unmanaged>	
    /// <unmanaged-short>IMFTimedTextStyle</unmanaged-short>	
    [Guid("09b2455d-b834-4f01-a347-9052e21c450e")]
    public partial class TimedTextStyle : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TimedTextStyle"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TimedTextStyle(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TimedTextStyle"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TimedTextStyle(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TimedTextStyle(nativePointer);
        }


        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the timed-text style is external.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::IsExternal']/*"/>	
        /// <msdn-id>dn800338</msdn-id>	
        /// <unmanaged>IsExternal</unmanaged>	
        /// <unmanaged-short>IsExternal</unmanaged-short>	
        /// <unmanaged>BOOL IMFTimedTextStyle::IsExternal()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsExternal
        {
            get { return IsExternal_(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the color of the timed-text style.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetColor']/*"/>	
        /// <msdn-id>dn800327</msdn-id>	
        /// <unmanaged>GetColor</unmanaged>	
        /// <unmanaged-short>GetColor</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetColor([Out] MFARGB* color)</unmanaged>
        public SharpDX.Mathematics.Interop.RawColorBGRA Color
        {
            get { SharpDX.Mathematics.Interop.RawColorBGRA __output__; GetColor(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the background color of the timed-text style.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetBackgroundColor']/*"/>	
        /// <msdn-id>dn800325</msdn-id>	
        /// <unmanaged>GetBackgroundColor</unmanaged>	
        /// <unmanaged-short>GetBackgroundColor</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetBackgroundColor([Out] MFARGB* bgColor)</unmanaged>
        public SharpDX.Mathematics.Interop.RawColorBGRA BackgroundColor
        {
            get { SharpDX.Mathematics.Interop.RawColorBGRA __output__; GetBackgroundColor(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the style  of timed text always shows the background.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetShowBackgroundAlways']/*"/>	
        /// <msdn-id>dn800334</msdn-id>	
        /// <unmanaged>GetShowBackgroundAlways</unmanaged>	
        /// <unmanaged-short>GetShowBackgroundAlways</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetShowBackgroundAlways([Out] BOOL* showBackgroundAlways)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool ShowBackgroundAlways
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; GetShowBackgroundAlways(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the font style of the timed-text style.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetFontStyle']/*"/>	
        /// <msdn-id>dn800330</msdn-id>	
        /// <unmanaged>GetFontStyle</unmanaged>	
        /// <unmanaged-short>GetFontStyle</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetFontStyle([Out] MF_TIMED_TEXT_FONT_STYLE* fontStyle)</unmanaged>
        public SharpDX.MediaFoundation.TimedTextFontStyle FontStyle
        {
            get { SharpDX.MediaFoundation.TimedTextFontStyle __output__; GetFontStyle(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the style  of timed text is bold.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetBold']/*"/>	
        /// <msdn-id>dn800326</msdn-id>	
        /// <unmanaged>GetBold</unmanaged>	
        /// <unmanaged-short>GetBold</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetBold([Out] BOOL* bold)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool Bold
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; GetBold(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the right to left writing mode of the timed-text style  is enabled.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetRightToLeft']/*"/>	
        /// <msdn-id>dn800332</msdn-id>	
        /// <unmanaged>GetRightToLeft</unmanaged>	
        /// <unmanaged-short>GetRightToLeft</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetRightToLeft([Out] BOOL* rightToLeft)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool RightToLeft
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; GetRightToLeft(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the text alignment of the timed-text style.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetTextAlignment']/*"/>	
        /// <msdn-id>dn800335</msdn-id>	
        /// <unmanaged>GetTextAlignment</unmanaged>	
        /// <unmanaged-short>GetTextAlignment</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetTextAlignment([Out] MF_TIMED_TEXT_ALIGNMENT* textAlign)</unmanaged>
        public SharpDX.MediaFoundation.TimedTextAlignment TextAlignment
        {
            get { SharpDX.MediaFoundation.TimedTextAlignment __output__; GetTextAlignment(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets how text is decorated for the timed-text style.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetTextDecoration']/*"/>	
        /// <msdn-id>dn800336</msdn-id>	
        /// <unmanaged>GetTextDecoration</unmanaged>	
        /// <unmanaged-short>GetTextDecoration</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetTextDecoration([Out] unsigned int* textDecoration)</unmanaged>
        public int TextDecoration
        {
            get { int __output__; GetTextDecoration(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the name of the timed-text style.</p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>A reference to a variable that receives the null-terminated wide-character string that contains the name of the style.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetName']/*"/>	
        /// <msdn-id>dn800331</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetName([Out] wchar_t** name)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextStyle::GetName</unmanaged-short>	
        public void GetName(System.IntPtr name)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)name, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the timed-text style is external.</p>	
        /// </summary>	
        /// <returns><p>Returns whether the timed-text style is external. If <strong>TRUE</strong>, the timed-text style is external; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>. </p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::IsExternal']/*"/>	
        /// <msdn-id>dn800338</msdn-id>	
        /// <unmanaged>BOOL IMFTimedTextStyle::IsExternal()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextStyle::IsExternal</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsExternal_()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the font family of the timed-text style.</p>	
        /// </summary>	
        /// <param name="fontFamily"><dd>  <p>A reference to a variable that receives the null-terminated wide-character string that contains the font family of the style.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetFontFamily']/*"/>	
        /// <msdn-id>dn800328</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetFontFamily([Out] wchar_t** fontFamily)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextStyle::GetFontFamily</unmanaged-short>	
        public void GetFontFamily(System.IntPtr fontFamily)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)fontFamily, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the font size  of the timed-text style.</p>	
        /// </summary>	
        /// <param name="fontSize"><dd>  <p>A reference to a variable that receives the font size  of the timed-text style.</p> </dd></param>	
        /// <param name="unitType"><dd>  <p>A reference to a variable that receives a <strong><see cref="SharpDX.MediaFoundation.TimedTextUnitType"/></strong>-typed value that specifies the units in which the timed-text style is measured.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetFontSize']/*"/>	
        /// <msdn-id>dn800329</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetFontSize([Out] double* fontSize,[Out] MF_TIMED_TEXT_UNIT_TYPE* unitType)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextStyle::GetFontSize</unmanaged-short>	
        public void GetFontSize(out double fontSize, out SharpDX.MediaFoundation.TimedTextUnitType unitType)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* fontSize_ = &fontSize)
                fixed (void* unitType_ = &unitType)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fontSize_, unitType_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the color of the timed-text style.</p>	
        /// </summary>	
        /// <param name="color"><dd>  <p>A reference to a variable that receives a <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that describes the color.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetColor']/*"/>	
        /// <msdn-id>dn800327</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetColor([Out] MFARGB* color)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextStyle::GetColor</unmanaged-short>	
        internal void GetColor(out SharpDX.Mathematics.Interop.RawColorBGRA color)
        {
            unsafe
            {
                color = new SharpDX.Mathematics.Interop.RawColorBGRA();
                SharpDX.Result __result__;
                fixed (void* color_ = &color)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, color_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the background color of the timed-text style.</p>	
        /// </summary>	
        /// <param name="bgColor"><dd>  <p>A reference to a variable that receives a <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that describes the background color.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetBackgroundColor']/*"/>	
        /// <msdn-id>dn800325</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetBackgroundColor([Out] MFARGB* bgColor)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextStyle::GetBackgroundColor</unmanaged-short>	
        internal void GetBackgroundColor(out SharpDX.Mathematics.Interop.RawColorBGRA bgColor)
        {
            unsafe
            {
                bgColor = new SharpDX.Mathematics.Interop.RawColorBGRA();
                SharpDX.Result __result__;
                fixed (void* bgColor_ = &bgColor)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bgColor_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the style  of timed text always shows the background.</p>	
        /// </summary>	
        /// <param name="showBackgroundAlways"><dd>  <p>A reference to a variable that receives a value that specifies whether the style  of timed text always shows the background. The variable specifies <strong>TRUE</strong> if the background is always shown; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetShowBackgroundAlways']/*"/>	
        /// <msdn-id>dn800334</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetShowBackgroundAlways([Out] BOOL* showBackgroundAlways)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextStyle::GetShowBackgroundAlways</unmanaged-short>	
        internal void GetShowBackgroundAlways(out SharpDX.Mathematics.Interop.RawBool showBackgroundAlways)
        {
            unsafe
            {
                showBackgroundAlways = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* showBackgroundAlways_ = &showBackgroundAlways)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, showBackgroundAlways_, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the font style of the timed-text style.</p>	
        /// </summary>	
        /// <param name="fontStyle"><dd>  <p>A reference to a variable that receives a <strong><see cref="SharpDX.MediaFoundation.TimedTextFontStyle"/></strong>-typed value that specifies the font style.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetFontStyle']/*"/>	
        /// <msdn-id>dn800330</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetFontStyle([Out] MF_TIMED_TEXT_FONT_STYLE* fontStyle)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextStyle::GetFontStyle</unmanaged-short>	
        internal void GetFontStyle(out SharpDX.MediaFoundation.TimedTextFontStyle fontStyle)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* fontStyle_ = &fontStyle)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fontStyle_, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the style  of timed text is bold.</p>	
        /// </summary>	
        /// <param name="bold"><dd>  <p>A reference to a variable that receives a value that specifies whether the style  of timed text is bold. The variable specifies <strong>TRUE</strong> if the style is bold; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetBold']/*"/>	
        /// <msdn-id>dn800326</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetBold([Out] BOOL* bold)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextStyle::GetBold</unmanaged-short>	
        internal void GetBold(out SharpDX.Mathematics.Interop.RawBool bold)
        {
            unsafe
            {
                bold = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* bold_ = &bold)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bold_, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the right to left writing mode of the timed-text style  is enabled.</p>	
        /// </summary>	
        /// <param name="rightToLeft"><dd>  <p>A reference to a variable that receives a value that specifies whether the right to left writing mode is enabled. The variable specifies <strong>TRUE</strong> if the right to left writing mode is enabled; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetRightToLeft']/*"/>	
        /// <msdn-id>dn800332</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetRightToLeft([Out] BOOL* rightToLeft)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextStyle::GetRightToLeft</unmanaged-short>	
        internal void GetRightToLeft(out SharpDX.Mathematics.Interop.RawBool rightToLeft)
        {
            unsafe
            {
                rightToLeft = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* rightToLeft_ = &rightToLeft)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, rightToLeft_, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the text alignment of the timed-text style.</p>	
        /// </summary>	
        /// <param name="textAlign"><dd>  <p>A reference to a variable that receives a <strong><see cref="SharpDX.MediaFoundation.TimedTextAlignment"/></strong>-typed value that specifies the text alignment.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetTextAlignment']/*"/>	
        /// <msdn-id>dn800335</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetTextAlignment([Out] MF_TIMED_TEXT_ALIGNMENT* textAlign)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextStyle::GetTextAlignment</unmanaged-short>	
        internal void GetTextAlignment(out SharpDX.MediaFoundation.TimedTextAlignment textAlign)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* textAlign_ = &textAlign)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, textAlign_, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets how text is decorated for the timed-text style.</p>	
        /// </summary>	
        /// <param name="textDecoration"><dd>  <p>A reference to a variable that receives a combination of <strong><see cref="SharpDX.MediaFoundation.TimedTextDecoration"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies how text is decorated.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetTextDecoration']/*"/>	
        /// <msdn-id>dn800336</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetTextDecoration([Out] unsigned int* textDecoration)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextStyle::GetTextDecoration</unmanaged-short>	
        internal void GetTextDecoration(out int textDecoration)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* textDecoration_ = &textDecoration)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, textDecoration_, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the text outline for the timed-text style.</p>	
        /// </summary>	
        /// <param name="color"><dd>  <p>A reference to a variable that receives a <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that describes the color.</p> </dd></param>	
        /// <param name="thickness"><dd>  <p>A reference to a variable that receives the thickness.</p> </dd></param>	
        /// <param name="blurRadius"><dd>  <p>A reference to a variable that receives the blur radius.</p> </dd></param>	
        /// <param name="unitType"><dd>  <p>A reference to a variable that receives a <strong><see cref="SharpDX.MediaFoundation.TimedTextUnitType"/></strong>-typed value that specifies the units in which the timed-text is measured.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextStyle::GetTextOutline']/*"/>	
        /// <msdn-id>dn800337</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextStyle::GetTextOutline([Out] MFARGB* color,[Out] double* thickness,[Out] double* blurRadius,[Out] MF_TIMED_TEXT_UNIT_TYPE* unitType)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextStyle::GetTextOutline</unmanaged-short>	
        public void GetTextOutline(out SharpDX.Mathematics.Interop.RawColorBGRA color, out double thickness, out double blurRadius, out SharpDX.MediaFoundation.TimedTextUnitType unitType)
        {
            unsafe
            {
                color = new SharpDX.Mathematics.Interop.RawColorBGRA();
                SharpDX.Result __result__;
                fixed (void* color_ = &color)
                fixed (void* thickness_ = &thickness)
                fixed (void* blurRadius_ = &blurRadius)
                fixed (void* unitType_ = &unitType)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, color_, thickness_, blurRadius_, unitType_, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Represents a track of timed text.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack']/*"/>	
    /// <msdn-id>dn800339</msdn-id>	
    /// <unmanaged>IMFTimedTextTrack</unmanaged>	
    /// <unmanaged-short>IMFTimedTextTrack</unmanaged-short>	
    [Guid("8822c32d-654e-4233-bf21-d7f2e67d30d4")]
    public partial class TimedTextTrack : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TimedTextTrack"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TimedTextTrack(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TimedTextTrack"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TimedTextTrack(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TimedTextTrack(nativePointer);
        }


        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the identifier of the track of timed text.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetId']/*"/>	
        /// <msdn-id>dn800344</msdn-id>	
        /// <unmanaged>GetId</unmanaged>	
        /// <unmanaged-short>GetId</unmanaged-short>	
        /// <unmanaged>unsigned int IMFTimedTextTrack::GetId()</unmanaged>
        public int Id
        {
            get { return GetId(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Sets the label of a timed-text track.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::SetLabel']/*"/>	
        /// <msdn-id>dn859182</msdn-id>	
        /// <unmanaged>SetLabel</unmanaged>	
        /// <unmanaged-short>SetLabel</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextTrack::SetLabel([In] const wchar_t* label)</unmanaged>
        public string Label
        {
            set { SetLabel(value); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the kind of timed-text track.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetTrackKind']/*"/>	
        /// <msdn-id>dn800348</msdn-id>	
        /// <unmanaged>GetTrackKind</unmanaged>	
        /// <unmanaged-short>GetTrackKind</unmanaged-short>	
        /// <unmanaged>MF_TIMED_TEXT_TRACK_KIND IMFTimedTextTrack::GetTrackKind()</unmanaged>
        public SharpDX.MediaFoundation.TimedTextTrackKind TrackKind
        {
            get { return GetTrackKind(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the timed-text track is inband.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::IsInBand']/*"/>	
        /// <msdn-id>dn800350</msdn-id>	
        /// <unmanaged>IsInBand</unmanaged>	
        /// <unmanaged-short>IsInBand</unmanaged-short>	
        /// <unmanaged>BOOL IMFTimedTextTrack::IsInBand()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsInBand
        {
            get { return IsInBand_(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the timed-text track is active.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::IsActive']/*"/>	
        /// <msdn-id>dn800349</msdn-id>	
        /// <unmanaged>IsActive</unmanaged>	
        /// <unmanaged-short>IsActive</unmanaged-short>	
        /// <unmanaged>BOOL IMFTimedTextTrack::IsActive()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsActive
        {
            get { return IsActive_(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a value indicating the error type of the latest error associated with the track.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetErrorCode']/*"/>	
        /// <msdn-id>dn859180</msdn-id>	
        /// <unmanaged>GetErrorCode</unmanaged>	
        /// <unmanaged-short>GetErrorCode</unmanaged-short>	
        /// <unmanaged>MF_TIMED_TEXT_ERROR_CODE IMFTimedTextTrack::GetErrorCode()</unmanaged>
        public SharpDX.MediaFoundation.TimedTextErrorCode ErrorCode
        {
            get { return GetErrorCode(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the extended error code for the latest error associated with the track.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If the most recent error was associated with a track, this value will be the same <strong><see cref="SharpDX.Result"/></strong> as returned by the <strong><see cref="SharpDX.MediaFoundation.TimedTextNotify.Error"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetExtendedErrorCode']/*"/>	
        /// <msdn-id>dn859181</msdn-id>	
        /// <unmanaged>GetExtendedErrorCode</unmanaged>	
        /// <unmanaged-short>GetExtendedErrorCode</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextTrack::GetExtendedErrorCode()</unmanaged>
        public SharpDX.Result ExtendedErrorCode
        {
            get { return GetExtendedErrorCode(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a <see cref="System.Guid"/> that identifies the track's underlying data format.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetDataFormat']/*"/>	
        /// <msdn-id>dn859179</msdn-id>	
        /// <unmanaged>GetDataFormat</unmanaged>	
        /// <unmanaged-short>GetDataFormat</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextTrack::GetDataFormat([Out] GUID* format)</unmanaged>
        public System.Guid DataFormat
        {
            get { System.Guid __output__; GetDataFormat(out __output__); return __output__; }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetReadyState']/*"/>	
        /// <unmanaged>GetReadyState</unmanaged>	
        /// <unmanaged-short>GetReadyState</unmanaged-short>	
        /// <unmanaged>MF_TIMED_TEXT_TRACK_READY_STATE IMFTimedTextTrack::GetReadyState()</unmanaged>
        public SharpDX.MediaFoundation.TimedTextTrackReadyState ReadyState
        {
            get { return GetReadyState(); }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetCueList']/*"/>	
        /// <unmanaged>GetCueList</unmanaged>	
        /// <unmanaged-short>GetCueList</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTimedTextTrack::GetCueList([Out] IMFTimedTextCueList** cues)</unmanaged>
        public SharpDX.MediaFoundation.TimedTextCueList CueList
        {
            get { SharpDX.MediaFoundation.TimedTextCueList __output__; GetCueList(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the identifier of the track of timed text.</p>	
        /// </summary>	
        /// <returns><p>Returns the identifier of the track. </p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetId']/*"/>	
        /// <msdn-id>dn800344</msdn-id>	
        /// <unmanaged>unsigned int IMFTimedTextTrack::GetId()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextTrack::GetId</unmanaged-short>	
        internal int GetId()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the label of the track.</p>	
        /// </summary>	
        /// <param name="label"><dd>  <p>A reference to a variable that receives the null-terminated wide-character string that contains the label of the track.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetLabel']/*"/>	
        /// <msdn-id>dn800346</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextTrack::GetLabel([Out] wchar_t** label)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextTrack::GetLabel</unmanaged-short>	
        public void GetLabel(System.IntPtr label)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)label, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Sets the label of a timed-text track.</p>	
        /// </summary>	
        /// <param name="label"><dd>  <p>A reference to a null-terminated wide-character string that contains the label of the track.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::SetLabel']/*"/>	
        /// <msdn-id>dn859182</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextTrack::SetLabel([In] const wchar_t* label)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextTrack::SetLabel</unmanaged-short>	
        internal void SetLabel(string label)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* label_ = label)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)label_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the language of the track.</p>	
        /// </summary>	
        /// <param name="language"><dd>  <p>A reference to a variable that receives the null-terminated wide-character string that contains the language of the track.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetLanguage']/*"/>	
        /// <msdn-id>dn800347</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextTrack::GetLanguage([Out] wchar_t** language)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextTrack::GetLanguage</unmanaged-short>	
        public void GetLanguage(System.IntPtr language)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)language, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the kind of timed-text track.</p>	
        /// </summary>	
        /// <returns><p>Returns a <strong><see cref="SharpDX.MediaFoundation.TimedTextTrackKind"/></strong>-typed value that specifies the kind of timed-text track.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetTrackKind']/*"/>	
        /// <msdn-id>dn800348</msdn-id>	
        /// <unmanaged>MF_TIMED_TEXT_TRACK_KIND IMFTimedTextTrack::GetTrackKind()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextTrack::GetTrackKind</unmanaged-short>	
        internal SharpDX.MediaFoundation.TimedTextTrackKind GetTrackKind()
        {
            unsafe
            {
                SharpDX.MediaFoundation.TimedTextTrackKind __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMediaFoundationTimedTextTrackKind(_nativePointer, ((void**)(*(void**)_nativePointer))[7]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the timed-text track is inband.</p>	
        /// </summary>	
        /// <returns><p>Returns whether the timed-text track is inband. If <strong>TRUE</strong>, the timed-text track is inband; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>. </p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::IsInBand']/*"/>	
        /// <msdn-id>dn800350</msdn-id>	
        /// <unmanaged>BOOL IMFTimedTextTrack::IsInBand()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextTrack::IsInBand</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsInBand_()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[8]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the in-band metadata of the track.</p>	
        /// </summary>	
        /// <param name="dispatchType"><dd>  <p>A reference to a variable that receives the null-terminated wide-character string that contains the in-band metadata of the track.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetInBandMetadataTrackDispatchType']/*"/>	
        /// <msdn-id>dn800345</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextTrack::GetInBandMetadataTrackDispatchType([Out] wchar_t** dispatchType)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextTrack::GetInBandMetadataTrackDispatchType</unmanaged-short>	
        public void GetInBandMetadataTrackDispatchType(System.IntPtr dispatchType)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)dispatchType, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the timed-text track is active.</p>	
        /// </summary>	
        /// <returns><p>Returns whether the timed-text track is active. If <strong>TRUE</strong>, the timed-text track is active; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>. </p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::IsActive']/*"/>	
        /// <msdn-id>dn800349</msdn-id>	
        /// <unmanaged>BOOL IMFTimedTextTrack::IsActive()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextTrack::IsActive</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsActive_()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[10]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a value indicating the error type of the latest error associated with the track.</p>	
        /// </summary>	
        /// <returns><p>A value indicating the error type of the latest error associated with the track.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetErrorCode']/*"/>	
        /// <msdn-id>dn859180</msdn-id>	
        /// <unmanaged>MF_TIMED_TEXT_ERROR_CODE IMFTimedTextTrack::GetErrorCode()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextTrack::GetErrorCode</unmanaged-short>	
        internal SharpDX.MediaFoundation.TimedTextErrorCode GetErrorCode()
        {
            unsafe
            {
                SharpDX.MediaFoundation.TimedTextErrorCode __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMediaFoundationTimedTextErrorCode(_nativePointer, ((void**)(*(void**)_nativePointer))[11]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the extended error code for the latest error associated with the track.</p>	
        /// </summary>	
        /// <returns><p>The extended error code for the latest error associated with the track.</p></returns>	
        /// <remarks>	
        /// <p>If the most recent error was associated with a track, this value will be the same <strong><see cref="SharpDX.Result"/></strong> as returned by the <strong><see cref="SharpDX.MediaFoundation.TimedTextNotify.Error"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetExtendedErrorCode']/*"/>	
        /// <msdn-id>dn859181</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextTrack::GetExtendedErrorCode()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextTrack::GetExtendedErrorCode</unmanaged-short>	
        internal SharpDX.Result GetExtendedErrorCode()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[12]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a <see cref="System.Guid"/> that identifies the track's underlying data format.</p>	
        /// </summary>	
        /// <param name="format"><dd>  <p>A <see cref="System.Guid"/> that identifies the track's underlying data format.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetDataFormat']/*"/>	
        /// <msdn-id>dn859179</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextTrack::GetDataFormat([Out] GUID* format)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextTrack::GetDataFormat</unmanaged-short>	
        internal void GetDataFormat(out System.Guid format)
        {
            unsafe
            {
                format = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* format_ = &format)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, format_, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetReadyState']/*"/>	
        /// <unmanaged>MF_TIMED_TEXT_TRACK_READY_STATE IMFTimedTextTrack::GetReadyState()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextTrack::GetReadyState</unmanaged-short>	
        internal SharpDX.MediaFoundation.TimedTextTrackReadyState GetReadyState()
        {
            unsafe
            {
                SharpDX.MediaFoundation.TimedTextTrackReadyState __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMediaFoundationTimedTextTrackReadyState(_nativePointer, ((void**)(*(void**)_nativePointer))[14]);
                return __result__;
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="cues">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrack::GetCueList']/*"/>	
        /// <unmanaged>HRESULT IMFTimedTextTrack::GetCueList([Out] IMFTimedTextCueList** cues)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextTrack::GetCueList</unmanaged-short>	
        internal void GetCueList(out SharpDX.MediaFoundation.TimedTextCueList cues)
        {
            unsafe
            {
                IntPtr cues_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &cues_, ((void**)(*(void**)_nativePointer))[15]);
                cues = (cues_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextCueList(cues_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Represents a list of timed-text tracks.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrackList']/*"/>	
    /// <msdn-id>dn800340</msdn-id>	
    /// <unmanaged>IMFTimedTextTrackList</unmanaged>	
    /// <unmanaged-short>IMFTimedTextTrackList</unmanaged-short>	
    [Guid("23ff334c-442c-445f-bccc-edc438aa11e2")]
    public partial class TimedTextTrackList : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TimedTextTrackList"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TimedTextTrackList(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TimedTextTrackList"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TimedTextTrackList(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TimedTextTrackList(nativePointer);
        }


        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the length, in tracks, of the timed-text-track list.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrackList::GetLength']/*"/>	
        /// <msdn-id>dn800341</msdn-id>	
        /// <unmanaged>GetLength</unmanaged>	
        /// <unmanaged-short>GetLength</unmanaged-short>	
        /// <unmanaged>unsigned int IMFTimedTextTrackList::GetLength()</unmanaged>
        public int Length
        {
            get { return GetLength(); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the length, in tracks, of the timed-text-track list.</p>	
        /// </summary>	
        /// <returns><p>Returns the length, in tracks, of the timed-text-track list.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrackList::GetLength']/*"/>	
        /// <msdn-id>dn800341</msdn-id>	
        /// <unmanaged>unsigned int IMFTimedTextTrackList::GetLength()</unmanaged>	
        /// <unmanaged-short>IMFTimedTextTrackList::GetLength</unmanaged-short>	
        internal int GetLength()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a text track in the list from the index of the track.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the track in the list to retrieve. </p> </dd></param>	
        /// <param name="track"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref="SharpDX.MediaFoundation.TimedTextTrack"/></strong> interface for the timed-text track.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrackList::GetTrack']/*"/>	
        /// <msdn-id>dn800342</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextTrackList::GetTrack([In] unsigned int index,[Out] IMFTimedTextTrack** track)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextTrackList::GetTrack</unmanaged-short>	
        public void GetTrack(int index, out SharpDX.MediaFoundation.TimedTextTrack track)
        {
            unsafe
            {
                IntPtr track_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, index, &track_, ((void**)(*(void**)_nativePointer))[4]);
                track = (track_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextTrack(track_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a text track in the list from the identifier of the track.</p>	
        /// </summary>	
        /// <param name="trackId"><dd>  <p>The identifier of the track in the list to retrieve. </p> </dd></param>	
        /// <param name="track"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref="SharpDX.MediaFoundation.TimedTextTrack"/></strong> interface for the timed-text track.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimedTextTrackList::GetTrackById']/*"/>	
        /// <msdn-id>dn800343</msdn-id>	
        /// <unmanaged>HRESULT IMFTimedTextTrackList::GetTrackById([In] unsigned int trackId,[Out] IMFTimedTextTrack** track)</unmanaged>	
        /// <unmanaged-short>IMFTimedTextTrackList::GetTrackById</unmanaged-short>	
        public void GetTrackById(int trackId, out SharpDX.MediaFoundation.TimedTextTrack track)
        {
            unsafe
            {
                IntPtr track_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, trackId, &track_, ((void**)(*(void**)_nativePointer))[5]);
                track = (track_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TimedTextTrack(track_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides a timer that invokes a callback at a specified time.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The presentation clock exposes this interface. To get a reference to the interface, call <strong>QueryInterface</strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimer']/*"/>	
    /// <msdn-id>ms694825</msdn-id>	
    /// <unmanaged>IMFTimer</unmanaged>	
    /// <unmanaged-short>IMFTimer</unmanaged-short>	
    [Guid("e56e4cbd-8f70-49d8-a0f8-edb3d6ab9bf2")]
    public partial class Timer : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.Timer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Timer(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.Timer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.Timer(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.Timer(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Sets a timer that invokes a callback at the specified time.</p>	
        /// </summary>	
        /// <param name="dwFlags"><dd> <p>Bitwise OR of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.TimerFlags"/></strong> enumeration.</p> </dd></param>	
        /// <param name="llClockTime"><dd> <p>The time at which the timer should fire, in units of the clock's frequency. The time is either absolute or relative to the current time, depending on the value of <em>dwFlags</em>.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. The callback's <strong>Invoke</strong> method is called at the time specified in the <em>llClockTime</em> parameter.</p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <param name="unkKeyOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a cancellation object. The caller must release the interface. To cancel the timer, pass this reference to the <strong><see cref="SharpDX.MediaFoundation.Timer.CancelTimer"/></strong> method. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The clock was shut down.</p> </td></tr> <tr><td> <dl> <dt><strong>MF_S_CLOCK_STOPPED</strong></dt> </dl> </td><td> <p>The method succeeded, but the clock is stopped.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the clock is stopped, the method returns MF_S_CLOCK_STOPPED. The callback will not be invoked until the clock is started.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimer::SetTimer']/*"/>	
        /// <msdn-id>ms696252</msdn-id>	
        /// <unmanaged>HRESULT IMFTimer::SetTimer([In] unsigned int dwFlags,[In] longlong llClockTime,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState,[In] IUnknown** ppunkKey)</unmanaged>	
        /// <unmanaged-short>IMFTimer::SetTimer</unmanaged-short>	
        internal void SetTimer_(int dwFlags, long llClockTime, System.IntPtr callbackRef, SharpDX.ComObject unkStateRef, out SharpDX.ComObject unkKeyOut)
        {
            unsafe
            {
                IntPtr unkKeyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwFlags, llClockTime, (void*)callbackRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), &unkKeyOut_, ((void**)(*(void**)_nativePointer))[3]);
                unkKeyOut = (unkKeyOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(unkKeyOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Cancels a timer that was set using the <strong><see cref="SharpDX.MediaFoundation.Timer.SetTimer_"/></strong> method.</p>	
        /// </summary>	
        /// <param name="unkKeyRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Because the timer is dispatched asynchronously, the application's timer callback might get invoked even if this method succeeds.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTimer::CancelTimer']/*"/>	
        /// <msdn-id>ms696276</msdn-id>	
        /// <unmanaged>HRESULT IMFTimer::CancelTimer([In] IUnknown* punkKey)</unmanaged>	
        /// <unmanaged-short>IMFTimer::CancelTimer</unmanaged-short>	
        public void CancelTimer(SharpDX.ComObject unkKeyRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((unkKeyRef == null) ? IntPtr.Zero : unkKeyRef.NativePointer), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Creates a fully loaded topology from the input partial topology. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p> This method creates any intermediate transforms that are needed to complete the topology. It also sets the input and output media types on all of the objects in the topology. If the method succeeds, the full topology is returned in the <em>ppOutputTopo</em> parameter. </p><p> You can use the <em>pCurrentTopo</em> parameter to provide a full topology that was previously loaded. If this topology contains objects that are needed in the new topology, the topology loader can re-use them without creating them again. This caching can potentially make the process faster. The objects from <em>pCurrentTopo</em> will not be reconfigured, so you can specify a topology that is actively streaming data. For example, while a topology is still running, you can pre-load the next topology. </p><p> Before calling this method, you must ensure that the output nodes in the partial topology have valid <strong><see cref="SharpDX.MediaFoundation.StreamSink"/></strong> references, not <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> references. The Media Session automatically performs this action inside the <strong><see cref="SharpDX.MediaFoundation.MediaSession.SetTopology"/></strong> method. However, if you call <strong>Load</strong> before calling <strong>SetTopology</strong>, you must bind the output nodes manually. For more information, see Binding Output Nodes to Media Sinks. </p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopoLoader']/*"/>	
    /// <msdn-id>ms693561</msdn-id>	
    /// <unmanaged>IMFTopoLoader</unmanaged>	
    /// <unmanaged-short>IMFTopoLoader</unmanaged-short>	
    [Guid("DE9A6157-F660-4643-B56A-DF9F7998C7CD")]
    public partial class TopoLoader : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TopoLoader"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TopoLoader(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TopoLoader"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TopoLoader(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TopoLoader(nativePointer);
        }


        /// <summary>	
        /// <p> Creates a fully loaded topology from the input partial topology. </p>	
        /// </summary>	
        /// <param name="inputTopoRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.Topology"/></strong> interface of the partial topology to be resolved.</p> </dd></param>	
        /// <param name="outputTopoOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Topology"/></strong> interface of the completed topology. The caller must release the interface.</p> </dd></param>	
        /// <param name="currentTopoRef"><dd> <p> A reference to the <strong><see cref="SharpDX.MediaFoundation.Topology"/></strong> interface of the previous full topology. The topology loader can re-use objects from this topology in the new topology. This parameter can be <strong><c>null</c></strong>. See Remarks. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TopoSinkActivatesUnsupported"/></strong></dt> </dl> </td><td> <p>One or more output nodes contain <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> references. The caller must bind the output nodes to media sinks. See  Binding Output Nodes to Media Sinks.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> This method creates any intermediate transforms that are needed to complete the topology. It also sets the input and output media types on all of the objects in the topology. If the method succeeds, the full topology is returned in the <em>ppOutputTopo</em> parameter. </p><p> You can use the <em>pCurrentTopo</em> parameter to provide a full topology that was previously loaded. If this topology contains objects that are needed in the new topology, the topology loader can re-use them without creating them again. This caching can potentially make the process faster. The objects from <em>pCurrentTopo</em> will not be reconfigured, so you can specify a topology that is actively streaming data. For example, while a topology is still running, you can pre-load the next topology. </p><p> Before calling this method, you must ensure that the output nodes in the partial topology have valid <strong><see cref="SharpDX.MediaFoundation.StreamSink"/></strong> references, not <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> references. The Media Session automatically performs this action inside the <strong><see cref="SharpDX.MediaFoundation.MediaSession.SetTopology"/></strong> method. However, if you call <strong>Load</strong> before calling <strong>SetTopology</strong>, you must bind the output nodes manually. For more information, see Binding Output Nodes to Media Sinks. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopoLoader::Load']/*"/>	
        /// <msdn-id>ms693561</msdn-id>	
        /// <unmanaged>HRESULT IMFTopoLoader::Load([In] IMFTopology* pInputTopo,[Out] IMFTopology** ppOutputTopo,[In] IMFTopology* pCurrentTopo)</unmanaged>	
        /// <unmanaged-short>IMFTopoLoader::Load</unmanaged-short>	
        public void Load(SharpDX.MediaFoundation.Topology inputTopoRef, out SharpDX.MediaFoundation.Topology outputTopoOut, SharpDX.MediaFoundation.Topology currentTopoRef)
        {
            unsafe
            {
                IntPtr outputTopoOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((inputTopoRef == null) ? IntPtr.Zero : inputTopoRef.NativePointer), &outputTopoOut_, (void*)((currentTopoRef == null) ? IntPtr.Zero : currentTopoRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                outputTopoOut = (outputTopoOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Topology(outputTopoOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a topology. A <em>topology</em> describes a collection of media sources, sinks, and transforms that are connected in a certain order. These objects are represented within the topology by <em>topology nodes</em>, which expose the <strong><see cref="SharpDX.MediaFoundation.TopologyNode"/></strong> interface. A topology describes the path of multimedia data through these nodes.</p><p>To create a topology, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateTopology"/></strong>.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopology']/*"/>	
    /// <msdn-id>ms705488</msdn-id>	
    /// <unmanaged>IMFTopology</unmanaged>	
    /// <unmanaged-short>IMFTopology</unmanaged-short>	
    [Guid("83CF873A-F6DA-4bc8-823F-BACFD55DC433")]
    public partial class Topology : SharpDX.MediaFoundation.MediaAttributes
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.Topology"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Topology(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.Topology"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.Topology(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.Topology(nativePointer);
        }


        /// <summary>	
        /// <p> Gets the identifier of the topology.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopology::GetTopologyID']/*"/>	
        /// <msdn-id>ms705620</msdn-id>	
        /// <unmanaged>GetTopologyID</unmanaged>	
        /// <unmanaged-short>GetTopologyID</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTopology::GetTopologyID([Out] unsigned longlong* pID)</unmanaged>
        public long TopologyID
        {
            get { long __output__; GetTopologyID(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Gets the number of nodes in the topology. </p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopology::GetNodeCount']/*"/>	
        /// <msdn-id>ms700175</msdn-id>	
        /// <unmanaged>GetNodeCount</unmanaged>	
        /// <unmanaged-short>GetNodeCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTopology::GetNodeCount([Out] unsigned short* pwNodes)</unmanaged>
        public short NodeCount
        {
            get { short __output__; GetNodeCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Gets the source nodes in the topology. </p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopology::GetSourceNodeCollection']/*"/>	
        /// <msdn-id>ms701611</msdn-id>	
        /// <unmanaged>GetSourceNodeCollection</unmanaged>	
        /// <unmanaged-short>GetSourceNodeCollection</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTopology::GetSourceNodeCollection([Out] IMFCollection** ppCollection)</unmanaged>
        public SharpDX.MediaFoundation.Collection SourceNodeCollection
        {
            get { SharpDX.MediaFoundation.Collection __output__; GetSourceNodeCollection(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Gets the output nodes in the topology. </p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopology::GetOutputNodeCollection']/*"/>	
        /// <msdn-id>ms694029</msdn-id>	
        /// <unmanaged>GetOutputNodeCollection</unmanaged>	
        /// <unmanaged-short>GetOutputNodeCollection</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTopology::GetOutputNodeCollection([Out] IMFCollection** ppCollection)</unmanaged>
        public SharpDX.MediaFoundation.Collection OutputNodeCollection
        {
            get { SharpDX.MediaFoundation.Collection __output__; GetOutputNodeCollection(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Gets the identifier of the topology.</p>	
        /// </summary>	
        /// <param name="iDRef"><dd> <p> Receives the identifier, as a <strong>TOPOID</strong> value. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopology::GetTopologyID']/*"/>	
        /// <msdn-id>ms705620</msdn-id>	
        /// <unmanaged>HRESULT IMFTopology::GetTopologyID([Out] unsigned longlong* pID)</unmanaged>	
        /// <unmanaged-short>IMFTopology::GetTopologyID</unmanaged-short>	
        internal void GetTopologyID(out long iDRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* iDRef_ = &iDRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, iDRef_, ((void**)(*(void**)_nativePointer))[33]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Adds a node to the topology.</p>	
        /// </summary>	
        /// <param name="nodeRef"><dd> <p>Pointer to the node's <strong><see cref="SharpDX.MediaFoundation.TopologyNode"/></strong> interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pNode</em> is invalid, possibly because the node already exists in the topology.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopology::AddNode']/*"/>	
        /// <msdn-id>ms697365</msdn-id>	
        /// <unmanaged>HRESULT IMFTopology::AddNode([In] IMFTopologyNode* pNode)</unmanaged>	
        /// <unmanaged-short>IMFTopology::AddNode</unmanaged-short>	
        public void AddNode(SharpDX.MediaFoundation.TopologyNode nodeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((nodeRef == null) ? IntPtr.Zero : nodeRef.NativePointer), ((void**)(*(void**)_nativePointer))[34]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Removes a node from the topology.</p>	
        /// </summary>	
        /// <param name="nodeRef"><dd> <p>Pointer to the node's <strong><see cref="SharpDX.MediaFoundation.TopologyNode"/></strong> interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The specified node is not a member of this topology.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method does not destroy the node, so the <strong><see cref="SharpDX.MediaFoundation.TopologyNode"/></strong> reference is still valid after the method returns.</p><p>The method breaks any connections between the specified node and other nodes.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopology::RemoveNode']/*"/>	
        /// <msdn-id>ms694226</msdn-id>	
        /// <unmanaged>HRESULT IMFTopology::RemoveNode([In] IMFTopologyNode* pNode)</unmanaged>	
        /// <unmanaged-short>IMFTopology::RemoveNode</unmanaged-short>	
        public void RemoveNode(SharpDX.MediaFoundation.TopologyNode nodeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((nodeRef == null) ? IntPtr.Zero : nodeRef.NativePointer), ((void**)(*(void**)_nativePointer))[35]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the number of nodes in the topology. </p>	
        /// </summary>	
        /// <param name="wNodesRef"><dd> <p> Receives the number of nodes. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopology::GetNodeCount']/*"/>	
        /// <msdn-id>ms700175</msdn-id>	
        /// <unmanaged>HRESULT IMFTopology::GetNodeCount([Out] unsigned short* pwNodes)</unmanaged>	
        /// <unmanaged-short>IMFTopology::GetNodeCount</unmanaged-short>	
        internal void GetNodeCount(out short wNodesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* wNodesRef_ = &wNodesRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, wNodesRef_, ((void**)(*(void**)_nativePointer))[36]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets a node in the topology, specified by index. </p>	
        /// </summary>	
        /// <param name="wIndex"><dd> <p> The zero-based index of the node. To get the number of nodes in the topology, call <strong><see cref="SharpDX.MediaFoundation.Topology.GetNodeCount"/></strong>. </p> </dd></param>	
        /// <param name="nodeOut"><dd> <p> Receives a reference to the node's <strong><see cref="SharpDX.MediaFoundation.TopologyNode"/></strong> interface. The caller must release the reference. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> The index is less than zero. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidIndex"/></strong></dt> </dl> </td><td> <p> No node can be found at the index <em>wIndex</em>. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopology::GetNode']/*"/>	
        /// <msdn-id>ms701569</msdn-id>	
        /// <unmanaged>HRESULT IMFTopology::GetNode([In] unsigned short wIndex,[Out] IMFTopologyNode** ppNode)</unmanaged>	
        /// <unmanaged-short>IMFTopology::GetNode</unmanaged-short>	
        public void GetNode(short wIndex, out SharpDX.MediaFoundation.TopologyNode nodeOut)
        {
            unsafe
            {
                IntPtr nodeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, wIndex, &nodeOut_, ((void**)(*(void**)_nativePointer))[37]);
                nodeOut = (nodeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TopologyNode(nodeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Removes all nodes from the topology.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You do not need to clear a topology before disposing of it. The <strong>Clear</strong> method is called automatically when the topology is destroyed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopology::Clear']/*"/>	
        /// <msdn-id>ms700800</msdn-id>	
        /// <unmanaged>HRESULT IMFTopology::Clear()</unmanaged>	
        /// <unmanaged-short>IMFTopology::Clear</unmanaged-short>	
        public void Clear()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[38]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Converts this topology into a copy of another topology. </p>	
        /// </summary>	
        /// <param name="topologyRef"><dd> <p> A reference to the <strong><see cref="SharpDX.MediaFoundation.Topology"/></strong> interface of the topology to clone. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method does the following:</p><ul> <li> Removes all of the nodes from this topology. </li> <li> Clones the nodes from <em>pTopology</em> and adds them to this topology. The cloned nodes have the same node identifiers as the nodes from <em>pTopology</em>. </li> <li> Connects the cloned nodes to match the connections in <em>pTopology</em>. </li> <li> Copies the attributes from <em>pTopology</em> to this topology. </li> <li> Copies the topology identifier from <em>pTopology</em> to this topology.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopology::CloneFrom']/*"/>	
        /// <msdn-id>ms702242</msdn-id>	
        /// <unmanaged>HRESULT IMFTopology::CloneFrom([In, Optional] IMFTopology* pTopology)</unmanaged>	
        /// <unmanaged-short>IMFTopology::CloneFrom</unmanaged-short>	
        public void CloneFrom(SharpDX.MediaFoundation.Topology topologyRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((topologyRef == null) ? IntPtr.Zero : topologyRef.NativePointer), ((void**)(*(void**)_nativePointer))[39]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a node in the topology, specified by node identifier.</p>	
        /// </summary>	
        /// <param name="qwTopoNodeID"><dd> <p> The identifier of the node to retrieve. To get a node's identifier, call <strong><see cref="SharpDX.MediaFoundation.TopologyNode.GetTopoNodeID"/></strong>. </p> </dd></param>	
        /// <param name="nodeOut"><dd> <p> Receives a reference to the node's <strong><see cref="SharpDX.MediaFoundation.TopologyNode"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotFound"/></strong></dt> </dl> </td><td> <p> The topology does not contain a node with this identifier. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopology::GetNodeByID']/*"/>	
        /// <msdn-id>ms696224</msdn-id>	
        /// <unmanaged>HRESULT IMFTopology::GetNodeByID([In] unsigned longlong qwTopoNodeID,[Out] IMFTopologyNode** ppNode)</unmanaged>	
        /// <unmanaged-short>IMFTopology::GetNodeByID</unmanaged-short>	
        public void GetNodeByID(long qwTopoNodeID, out SharpDX.MediaFoundation.TopologyNode nodeOut)
        {
            unsafe
            {
                IntPtr nodeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, qwTopoNodeID, &nodeOut_, ((void**)(*(void**)_nativePointer))[40]);
                nodeOut = (nodeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TopologyNode(nodeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the source nodes in the topology. </p>	
        /// </summary>	
        /// <param name="collectionOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Collection"/></strong> interface. The caller must release the reference. The collection contains <strong><see cref="SharpDX.ComObject"/></strong> references to all of the source nodes in the topology. Each reference can be queried for the <strong><see cref="SharpDX.MediaFoundation.TopologyNode"/></strong> interface. The collection might be empty.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopology::GetSourceNodeCollection']/*"/>	
        /// <msdn-id>ms701611</msdn-id>	
        /// <unmanaged>HRESULT IMFTopology::GetSourceNodeCollection([Out] IMFCollection** ppCollection)</unmanaged>	
        /// <unmanaged-short>IMFTopology::GetSourceNodeCollection</unmanaged-short>	
        internal void GetSourceNodeCollection(out SharpDX.MediaFoundation.Collection collectionOut)
        {
            unsafe
            {
                IntPtr collectionOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &collectionOut_, ((void**)(*(void**)_nativePointer))[41]);
                collectionOut = (collectionOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Collection(collectionOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the output nodes in the topology. </p>	
        /// </summary>	
        /// <param name="collectionOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Collection"/></strong> interface. The caller must release the reference. The collection contains <strong><see cref="SharpDX.ComObject"/></strong> references to all of the output nodes in the topology. Each reference can be queried for the <strong><see cref="SharpDX.MediaFoundation.TopologyNode"/></strong> interface. The collection might be empty. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopology::GetOutputNodeCollection']/*"/>	
        /// <msdn-id>ms694029</msdn-id>	
        /// <unmanaged>HRESULT IMFTopology::GetOutputNodeCollection([Out] IMFCollection** ppCollection)</unmanaged>	
        /// <unmanaged-short>IMFTopology::GetOutputNodeCollection</unmanaged-short>	
        internal void GetOutputNodeCollection(out SharpDX.MediaFoundation.Collection collectionOut)
        {
            unsafe
            {
                IntPtr collectionOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &collectionOut_, ((void**)(*(void**)_nativePointer))[42]);
                collectionOut = (collectionOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Collection(collectionOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a node in a topology. The following node types are supported:</p><ul> <li> Output node. Represents a media sink. </li> <li> Source node. Represents a media stream. </li> <li> Transform node. Represents a Media Foundation Transform (MFT). </li> <li> Tee node. Delivers a media stream to two or more nodes. </li> </ul><p>To create a new node, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateTopologyNode"/></strong> function.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode']/*"/>	
    /// <msdn-id>ms693529</msdn-id>	
    /// <unmanaged>IMFTopologyNode</unmanaged>	
    /// <unmanaged-short>IMFTopologyNode</unmanaged-short>	
    [Guid("83CF873A-F6DA-4bc8-823F-BACFD55DC430")]
    public partial class TopologyNode : SharpDX.MediaFoundation.MediaAttributes
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TopologyNode"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TopologyNode(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TopologyNode"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TopologyNode(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TopologyNode(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Sets the object associated with this node.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>All node types support this method, but the object reference is not used by every node type.</p><table> <tr><th>Node type</th><th>Object reference</th></tr> <tr><td>Source node.</td><td>Not used.</td></tr> <tr><td>Transform node.</td><td> <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> or <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface.</td></tr> <tr><td>Output node</td><td> <strong><see cref="SharpDX.MediaFoundation.StreamSink"/></strong> or <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface.</td></tr> <tr><td>Tee node.</td><td>Not used.</td></tr> </table><p>?</p><p>If the object supports <strong><see cref="SharpDX.ComPersistBase"/></strong>, <strong>IPersistStorage</strong>, or <strong>IPersistPropertyBag</strong>, the method gets the object's CLSID and sets the <strong><see cref="SharpDX.MediaFoundation.TopologyNodeAttributeKeys.TransformObjectid"/></strong> attribute on the node.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::SetObject']/*"/>	
        /// <msdn-id>ms702992</msdn-id>	
        /// <unmanaged>SetObject</unmanaged>	
        /// <unmanaged-short>SetObject</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTopologyNode::SetObject([In, Optional] IUnknown* pObject)</unmanaged>
        public SharpDX.ComObject Object
        {
            set { SetObject(value); }
        }

        /// <summary>	
        /// <p> Gets the object associated with this node. </p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::GetObjectW']/*"/>	
        /// <msdn-id>ms693569</msdn-id>	
        /// <unmanaged>GetObjectW</unmanaged>	
        /// <unmanaged-short>GetObjectW</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTopologyNode::GetObjectW([Out] IUnknown** ppObject)</unmanaged>
        public SharpDX.ComObject ObjectW
        {
            get { SharpDX.ComObject __output__; GetObjectW(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the node type.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::GetNodeType']/*"/>	
        /// <msdn-id>ms697514</msdn-id>	
        /// <unmanaged>GetNodeType</unmanaged>	
        /// <unmanaged-short>GetNodeType</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTopologyNode::GetNodeType([Out] MF_TOPOLOGY_TYPE* pType)</unmanaged>
        public SharpDX.MediaFoundation.TopologyType NodeType
        {
            get { SharpDX.MediaFoundation.TopologyType __output__; GetNodeType(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Retrieves or sets the identifier of the node.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> When a node is first created, it is assigned an identifier. Node identifiers are unique within a topology, but can be reused across several topologies. The topology loader uses the identifier to look up nodes in the previous topology, so that it can reuse objects from the previous topology. </p><p> To find a node in a topology by its identifier, call <strong><see cref="SharpDX.MediaFoundation.Topology.GetNodeByID"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::GetTopoNodeID']/*"/>	
        /// <msdn-id>ms701602</msdn-id>	
        /// <unmanaged>GetTopoNodeID / SetTopoNodeID</unmanaged>	
        /// <unmanaged-short>GetTopoNodeID</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTopologyNode::GetTopoNodeID([Out] unsigned longlong* pID)</unmanaged>
        public long TopoNodeID
        {
            get { long __output__; GetTopoNodeID(out __output__); return __output__; }
            set { SetTopoNodeID(value); }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of input streams that currently exist on this node.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The input streams may or may not be connected to output streams on other nodes. To get the node that is connected to a specified input stream, call <strong><see cref="SharpDX.MediaFoundation.TopologyNode.GetInput"/></strong>.</p><p>The <strong><see cref="SharpDX.MediaFoundation.TopologyNode.ConnectOutput"/></strong> and <strong><see cref="SharpDX.MediaFoundation.TopologyNode.SetInputPrefType"/></strong> methods add new input streams as needed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::GetInputCount']/*"/>	
        /// <msdn-id>ms700165</msdn-id>	
        /// <unmanaged>GetInputCount</unmanaged>	
        /// <unmanaged-short>GetInputCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTopologyNode::GetInputCount([Out] unsigned int* pcInputs)</unmanaged>
        public int InputCount
        {
            get { int __output__; GetInputCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of output streams that currently exist on this node.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The output streams may or may not be connected to input streams on other nodes. To get the node that is connected to a specific output stream on this node, call <strong><see cref="SharpDX.MediaFoundation.TopologyNode.GetOutput"/></strong>.</p><p>The <strong><see cref="SharpDX.MediaFoundation.TopologyNode.ConnectOutput"/></strong> and <strong><see cref="SharpDX.MediaFoundation.TopologyNode.SetOutputPrefType"/></strong> methods add new input streams as needed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::GetOutputCount']/*"/>	
        /// <msdn-id>ms704019</msdn-id>	
        /// <unmanaged>GetOutputCount</unmanaged>	
        /// <unmanaged-short>GetOutputCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTopologyNode::GetOutputCount([Out] unsigned int* pcOutputs)</unmanaged>
        public int OutputCount
        {
            get { int __output__; GetOutputCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Sets the object associated with this node.</p>	
        /// </summary>	
        /// <param name="objectRef"><dd> <p>A reference to the object's <strong><see cref="SharpDX.ComObject"/></strong> interface. Use the value <strong><c>null</c></strong> to clear an object that was previous set.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>All node types support this method, but the object reference is not used by every node type.</p><table> <tr><th>Node type</th><th>Object reference</th></tr> <tr><td>Source node.</td><td>Not used.</td></tr> <tr><td>Transform node.</td><td> <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> or <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface.</td></tr> <tr><td>Output node</td><td> <strong><see cref="SharpDX.MediaFoundation.StreamSink"/></strong> or <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface.</td></tr> <tr><td>Tee node.</td><td>Not used.</td></tr> </table><p>?</p><p>If the object supports <strong><see cref="SharpDX.ComPersistBase"/></strong>, <strong>IPersistStorage</strong>, or <strong>IPersistPropertyBag</strong>, the method gets the object's CLSID and sets the <strong><see cref="SharpDX.MediaFoundation.TopologyNodeAttributeKeys.TransformObjectid"/></strong> attribute on the node.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::SetObject']/*"/>	
        /// <msdn-id>ms702992</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNode::SetObject([In, Optional] IUnknown* pObject)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNode::SetObject</unmanaged-short>	
        internal void SetObject(SharpDX.ComObject objectRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((objectRef == null) ? IntPtr.Zero : objectRef.NativePointer), ((void**)(*(void**)_nativePointer))[33]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the object associated with this node. </p>	
        /// </summary>	
        /// <param name="objectOut"><dd> <p> Receives a reference to the object's <strong><see cref="SharpDX.ComObject"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p> There is no object associated with this node. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::GetObjectW']/*"/>	
        /// <msdn-id>ms693569</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNode::GetObjectW([Out] IUnknown** ppObject)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNode::GetObjectW</unmanaged-short>	
        internal void GetObjectW(out SharpDX.ComObject objectOut)
        {
            unsafe
            {
                IntPtr objectOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &objectOut_, ((void**)(*(void**)_nativePointer))[34]);
                objectOut = (objectOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(objectOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the node type.</p>	
        /// </summary>	
        /// <param name="typeRef"><dd> <p>Receives the node type, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.TopologyType"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::GetNodeType']/*"/>	
        /// <msdn-id>ms697514</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNode::GetNodeType([Out] MF_TOPOLOGY_TYPE* pType)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNode::GetNodeType</unmanaged-short>	
        internal void GetNodeType(out SharpDX.MediaFoundation.TopologyType typeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* typeRef_ = &typeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, typeRef_, ((void**)(*(void**)_nativePointer))[35]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Retrieves the identifier of the node.</p>	
        /// </summary>	
        /// <param name="iDRef"><dd> <p>Receives the identifier.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> When a node is first created, it is assigned an identifier. Node identifiers are unique within a topology, but can be reused across several topologies. The topology loader uses the identifier to look up nodes in the previous topology, so that it can reuse objects from the previous topology. </p><p> To find a node in a topology by its identifier, call <strong><see cref="SharpDX.MediaFoundation.Topology.GetNodeByID"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::GetTopoNodeID']/*"/>	
        /// <msdn-id>ms701602</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNode::GetTopoNodeID([Out] unsigned longlong* pID)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNode::GetTopoNodeID</unmanaged-short>	
        internal void GetTopoNodeID(out long iDRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* iDRef_ = &iDRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, iDRef_, ((void**)(*(void**)_nativePointer))[36]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the identifier for the node.</p>	
        /// </summary>	
        /// <param name="ullTopoID"><dd> <p> The identifier for the node. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> The <strong>TOPOID</strong> has already been set for this object. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> When a node is first created, it is assigned an identifier. Typically there is no reason for an application to override the identifier. Within a topology, each node identifier should be unique. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::SetTopoNodeID']/*"/>	
        /// <msdn-id>bb970438</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNode::SetTopoNodeID([In] unsigned longlong ullTopoID)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNode::SetTopoNodeID</unmanaged-short>	
        internal void SetTopoNodeID(long ullTopoID)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ullTopoID, ((void**)(*(void**)_nativePointer))[37]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of input streams that currently exist on this node.</p>	
        /// </summary>	
        /// <param name="cInputsRef"><dd> <p>Receives the number of input streams.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The input streams may or may not be connected to output streams on other nodes. To get the node that is connected to a specified input stream, call <strong><see cref="SharpDX.MediaFoundation.TopologyNode.GetInput"/></strong>.</p><p>The <strong><see cref="SharpDX.MediaFoundation.TopologyNode.ConnectOutput"/></strong> and <strong><see cref="SharpDX.MediaFoundation.TopologyNode.SetInputPrefType"/></strong> methods add new input streams as needed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::GetInputCount']/*"/>	
        /// <msdn-id>ms700165</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNode::GetInputCount([Out] unsigned int* pcInputs)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNode::GetInputCount</unmanaged-short>	
        internal void GetInputCount(out int cInputsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cInputsRef_ = &cInputsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cInputsRef_, ((void**)(*(void**)_nativePointer))[38]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the number of output streams that currently exist on this node.</p>	
        /// </summary>	
        /// <param name="cOutputsRef"><dd> <p>Receives the number of output streams.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The output streams may or may not be connected to input streams on other nodes. To get the node that is connected to a specific output stream on this node, call <strong><see cref="SharpDX.MediaFoundation.TopologyNode.GetOutput"/></strong>.</p><p>The <strong><see cref="SharpDX.MediaFoundation.TopologyNode.ConnectOutput"/></strong> and <strong><see cref="SharpDX.MediaFoundation.TopologyNode.SetOutputPrefType"/></strong> methods add new input streams as needed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::GetOutputCount']/*"/>	
        /// <msdn-id>ms704019</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNode::GetOutputCount([Out] unsigned int* pcOutputs)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNode::GetOutputCount</unmanaged-short>	
        internal void GetOutputCount(out int cOutputsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cOutputsRef_ = &cOutputsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cOutputsRef_, ((void**)(*(void**)_nativePointer))[39]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Connects an output stream from this node to the input stream of another node.</p>	
        /// </summary>	
        /// <param name="dwOutputIndex"><dd> <p>Zero-based index of the output stream on this node.</p> </dd></param>	
        /// <param name="downstreamNodeRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.TopologyNode"/></strong> interface of the node to connect to.</p> </dd></param>	
        /// <param name="dwInputIndexOnDownstreamNode"><dd> <p>Zero-based index of the input stream on the other node.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p>The method failed.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid parameter.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Node connections represent data flow from one node to the next. The streams are logical, and are specified by index.</p><p>If the node is already connected at the specified output, the method breaks the existing connection. If <em>dwOutputIndex</em> or <em>dwInputIndexOnDownstreamNode</em> specify streams that do not exist yet, the method adds as many streams as needed.</p><p>This method checks for certain invalid conditions:</p><ul> <li> <p>An output node cannot have any output connections. If you call this method on an output node, the method returns E_FAIL.</p> </li> <li> <p>A node cannot be connected to itself. If <em>pDownstreamNode</em> specifies the same node as the method call, the method returns E_INVALIDARG.</p> </li> </ul><p>However, if the method succeeds, it does not guarantee that the node connection is valid. It is possible to create a partial topology that the topology loader cannot resolve. If so, the <strong><see cref="SharpDX.MediaFoundation.TopoLoader.Load"/></strong> method will fail.</p><p>To break an existing node connection, call <strong><see cref="SharpDX.MediaFoundation.TopologyNode.DisconnectOutput"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::ConnectOutput']/*"/>	
        /// <msdn-id>ms695284</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNode::ConnectOutput([In] unsigned int dwOutputIndex,[In] IMFTopologyNode* pDownstreamNode,[In] unsigned int dwInputIndexOnDownstreamNode)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNode::ConnectOutput</unmanaged-short>	
        public void ConnectOutput(int dwOutputIndex, SharpDX.MediaFoundation.TopologyNode downstreamNodeRef, int dwInputIndexOnDownstreamNode)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputIndex, (void*)((downstreamNodeRef == null) ? IntPtr.Zero : downstreamNodeRef.NativePointer), dwInputIndexOnDownstreamNode, ((void**)(*(void**)_nativePointer))[40]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Disconnects an output stream on this node.</p>	
        /// </summary>	
        /// <param name="dwOutputIndex"><dd> <p>Zero-based index of the output stream to disconnect.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The <em>dwOutputIndex</em> parameter is out of range.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotFound"/></strong></dt> </dl> </td><td> <p>The specified output stream is not connected to another node.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the specified output stream is connected to another node, this method breaks the connection.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::DisconnectOutput']/*"/>	
        /// <msdn-id>ms698991</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNode::DisconnectOutput([In] unsigned int dwOutputIndex)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNode::DisconnectOutput</unmanaged-short>	
        public void DisconnectOutput(int dwOutputIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputIndex, ((void**)(*(void**)_nativePointer))[41]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the node that is connected to a specified input stream on this node.</p>	
        /// </summary>	
        /// <param name="dwInputIndex"><dd> <p>Zero-based index of an input stream on this node.</p> </dd></param>	
        /// <param name="upstreamNodeOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.TopologyNode"/></strong> interface of the node that is connected to the specified input stream. The caller must release the interface.</p> </dd></param>	
        /// <param name="dwOutputIndexOnUpstreamNodeRef"><dd> <p>Receives the index of the output stream that is connected to this node's input stream.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The index is out of range.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotFound"/></strong></dt> </dl> </td><td> <p>The specified input stream is not connected to another node.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::GetInput']/*"/>	
        /// <msdn-id>ms697020</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNode::GetInput([In] unsigned int dwInputIndex,[Out] IMFTopologyNode** ppUpstreamNode,[Out] unsigned int* pdwOutputIndexOnUpstreamNode)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNode::GetInput</unmanaged-short>	
        public void GetInput(int dwInputIndex, out SharpDX.MediaFoundation.TopologyNode upstreamNodeOut, out int dwOutputIndexOnUpstreamNodeRef)
        {
            unsafe
            {
                IntPtr upstreamNodeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* dwOutputIndexOnUpstreamNodeRef_ = &dwOutputIndexOnUpstreamNodeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputIndex, &upstreamNodeOut_, dwOutputIndexOnUpstreamNodeRef_, ((void**)(*(void**)_nativePointer))[42]);
                upstreamNodeOut = (upstreamNodeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TopologyNode(upstreamNodeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the node that is connected to a specified output stream on this node.</p>	
        /// </summary>	
        /// <param name="dwOutputIndex"><dd> <p>Zero-based index of an output stream on this node.</p> </dd></param>	
        /// <param name="downstreamNodeOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.TopologyNode"/></strong> interface of the node that is connected to the specified output stream. The caller must release the interface.</p> </dd></param>	
        /// <param name="dwInputIndexOnDownstreamNodeRef"><dd> <p>Receives the index of the input stream that is connected to this node's output stream.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The index is out of range.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotFound"/></strong></dt> </dl> </td><td> <p>The specified input stream is not connected to another node.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::GetOutput']/*"/>	
        /// <msdn-id>bb970327</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNode::GetOutput([In] unsigned int dwOutputIndex,[Out] IMFTopologyNode** ppDownstreamNode,[Out] unsigned int* pdwInputIndexOnDownstreamNode)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNode::GetOutput</unmanaged-short>	
        public void GetOutput(int dwOutputIndex, out SharpDX.MediaFoundation.TopologyNode downstreamNodeOut, out int dwInputIndexOnDownstreamNodeRef)
        {
            unsafe
            {
                IntPtr downstreamNodeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* dwInputIndexOnDownstreamNodeRef_ = &dwInputIndexOnDownstreamNodeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputIndex, &downstreamNodeOut_, dwInputIndexOnDownstreamNodeRef_, ((void**)(*(void**)_nativePointer))[43]);
                downstreamNodeOut = (downstreamNodeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.TopologyNode(downstreamNodeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the preferred media type for an output stream on this node.</p>	
        /// </summary>	
        /// <param name="dwOutputIndex"><dd> <p>Zero-based index of the output stream.</p> </dd></param>	
        /// <param name="typeRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>This node is an output node.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The preferred type is a hint for the topology loader.</p><p>Do not call this method after loading a topology or setting a topology on the Media Session. Changing the preferred type on a running topology can cause connection errors.</p><p>If no output stream exists at the specified index, the method creates new streams up to and including the specified index number.</p><p>Output nodes cannot have outputs. If this method is called on an output node, it returns E_NOTIMPL</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::SetOutputPrefType']/*"/>	
        /// <msdn-id>ms701546</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNode::SetOutputPrefType([In] unsigned int dwOutputIndex,[In] IMFMediaType* pType)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNode::SetOutputPrefType</unmanaged-short>	
        public void SetOutputPrefType(int dwOutputIndex, SharpDX.MediaFoundation.MediaType typeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputIndex, (void*)((typeRef == null) ? IntPtr.Zero : typeRef.NativePointer), ((void**)(*(void**)_nativePointer))[44]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the preferred media type for an output stream on this node.</p>	
        /// </summary>	
        /// <param name="dwOutputIndex"><dd> <p>Zero-based index of the output stream.</p> </dd></param>	
        /// <param name="typeOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p>This node does not have a preferred output type.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid stream index.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>This node is an output node.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Output nodes cannot have outputs. If this method is called on an output node, it returns E_NOTIMPL.</p><p>The preferred output type provides a hint to the topology loader. In a fully resolved topology, there is no guarantee that every topology node will have a preferred output type. To get the actual media type for a node, you must get a reference to the node's underlying object. (For more information, see <strong><see cref="SharpDX.MediaFoundation.TopologyType"/></strong> enumeration.)</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::GetOutputPrefType']/*"/>	
        /// <msdn-id>ms701571</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNode::GetOutputPrefType([In] unsigned int dwOutputIndex,[Out] IMFMediaType** ppType)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNode::GetOutputPrefType</unmanaged-short>	
        public void GetOutputPrefType(int dwOutputIndex, out SharpDX.MediaFoundation.MediaType typeOut)
        {
            unsafe
            {
                IntPtr typeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputIndex, &typeOut_, ((void**)(*(void**)_nativePointer))[45]);
                typeOut = (typeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(typeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the preferred media type for an input stream on this node.</p>	
        /// </summary>	
        /// <param name="dwInputIndex"><dd> <p>Zero-based index of the input stream.</p> </dd></param>	
        /// <param name="typeRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>This node is a source node.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The preferred type is a hint for the topology loader.</p><p>Do not call this method after loading a topology or setting a topology on the Media Session. Changing the preferred type on a running topology can cause connection errors.</p><p>If no input stream exists at the specified index, the method creates new streams up to and including the specified index number.</p><p>Source nodes cannot have inputs. If this method is called on a source node, it returns E_NOTIMPL.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::SetInputPrefType']/*"/>	
        /// <msdn-id>ms696223</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNode::SetInputPrefType([In] unsigned int dwInputIndex,[In] IMFMediaType* pType)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNode::SetInputPrefType</unmanaged-short>	
        public void SetInputPrefType(int dwInputIndex, SharpDX.MediaFoundation.MediaType typeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputIndex, (void*)((typeRef == null) ? IntPtr.Zero : typeRef.NativePointer), ((void**)(*(void**)_nativePointer))[46]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the preferred media type for an input stream on this node.</p>	
        /// </summary>	
        /// <param name="dwInputIndex"><dd> <p>Zero-based index of the input stream.</p> </dd></param>	
        /// <param name="typeOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p>This node does not have a preferred input type.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid stream index.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>This node is a source node.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Source nodes cannot have inputs. If this method is called on a source node, it returns E_NOTIMPL.</p><p>The preferred input type provides a hint to the topology loader. In a fully resolved topology, there is no guarantee that every topology node will have a preferred input type. To get the actual media type for a node, you must get a reference to the node's underlying object. (For more information, see <strong><see cref="SharpDX.MediaFoundation.TopologyType"/></strong> enumeration.)</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::GetInputPrefType']/*"/>	
        /// <msdn-id>ms696221</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNode::GetInputPrefType([In] unsigned int dwInputIndex,[Out] IMFMediaType** ppType)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNode::GetInputPrefType</unmanaged-short>	
        public void GetInputPrefType(int dwInputIndex, out SharpDX.MediaFoundation.MediaType typeOut)
        {
            unsafe
            {
                IntPtr typeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputIndex, &typeOut_, ((void**)(*(void**)_nativePointer))[47]);
                typeOut = (typeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(typeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Copies the data from another topology node into this node.</p>	
        /// </summary>	
        /// <param name="nodeRef"><dd> <p> A reference to the <strong><see cref="SharpDX.MediaFoundation.TopologyNode"/></strong> interface of the node to copy. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p> The node types do not match. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> The two nodes must have the same node type. To get the node type, call <strong><see cref="SharpDX.MediaFoundation.TopologyNode.GetNodeType"/></strong>. </p><p> This method copies the object reference, preferred types, and attributes from <em>pNode</em> to this node. It also copies the <strong>TOPOID</strong> that uniquely identifies each node in a topology. It does not duplicate any of the connections from <em>pNode</em> to other nodes. </p><p> The purpose of this method is to copy nodes from one topology to another. Do not use duplicate nodes within the same topology. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNode::CloneFrom']/*"/>	
        /// <msdn-id>ms700790</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNode::CloneFrom([In, Optional] IMFTopologyNode* pNode)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNode::CloneFrom</unmanaged-short>	
        public void CloneFrom(SharpDX.MediaFoundation.TopologyNode nodeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((nodeRef == null) ? IntPtr.Zero : nodeRef.NativePointer), ((void**)(*(void**)_nativePointer))[48]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Updates the attributes of one or more nodes in the Media Session's current topology.</p><p>The Media Session exposes this interface as a service. To get a reference to the interface, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong>. The service identifier is <see cref="SharpDX.MediaFoundation.MediaServiceKeys.ToplogyNodeAttributeEditor"/>.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Currently the only attribute that can be updated is the <strong><see cref="SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Mediastop"/></strong> attribute.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNodeAttributeEditor']/*"/>	
    /// <msdn-id>aa371345</msdn-id>	
    /// <unmanaged>IMFTopologyNodeAttributeEditor</unmanaged>	
    /// <unmanaged-short>IMFTopologyNodeAttributeEditor</unmanaged-short>	
    [Guid("676aa6dd-238a-410d-bb99-65668d01605a")]
    public partial class TopologyNodeAttributeEditor : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TopologyNodeAttributeEditor"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TopologyNodeAttributeEditor(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TopologyNodeAttributeEditor"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TopologyNodeAttributeEditor(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TopologyNodeAttributeEditor(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Updates the attributes of one or more nodes in the current topology.</p>	
        /// </summary>	
        /// <param name="topoId"><dd> <p>Reserved.</p> </dd></param>	
        /// <param name="cUpdates"><dd> <p>The number of elements in the <em>pUpdates</em> array.</p> </dd></param>	
        /// <param name="updatesRef"><dd> <p>Pointer to an array of <strong><see cref="SharpDX.MediaFoundation.ToponodeAttributeUpdate"/></strong> structures. Each element of the array updates one attribute on a node.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Currently the only attribute that can be updated is the <strong><see cref="SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Mediastop"/></strong> attribute. The method ignores any other attributes.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyNodeAttributeEditor::UpdateNodeAttributes']/*"/>	
        /// <msdn-id>aa371868</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyNodeAttributeEditor::UpdateNodeAttributes([In] unsigned longlong TopoId,[In] unsigned int cUpdates,[In, Buffer] MFTOPONODE_ATTRIBUTE_UPDATE* pUpdates)</unmanaged>	
        /// <unmanaged-short>IMFTopologyNodeAttributeEditor::UpdateNodeAttributes</unmanaged-short>	
        public void UpdateNodeAttributes(long topoId, int cUpdates, SharpDX.MediaFoundation.ToponodeAttributeUpdate[] updatesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* updatesRef_ = updatesRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, topoId, cUpdates, updatesRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables a custom video mixer or video presenter to get interface references from the Enhanced Video Renderer (EVR). The mixer can also use this interface to get interface references from the presenter, and the presenter can use it to get interface references from the mixer.</p><p>To use this interface, implement the <strong><see cref="SharpDX.MediaFoundation.TopologyServiceLookupClient"/></strong> interface on your custom mixer or presenter. The EVR calls <strong><see cref="SharpDX.MediaFoundation.TopologyServiceLookupClient.InitServicePointers"/></strong> with a reference to the EVR's <strong><see cref="SharpDX.MediaFoundation.TopologyServiceLookup"/></strong> interface.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyServiceLookup']/*"/>	
    /// <msdn-id>ms702001</msdn-id>	
    /// <unmanaged>IMFTopologyServiceLookup</unmanaged>	
    /// <unmanaged-short>IMFTopologyServiceLookup</unmanaged-short>	
    [Guid("fa993889-4383-415a-a930-dd472a8cf6f7")]
    public partial class TopologyServiceLookup : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TopologyServiceLookup"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TopologyServiceLookup(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TopologyServiceLookup"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TopologyServiceLookup(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TopologyServiceLookup(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves an interface from the enhanced video renderer (EVR), or from the video mixer or video presenter.</p>	
        /// </summary>	
        /// <param name="type"><dd> <p>Specifies the scope of the search. Currently this parameter is ignored. Use the value <see cref="SharpDX.MediaFoundation.ServiceLookupType.Global"/>.</p> </dd></param>	
        /// <param name="dwIndex"><dd> <p>Reserved, must be zero.</p> </dd></param>	
        /// <param name="guidService"><dd> <p>Service <see cref="System.Guid"/> of the requested interface.</p> </dd></param>	
        /// <param name="riid"><dd> <p>Interface identifier of the requested interface.</p> </dd></param>	
        /// <param name="vObjectsOut"><dd> <p>Array of interface references. If the method succeeds, each member of the array contains either a valid interface reference or <strong><c>null</c></strong>. The caller must release the interface references when the EVR calls <strong><see cref="SharpDX.MediaFoundation.TopologyServiceLookupClient.ReleaseServicePointers"/></strong> (or earlier). If the method fails, every member of the array is <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="nObjectsRef"><dd> <p>Pointer to a value that specifies the size of the <em>ppvObjects</em> array. The value must be at least 1. In the current implementation, there is no reason to specify an array size larger than one element. The value is not changed on output.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOINTERFACE</strong></dt> </dl> </td><td> <p>The requested interface is not available.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotAccepting"/></strong></dt> </dl> </td><td> <p>The method was not called from inside the <strong><see cref="SharpDX.MediaFoundation.TopologyServiceLookupClient.InitServicePointers"/></strong> method. See Remarks.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedService"/></strong></dt> </dl> </td><td> <p>The object does not support the specified service <see cref="System.Guid"/>.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method can be called only from inside the <strong><see cref="SharpDX.MediaFoundation.TopologyServiceLookupClient.InitServicePointers"/></strong> method. At any other time, the method returns <see cref="SharpDX.MediaFoundation.ResultCode.NotAccepting"/>.</p><p>The presenter can use this method to query the EVR and the mixer. The mixer can use it to query the EVR and the presenter. Which objects are queried depends on the caller and the service <see cref="System.Guid"/>, as shown in the following table.</p><table> <tr><th>Caller</th><th>Service <see cref="System.Guid"/></th><th>Objects queried</th></tr> <tr><td>Presenter</td><td>MR_VIDEO_RENDER_SERVICE</td><td>EVR</td></tr> <tr><td>Presenter</td><td>MR_VIDEO_MIXER_SERVICE</td><td>Mixer</td></tr> <tr><td>Mixer</td><td>MR_VIDEO_RENDER_SERVICE</td><td>Presenter and EVR</td></tr> </table><p>?</p><p>The following interfaces are available from the EVR:</p><ul> <li> <p><strong>IMediaEventSink</strong>. This interface is documented in the DirectShow SDK documentation.</p> </li> <li> <p> <strong><see cref="SharpDX.MediaFoundation.Clock"/></strong> interface. This interface is available if the EVR has access to a clock (reference clock in DirectShow or presentation clock in Media Foundation). This interface might not be available. Presenter and mixers must be able to process data without a clock. If the <strong><see cref="SharpDX.MediaFoundation.Clock"/></strong> interface is available, you can also get these related interfaces:</p> <ul> <li> <p> <strong><see cref="SharpDX.MediaFoundation.Timer"/></strong> </p> </li> <li> <p> <strong><see cref="SharpDX.MediaFoundation.PresentationClock"/></strong> (Media Foundation EVR only)</p> </li> </ul> </li> </ul><p>The following interfaces are available from the mixer:</p><ul> <li> <p> <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> </p> </li> <li> <p> <strong><see cref="SharpDX.MediaFoundation.VideoDeviceID"/></strong> </p> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyServiceLookup::LookupService']/*"/>	
        /// <msdn-id>bb970504</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyServiceLookup::LookupService([In] MF_SERVICE_LOOKUP_TYPE Type,[In] unsigned int dwIndex,[In] const GUID&amp; guidService,[In] const GUID&amp; riid,[Out, Buffer] void** ppvObjects,[InOut] unsigned int* pnObjects)</unmanaged>	
        /// <unmanaged-short>IMFTopologyServiceLookup::LookupService</unmanaged-short>	
        public void LookupService(SharpDX.MediaFoundation.ServiceLookupType type, int dwIndex, System.Guid guidService, System.Guid riid, System.IntPtr vObjectsOut, ref int nObjectsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* nObjectsRef_ = &nObjectsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)type), dwIndex, &guidService, &riid, (void*)vObjectsOut, nObjectsRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Initializes a video mixer or presenter. This interface is implemented by mixers and presenters, and enables them to query the enhanced video renderer (EVR) for interface references.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>When the EVR loads the video mixer and the video presenter, the EVR queries the object for this interface and calls <strong>InitServicePointers</strong>. Inside the <strong>InitServicePointers</strong> method, the object can query the EVR for interface references.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyServiceLookupClient']/*"/>	
    /// <msdn-id>ms703063</msdn-id>	
    /// <unmanaged>IMFTopologyServiceLookupClient</unmanaged>	
    /// <unmanaged-short>IMFTopologyServiceLookupClient</unmanaged-short>	
    [Guid("fa99388a-4383-415a-a930-dd472a8cf6f7")]
    public partial class TopologyServiceLookupClient : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TopologyServiceLookupClient"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TopologyServiceLookupClient(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TopologyServiceLookupClient"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TopologyServiceLookupClient(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TopologyServiceLookupClient(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Signals the mixer or presenter to query the enhanced video renderer (EVR) for interface references.</p>	
        /// </summary>	
        /// <param name="lookupRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.TopologyServiceLookup"/></strong> interface. To query the EVR for an interface, call <strong><see cref="SharpDX.MediaFoundation.TopologyServiceLookup.LookupService"/></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.MediaFoundation.TopologyServiceLookup"/></strong> reference is guaranteed to be valid only during the call to <strong>InitServicePointers</strong>. The mixer or presenter should not store a reference to this interface after the method returns.</p><p>When the EVR calls <strong><see cref="SharpDX.MediaFoundation.TopologyServiceLookupClient.ReleaseServicePointers"/></strong>, the mixer or presenter should release any references it obtained from the EVR.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyServiceLookupClient::InitServicePointers']/*"/>	
        /// <msdn-id>bb970502</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyServiceLookupClient::InitServicePointers([In] IMFTopologyServiceLookup* pLookup)</unmanaged>	
        /// <unmanaged-short>IMFTopologyServiceLookupClient::InitServicePointers</unmanaged-short>	
        public void InitServicePointers(SharpDX.MediaFoundation.TopologyServiceLookup lookupRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((lookupRef == null) ? IntPtr.Zero : lookupRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Signals the object to release the interface references obtained from the enhanced video renderer (EVR).</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>After this method is called, any interface references obtained during the previous call to <strong><see cref="SharpDX.MediaFoundation.TopologyServiceLookupClient.InitServicePointers"/></strong> are no longer valid. The object must release them.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTopologyServiceLookupClient::ReleaseServicePointers']/*"/>	
        /// <msdn-id>ms693584</msdn-id>	
        /// <unmanaged>HRESULT IMFTopologyServiceLookupClient::ReleaseServicePointers()</unmanaged>	
        /// <unmanaged-short>IMFTopologyServiceLookupClient::ReleaseServicePointers</unmanaged-short>	
        public void ReleaseServicePointers()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Tracks the reference counts on a video media sample. Video samples created by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateVideoSampleFromSurface"/></strong> function expose this interface.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Use this interface to determine whether it is safe to delete or re-use the buffer contained in a sample. One object assigns itself as the owner of the video sample by calling <strong>SetAllocator</strong>. When all objects release their reference counts on the sample, the owner's callback method is invoked.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTrackedSample']/*"/>	
    /// <msdn-id>ms697026</msdn-id>	
    /// <unmanaged>IMFTrackedSample</unmanaged>	
    /// <unmanaged-short>IMFTrackedSample</unmanaged-short>	
    [Guid("245BF8E9-0755-40f7-88A5-AE0F18D55E17")]
    public partial class TrackedSample : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TrackedSample"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TrackedSample(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TrackedSample"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TrackedSample(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TrackedSample(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Sets the owner for the sample.</p>	
        /// </summary>	
        /// <param name="sampleAllocatorRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>	
        /// <param name="unkStateRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotAccepting"/></strong></dt> </dl> </td><td> <p>The owner was already set. This method cannot be called twice on the sample.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>When this method is called, the sample holds an additional reference count on itself. When every other object releases its reference counts on the sample, the sample invokes the <em>pSampleAllocator</em> callback method. To get a reference to the sample, call <strong><see cref="SharpDX.MediaFoundation.AsyncResult.GetObject"/></strong> on the asynchronous result object given to the callback's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.</p><p>After the callback is invoked, the sample clears the callback. To reinstate the callback, you must call <strong>SetAllocator</strong> again.</p><p>It is safe to pass in the sample's <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface reference as the state object (<em>pUnkState</em>) for the callback. If <em>pUnkState</em> points to the sample, the <strong>SetAllocator</strong> method accounts for the additional reference count on <em>pUnkState</em>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTrackedSample::SetAllocator']/*"/>	
        /// <msdn-id>ms704797</msdn-id>	
        /// <unmanaged>HRESULT IMFTrackedSample::SetAllocator([In] IMFAsyncCallback* pSampleAllocator,[In] IUnknown* pUnkState)</unmanaged>	
        /// <unmanaged-short>IMFTrackedSample::SetAllocator</unmanaged-short>	
        internal void SetAllocator_(System.IntPtr sampleAllocatorRef, SharpDX.ComObject unkStateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)sampleAllocatorRef, (void*)((unkStateRef == null) ? IntPtr.Zero : unkStateRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Implemented by the transcode profile object.</p><p>The transcode profile stores configuration settings that the topology builder uses to generate the transcode topology for the output file. These configuration settings are specified by the caller and include audio and video stream properties, encoder settings, and  container settings that are specified by the caller.</p><p>To create the transcode profile object, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateTranscodeProfile"/></strong>. The configured transcode profile is passed to <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateTranscodeTopology"/></strong>, which creates the transcode topology with the appropriate settings. </p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeProfile']/*"/>	
    /// <msdn-id>dd369139</msdn-id>	
    /// <unmanaged>IMFTranscodeProfile</unmanaged>	
    /// <unmanaged-short>IMFTranscodeProfile</unmanaged-short>	
    [Guid("4ADFDBA3-7AB0-4953-A62B-461E7FF3DA1E")]
    public partial class TranscodeProfile : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TranscodeProfile"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TranscodeProfile(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TranscodeProfile"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TranscodeProfile(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TranscodeProfile(nativePointer);
        }


        /// <summary>	
        /// <p>Gets or sets the audio stream settings that are currently set in the transcode profile. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If there are no audio attributes set in the transcode profile, the call to <strong>GetAudioAttributes</strong> succeeds and  <em>ppAttrs</em> receives <strong><c>null</c></strong>.</p><p>To get a specific attribute value, the caller must call the appropriate <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> method depending on the data type of the attribute, and specify the attribute name. The following topics describe the audio attributes:</p><ul> <li> Audio Media Types </li> <li> <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeEncodingprofile"/> </li> <li> <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeQualityvsspeed"/> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeProfile::GetAudioAttributes']/*"/>	
        /// <msdn-id>dd369140</msdn-id>	
        /// <unmanaged>GetAudioAttributes / SetAudioAttributes</unmanaged>	
        /// <unmanaged-short>GetAudioAttributes</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTranscodeProfile::GetAudioAttributes([Out, Optional] IMFAttributes** ppAttrs)</unmanaged>
        public SharpDX.MediaFoundation.MediaAttributes AudioAttributes
        {
            get { SharpDX.MediaFoundation.MediaAttributes __output__; GetAudioAttributes(out __output__); return __output__; }
            set { SetAudioAttributes(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the video stream settings that are currently set in the transcode profile.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If there are no container attributes set in the transcode profile, the <strong>GetVideoAttributes</strong> method  succeeds and  <em>ppAttrs</em> receives <strong><c>null</c></strong>.</p><p>To get a specific attribute value, the caller must call the appropriate <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> method depending on the data type of the attribute, and specify the attribute name. The following list shows the video attributes:</p><ul> <li> Video Media Types </li> <li> <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeEncodingprofile"/> </li> <li> <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeQualityvsspeed"/> </li> <li> <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeDonotInsertEncoder"/> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeProfile::GetVideoAttributes']/*"/>	
        /// <msdn-id>dd369142</msdn-id>	
        /// <unmanaged>GetVideoAttributes / SetVideoAttributes</unmanaged>	
        /// <unmanaged-short>GetVideoAttributes</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTranscodeProfile::GetVideoAttributes([Out, Optional] IMFAttributes** ppAttrs)</unmanaged>
        public SharpDX.MediaFoundation.MediaAttributes VideoAttributes
        {
            get { SharpDX.MediaFoundation.MediaAttributes __output__; GetVideoAttributes(out __output__); return __output__; }
            set { SetVideoAttributes(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the container settings that are currently set in the transcode profile.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If there are no container attributes set in the transcode profile, the call to <strong>GetContainerAttributes</strong> succeeds and  <em>ppAttrs</em> receives <strong><c>null</c></strong>.</p><p> To get a specific attribute value, the caller must call the appropriate <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> method depending on the data type of the attribute. The following list shows the container attributes:</p><ul> <li> <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeContainertype"/> </li> <li> <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeSkipMetadataTransfer"/> </li> <li> <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeTopologymode"/> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeProfile::GetContainerAttributes']/*"/>	
        /// <msdn-id>dd369141</msdn-id>	
        /// <unmanaged>GetContainerAttributes / SetContainerAttributes</unmanaged>	
        /// <unmanaged-short>GetContainerAttributes</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTranscodeProfile::GetContainerAttributes([Out, Optional] IMFAttributes** ppAttrs)</unmanaged>
        public SharpDX.MediaFoundation.MediaAttributes ContainerAttributes
        {
            get { SharpDX.MediaFoundation.MediaAttributes __output__; GetContainerAttributes(out __output__); return __output__; }
            set { SetContainerAttributes(value); }
        }

        /// <summary>	
        /// <p>Sets audio stream configuration settings  in the transcode profile.</p><p>To get a list of compatible audio media types supported by the Media Foundation transform (MFT) encoder , call  <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TranscodeGetAudioOutputAvailableTypes"/></strong>. You can get the attributes that are set on the required media type and set them on the transcode profile. To set the audio attributes properly, create a new attribute store and copy the attribute store from the required media media type by calling <strong><see cref="SharpDX.MediaFoundation.MediaAttributes.CopyAllItems"/></strong>. This makes sure that the caller does not hold the references to the media type retrieved from the encoder. For example code, see <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateTranscodeProfile"/></strong>.</p>	
        /// </summary>	
        /// <param name="attrsRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeProfile::SetAudioAttributes']/*"/>	
        /// <msdn-id>dd369143</msdn-id>	
        /// <unmanaged>HRESULT IMFTranscodeProfile::SetAudioAttributes([In, Optional] IMFAttributes* pAttrs)</unmanaged>	
        /// <unmanaged-short>IMFTranscodeProfile::SetAudioAttributes</unmanaged-short>	
        internal void SetAudioAttributes(SharpDX.MediaFoundation.MediaAttributes attrsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((attrsRef == null) ? IntPtr.Zero : attrsRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the audio stream settings that are currently set in the transcode profile. </p>	
        /// </summary>	
        /// <param name="attrsOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the attribute store containing the current audio stream settings. Caller must release the interface reference.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If there are no audio attributes set in the transcode profile, the call to <strong>GetAudioAttributes</strong> succeeds and  <em>ppAttrs</em> receives <strong><c>null</c></strong>.</p><p>To get a specific attribute value, the caller must call the appropriate <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> method depending on the data type of the attribute, and specify the attribute name. The following topics describe the audio attributes:</p><ul> <li> Audio Media Types </li> <li> <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeEncodingprofile"/> </li> <li> <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeQualityvsspeed"/> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeProfile::GetAudioAttributes']/*"/>	
        /// <msdn-id>dd369140</msdn-id>	
        /// <unmanaged>HRESULT IMFTranscodeProfile::GetAudioAttributes([Out, Optional] IMFAttributes** ppAttrs)</unmanaged>	
        /// <unmanaged-short>IMFTranscodeProfile::GetAudioAttributes</unmanaged-short>	
        internal void GetAudioAttributes(out SharpDX.MediaFoundation.MediaAttributes attrsOut)
        {
            unsafe
            {
                IntPtr attrsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &attrsOut_, ((void**)(*(void**)_nativePointer))[4]);
                attrsOut = (attrsOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(attrsOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets video stream configuration settings  in the transcode profile.</p><p> For example code, see <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateTranscodeProfile"/></strong>.</p>	
        /// </summary>	
        /// <param name="attrsRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeProfile::SetVideoAttributes']/*"/>	
        /// <msdn-id>dd369145</msdn-id>	
        /// <unmanaged>HRESULT IMFTranscodeProfile::SetVideoAttributes([In, Optional] IMFAttributes* pAttrs)</unmanaged>	
        /// <unmanaged-short>IMFTranscodeProfile::SetVideoAttributes</unmanaged-short>	
        internal void SetVideoAttributes(SharpDX.MediaFoundation.MediaAttributes attrsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((attrsRef == null) ? IntPtr.Zero : attrsRef.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the video stream settings that are currently set in the transcode profile.</p>	
        /// </summary>	
        /// <param name="attrsOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the attribute store containing the current video stream settings. Caller must release the interface reference.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If there are no container attributes set in the transcode profile, the <strong>GetVideoAttributes</strong> method  succeeds and  <em>ppAttrs</em> receives <strong><c>null</c></strong>.</p><p>To get a specific attribute value, the caller must call the appropriate <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> method depending on the data type of the attribute, and specify the attribute name. The following list shows the video attributes:</p><ul> <li> Video Media Types </li> <li> <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeEncodingprofile"/> </li> <li> <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeQualityvsspeed"/> </li> <li> <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeDonotInsertEncoder"/> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeProfile::GetVideoAttributes']/*"/>	
        /// <msdn-id>dd369142</msdn-id>	
        /// <unmanaged>HRESULT IMFTranscodeProfile::GetVideoAttributes([Out, Optional] IMFAttributes** ppAttrs)</unmanaged>	
        /// <unmanaged-short>IMFTranscodeProfile::GetVideoAttributes</unmanaged-short>	
        internal void GetVideoAttributes(out SharpDX.MediaFoundation.MediaAttributes attrsOut)
        {
            unsafe
            {
                IntPtr attrsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &attrsOut_, ((void**)(*(void**)_nativePointer))[6]);
                attrsOut = (attrsOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(attrsOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets container configuration settings  in the transcode profile.</p><p> For example code, see <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateTranscodeProfile"/></strong>.</p>	
        /// </summary>	
        /// <param name="attrsRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeProfile::SetContainerAttributes']/*"/>	
        /// <msdn-id>dd369144</msdn-id>	
        /// <unmanaged>HRESULT IMFTranscodeProfile::SetContainerAttributes([In, Optional] IMFAttributes* pAttrs)</unmanaged>	
        /// <unmanaged-short>IMFTranscodeProfile::SetContainerAttributes</unmanaged-short>	
        internal void SetContainerAttributes(SharpDX.MediaFoundation.MediaAttributes attrsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((attrsRef == null) ? IntPtr.Zero : attrsRef.NativePointer), ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the container settings that are currently set in the transcode profile.</p>	
        /// </summary>	
        /// <param name="attrsOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the attribute store containing the current container type for the output file. Caller must release the interface reference.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If there are no container attributes set in the transcode profile, the call to <strong>GetContainerAttributes</strong> succeeds and  <em>ppAttrs</em> receives <strong><c>null</c></strong>.</p><p> To get a specific attribute value, the caller must call the appropriate <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> method depending on the data type of the attribute. The following list shows the container attributes:</p><ul> <li> <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeContainertype"/> </li> <li> <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeSkipMetadataTransfer"/> </li> <li> <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeTopologymode"/> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeProfile::GetContainerAttributes']/*"/>	
        /// <msdn-id>dd369141</msdn-id>	
        /// <unmanaged>HRESULT IMFTranscodeProfile::GetContainerAttributes([Out, Optional] IMFAttributes** ppAttrs)</unmanaged>	
        /// <unmanaged-short>IMFTranscodeProfile::GetContainerAttributes</unmanaged-short>	
        internal void GetContainerAttributes(out SharpDX.MediaFoundation.MediaAttributes attrsOut)
        {
            unsafe
            {
                IntPtr attrsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &attrsOut_, ((void**)(*(void**)_nativePointer))[8]);
                attrsOut = (attrsOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(attrsOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Sets the name of the encoded output file.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p> The media sink will create a local file with the specified file name.</p><p>Alternately, you can call <strong><see cref="SharpDX.MediaFoundation.TranscodeSinkInfoProvider.SetOutputByteStream"/></strong> to specify a byte stream  that will receive the transcoded data. These two methods are mutually exclusive.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeSinkInfoProvider']/*"/>	
    /// <msdn-id>dd369149</msdn-id>	
    /// <unmanaged>IMFTranscodeSinkInfoProvider</unmanaged>	
    /// <unmanaged-short>IMFTranscodeSinkInfoProvider</unmanaged-short>	
    [Guid("8CFFCD2E-5A03-4a3a-AFF7-EDCD107C620E")]
    public partial class TranscodeSinkInfoProvider : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TranscodeSinkInfoProvider"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TranscodeSinkInfoProvider(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TranscodeSinkInfoProvider"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TranscodeSinkInfoProvider(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TranscodeSinkInfoProvider(nativePointer);
        }


        /// <summary>	
        /// <p>Sets the name of the encoded output file.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> The media sink will create a local file with the specified file name.</p><p>Alternately, you can call <strong><see cref="SharpDX.MediaFoundation.TranscodeSinkInfoProvider.SetOutputByteStream"/></strong> to specify a byte stream  that will receive the transcoded data. These two methods are mutually exclusive.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeSinkInfoProvider::SetOutputFile']/*"/>	
        /// <msdn-id>dd369149</msdn-id>	
        /// <unmanaged>SetOutputFile</unmanaged>	
        /// <unmanaged-short>SetOutputFile</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTranscodeSinkInfoProvider::SetOutputFile([In] const wchar_t* pwszFileName)</unmanaged>
        public string OutputFile
        {
            set { SetOutputFile(value); }
        }

        /// <summary>	
        /// <p>Sets an output byte stream for the transcode media sink.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Call this method to provide a writeable byte stream  that will receive the transcoded data.</p><p>Alternatively, you can provide the name of an  output file, by calling <strong><see cref="SharpDX.MediaFoundation.TranscodeSinkInfoProvider.SetOutputFile"/></strong>. These two methods are mutually exclusive.</p><p>The <em>pByteStreamActivate</em> parameter must specify an activation object that creates a writeable byte stream. Internally, the transcode media sink calls <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> to create the byte stream, as follows:</p><code><see cref="SharpDX.MediaFoundation.IByteStream"/> *pByteStream = <c>null</c>; <see cref="SharpDX.Result"/> hr = pByteStreamActivate-&gt;ActivateObject(IID_IMFByteStream, (void**)&amp;pByteStream);</code><p>Currently, Microsoft Media Foundation does not provide any byte-stream activation objects. To use this method, an application must provide a custom implementation of <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeSinkInfoProvider::SetOutputByteStream']/*"/>	
        /// <msdn-id>dd369148</msdn-id>	
        /// <unmanaged>SetOutputByteStream</unmanaged>	
        /// <unmanaged-short>SetOutputByteStream</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTranscodeSinkInfoProvider::SetOutputByteStream([In] IMFActivate* pByteStreamActivate)</unmanaged>
        public SharpDX.MediaFoundation.Activate OutputByteStream
        {
            set { SetOutputByteStream(value); }
        }

        /// <summary>	
        /// <p>Sets the transcoding profile on the transcode sink activation object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Before calling this method, initialize the profile object as follows:</p><ul> <li>Set the <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeContainertype"/> attribute to specify the container type of the output file.</li> <li>If the output file will have a video stream, set video attributes by calling the <strong><see cref="SharpDX.MediaFoundation.TranscodeProfile.SetVideoAttributes"/></strong> method.</li> <li>If the output file will have an audio stream, set audio attributes by calling the <strong><see cref="SharpDX.MediaFoundation.TranscodeProfile.SetAudioAttributes"/></strong> method.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeSinkInfoProvider::SetProfile']/*"/>	
        /// <msdn-id>dd369150</msdn-id>	
        /// <unmanaged>SetProfile</unmanaged>	
        /// <unmanaged-short>SetProfile</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTranscodeSinkInfoProvider::SetProfile([In] IMFTranscodeProfile* pProfile)</unmanaged>
        public SharpDX.MediaFoundation.TranscodeProfile Profile
        {
            set { SetProfile(value); }
        }

        /// <summary>	
        /// <p> Gets the media types for the audio and video streams specified in the transcode profile.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Before calling this method, call <strong><see cref="SharpDX.MediaFoundation.TranscodeSinkInfoProvider.SetProfile"/></strong> to set the transcode profile. The <strong>GetSinkInfo</strong> method  uses the profile to create media types for the audio and video streams. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeSinkInfoProvider::GetSinkInfo']/*"/>	
        /// <msdn-id>dd369147</msdn-id>	
        /// <unmanaged>GetSinkInfo</unmanaged>	
        /// <unmanaged-short>GetSinkInfo</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTranscodeSinkInfoProvider::GetSinkInfo([Out] MF_TRANSCODE_SINK_INFO* pSinkInfo)</unmanaged>
        public SharpDX.MediaFoundation.TranscodeSinkInformation SinkInfo
        {
            get { SharpDX.MediaFoundation.TranscodeSinkInformation __output__; GetSinkInfo(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Sets the name of the encoded output file.</p>	
        /// </summary>	
        /// <param name="wszFileNameRef"><dd> <p>Pointer to a null-terminated string that contains the name of the output file.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The media sink will create a local file with the specified file name.</p><p>Alternately, you can call <strong><see cref="SharpDX.MediaFoundation.TranscodeSinkInfoProvider.SetOutputByteStream"/></strong> to specify a byte stream  that will receive the transcoded data. These two methods are mutually exclusive.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeSinkInfoProvider::SetOutputFile']/*"/>	
        /// <msdn-id>dd369149</msdn-id>	
        /// <unmanaged>HRESULT IMFTranscodeSinkInfoProvider::SetOutputFile([In] const wchar_t* pwszFileName)</unmanaged>	
        /// <unmanaged-short>IMFTranscodeSinkInfoProvider::SetOutputFile</unmanaged-short>	
        internal void SetOutputFile(string wszFileNameRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* wszFileNameRef_ = wszFileNameRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)wszFileNameRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets an output byte stream for the transcode media sink.</p>	
        /// </summary>	
        /// <param name="byteStreamActivateRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong> interface of a byte-stream activation object. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Call this method to provide a writeable byte stream  that will receive the transcoded data.</p><p>Alternatively, you can provide the name of an  output file, by calling <strong><see cref="SharpDX.MediaFoundation.TranscodeSinkInfoProvider.SetOutputFile"/></strong>. These two methods are mutually exclusive.</p><p>The <em>pByteStreamActivate</em> parameter must specify an activation object that creates a writeable byte stream. Internally, the transcode media sink calls <strong><see cref="SharpDX.MediaFoundation.Activate.ActivateObject"/></strong> to create the byte stream, as follows:</p><code><see cref="SharpDX.MediaFoundation.IByteStream"/> *pByteStream = <c>null</c>; <see cref="SharpDX.Result"/> hr = pByteStreamActivate-&gt;ActivateObject(IID_IMFByteStream, (void**)&amp;pByteStream);</code><p>Currently, Microsoft Media Foundation does not provide any byte-stream activation objects. To use this method, an application must provide a custom implementation of <strong><see cref="SharpDX.MediaFoundation.Activate"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeSinkInfoProvider::SetOutputByteStream']/*"/>	
        /// <msdn-id>dd369148</msdn-id>	
        /// <unmanaged>HRESULT IMFTranscodeSinkInfoProvider::SetOutputByteStream([In] IMFActivate* pByteStreamActivate)</unmanaged>	
        /// <unmanaged-short>IMFTranscodeSinkInfoProvider::SetOutputByteStream</unmanaged-short>	
        internal void SetOutputByteStream(SharpDX.MediaFoundation.Activate byteStreamActivateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((byteStreamActivateRef == null) ? IntPtr.Zero : byteStreamActivateRef.NativePointer), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the transcoding profile on the transcode sink activation object.</p>	
        /// </summary>	
        /// <param name="profileRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.TranscodeProfile"/></strong> interface. To get a reference to this interface, call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateTranscodeProfile"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Before calling this method, initialize the profile object as follows:</p><ul> <li>Set the <see cref="SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeContainertype"/> attribute to specify the container type of the output file.</li> <li>If the output file will have a video stream, set video attributes by calling the <strong><see cref="SharpDX.MediaFoundation.TranscodeProfile.SetVideoAttributes"/></strong> method.</li> <li>If the output file will have an audio stream, set audio attributes by calling the <strong><see cref="SharpDX.MediaFoundation.TranscodeProfile.SetAudioAttributes"/></strong> method.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeSinkInfoProvider::SetProfile']/*"/>	
        /// <msdn-id>dd369150</msdn-id>	
        /// <unmanaged>HRESULT IMFTranscodeSinkInfoProvider::SetProfile([In] IMFTranscodeProfile* pProfile)</unmanaged>	
        /// <unmanaged-short>IMFTranscodeSinkInfoProvider::SetProfile</unmanaged-short>	
        internal void SetProfile(SharpDX.MediaFoundation.TranscodeProfile profileRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((profileRef == null) ? IntPtr.Zero : profileRef.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the media types for the audio and video streams specified in the transcode profile.</p>	
        /// </summary>	
        /// <param name="sinkInfoRef"><dd> <p>A reference to an <strong><see cref="SharpDX.MediaFoundation.TranscodeSinkInformation"/></strong> structure.</p> <p>If the method succeeds, the method assigns <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> references to the <strong>pAudioMediaType</strong> and <strong>pVideoMediaType</strong> members of this structure. The method might set either member to <strong><c>null</c></strong>. If either member is non-<c>null</c> after the method returns, the caller must release the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> references.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Before calling this method, call <strong><see cref="SharpDX.MediaFoundation.TranscodeSinkInfoProvider.SetProfile"/></strong> to set the transcode profile. The <strong>GetSinkInfo</strong> method  uses the profile to create media types for the audio and video streams. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTranscodeSinkInfoProvider::GetSinkInfo']/*"/>	
        /// <msdn-id>dd369147</msdn-id>	
        /// <unmanaged>HRESULT IMFTranscodeSinkInfoProvider::GetSinkInfo([Out] MF_TRANSCODE_SINK_INFO* pSinkInfo)</unmanaged>	
        /// <unmanaged-short>IMFTranscodeSinkInfoProvider::GetSinkInfo</unmanaged-short>	
        internal void GetSinkInfo(out SharpDX.MediaFoundation.TranscodeSinkInformation sinkInfoRef)
        {
            unsafe
            {
                sinkInfoRef = new SharpDX.MediaFoundation.TranscodeSinkInformation();
                SharpDX.Result __result__;
                fixed (void* sinkInfoRef_ = &sinkInfoRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, sinkInfoRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Implemented by all Media Foundation Transforms (MFTs).</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform']/*"/>	
    /// <msdn-id>ms696260</msdn-id>	
    /// <unmanaged>IMFTransform</unmanaged>	
    /// <unmanaged-short>IMFTransform</unmanaged-short>	
    [Guid("bf94c121-5b05-4e6f-8000-ba598961414d")]
    public partial class Transform : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.Transform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Transform(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.Transform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.Transform(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.Transform(nativePointer);
        }


        /// <summary>	
        /// <p> Gets the global attribute store for this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <remarks>	
        /// <p> Use the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> reference retrieved by this method to get or set attributes that apply to the entire MFT. To get the attribute store for an input stream, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetInputStreamAttributes"/></strong>. To get the attribute store for an output stream, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetOutputStreamAttributes"/></strong>. </p><p> Implementation of this method is optional unless the MFT needs to support a particular set of attributes. Exception: Hardware-based MFTs must implement this method. See Hardware MFTs.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::GetAttributes']/*"/>	
        /// <msdn-id>ms703141</msdn-id>	
        /// <unmanaged>GetAttributes</unmanaged>	
        /// <unmanaged-short>GetAttributes</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTransform::GetAttributes([Out] IMFAttributes** pAttributes)</unmanaged>
        public SharpDX.MediaFoundation.MediaAttributes Attributes
        {
            get { SharpDX.MediaFoundation.MediaAttributes __output__; GetAttributes(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Queries whether the Media Foundation transform (MFT) is ready to produce output data. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p> If the method returns the <strong><see cref="SharpDX.MediaFoundation.MftOutputStatusFlags.MftOutputStatusSampleReady"/></strong> flag, it means you can generate one or more output samples by calling <strong><see cref="SharpDX.MediaFoundation.Transform.ProcessOutput"/></strong>. </p><p> MFTs are not required to implement this method. If the method returns <strong>E_NOTIMPL</strong>, you must call <strong>ProcessOutput</strong> to determine whether the transform has output data. </p><p> If the MFT has more than one output stream, but it does not produce samples at the same time for each stream, it can set the <strong><see cref="SharpDX.MediaFoundation.MftOutputStatusFlags.MftOutputStatusSampleReady"/></strong> flag when just one stream is ready. However, if the MFT normally produces samples at the same time for each output stream, it should not set this flag until all streams are ready. </p><p> After the client has set valid media types on all of the streams, the MFT should always be in one of two states: Able to accept more input, or able to produce more output. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetOutputStatus</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::GetOutputStatus']/*"/>	
        /// <msdn-id>ms696269</msdn-id>	
        /// <unmanaged>GetOutputStatus</unmanaged>	
        /// <unmanaged-short>GetOutputStatus</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTransform::GetOutputStatus([Out] unsigned int* pdwFlags)</unmanaged>
        public int OutputStatus
        {
            get { int __output__; GetOutputStatus(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Gets the minimum and maximum number of input and output streams for this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="dwInputMinimumRef"><dd> <p> Receives the minimum number of input streams. </p> </dd></param>	
        /// <param name="dwInputMaximumRef"><dd> <p> Receives the maximum number of input streams. If there is no maximum, receives the value <strong>MFT_STREAMS_UNLIMITED</strong>. </p> </dd></param>	
        /// <param name="dwOutputMinimumRef"><dd> <p> Receives the minimum number of output streams. </p> </dd></param>	
        /// <param name="dwOutputMaximumRef"><dd> <p> Receives the maximum number of output streams. If there is no maximum, receives the value <strong>MFT_STREAMS_UNLIMITED</strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> If the MFT has a fixed number of streams, the minimum and maximum values are the same. </p><p> It is not recommended to create an MFT that supports zero inputs or zero outputs. An MFT with no inputs or no outputs may not be compatible with the rest of the Media Foundation pipeline. You should create a Media Foundation sink or source for this purpose instead. </p><p> When an MFT is first created, it is not guaranteed to have the minimum number of streams. To find the actual number of streams, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamCount"/></strong>. </p><p> This method should not be called with <strong><c>null</c></strong> parameters, although in practice some implementations may allow <strong><c>null</c></strong> parameters. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetStreamLimits</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::GetStreamLimits']/*"/>	
        /// <msdn-id>ms697040</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::GetStreamLimits([Out] unsigned int* pdwInputMinimum,[Out] unsigned int* pdwInputMaximum,[Out] unsigned int* pdwOutputMinimum,[Out] unsigned int* pdwOutputMaximum)</unmanaged>	
        /// <unmanaged-short>IMFTransform::GetStreamLimits</unmanaged-short>	
        public void GetStreamLimits(out int dwInputMinimumRef, out int dwInputMaximumRef, out int dwOutputMinimumRef, out int dwOutputMaximumRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwInputMinimumRef_ = &dwInputMinimumRef)
                fixed (void* dwInputMaximumRef_ = &dwInputMaximumRef)
                fixed (void* dwOutputMinimumRef_ = &dwOutputMinimumRef)
                fixed (void* dwOutputMaximumRef_ = &dwOutputMaximumRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputMinimumRef_, dwInputMaximumRef_, dwOutputMinimumRef_, dwOutputMaximumRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the current number of input and output streams on this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="cInputStreamsRef"><dd> <p> Receives the number of input streams. </p> </dd></param>	
        /// <param name="cOutputStreamsRef"><dd> <p> Receives the number of output streams. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The number of streams includes unselected streams?that is, streams with no media type or a <strong><c>null</c></strong> media type.</p><p> This method should not be called with <strong><c>null</c></strong> parameters, although in practice some implementations may allow <strong><c>null</c></strong> parameters. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetStreamCount</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::GetStreamCount']/*"/>	
        /// <msdn-id>ms697018</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::GetStreamCount([Out] unsigned int* pcInputStreams,[Out] unsigned int* pcOutputStreams)</unmanaged>	
        /// <unmanaged-short>IMFTransform::GetStreamCount</unmanaged-short>	
        public void GetStreamCount(out int cInputStreamsRef, out int cOutputStreamsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cInputStreamsRef_ = &cInputStreamsRef)
                fixed (void* cOutputStreamsRef_ = &cOutputStreamsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cInputStreamsRef_, cOutputStreamsRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the stream identifiers for the input and output streams on this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="dwInputIDArraySize"><dd> <p> Number of elements in the <em>pdwInputIDs</em> array. </p> </dd></param>	
        /// <param name="dwInputIDsRef"><dd> <p> Pointer to an array allocated by the caller. The method fills the array with the input stream identifiers. The array size must be at least equal to the number of input streams. To get the number of input streams, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamCount"/></strong>. </p> <p>If the caller passes an array that is larger than the number of input streams, the MFT must not write values into the extra array entries.</p> </dd></param>	
        /// <param name="dwOutputIDArraySize"><dd> <p> Number of elements in the <em>pdwOutputIDs</em> array. </p> </dd></param>	
        /// <param name="dwOutputIDsRef"><dd> <p> Pointer to an array allocated by the caller. The method fills the array with the output stream identifiers. The array size must be at least equal to the number of output streams. To get the number of output streams, call <strong>GetStreamCount</strong>. </p> <p>If the caller passes an array that is larger than the number of output streams, the MFT must not write values into the extra array entries.</p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> Not implemented. See Remarks. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.BufferTooSmall"/></strong></dt> </dl> </td><td> <p> One or both of the arrays is too small. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> Stream identifiers are necessary because some MFTs can add or remove streams, so the index of a stream may not be unique. Therefore, <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> methods that operate on streams take stream identifiers. </p><p>This method can return <strong>E_NOTIMPL</strong> if both of the following conditions are true:</p><ul> <li> The transform has a fixed number of streams. </li> <li> The streams are numbered consecutively from 0 to n ? 1, where n is the number of input streams or output streams. In other words, the first input stream is 0, the second is 1, and so on; and the first output stream is 0, the second is 1, and so on. </li> </ul><p>This method must be implemented if any of the following conditions is true:</p><ul> <li> The MFT can add or remove output streams. </li> <li> The MFT allows the client to add or remove input streams. </li> <li> The stream identifiers are not consecutive. </li> </ul><p> All input stream identifiers must be unique within an MFT, and all output stream identifiers must be unique. However, an input stream and an output stream can share the same identifier. </p><p> If the client adds an input stream, the client assigns the identifier, so the MFT must allow arbitrary identifiers, as long as they are unique. If the MFT creates an output stream, the MFT assigns the identifier. </p><p> By convention, if an MFT has exactly one fixed input stream and one fixed output stream, it should assign the identifier 0 to both streams. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetStreamIDs</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::GetStreamIDs']/*"/>	
        /// <msdn-id>ms693988</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::GetStreamIDs([In] unsigned int dwInputIDArraySize,[Out, Buffer] unsigned int* pdwInputIDs,[In] unsigned int dwOutputIDArraySize,[Out, Buffer] unsigned int* pdwOutputIDs)</unmanaged>	
        /// <unmanaged-short>IMFTransform::GetStreamIDs</unmanaged-short>	
        internal SharpDX.Result GetStreamIDs(int dwInputIDArraySize, int[] dwInputIDsRef, int dwOutputIDArraySize, int[] dwOutputIDsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwInputIDsRef_ = dwInputIDsRef)
                fixed (void* dwOutputIDsRef_ = dwOutputIDsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputIDArraySize, dwInputIDsRef_, dwOutputIDArraySize, dwOutputIDsRef_, ((void**)(*(void**)_nativePointer))[5]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the buffer requirements and other information for an input stream on this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="dwInputStreamID"><dd> <p> Input stream identifier. To get the list of stream identifiers, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamIDs"/></strong>. </p> </dd></param>	
        /// <param name="streamInfoRef"><dd> <p> Pointer to an <strong><see cref="SharpDX.MediaFoundation.TInputStreamInformation"/></strong> structure. The method fills the structure with information about the input stream. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>It is valid to call this method before setting the media types.</p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetInputStreamInfo</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::GetInputStreamInfo']/*"/>	
        /// <msdn-id>ms703894</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::GetInputStreamInfo([In] unsigned int dwInputStreamID,[Out] MFT_INPUT_STREAM_INFO* pStreamInfo)</unmanaged>	
        /// <unmanaged-short>IMFTransform::GetInputStreamInfo</unmanaged-short>	
        public void GetInputStreamInfo(int dwInputStreamID, out SharpDX.MediaFoundation.TInputStreamInformation streamInfoRef)
        {
            unsafe
            {
                streamInfoRef = new SharpDX.MediaFoundation.TInputStreamInformation();
                SharpDX.Result __result__;
                fixed (void* streamInfoRef_ = &streamInfoRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamID, streamInfoRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the buffer requirements and other information for an output stream on this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="dwOutputStreamID"><dd> <p> Output stream identifier. To get the list of stream identifiers, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamIDs"/></strong>. </p> </dd></param>	
        /// <param name="streamInfoRef"><dd> <p> Pointer to an <strong><see cref="SharpDX.MediaFoundation.TOutputStreamInformation"/></strong> structure. The method fills the structure with information about the output stream. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream number. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>It is valid to call this method before setting the media types.</p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetOutputStreamInfo</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::GetOutputStreamInfo']/*"/>	
        /// <msdn-id>ms693880</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::GetOutputStreamInfo([In] unsigned int dwOutputStreamID,[Out] MFT_OUTPUT_STREAM_INFO* pStreamInfo)</unmanaged>	
        /// <unmanaged-short>IMFTransform::GetOutputStreamInfo</unmanaged-short>	
        public void GetOutputStreamInfo(int dwOutputStreamID, out SharpDX.MediaFoundation.TOutputStreamInformation streamInfoRef)
        {
            unsafe
            {
                streamInfoRef = new SharpDX.MediaFoundation.TOutputStreamInformation();
                SharpDX.Result __result__;
                fixed (void* streamInfoRef_ = &streamInfoRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputStreamID, streamInfoRef_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the global attribute store for this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="attributesRef"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> The MFT does not support attributes. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> Use the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> reference retrieved by this method to get or set attributes that apply to the entire MFT. To get the attribute store for an input stream, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetInputStreamAttributes"/></strong>. To get the attribute store for an output stream, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetOutputStreamAttributes"/></strong>. </p><p> Implementation of this method is optional unless the MFT needs to support a particular set of attributes. Exception: Hardware-based MFTs must implement this method. See Hardware MFTs.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::GetAttributes']/*"/>	
        /// <msdn-id>ms703141</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::GetAttributes([Out] IMFAttributes** pAttributes)</unmanaged>	
        /// <unmanaged-short>IMFTransform::GetAttributes</unmanaged-short>	
        internal void GetAttributes(out SharpDX.MediaFoundation.MediaAttributes attributesRef)
        {
            unsafe
            {
                IntPtr attributesRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &attributesRef_, ((void**)(*(void**)_nativePointer))[8]);
                attributesRef = (attributesRef_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(attributesRef_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the attribute store for an input stream on this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="dwInputStreamID"><dd> <p> Input stream identifier. To get the list of stream identifiers, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamIDs"/></strong>. </p> </dd></param>	
        /// <param name="attributesRef"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> The MFT does not support input stream attributes. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> Implementation of this method is optional unless the MFT needs to support a particular set of attributes. </p><p> To get the attribute store for the entire MFT, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetAttributes"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::GetInputStreamAttributes']/*"/>	
        /// <msdn-id>ms695366</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::GetInputStreamAttributes([In] unsigned int dwInputStreamID,[Out] IMFAttributes** pAttributes)</unmanaged>	
        /// <unmanaged-short>IMFTransform::GetInputStreamAttributes</unmanaged-short>	
        public void GetInputStreamAttributes(int dwInputStreamID, out SharpDX.MediaFoundation.MediaAttributes attributesRef)
        {
            unsafe
            {
                IntPtr attributesRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamID, &attributesRef_, ((void**)(*(void**)_nativePointer))[9]);
                attributesRef = (attributesRef_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(attributesRef_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the attribute store for an output stream on this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="dwOutputStreamID"><dd> <p> Output stream identifier. To get the list of stream identifiers, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamIDs"/></strong>. </p> </dd></param>	
        /// <param name="attributesRef"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> The MFT does not support output stream attributes. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> Implementation of this method is optional unless the MFT needs to support a particular set of attributes. </p><p> To get the attribute store for the entire MFT, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetAttributes"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::GetOutputStreamAttributes']/*"/>	
        /// <msdn-id>ms703886</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::GetOutputStreamAttributes([In] unsigned int dwOutputStreamID,[Out] IMFAttributes** pAttributes)</unmanaged>	
        /// <unmanaged-short>IMFTransform::GetOutputStreamAttributes</unmanaged-short>	
        public void GetOutputStreamAttributes(int dwOutputStreamID, out SharpDX.MediaFoundation.MediaAttributes attributesRef)
        {
            unsafe
            {
                IntPtr attributesRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputStreamID, &attributesRef_, ((void**)(*(void**)_nativePointer))[10]);
                attributesRef = (attributesRef_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaAttributes(attributesRef_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Removes an input stream from this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="dwStreamID"><dd> <p> Identifier of the input stream to remove. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> The transform has a fixed number of input streams. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p> The stream is not removable, or the transform currently has the minimum number of input streams it can support. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformInputRemaining"/></strong></dt> </dl> </td><td> <p> The transform has unprocessed input buffers for the specified stream. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If the transform has a fixed number of input streams, the method returns <strong>E_NOTIMPL</strong>. </p><p> An MFT might support this method but not allow certain input streams to be removed. If an input stream can be removed, the <strong><see cref="SharpDX.MediaFoundation.Transform.GetInputStreamInfo"/></strong> method returns the <strong><see cref="SharpDX.MediaFoundation.MftInputStreamInformationFlags.MftInputStreamRemovable"/></strong> flag for that stream. Otherwise, the stream cannot be removed, and the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong>. The method also fails if the MFT currently has the minimum number of input streams that it requires. To find the minimum number of streams, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamLimits"/></strong>. </p><p> If the transform still has unprocessed input for that stream, the method might succeed or it might return <strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformInputRemaining"/></strong>. If the method succeeds, the MFT will continue to process the remaining input after the stream is removed. If the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformInputRemaining"/></strong>, you must clear the input buffers before removing the stream. To clear the input buffers, either call <strong><see cref="SharpDX.MediaFoundation.Transform.ProcessOutput"/></strong> or else call <strong><see cref="SharpDX.MediaFoundation.Transform.ProcessMessage"/></strong> with the <strong><see cref="SharpDX.MediaFoundation.TMessageType.CommandFlush"/></strong> to flush the MFT. Then call the <strong>DeleteInputStream</strong> again. An MFT should never discard input buffers when <strong>DeleteInputStream</strong> is called. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTDeleteInputStream</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::DeleteInputStream']/*"/>	
        /// <msdn-id>ms703159</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::DeleteInputStream([In] unsigned int dwStreamID)</unmanaged>	
        /// <unmanaged-short>IMFTransform::DeleteInputStream</unmanaged-short>	
        public void DeleteInputStream(int dwStreamID)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamID, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Adds one or more new input streams to this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="cStreams"><dd> <p> Number of streams to add. </p> </dd></param>	
        /// <param name="adwStreamIDs"><dd> <p> Array of stream identifiers. The new stream identifiers must not match any existing input streams. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> Invalid argument. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> The MFT has a fixed number of input streams. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If the new streams exceed the maximum number of input streams for this transform, the method returns <strong>E_INVALIDARG.</strong> To find the maximum number of input streams, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamLimits"/></strong>. </p><p> If any of the new stream identifiers conflicts with an existing input stream, the method returns <strong>E_INVALIDARG</strong>. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTAddInputStreams</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::AddInputStreams']/*"/>	
        /// <msdn-id>ms696211</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::AddInputStreams([In] unsigned int cStreams,[In] unsigned int* adwStreamIDs)</unmanaged>	
        /// <unmanaged-short>IMFTransform::AddInputStreams</unmanaged-short>	
        public void AddInputStreams(int cStreams, int adwStreamIDs)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cStreams, &adwStreamIDs, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets an available media type for an input stream on this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="dwInputStreamID"><dd> <p> Input stream identifier. To get the list of stream identifiers, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamIDs"/></strong>. </p> </dd></param>	
        /// <param name="dwTypeIndex"><dd> <p> Index of the media type to retrieve. Media types are indexed from zero and returned in approximate order of preference. </p> </dd></param>	
        /// <param name="typeOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> The MFT does not have a list of available input types. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoMoreTypes"/></strong></dt> </dl> </td><td> <p> The <em>dwTypeIndex</em> parameter is out of range. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> You must set the output types before setting the input types. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> The MFT defines a list of available media types for each input stream and orders them by preference. This method enumerates the available media types for an input stream. To enumerate the available types, increment <em>dwTypeIndex</em> until the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.NoMoreTypes"/></strong>. </p><p> Setting the media type on one stream might change the available types for another stream, or change the preference order. However, an MFT is not required to update the list of available types dynamically. The only guaranteed way to test whether you can set a particular input type is to call <strong><see cref="SharpDX.MediaFoundation.Transform.SetInputType"/></strong>. </p><p> In some cases, an MFT cannot return a list of input types until one or more output types are set. If so, the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong>. </p><p> An MFT is not required to implement this method. However, most MFTs should implement this method, unless the supported types are simple and can be discovered through the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TGetInfo"/></strong> function.</p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetInputAvailableType</strong>. See Creating Hybrid DMO/MFT Objects.</p><p>For encoders, after the output type is set, <strong>GetInputAvailableType</strong> must return a list of input types that are compatible with the current output type. This means that all types returned by <strong>GetInputAvailableType</strong> after the output type is set must be valid types for <strong>SetInputType</strong>.</p><p>Encoders should reject input types if the attributes of the input media type and output media type do not match, such as resolution setting with <see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.FrameSize"/>, nominal range setting with <see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.VideoNominalRange"/>, or frame rate setting with <see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.FrameSize"/></p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::GetInputAvailableType']/*"/>	
        /// <msdn-id>ms704814</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::GetInputAvailableType([In] unsigned int dwInputStreamID,[In] unsigned int dwTypeIndex,[Out] IMFMediaType** ppType)</unmanaged>	
        /// <unmanaged-short>IMFTransform::GetInputAvailableType</unmanaged-short>	
        public void GetInputAvailableType(int dwInputStreamID, int dwTypeIndex, out SharpDX.MediaFoundation.MediaType typeOut)
        {
            unsafe
            {
                IntPtr typeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamID, dwTypeIndex, &typeOut_, ((void**)(*(void**)_nativePointer))[13]);
                typeOut = (typeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(typeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets an available media type for an output stream on this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="dwOutputStreamID"><dd> <p> Output stream identifier. To get the list of stream identifiers, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamIDs"/></strong>. </p> </dd></param>	
        /// <param name="dwTypeIndex"><dd> <p> Index of the media type to retrieve. Media types are indexed from zero and returned in approximate order of preference. </p> </dd></param>	
        /// <param name="typeOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> The MFT does not have a list of available output types. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoMoreTypes"/></strong></dt> </dl> </td><td> <p> The <em>dwTypeIndex</em> parameter is out of range. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> You must set the input types before setting the output types. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> The MFT defines a list of available media types for each output stream and orders them by preference. This method enumerates the available media types for an output stream. To enumerate the available types, increment <em>dwTypeIndex</em> until the method returns MF_<strong>E_NO_MORE_TYPES</strong>. </p><p> Setting the media type on one stream can change the available types for another stream (or change the preference order). However, an MFT is not required to update the list of available types dynamically. The only guaranteed way to test whether you can set a particular input type is to call <strong><see cref="SharpDX.MediaFoundation.Transform.SetOutputType"/></strong>. </p><p> In some cases, an MFT cannot return a list of output types until one or more input types are set. If so, the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong>. </p><p> An MFT is not required to implement this method. However, most MFTs should implement this method, unless the supported types are simple and can be discovered through the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.TGetInfo"/></strong> function. </p><p> This method can return a <em>partial</em> media type. A partial media type contains an incomplete description of a format, and is used to provide a hint to the caller. For example, a partial type might include just the major type and subtype GUIDs. However, after the client sets the input types on the MFT, the MFT should generally return at least one complete output type, which can be used without further modification. For more information, see Complete and Partial Media Types.</p><p>Some MFTs cannot provide an accurate list of output types until the MFT receives the first input sample. For example, the MFT might need to read the first packet header to deduce the format. An MFT should handle this situation as follows:</p><ol> <li> Before the MFT receives any input, it offers a list of one or more output types that it could possibly produce. For example, an MPEG-2 decoder might return a media type that describes the MPEG-2 main profile/main level. </li> <li> The client selects one of these types (generally the first) and sets it on the output stream. </li> <li> The client delivers the first input sample by calling <strong><see cref="SharpDX.MediaFoundation.Transform.ProcessInput"/></strong>. </li> <li> If the output type does not conform to the input data, the transform signals a format change in the <strong>ProcessOutput</strong> method. For more information about format changes, see <strong><see cref="SharpDX.MediaFoundation.Transform.ProcessOutput"/></strong>. </li> <li> The calls <strong>GetOutputAvailableType</strong> again. At this point, the method should return an updated list of types that reflects the input data. </li> <li> The client selects a new output type from this list and calls <strong>SetOutputType</strong>. </li> </ol><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetOutputAvailableType</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::GetOutputAvailableType']/*"/>	
        /// <msdn-id>ms703812</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::GetOutputAvailableType([In] unsigned int dwOutputStreamID,[In] unsigned int dwTypeIndex,[Out] IMFMediaType** ppType)</unmanaged>	
        /// <unmanaged-short>IMFTransform::GetOutputAvailableType</unmanaged-short>	
        internal SharpDX.Result GetOutputAvailableType(int dwOutputStreamID, int dwTypeIndex, out SharpDX.MediaFoundation.MediaType typeOut)
        {
            unsafe
            {
                IntPtr typeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputStreamID, dwTypeIndex, &typeOut_, ((void**)(*(void**)_nativePointer))[14]);
                typeOut = (typeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(typeOut_);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Sets, tests, or clears the media type for an input stream on this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="dwInputStreamID"><dd> <p> Input stream identifier. To get the list of stream identifiers, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamIDs"/></strong>. </p> </dd></param>	
        /// <param name="typeRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface, or <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="dwFlags"><dd> <p> Zero or more flags from the <strong>_MFT_SET_TYPE_FLAGS</strong> enumeration. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidMediaType"/></strong></dt> </dl> </td><td> <p> The MFT cannot use the proposed media type. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidType"/></strong></dt> </dl> </td><td> <p> The proposed type is not valid. This error code indicates that the media type itself is not configured correctly; for example, it might contain mutually contradictory attributes. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformCannotChangeMediaTypeWhileProcessing"/></strong></dt> </dl> </td><td> <p> The MFT cannot switch types while processing data. Try draining or flushing the MFT. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> You must set the output types before setting the input types. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedD3DType"/></strong></dt> </dl> </td><td> <p> The MFT could not find a suitable DirectX Video Acceleration (DXVA) configuration. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method can be used to set, test without setting, or clear the media type:</p><ul> <li> To set the media type, set <em>dwFlags</em> to zero and set <em>pType</em> to a non-<strong><c>null</c></strong> reference that specifies the media type. </li> <li> To test the media type without setting it, set <em>dwFlags</em> to <strong><see cref="SharpDX.MediaFoundation.MftSetTypeFlags.MftSetTypeTestOnly"/></strong> and set <em>pType</em> to a non-<strong><c>null</c></strong> reference that specifies the media type. If the media type is acceptable, the method return <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidMediaType"/></strong>. Regardless of the return value, the current media type does not change. </li> <li> To clear the media type, set <em>pType</em> to <strong><c>null</c></strong>. </li> </ul><p> Setting the media type on one stream may change the acceptable types on another stream. </p><p> An MFT may require the caller to set one or more output types before setting the input type. If so, the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong>. </p><p> If the MFT supports DirectX Video Acceleration (DXVA) but is unable to find a suitable DXVA configuration (for example, if the graphics driver does not have the right capabilities), the method should return <strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedD3DType"/></strong>. For more information, see Supporting DXVA 2.0 in Media Foundation. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTSetInputType</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::SetInputType']/*"/>	
        /// <msdn-id>ms700113</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::SetInputType([In] unsigned int dwInputStreamID,[In, Optional] IMFMediaType* pType,[In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IMFTransform::SetInputType</unmanaged-short>	
        public void SetInputType(int dwInputStreamID, SharpDX.MediaFoundation.MediaType typeRef, int dwFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamID, (void*)((typeRef == null) ? IntPtr.Zero : typeRef.NativePointer), dwFlags, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets, tests, or clears the media type for an output stream on this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="dwOutputStreamID"><dd> <p> Output stream identifier. To get the list of stream identifiers, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamIDs"/></strong>. </p> </dd></param>	
        /// <param name="typeRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface, or <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="dwFlags"><dd> <p> Zero or more flags from the <strong>_MFT_SET_TYPE_FLAGS</strong> enumeration. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidMediaType"/></strong></dt> </dl> </td><td> <p> The transform cannot use the proposed media type. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidType"/></strong></dt> </dl> </td><td> <p> The proposed type is not valid. This error code indicates that the media type itself is not configured correctly; for example, it might contain mutually contradictory flags. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformCannotChangeMediaTypeWhileProcessing"/></strong></dt> </dl> </td><td> <p> The MFT cannot switch types while processing data. Try draining or flushing the MFT. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> You must set the input types before setting the output types. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedD3DType"/></strong></dt> </dl> </td><td> <p> The MFT could not find a suitable DirectX Video Acceleration (DXVA) configuration. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method can be used to set, test without setting, or clear the media type:</p><ul> <li> To set the media type, set <em>dwFlags</em> to zero and set <em>pType</em> to a non-<strong><c>null</c></strong> reference that specifies the media type. </li> <li> To test the media type without setting it, set <em>dwFlags</em> to <strong><see cref="SharpDX.MediaFoundation.MftSetTypeFlags.MftSetTypeTestOnly"/></strong> and set <em>pType</em> to a non-<strong><c>null</c></strong> reference that specifies the media type. If the media type is acceptable, the method return <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidMediaType"/></strong>. Regardless of the return value, the current media type does not change. </li> <li> To clear the media type, set <em>pType</em> to <strong><c>null</c></strong>. </li> </ul><p> Setting the media type on one stream may change the acceptable types on another stream. </p><p> An MFT may require the caller to set one or more input types before setting the output type. If so, the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong>. </p><p>If the MFT supports DirectX Video Acceleration (DXVA) but is unable to find a suitable DXVA configuration (for example, if the graphics driver does not have the right capabilities), the method should return <strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedD3DType"/></strong>. For more information, see Supporting DXVA 2.0 in Media Foundation.</p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTSetOutputType</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::SetOutputType']/*"/>	
        /// <msdn-id>ms702016</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::SetOutputType([In] unsigned int dwOutputStreamID,[In, Optional] IMFMediaType* pType,[In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IMFTransform::SetOutputType</unmanaged-short>	
        public void SetOutputType(int dwOutputStreamID, SharpDX.MediaFoundation.MediaType typeRef, int dwFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputStreamID, (void*)((typeRef == null) ? IntPtr.Zero : typeRef.NativePointer), dwFlags, ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the current media type for an input stream on this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="dwInputStreamID"><dd> <p> Input stream identifier. To get the list of stream identifiers, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamIDs"/></strong>. </p> </dd></param>	
        /// <param name="typeOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> The input media type has not been set. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If the specified input stream does not yet have a media type, the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong>. Most MFTs do not set any default media types when first created. Instead, the client must set the media type by calling <strong><see cref="SharpDX.MediaFoundation.Transform.SetInputType"/></strong>. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetInputCurrentType</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::GetInputCurrentType']/*"/>	
        /// <msdn-id>ms705607</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::GetInputCurrentType([In] unsigned int dwInputStreamID,[Out] IMFMediaType** ppType)</unmanaged>	
        /// <unmanaged-short>IMFTransform::GetInputCurrentType</unmanaged-short>	
        public void GetInputCurrentType(int dwInputStreamID, out SharpDX.MediaFoundation.MediaType typeOut)
        {
            unsafe
            {
                IntPtr typeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamID, &typeOut_, ((void**)(*(void**)_nativePointer))[17]);
                typeOut = (typeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(typeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the current media type for an output stream on this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="dwOutputStreamID"><dd> <p> Output stream identifier. To get the list of stream identifiers, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamIDs"/></strong>. </p> </dd></param>	
        /// <param name="typeOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> The output media type has not been set. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If the specified output stream does not yet have a media type, the method returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong>. Most MFTs do not set any default media types when first created. Instead, the client must set the media type by calling <strong><see cref="SharpDX.MediaFoundation.Transform.SetOutputType"/></strong>. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetOutputCurrentType</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::GetOutputCurrentType']/*"/>	
        /// <msdn-id>ms696985</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::GetOutputCurrentType([In] unsigned int dwOutputStreamID,[Out] IMFMediaType** ppType)</unmanaged>	
        /// <unmanaged-short>IMFTransform::GetOutputCurrentType</unmanaged-short>	
        public void GetOutputCurrentType(int dwOutputStreamID, out SharpDX.MediaFoundation.MediaType typeOut)
        {
            unsafe
            {
                IntPtr typeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwOutputStreamID, &typeOut_, ((void**)(*(void**)_nativePointer))[18]);
                typeOut = (typeOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.MediaType(typeOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Queries whether an input stream on this Media Foundation transform (MFT) can accept more data. </p>	
        /// </summary>	
        /// <param name="dwInputStreamID"><dd> <p> Input stream identifier. To get the list of stream identifiers, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamIDs"/></strong>. </p> </dd></param>	
        /// <param name="dwFlagsRef"><dd> <p> Receives a member of the <strong>_MFT_INPUT_STATUS_FLAGS</strong> enumeration, or zero. If the value is <strong><see cref="SharpDX.MediaFoundation.MftInputStatusFlags.MftInputStatusAcceptData"/></strong>, the stream specified in <em>dwInputStreamID</em> can accept more input data. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> The media type is not set on one or more streams. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If the method returns the <strong><see cref="SharpDX.MediaFoundation.MftInputStatusFlags.MftInputStatusAcceptData"/></strong> flag, you can deliver an input sample to the specified stream by calling <strong><see cref="SharpDX.MediaFoundation.Transform.ProcessInput"/></strong>. If the method succeeds but does not return any flags in the <em>pdwFlags</em> parameter, it means the input stream already has as much data as it can accept. </p><p> Use this method to test whether the input stream is ready to accept more data, without incurring the overhead of allocating a new sample and calling <strong>ProcessInput</strong>. </p><p> After the client has set valid media types on all of the streams, the MFT should always be in one of two states: Able to accept more input, or able to produce more output (or both). </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetInputStatus</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::GetInputStatus']/*"/>	
        /// <msdn-id>ms697478</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::GetInputStatus([In] unsigned int dwInputStreamID,[Out] unsigned int* pdwFlags)</unmanaged>	
        /// <unmanaged-short>IMFTransform::GetInputStatus</unmanaged-short>	
        public void GetInputStatus(int dwInputStreamID, out int dwFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwFlagsRef_ = &dwFlagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamID, dwFlagsRef_, ((void**)(*(void**)_nativePointer))[19]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Queries whether the Media Foundation transform (MFT) is ready to produce output data. </p>	
        /// </summary>	
        /// <param name="dwFlagsRef"><dd> <p> Receives a member of the <strong>_MFT_OUTPUT_STATUS_FLAGS</strong> enumeration, or zero. If the value is <strong><see cref="SharpDX.MediaFoundation.MftOutputStatusFlags.MftOutputStatusSampleReady"/></strong>, the MFT can produce an output sample. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> Not implemented. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> The media type is not set on one or more streams. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If the method returns the <strong><see cref="SharpDX.MediaFoundation.MftOutputStatusFlags.MftOutputStatusSampleReady"/></strong> flag, it means you can generate one or more output samples by calling <strong><see cref="SharpDX.MediaFoundation.Transform.ProcessOutput"/></strong>. </p><p> MFTs are not required to implement this method. If the method returns <strong>E_NOTIMPL</strong>, you must call <strong>ProcessOutput</strong> to determine whether the transform has output data. </p><p> If the MFT has more than one output stream, but it does not produce samples at the same time for each stream, it can set the <strong><see cref="SharpDX.MediaFoundation.MftOutputStatusFlags.MftOutputStatusSampleReady"/></strong> flag when just one stream is ready. However, if the MFT normally produces samples at the same time for each output stream, it should not set this flag until all streams are ready. </p><p> After the client has set valid media types on all of the streams, the MFT should always be in one of two states: Able to accept more input, or able to produce more output. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetOutputStatus</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::GetOutputStatus']/*"/>	
        /// <msdn-id>ms696269</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::GetOutputStatus([Out] unsigned int* pdwFlags)</unmanaged>	
        /// <unmanaged-short>IMFTransform::GetOutputStatus</unmanaged-short>	
        internal void GetOutputStatus(out int dwFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwFlagsRef_ = &dwFlagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwFlagsRef_, ((void**)(*(void**)_nativePointer))[20]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the range of time stamps the client needs for output. </p>	
        /// </summary>	
        /// <param name="hnsLowerBound"><dd> <p> Specifies the earliest time stamp. The Media Foundation transform (MFT) will accept input until it can produce an output sample that begins at this time; or until it can produce a sample that ends at this time or later. If there is no lower bound, use the value <strong>MFT_OUTPUT_BOUND_LOWER_UNBOUNDED</strong>. </p> </dd></param>	
        /// <param name="hnsUpperBound"><dd> <p> Specifies the latest time stamp. The MFT will not produce an output sample with time stamps later than this time. If there is no upper bound, use the value <strong>MFT_OUTPUT_BOUND_UPPER_UNBOUNDED</strong>. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> Not implemented. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> The media type is not set on one or more streams. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> This method can be used to optimize preroll, especially in formats that have gaps between time stamps, or formats where the data must start on a sync point, such as MPEG-2. Calling this method is optional, and implementation of this method by an MFT is optional. If the MFT does not implement the method, the return value is <strong>E_NOTIMPL</strong>.</p><p> If an MFT implements this method, it must limit its output data to the range of times specified by <em>hnsLowerBound</em> and <em>hnsUpperBound</em>. The MFT discards any input data that is not needed to produce output within this range. If the sample boundaries do not exactly match the range, the MFT should split the output samples, if possible. Otherwise, the output samples can overlap the range. </p><p> For example, suppose the output range is 100 to 150 milliseconds (ms), and the output format is video with each frame lasting 33 ms. A sample with a time stamp of 67 ms overlaps the range (67 + 33 = 100) and is produced as output. A sample with a time stamp of  66 ms is discarded (66 + 33 = 99). Similarly, a sample with a time stamp of 150 ms is produced as output, but a sample with a time stamp of 151 is discarded.</p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTSetOutputBounds</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::SetOutputBounds']/*"/>	
        /// <msdn-id>ms693812</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::SetOutputBounds([In] longlong hnsLowerBound,[In] longlong hnsUpperBound)</unmanaged>	
        /// <unmanaged-short>IMFTransform::SetOutputBounds</unmanaged-short>	
        public void SetOutputBounds(long hnsLowerBound, long hnsUpperBound)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, hnsLowerBound, hnsUpperBound, ((void**)(*(void**)_nativePointer))[21]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sends an event to an input stream on this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="dwInputStreamID"><dd> <p> Input stream identifier. To get the list of stream identifiers, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamIDs"/></strong>. </p> </dd></param>	
        /// <param name="eventRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaEvent"/></strong> interface of an event object. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> Not implemented. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream number. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> The media type is not set on one or more streams. </p> </td></tr> <tr><td> <dl> <dt><strong>MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT</strong></dt> </dl> </td><td> <p> The pipeline should not propagate the event. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> An MFT can handle sending the event downstream, or it can let the pipeline do this, as indicated by the return value: </p><ul> <li><strong>E_NOTIMPL</strong>: The MFT ignores all events, and the pipeline should send all events downstream. After the pipeline receives this return value, it might not call <strong>ProcessEvent</strong> again. </li> <li><strong><see cref="SharpDX.Result.Ok"/></strong>: The MFT has examined this event, but the pipeline should send the event downstream. Internally, the MFT might respond to the event in some way, or it might ignore the event. </li> <li><strong>MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT</strong>: The pipeline should not propagate this event downstream. Either the MFT will send the event downstream, or else the MFT will consume the event and not send it downstream. The MFT should only consume the event if the event should stop at this MFT and not travel any further downstream. But in most cases, the event should travel downstream. </li> </ul><p> To send the event downstream, the MFT adds the event to the collection object that is provided by the client in the <strong>pEvents</strong> member of the <strong><see cref="SharpDX.MediaFoundation.TOutputDataBuffer"/></strong> structure, when the client calls <strong><see cref="SharpDX.MediaFoundation.Transform.ProcessOutput"/></strong>. </p><p> Events must be serialized with the samples that come before and after them. Attach the event to the output sample that follows the event. (The pipeline will process the event first, and then the sample.) If an MFT holds back one or more samples between calls to <strong><see cref="SharpDX.MediaFoundation.Transform.ProcessInput"/></strong> and <strong>ProcessOutput</strong>, the MFT should handle sending all events downstream, because in this situation the pipeline cannot correlate input samples with output samples. </p><p> If an MFT does not hold back samples and does not need to examine any events, it can return <strong>E_NOTIMPL</strong>. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTProcessEvent</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::ProcessEvent']/*"/>	
        /// <msdn-id>ms695394</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::ProcessEvent([In] unsigned int dwInputStreamID,[In, Optional] IMFMediaEvent* pEvent)</unmanaged>	
        /// <unmanaged-short>IMFTransform::ProcessEvent</unmanaged-short>	
        public void ProcessEvent(int dwInputStreamID, SharpDX.MediaFoundation.MediaEvent eventRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamID, (void*)((eventRef == null) ? IntPtr.Zero : eventRef.NativePointer), ((void**)(*(void**)_nativePointer))[22]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sends a message to the Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="eMessage"><dd> <p> The message to send, specified as a member of the <strong><see cref="SharpDX.MediaFoundation.TMessageType"/></strong> enumeration. </p> </dd></param>	
        /// <param name="ulParam"><dd> <p> Message parameter. The meaning of this parameter depends on the message type. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream number. Applies to the <strong><see cref="SharpDX.MediaFoundation.TMessageType.NotifyEndOfStream"/></strong> message. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> The media type is not set on one or more streams. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> Before calling this method, set the media types on all input and output streams. </p><p> The MFT might ignore certain message types. If so, the method returns <strong><see cref="SharpDX.Result.Ok"/></strong>. An error code indicates that the transform handles this message type but was unable to process the message in this instance. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTProcessMessage</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::ProcessMessage']/*"/>	
        /// <msdn-id>ms701863</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::ProcessMessage([In] MFT_MESSAGE_TYPE eMessage,[In] ULONG_PTR ulParam)</unmanaged>	
        /// <unmanaged-short>IMFTransform::ProcessMessage</unmanaged-short>	
        public void ProcessMessage(SharpDX.MediaFoundation.TMessageType eMessage, System.IntPtr ulParam)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)eMessage), (void*)ulParam, ((void**)(*(void**)_nativePointer))[23]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Delivers data to an input stream on this Media Foundation transform (MFT). </p>	
        /// </summary>	
        /// <param name="dwInputStreamID"><dd> <p> Input stream identifier. To get the list of stream identifiers, call <strong><see cref="SharpDX.MediaFoundation.Transform.GetStreamIDs"/></strong>. </p> </dd></param>	
        /// <param name="sampleRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface of the input sample. The sample must contain at least one media buffer that contains valid input data. </p> </dd></param>	
        /// <param name="dwFlags"><dd> <p> Reserved. Must be zero. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> Invalid argument. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoSampleDuration"/></strong></dt> </dl> </td><td> <p>The input sample requires a valid sample duration. To set the duration, call <strong><see cref="SharpDX.MediaFoundation.Sample.SetSampleDuration"/></strong>. </p> <p>Some MFTs require that input samples have valid durations. Some MFTs do not require sample durations.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NoSampleTimestamp"/></strong></dt> </dl> </td><td> <p>The input sample requires a time stamp. To set the time stamp, call <strong><see cref="SharpDX.MediaFoundation.Sample.SetSampleTime"/></strong>. </p> <p>Some MFTs require that input samples have valid time stamps. Some MFTs do not require time stamps.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotAccepting"/></strong></dt> </dl> </td><td> <p> The transform cannot process more input at this time. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> The media type is not set on one or more streams. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.UnsupportedD3DType"/></strong></dt> </dl> </td><td> <p> The media type is not supported for DirectX Video Acceleration (DXVA). A DXVA-enabled decoder might return this error code. </p> </td></tr> </table><p>?</p><strong>Note</strong>??If you are converting a DirectX Media Object (DMO) to an MFT, be aware that <strong>S_FALSE</strong> is not a valid return code for <strong><see cref="SharpDX.MediaFoundation.Transform.ProcessInput"/></strong>, unlike the <strong><see cref="SharpDX.MediaFoundation.IMediaObject.ProcessInput"/></strong> method.?</returns>	
        /// <remarks>	
        /// <p> In most cases, if the method succeeds, the MFT stores the sample and holds a reference count on the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> reference. Do not re-use the sample until the MFT releases the sample. Instead of storing the sample, however, an MFT might copy the sample data into a new buffer. In that case, the MFT should set the <strong><see cref="SharpDX.MediaFoundation.MftInputStreamInformationFlags.MftInputStreamDoesNotAddref"/></strong> flag in the <strong><see cref="SharpDX.MediaFoundation.Transform.GetInputStreamInfo"/></strong> method. </p><p> If the MFT already has enough input data to produce an output sample, it does not accept new input data, and <strong>ProcessInput</strong> returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.NotAccepting"/></strong>. At that point, the client should clear the pending input data by doing one of the following: </p><ul> <li> Generate new output by calling <strong><see cref="SharpDX.MediaFoundation.Transform.ProcessOutput"/></strong>. </li> <li> Flush the input data by calling <strong><see cref="SharpDX.MediaFoundation.Transform.ProcessMessage"/></strong> with the MFT_<strong>MESSAGE_COMMAND_FLUSH</strong> message. </li> </ul><p> An exception to this rule is the <strong><see cref="SharpDX.MediaFoundation.MftOutputStreamInformationFlags.MftOutputStreamLazyRead"/></strong> flag. When this flag is present, the transform will discard stored samples if you give it more input. For more information, see <strong><see cref="SharpDX.MediaFoundation.Transform.GetOutputStreamInfo"/></strong>. A transform should never queue any more input data than is required to produce the correct output. </p><p> An MFT can process the input data in the <strong>ProcessInput</strong> method. However, most MFTs wait until the client calls <strong>ProcessOutput</strong>. </p><p> After the client has set valid media types on all of the streams, the MFT should always be in one of two states: Able to accept more input, or able to produce more output. It should never be in both states or neither state. An MFT should only accept as much input as it needs to generate at least one output sample, at which point <strong>ProcessInput</strong> returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.NotAccepting"/></strong>. When <strong>ProcessInput</strong> returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.NotAccepting"/></strong>, the client can assume that the MFT is ready to produce output. </p><p> If an MFT encounters a non-fatal error in the input data, it can simply drop the data and attempt to recover when it gets the more input data. To request more input data, the MFT returns <strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformNeedMoreInput"/></strong> from the <strong><see cref="SharpDX.MediaFoundation.Transform.ProcessOutput"/></strong> method. If the MFT drops any data, it should set the <strong><see cref="SharpDX.MediaFoundation.SampleAttributeKeys.Discontinuity"/></strong> attribute attribute on the next output sample, to notify the caller that there is a gap in the data stream. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTProcessInput</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::ProcessInput']/*"/>	
        /// <msdn-id>ms703131</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::ProcessInput([In] unsigned int dwInputStreamID,[In] IMFSample* pSample,[In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IMFTransform::ProcessInput</unmanaged-short>	
        public void ProcessInput(int dwInputStreamID, SharpDX.MediaFoundation.Sample sampleRef, int dwFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwInputStreamID, (void*)((sampleRef == null) ? IntPtr.Zero : sampleRef.NativePointer), dwFlags, ((void**)(*(void**)_nativePointer))[24]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Generates output from the current input data. </p>	
        /// </summary>	
        /// <param name="dwFlags"><dd> <p> Bitwise <strong>OR</strong> of zero or more flags from the <strong>_MFT_PROCESS_OUTPUT_FLAGS</strong> enumeration. </p> </dd></param>	
        /// <param name="cOutputBufferCount"><dd> <p> Number of elements in the <em>pOutputSamples</em> array. The value must be at least 1. </p> </dd></param>	
        /// <param name="outputSamplesRef"><dd> <p> Pointer to an array of <strong><see cref="SharpDX.MediaFoundation.TOutputDataBuffer"/></strong> structures, allocated by the caller. The MFT uses this array to return output data to the caller. </p> </dd></param>	
        /// <param name="dwStatusRef"><dd> <p> Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong>_MFT_PROCESS_OUTPUT_STATUS</strong> enumeration. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_UNEXPECTED</strong></dt> </dl> </td><td> <p>The <strong>ProcessOutput</strong> method was called on an asynchronous MFT that was not expecting this method call.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier in the <strong>dwStreamID</strong> member of one or more <strong><see cref="SharpDX.MediaFoundation.TOutputDataBuffer"/></strong> structures. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformNeedMoreInput"/></strong></dt> </dl> </td><td> <p> The transform cannot produce output data until it receives more input data. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformStreamChange"/></strong></dt> </dl> </td><td> <p> The format has changed on an output stream, or there is a new preferred format, or there is a new output stream. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> You must set the media type on one or more streams of the MFT. </p> </td></tr> </table><p>?</p><strong>Note</strong>??If you are converting a DirectX Media Object (DMO) to an MFT, be aware that <strong>S_FALSE</strong> is not a valid return code for <strong><see cref="SharpDX.MediaFoundation.Transform.ProcessOutput"/></strong>, unlike the <strong><see cref="SharpDX.MediaFoundation.IMediaObject.ProcessOutput"/></strong> method.?</returns>	
        /// <remarks>	
        /// <p> The size of the <em>pOutputSamples</em> array must be equal to or greater than the number of <em>selected</em> output streams. The number of selected output streams equals the total number of output streams minus the number of <em>deselected</em> streams. A stream is deselected if it has the <strong><see cref="SharpDX.MediaFoundation.MftOutputStreamInformationFlags.MftOutputStreamOptional"/></strong> flag and the caller does not set a media type (or sets the media type to <strong><c>null</c></strong>). For more information, see <strong>_MFT_OUTPUT_STREAM_INFO_FLAGS</strong> enumeration. </p><p>This method generates output samples and can also generate events. If the method succeeds, at least one of the following conditions is true:</p><ul> <li> One or more samples in the <em>pOutputSamples</em> array contains output data. </li> <li> One or more members of the <em>pOutputSamples</em> array contains a non-empty collection of events. </li> </ul><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including Mftransform.h, this method is renamed <strong>MFTProcessOutput</strong>. See Creating Hybrid DMO/MFT Objects.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTransform::ProcessOutput']/*"/>	
        /// <msdn-id>ms704014</msdn-id>	
        /// <unmanaged>HRESULT IMFTransform::ProcessOutput([In] _MFT_PROCESS_OUTPUT_FLAGS dwFlags,[In] unsigned int cOutputBufferCount,[In] MFT_OUTPUT_DATA_BUFFER* pOutputSamples,[Out] _MFT_PROCESS_OUTPUT_STATUS* pdwStatus)</unmanaged>	
        /// <unmanaged-short>IMFTransform::ProcessOutput</unmanaged-short>	
        internal SharpDX.Result ProcessOutput(SharpDX.MediaFoundation.TransformProcessOutputFlags dwFlags, int cOutputBufferCount, SharpDX.MediaFoundation.TOutputDataBuffer outputSamplesRef, out SharpDX.MediaFoundation.TransformProcessOutputStatus dwStatusRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwStatusRef_ = &dwStatusRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)dwFlags), cOutputBufferCount, &outputSamplesRef, dwStatusRef_, ((void**)(*(void**)_nativePointer))[25]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p> Implemented by components that provide input trust authorities (ITAs). This interface is used to get the ITA for each of the component's streams. </p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTrustedInput']/*"/>	
    /// <msdn-id>ms697279</msdn-id>	
    /// <unmanaged>IMFTrustedInput</unmanaged>	
    /// <unmanaged-short>IMFTrustedInput</unmanaged-short>	
    [Guid("542612C4-A1B8-4632-B521-DE11EA64A0B0")]
    public partial class TrustedInput : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TrustedInput"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TrustedInput(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TrustedInput"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TrustedInput(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TrustedInput(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Retrieves the input trust authority (ITA) for a specified stream.</p>	
        /// </summary>	
        /// <param name="dwStreamID"><dd> <p>The stream identifier for which the ITA is being requested.</p> </dd></param>	
        /// <param name="riid"><dd> <p>The interface identifier (IID) of the interface being requested. Currently the only supported value is IID_IMFInputTrustAuthority.</p> </dd></param>	
        /// <param name="unkObjectOut"><dd> <p>Receives a reference to the ITA's <strong><see cref="SharpDX.ComObject"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOINTERFACE</strong></dt> </dl> </td><td> <p>The ITA does not expose the requested interface.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTrustedInput::GetInputTrustAuthority']/*"/>	
        /// <msdn-id>bb970501</msdn-id>	
        /// <unmanaged>HRESULT IMFTrustedInput::GetInputTrustAuthority([In] unsigned int dwStreamID,[In] const GUID&amp; riid,[Out] IUnknown** ppunkObject)</unmanaged>	
        /// <unmanaged-short>IMFTrustedInput::GetInputTrustAuthority</unmanaged-short>	
        public void GetInputTrustAuthority(int dwStreamID, System.Guid riid, out SharpDX.ComObject unkObjectOut)
        {
            unsafe
            {
                IntPtr unkObjectOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamID, &riid, &unkObjectOut_, ((void**)(*(void**)_nativePointer))[3]);
                unkObjectOut = (unkObjectOut_ == IntPtr.Zero) ? null : new SharpDX.ComObject(unkObjectOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Implemented by components that provide output trust authorities (OTAs). Any Media Foundation transform (MFT) or media sink that is designed to work within the protected media path (PMP) and also sends protected content outside the Media Foundation pipeline must implement this interface.</p><p>The policy engine uses this interface to negotiate what type of content protection should be applied to the content. Applications do not use this interface directly.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If an MFT supports <strong><see cref="SharpDX.MediaFoundation.TrustedOutput"/></strong>, it must expose the interface through <strong>QueryInterface</strong>. The interface applies to all of the input streams on the MFT. (There is no mechanism to return a separate <strong><see cref="SharpDX.MediaFoundation.TrustedOutput"/></strong> reference for each stream.) The MFT must apply the  output policies to all of its input streams. If the MFT sends different streams to separate connectors, it must report all of the connector attributes.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTrustedOutput']/*"/>	
    /// <msdn-id>ms694305</msdn-id>	
    /// <unmanaged>IMFTrustedOutput</unmanaged>	
    /// <unmanaged-short>IMFTrustedOutput</unmanaged-short>	
    [Guid("D19F8E95-B126-4446-890C-5DCB7AD71453")]
    public partial class TrustedOutput : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TrustedOutput"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TrustedOutput(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TrustedOutput"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TrustedOutput(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TrustedOutput(nativePointer);
        }


        /// <summary>	
        /// <p> Gets the number of output trust authorities (OTAs) provided by this trusted output. Each OTA reports a single action.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTrustedOutput::GetOutputTrustAuthorityCount']/*"/>	
        /// <msdn-id>bb970384</msdn-id>	
        /// <unmanaged>GetOutputTrustAuthorityCount</unmanaged>	
        /// <unmanaged-short>GetOutputTrustAuthorityCount</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTrustedOutput::GetOutputTrustAuthorityCount([Out] unsigned int* pcOutputTrustAuthorities)</unmanaged>
        public int OutputTrustAuthorityCount
        {
            get { int __output__; GetOutputTrustAuthorityCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Queries whether this output is a policy sink, meaning it handles the rights and restrictions required by the input trust authority (ITA).</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>A trusted output is generally considered to be a policy sink if it does not pass the media content that it receives anywhere else; or, if it does pass the media content elsewhere, either it protects the content using some proprietary method such as encryption, or it sufficiently devalues the content so as not to require protection.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTrustedOutput::IsFinal']/*"/>	
        /// <msdn-id>bb970324</msdn-id>	
        /// <unmanaged>IsFinal</unmanaged>	
        /// <unmanaged-short>IsFinal</unmanaged-short>	
        /// <unmanaged>HRESULT IMFTrustedOutput::IsFinal([Out] BOOL* pfIsFinal)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsFinal
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; IsFinal_(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Gets the number of output trust authorities (OTAs) provided by this trusted output. Each OTA reports a single action.</p>	
        /// </summary>	
        /// <param name="cOutputTrustAuthoritiesRef"><dd> <p> Receives the number of OTAs. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTrustedOutput::GetOutputTrustAuthorityCount']/*"/>	
        /// <msdn-id>bb970384</msdn-id>	
        /// <unmanaged>HRESULT IMFTrustedOutput::GetOutputTrustAuthorityCount([Out] unsigned int* pcOutputTrustAuthorities)</unmanaged>	
        /// <unmanaged-short>IMFTrustedOutput::GetOutputTrustAuthorityCount</unmanaged-short>	
        internal void GetOutputTrustAuthorityCount(out int cOutputTrustAuthoritiesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cOutputTrustAuthoritiesRef_ = &cOutputTrustAuthoritiesRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cOutputTrustAuthoritiesRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets an output trust authority (OTA), specified by index.</p>	
        /// </summary>	
        /// <param name="dwIndex"><dd> <p> Zero-based index of the OTA to retrieve. To get the number of OTAs provided by this object, call <strong><see cref="SharpDX.MediaFoundation.TrustedOutput.GetOutputTrustAuthorityCount"/></strong>. </p> </dd></param>	
        /// <param name="authorityOut"><dd> <p> Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.OutputTrustAuthority"/></strong> interface of the OTA. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTrustedOutput::GetOutputTrustAuthorityByIndex']/*"/>	
        /// <msdn-id>bb970401</msdn-id>	
        /// <unmanaged>HRESULT IMFTrustedOutput::GetOutputTrustAuthorityByIndex([In] unsigned int dwIndex,[Out] IMFOutputTrustAuthority** ppauthority)</unmanaged>	
        /// <unmanaged-short>IMFTrustedOutput::GetOutputTrustAuthorityByIndex</unmanaged-short>	
        public void GetOutputTrustAuthorityByIndex(int dwIndex, out SharpDX.MediaFoundation.OutputTrustAuthority authorityOut)
        {
            unsafe
            {
                IntPtr authorityOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwIndex, &authorityOut_, ((void**)(*(void**)_nativePointer))[4]);
                authorityOut = (authorityOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.OutputTrustAuthority(authorityOut_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Queries whether this output is a policy sink, meaning it handles the rights and restrictions required by the input trust authority (ITA).</p>	
        /// </summary>	
        /// <param name="fIsFinalRef"><dd> <p>Receives a Boolean value. If <strong>TRUE</strong>, this object is a policy sink. If <strong><see cref="SharpDX.Result.False"/></strong>, the policy must be enforced further downstream.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>A trusted output is generally considered to be a policy sink if it does not pass the media content that it receives anywhere else; or, if it does pass the media content elsewhere, either it protects the content using some proprietary method such as encryption, or it sufficiently devalues the content so as not to require protection.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFTrustedOutput::IsFinal']/*"/>	
        /// <msdn-id>bb970324</msdn-id>	
        /// <unmanaged>HRESULT IMFTrustedOutput::IsFinal([Out] BOOL* pfIsFinal)</unmanaged>	
        /// <unmanaged-short>IMFTrustedOutput::IsFinal</unmanaged-short>	
        internal void IsFinal_(out SharpDX.Mathematics.Interop.RawBool fIsFinalRef)
        {
            unsafe
            {
                fIsFinalRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fIsFinalRef_ = &fIsFinalRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fIsFinalRef_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Limits the effective video resolution. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This method limits the effective resolution of the video image. The actual resolution on the target device might be higher, due to stretching the image.</p><p>The EVR might call this method at any time if the <strong><see cref="SharpDX.MediaFoundation.TrustedVideoPlugin.CanConstrict"/></strong> method returns <strong>TRUE</strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEVRTrustedVideoPlugin']/*"/>	
    /// <msdn-id>aa473833</msdn-id>	
    /// <unmanaged>IEVRTrustedVideoPlugin</unmanaged>	
    /// <unmanaged-short>IEVRTrustedVideoPlugin</unmanaged-short>	
    [Guid("83A4CE40-7710-494b-A893-A472049AF630")]
    public partial class TrustedVideoPlugin : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.TrustedVideoPlugin"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TrustedVideoPlugin(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.TrustedVideoPlugin"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.TrustedVideoPlugin(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.TrustedVideoPlugin(nativePointer);
        }


        /// <summary>	
        /// <p> Limits the effective video resolution. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method limits the effective resolution of the video image. The actual resolution on the target device might be higher, due to stretching the image.</p><p>The EVR might call this method at any time if the <strong><see cref="SharpDX.MediaFoundation.TrustedVideoPlugin.CanConstrict"/></strong> method returns <strong>TRUE</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEVRTrustedVideoPlugin::SetConstriction']/*"/>	
        /// <msdn-id>aa473833</msdn-id>	
        /// <unmanaged>SetConstriction</unmanaged>	
        /// <unmanaged-short>SetConstriction</unmanaged-short>	
        /// <unmanaged>HRESULT IEVRTrustedVideoPlugin::SetConstriction([In] unsigned int dwKPix)</unmanaged>
        public int Constriction
        {
            set { SetConstriction(value); }
        }

        /// <summary>	
        /// <p> Queries whether the plug-in has any transient vulnerabilities at this time. </p>	
        /// </summary>	
        /// <param name="yesRef"><dd> <p>Receives a Boolean value. If <strong>TRUE</strong>, the plug-in has no transient vulnerabilities at the moment and can receive protected content. If <strong><see cref="SharpDX.Result.False"/></strong>, the plug-in has a transient vulnerability. If the method fails, the EVR treats the value as <strong><see cref="SharpDX.Result.False"/></strong> (untrusted).</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method provides a way for the plug-in to report temporary conditions that would cause the input trust authority (ITA) to distrust the plug-in. For example, if an EVR presenter is in windowed mode, it is vulnerable to GDI screen captures.</p><p>To disable screen capture in Direct3D, the plug-in must do the following:</p><ul> <li> <p>Create the Direct3D device in full-screen exlusive mode.</p> </li> <li> <p>Specify the D3DCREATE_DISABLE_PRINTSCREEN flag when you create the device. For more information, see <strong>IDirect3D9::CreateDevice</strong> in the DirectX documentation.</p> </li> </ul><p>In addition, the graphics adapter must support the Windows Vista Display Driver Model (WDDM) and the Direct3D extensions for Windows Vista (sometimes called D3D9Ex or D3D9L).</p><p>If these conditions are met, the presenter can return <strong>TRUE</strong> in the <em>pYes</em> parameter. Otherwise, it should return <strong><see cref="SharpDX.Result.False"/></strong>.</p><p>The EVR calls this method whenever the device changes. If the plug-in returns <strong><see cref="SharpDX.Result.False"/></strong>, the EVR treats this condition as if the plug-in had a new output connector of unknown type. The policy object can then allow or block playback, depending on the ITA's policy.</p><p>This method should be used only to report transient conditions. A plug-in that is never in a trusted state should not implement the <strong><see cref="SharpDX.MediaFoundation.TrustedVideoPlugin"/></strong> interface at all.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEVRTrustedVideoPlugin::IsInTrustedVideoMode']/*"/>	
        /// <msdn-id>aa473794</msdn-id>	
        /// <unmanaged>HRESULT IEVRTrustedVideoPlugin::IsInTrustedVideoMode([In] BOOL* pYes)</unmanaged>	
        /// <unmanaged-short>IEVRTrustedVideoPlugin::IsInTrustedVideoMode</unmanaged-short>	
        public void IsInTrustedVideoMode(SharpDX.Mathematics.Interop.RawBool yesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &yesRef, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Queries whether the plug-in can limit the effective video resolution. </p>	
        /// </summary>	
        /// <param name="yesRef"><dd> <p>Receives a Boolean value. If <strong>TRUE</strong>, the plug-in can limit the effective video resolution. Otherwise, the plug-in cannot limit the video resolution. If the method fails, the EVR treats the value as <strong><see cref="SharpDX.Result.False"/></strong> (not supported).</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Constriction is a protection mechanism that limits the effective resolution of the video frame to a specified maximum number of pixels.</p><p>Video constriction can be implemented by either the mixer or the presenter.</p><p>If the method returns <strong>TRUE</strong>, the EVR might call <strong><see cref="SharpDX.MediaFoundation.TrustedVideoPlugin.SetConstriction"/></strong> at any time.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEVRTrustedVideoPlugin::CanConstrict']/*"/>	
        /// <msdn-id>aa473782</msdn-id>	
        /// <unmanaged>HRESULT IEVRTrustedVideoPlugin::CanConstrict([In] BOOL* pYes)</unmanaged>	
        /// <unmanaged-short>IEVRTrustedVideoPlugin::CanConstrict</unmanaged-short>	
        public void CanConstrict(SharpDX.Mathematics.Interop.RawBool yesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &yesRef, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Limits the effective video resolution. </p>	
        /// </summary>	
        /// <param name="dwKPix"><dd> <p>Maximum number of source pixels that may appear in the final video image, in thousands of pixels. If the value is zero, the video is disabled. If the value is MAXDWORD (0xFFFFFFFF), video constriction is removed and the video may be rendered at full resolution.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method limits the effective resolution of the video image. The actual resolution on the target device might be higher, due to stretching the image.</p><p>The EVR might call this method at any time if the <strong><see cref="SharpDX.MediaFoundation.TrustedVideoPlugin.CanConstrict"/></strong> method returns <strong>TRUE</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEVRTrustedVideoPlugin::SetConstriction']/*"/>	
        /// <msdn-id>aa473833</msdn-id>	
        /// <unmanaged>HRESULT IEVRTrustedVideoPlugin::SetConstriction([In] unsigned int dwKPix)</unmanaged>	
        /// <unmanaged-short>IEVRTrustedVideoPlugin::SetConstriction</unmanaged-short>	
        internal void SetConstriction(int dwKPix)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwKPix, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Enables or disables the ability of the plug-in to export the video image. </p>	
        /// </summary>	
        /// <param name="bDisable"><dd> <p>Boolean value. Specify <strong>TRUE</strong> to disable image exporting, or <strong><see cref="SharpDX.Result.False"/></strong> to enable it.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>An EVR plug-in might expose a way for the application to get a copy of the video frames. For example, the standard EVR presenter implements <strong><see cref="SharpDX.MediaFoundation.VideoDisplayControl.GetCurrentImage"/></strong>.</p><p>If the plug-in supports image exporting, this method enables or disables it. Before this method has been called for the first time, the EVR assumes that the mechanism is enabled.</p><p>If the plug-in does not support image exporting, this method should return <see cref="SharpDX.Result.Ok"/> and ignore the value of <em>bDisable</em>. If the method fails, the EVR treats it as a failure to enforce the policy, which will probably cause playback to stop.</p><p>While image exporting is disabled, any associated export method, such as <strong>GetCurrentImage</strong>, should return <see cref="SharpDX.MediaFoundation.ResultCode.LicenseIncorrectRights"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IEVRTrustedVideoPlugin::DisableImageExport']/*"/>	
        /// <msdn-id>aa473830</msdn-id>	
        /// <unmanaged>HRESULT IEVRTrustedVideoPlugin::DisableImageExport([In] BOOL bDisable)</unmanaged>	
        /// <unmanaged-short>IEVRTrustedVideoPlugin::DisableImageExport</unmanaged-short>	
        public void DisableImageExport(SharpDX.Mathematics.Interop.RawBool bDisable)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint6(_nativePointer, bDisable, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Returns the device identifier supported by a video renderer component. This interface is implemented by mixers and presenters for the enhanced video renderer (EVR). If you replace either of these components, the mixer and presenter must report the same device identifier.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDeviceID']/*"/>	
    /// <msdn-id>ms703065</msdn-id>	
    /// <unmanaged>IMFVideoDeviceID</unmanaged>	
    /// <unmanaged-short>IMFVideoDeviceID</unmanaged-short>	
    [Guid("A38D9567-5A9C-4f3c-B293-8EB415B279BA")]
    public partial class VideoDeviceID : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.VideoDeviceID"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoDeviceID(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.VideoDeviceID"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.VideoDeviceID(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.VideoDeviceID(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Returns the identifier of the video device supported by an EVR mixer or presenter.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If a mixer or presenter uses Direct3D 9, it must return the value IID_IDirect3DDevice9 in <em>pDeviceID</em>. The EVR's default mixer and presenter both return this value. If you write a custom mixer or presenter, it can return some other value. However, the mixer and presenter must use matching device identifiers.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDeviceID::GetDeviceID']/*"/>	
        /// <msdn-id>ms704630</msdn-id>	
        /// <unmanaged>GetDeviceID</unmanaged>	
        /// <unmanaged-short>GetDeviceID</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoDeviceID::GetDeviceID([Out] GUID* pDeviceID)</unmanaged>
        public System.Guid DeviceID
        {
            get { System.Guid __output__; GetDeviceID(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> </p><p>Returns the identifier of the video device supported by an EVR mixer or presenter.</p>	
        /// </summary>	
        /// <param name="deviceIDRef"><dd> <p>Receives the device identifier. Generally, the value is IID_IDirect3DDevice9.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If a mixer or presenter uses Direct3D 9, it must return the value IID_IDirect3DDevice9 in <em>pDeviceID</em>. The EVR's default mixer and presenter both return this value. If you write a custom mixer or presenter, it can return some other value. However, the mixer and presenter must use matching device identifiers.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDeviceID::GetDeviceID']/*"/>	
        /// <msdn-id>ms704630</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDeviceID::GetDeviceID([Out] GUID* pDeviceID)</unmanaged>	
        /// <unmanaged-short>IMFVideoDeviceID::GetDeviceID</unmanaged-short>	
        internal void GetDeviceID(out System.Guid deviceIDRef)
        {
            unsafe
            {
                deviceIDRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* deviceIDRef_ = &deviceIDRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, deviceIDRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Controls how the Enhanced Video Renderer (EVR) displays video.</p><p>The EVR presenter implements this interface. To get a reference to the interface, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong>. The service identifier is <see cref="System.Guid"/> MR_VIDEO_RENDER_SERVICE. Call <strong>GetService</strong> on any of the following objects:</p><ul> <li> The Media Session, if the topology contains an instance of the EVR. </li> <li>The EVR media sink. </li> <li>The DirectShow EVR filter. </li> <li>The EVR presenter. </li> </ul><p>If you implement a custom presenter for the EVR, the presenter can optionally expose this interface as a service.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl']/*"/>	
    /// <msdn-id>ms704002</msdn-id>	
    /// <unmanaged>IMFVideoDisplayControl</unmanaged>	
    /// <unmanaged-short>IMFVideoDisplayControl</unmanaged-short>	
    [Guid("a490b1e4-ab84-4d31-a1b2-181e03b1077a")]
    public partial class VideoDisplayControl : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.VideoDisplayControl"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoDisplayControl(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.VideoDisplayControl"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.VideoDisplayControl(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.VideoDisplayControl(nativePointer);
        }


        /// <summary>	
        /// <p> Queries how the enhanced video renderer (EVR) handles the aspect ratio of the source video. </p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::GetAspectRatioMode']/*"/>	
        /// <msdn-id>ms702253</msdn-id>	
        /// <unmanaged>GetAspectRatioMode / SetAspectRatioMode</unmanaged>	
        /// <unmanaged-short>GetAspectRatioMode</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::GetAspectRatioMode([Out] unsigned int* pdwAspectRatioMode)</unmanaged>
        public int AspectRatioMode
        {
            get { int __output__; GetAspectRatioMode(out __output__); return __output__; }
            set { SetAspectRatioMode(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the clipping window for the video. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>There is no default clipping window. The application must set the clipping window.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::GetVideoWindow']/*"/>	
        /// <msdn-id>ms694138</msdn-id>	
        /// <unmanaged>GetVideoWindow / SetVideoWindow</unmanaged>	
        /// <unmanaged-short>GetVideoWindow</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::GetVideoWindow([Out] HWND* phwndVideo)</unmanaged>
        public System.IntPtr VideoWindow
        {
            get { System.IntPtr __output__; GetVideoWindow(out __output__); return __output__; }
            set { SetVideoWindow(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the border color for the video. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The border color is used for areas where the enhanced video renderer (EVR) does not draw any video.</p><p>The border color is not used for letterboxing. To get the letterbox color, call <strong>IMFVideoProcessor::GetBackgroundColor</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::GetBorderColor']/*"/>	
        /// <msdn-id>ms694894</msdn-id>	
        /// <unmanaged>GetBorderColor / SetBorderColor</unmanaged>	
        /// <unmanaged-short>GetBorderColor</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::GetBorderColor([Out] COLORREF* pClr)</unmanaged>
        public int BorderColor
        {
            get { int __output__; GetBorderColor(out __output__); return __output__; }
            set { SetBorderColor(value); }
        }

        /// <summary>	
        /// <p>Gets or sets various video rendering settings. </p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::GetRenderingPrefs']/*"/>	
        /// <msdn-id>ms701592</msdn-id>	
        /// <unmanaged>GetRenderingPrefs / SetRenderingPrefs</unmanaged>	
        /// <unmanaged-short>GetRenderingPrefs</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::GetRenderingPrefs([Out] unsigned int* pdwRenderFlags)</unmanaged>
        public int RenderingPrefs
        {
            get { int __output__; GetRenderingPrefs(out __output__); return __output__; }
            set { SetRenderingPrefs(value); }
        }

        /// <summary>	
        /// <p> Queries whether the enhanced video renderer (EVR) is currently in full-screen mode. </p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::GetFullscreen']/*"/>	
        /// <msdn-id>ms704817</msdn-id>	
        /// <unmanaged>GetFullscreen / SetFullscreen</unmanaged>	
        /// <unmanaged-short>GetFullscreen</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::GetFullscreen([Out] BOOL* pfFullscreen)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool Fullscreen
        {
            get { SharpDX.Mathematics.Interop.RawBool __output__; GetFullscreen(out __output__); return __output__; }
            set { SetFullscreen(value); }
        }

        /// <summary>	
        /// <p> Gets the size and aspect ratio of the video, prior to any stretching by the video renderer. </p>	
        /// </summary>	
        /// <param name="szVideoRef"><dd> <p>Receives the size of the native video rectangle. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="szARVideoRef"><dd> <p>Receives the aspect ratio of the video. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>At least one of the parameters must be non-<strong><c>null</c></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If no media types have been set on any video streams, the method succeeds but all parameters are set to zero.</p><p>You can set <em>pszVideo</em> or <em>pszARVideo</em> to <strong><c>null</c></strong>, but not both.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::GetNativeVideoSize']/*"/>	
        /// <msdn-id>ms694294</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::GetNativeVideoSize([InOut, Optional] SIZE* pszVideo,[InOut, Optional] SIZE* pszARVideo)</unmanaged>	
        /// <unmanaged-short>IMFVideoDisplayControl::GetNativeVideoSize</unmanaged-short>	
        public void GetNativeVideoSize(System.IntPtr szVideoRef, System.IntPtr szARVideoRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szVideoRef, (void*)szARVideoRef, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the range of sizes that the enhanced video renderer (EVR) can display without significantly degrading performance or image quality. </p>	
        /// </summary>	
        /// <param name="szMinRef"><dd> <p>Receives the minimum ideal size. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="szMaxRef"><dd> <p>Receives the maximum ideal size. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>At least one parameter must be non-<strong><c>null</c></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You can set <em>pszMin</em> or <em>pszMax</em> to <strong><c>null</c></strong>, but not both.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::GetIdealVideoSize']/*"/>	
        /// <msdn-id>ms703076</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::GetIdealVideoSize([InOut, Optional] SIZE* pszMin,[InOut, Optional] SIZE* pszMax)</unmanaged>	
        /// <unmanaged-short>IMFVideoDisplayControl::GetIdealVideoSize</unmanaged-short>	
        public void GetIdealVideoSize(System.IntPtr szMinRef, System.IntPtr szMaxRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)szMinRef, (void*)szMaxRef, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the source and destination rectangles for the video.</p>	
        /// </summary>	
        /// <param name="nrcSourceRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure that specifies the source rectangle. This parameter can be <strong><c>null</c></strong>. If this parameter is <strong><c>null</c></strong>, the source rectangle does not change.</p> </dd></param>	
        /// <param name="rcDestRef"><dd> <p>Specifies the destination rectangle. This parameter can be <strong><c>null</c></strong>. If this parameter is <strong><c>null</c></strong>, the destination rectangle does not change.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>At least one parameter must be non-<strong><c>null</c></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The source rectangle defines which portion of the video is displayed. It is specified in <em>normalized</em> coordinates. For more information, see <strong><see cref="SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure. To display the entire video image, set the source rectangle to {0, 0, 1, 1}. The default source rectangle is {0, 0, 1, 1}.</p><p>The destination rectangle defines a rectangle within the clipping window where the video appears. It is specified in pixels, relative to the client area of the window. To fill the entire window, set the destination rectangle to {0, 0, <em>width</em>, <em>height</em>}, where <em>width</em> and <em>height</em> are dimensions of the window client area. The default destination rectangle is {0, 0, 0, 0}.</p><p>To update just one of these rectangles, set the other parameter to <strong><c>null</c></strong>. You can set <em>pnrcSource</em> or <em>prcDest</em> to <strong><c>null</c></strong>, but not both.</p><p>Before setting the destination rectangle (<em>prcDest</em>), you must set the video window by calling <strong><see cref="SharpDX.MediaFoundation.VideoDisplayControl.SetVideoWindow"/></strong>. (For the Media Foundation version of the EVR, you can also provide the video window in the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateVideoRendererActivate"/></strong> function.) If no video window was provided, <strong>SetVideoPosition</strong> returns E_POINTER.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::SetVideoPosition']/*"/>	
        /// <msdn-id>ms697352</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::SetVideoPosition([In, Optional] const MFVideoNormalizedRect* pnrcSource,[In, Optional] const RECT* prcDest)</unmanaged>	
        /// <unmanaged-short>IMFVideoDisplayControl::SetVideoPosition</unmanaged-short>	
        public void SetVideoPosition(SharpDX.MediaFoundation.VideoNormalizedRect? nrcSourceRef, SharpDX.Mathematics.Interop.RawRectangle? rcDestRef)
        {
            unsafe
            {
                SharpDX.MediaFoundation.VideoNormalizedRect nrcSourceRef_;
                if (nrcSourceRef.HasValue)
                    nrcSourceRef_ = nrcSourceRef.Value;
                SharpDX.Mathematics.Interop.RawRectangle rcDestRef_;
                if (rcDestRef.HasValue)
                    rcDestRef_ = rcDestRef.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (nrcSourceRef.HasValue) ? &nrcSourceRef_ : (void*)IntPtr.Zero, (rcDestRef.HasValue) ? &rcDestRef_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the source and destination rectangles for the video. </p>	
        /// </summary>	
        /// <param name="nrcSourceRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure that receives the source rectangle.</p> </dd></param>	
        /// <param name="rcDestRef"><dd> <p>Receives the current destination rectangle.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>One or more required parameters are <strong><c>null</c></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::GetVideoPosition']/*"/>	
        /// <msdn-id>bb970409</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::GetVideoPosition([Out] MFVideoNormalizedRect* pnrcSource,[Out] RECT* prcDest)</unmanaged>	
        /// <unmanaged-short>IMFVideoDisplayControl::GetVideoPosition</unmanaged-short>	
        public void GetVideoPosition(out SharpDX.MediaFoundation.VideoNormalizedRect nrcSourceRef, out SharpDX.Mathematics.Interop.RawRectangle rcDestRef)
        {
            unsafe
            {
                nrcSourceRef = new SharpDX.MediaFoundation.VideoNormalizedRect();
                rcDestRef = new SharpDX.Mathematics.Interop.RawRectangle();
                SharpDX.Result __result__;
                fixed (void* nrcSourceRef_ = &nrcSourceRef)
                fixed (void* rcDestRef_ = &rcDestRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, nrcSourceRef_, rcDestRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Specifies how the enhanced video renderer (EVR) handles the aspect ratio of the source video.</p>	
        /// </summary>	
        /// <param name="dwAspectRatioMode"><dd> <p>Bitwise <strong>OR</strong> of one or more flags from the <strong><see cref="SharpDX.MediaFoundation.VideoAspectRatioMode"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid flags.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::SetAspectRatioMode']/*"/>	
        /// <msdn-id>ms704027</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::SetAspectRatioMode([In] unsigned int dwAspectRatioMode)</unmanaged>	
        /// <unmanaged-short>IMFVideoDisplayControl::SetAspectRatioMode</unmanaged-short>	
        internal void SetAspectRatioMode(int dwAspectRatioMode)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwAspectRatioMode, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Queries how the enhanced video renderer (EVR) handles the aspect ratio of the source video. </p>	
        /// </summary>	
        /// <param name="dwAspectRatioModeRef"><dd> <p>Receives a bitwise <strong>OR</strong> of one or more flags from the <strong><see cref="SharpDX.MediaFoundation.VideoAspectRatioMode"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::GetAspectRatioMode']/*"/>	
        /// <msdn-id>ms702253</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::GetAspectRatioMode([Out] unsigned int* pdwAspectRatioMode)</unmanaged>	
        /// <unmanaged-short>IMFVideoDisplayControl::GetAspectRatioMode</unmanaged-short>	
        internal void GetAspectRatioMode(out int dwAspectRatioModeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwAspectRatioModeRef_ = &dwAspectRatioModeRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwAspectRatioModeRef_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the source and destination rectangles for the video.</p>	
        /// </summary>	
        /// <param name="hwndVideo"><dd> <p>Pointer to an <strong><see cref="SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure that specifies the source rectangle. This parameter can be <strong><c>null</c></strong>. If this parameter is <strong><c>null</c></strong>, the source rectangle does not change.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>At least one parameter must be non-<strong><c>null</c></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The source rectangle defines which portion of the video is displayed. It is specified in <em>normalized</em> coordinates. For more information, see <strong><see cref="SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure. To display the entire video image, set the source rectangle to {0, 0, 1, 1}. The default source rectangle is {0, 0, 1, 1}.</p><p>The destination rectangle defines a rectangle within the clipping window where the video appears. It is specified in pixels, relative to the client area of the window. To fill the entire window, set the destination rectangle to {0, 0, <em>width</em>, <em>height</em>}, where <em>width</em> and <em>height</em> are dimensions of the window client area. The default destination rectangle is {0, 0, 0, 0}.</p><p>To update just one of these rectangles, set the other parameter to <strong><c>null</c></strong>. You can set <em>pnrcSource</em> or <em>prcDest</em> to <strong><c>null</c></strong>, but not both.</p><p>Before setting the destination rectangle (<em>prcDest</em>), you must set the video window by calling <strong><see cref="SharpDX.MediaFoundation.VideoDisplayControl.SetVideoWindow"/></strong>. (For the Media Foundation version of the EVR, you can also provide the video window in the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateVideoRendererActivate"/></strong> function.) If no video window was provided, <strong>SetVideoPosition</strong> returns E_POINTER.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::SetVideoWindow']/*"/>	
        /// <msdn-id>ms697352</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::SetVideoWindow([In] HWND hwndVideo)</unmanaged>	
        /// <unmanaged-short>IMFVideoDisplayControl::SetVideoWindow</unmanaged-short>	
        internal void SetVideoWindow(System.IntPtr hwndVideo)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)hwndVideo, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the clipping window for the video. </p>	
        /// </summary>	
        /// <param name="hwndVideoRef"><dd> <p>Receives a handle to the window where the enhanced video renderer (EVR) will draw the video.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>There is no default clipping window. The application must set the clipping window.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::GetVideoWindow']/*"/>	
        /// <msdn-id>ms694138</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::GetVideoWindow([Out] HWND* phwndVideo)</unmanaged>	
        /// <unmanaged-short>IMFVideoDisplayControl::GetVideoWindow</unmanaged-short>	
        internal void GetVideoWindow(out System.IntPtr hwndVideoRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* hwndVideoRef_ = &hwndVideoRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, hwndVideoRef_, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Repaints the current video frame. Call this method whenever the application receives a WM_PAINT message.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The EVR cannot repaint the frame at this time. This error can occur while the EVR is switching between full-screen and windowed mode. The caller can safely ignore this error.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::RepaintVideo']/*"/>	
        /// <msdn-id>ms703113</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::RepaintVideo()</unmanaged>	
        /// <unmanaged-short>IMFVideoDisplayControl::RepaintVideo</unmanaged-short>	
        public void RepaintVideo()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets a copy of the current image being displayed by the video renderer. </p>	
        /// </summary>	
        /// <param name="bihRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.Win32.BitmapInfoHeader"/></strong> structure that receives a description of the bitmap. Set the <strong>biSize</strong> member of the structure to <code>sizeof(<see cref="SharpDX.Win32.BitmapInfoHeader"/>)</code> before calling the method.</p> </dd></param>	
        /// <param name="dibRef"><dd> <p>Receives a reference to a buffer that contains a packed Windows device-independent bitmap (DIB). The caller must free the memory for the bitmap by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>	
        /// <param name="cbDibRef"><dd> <p>Receives the size of the buffer returned in <em>pDib</em>, in bytes.</p> </dd></param>	
        /// <param name="timeStampRef"><dd> <p>Receives the time stamp of the captured image.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.LicenseIncorrectRights"/></strong></dt> </dl> </td><td> <p>The content is protected and the license does not permit capturing the image.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method can be called at any time. However, calling the method too frequently degrades the video playback performance.</p><p>This method retrieves a copy of the final composited image, which includes any substreams, alpha-blended bitmap, aspect ratio correction, background color, and so forth.</p><p>In windowed mode, the bitmap is the size of the destination rectangle specified in <strong><see cref="SharpDX.MediaFoundation.VideoDisplayControl.SetVideoPosition"/></strong>. In full-screen mode, the bitmap is the size of the display.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::GetCurrentImage']/*"/>	
        /// <msdn-id>ms695342</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::GetCurrentImage([InOut] BITMAPINFOHEADER* pBih,[Buffer, Optional] unsigned char** pDib,[Out] unsigned int* pcbDib,[InOut, Optional] longlong* pTimeStamp)</unmanaged>	
        /// <unmanaged-short>IMFVideoDisplayControl::GetCurrentImage</unmanaged-short>	
        public void GetCurrentImage(ref SharpDX.Win32.BitmapInfoHeader bihRef, byte[] dibRef, out int cbDibRef, System.IntPtr timeStampRef)
        {
            unsafe
            {
                byte[] dibRef__ = dibRef;
                SharpDX.Result __result__;
                fixed (void* bihRef_ = &bihRef)
                fixed (void* dibRef_ = dibRef__)
                fixed (void* cbDibRef_ = &cbDibRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, bihRef_, dibRef_, cbDibRef_, (void*)timeStampRef, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets the border color for the video.</p>	
        /// </summary>	
        /// <param name="clr"><dd> <p>Specifies the border color as a <strong><see cref="int"/></strong> value.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>By default, if the video window straddles two monitors, the enhanced video renderer (EVR) clips the video to one monitor and draws the border color on the remaining portion of the window. (To change the clipping behavior, call <strong><see cref="SharpDX.MediaFoundation.VideoDisplayControl.SetRenderingPrefs"/></strong>.)</p><p>The border color is not used for letterboxing. To change the letterbox color, call <strong>IMFVideoProcessor::SetBackgroundColor</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::SetBorderColor']/*"/>	
        /// <msdn-id>ms697024</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::SetBorderColor([In] COLORREF Clr)</unmanaged>	
        /// <unmanaged-short>IMFVideoDisplayControl::SetBorderColor</unmanaged-short>	
        internal void SetBorderColor(int clr)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, clr, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the border color for the video. </p>	
        /// </summary>	
        /// <param name="clrRef"><dd> <p>Receives the border color, as a <strong><see cref="int"/></strong> value.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The border color is used for areas where the enhanced video renderer (EVR) does not draw any video.</p><p>The border color is not used for letterboxing. To get the letterbox color, call <strong>IMFVideoProcessor::GetBackgroundColor</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::GetBorderColor']/*"/>	
        /// <msdn-id>ms694894</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::GetBorderColor([Out] COLORREF* pClr)</unmanaged>	
        /// <unmanaged-short>IMFVideoDisplayControl::GetBorderColor</unmanaged-short>	
        internal void GetBorderColor(out int clrRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* clrRef_ = &clrRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, clrRef_, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Sets various preferences related to video rendering.</p>	
        /// </summary>	
        /// <param name="dwRenderFlags"><dd> <p>Bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.VideoRenderPrefs"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid flags.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::SetRenderingPrefs']/*"/>	
        /// <msdn-id>ms698981</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::SetRenderingPrefs([In] unsigned int dwRenderFlags)</unmanaged>	
        /// <unmanaged-short>IMFVideoDisplayControl::SetRenderingPrefs</unmanaged-short>	
        internal void SetRenderingPrefs(int dwRenderFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwRenderFlags, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets various video rendering settings. </p>	
        /// </summary>	
        /// <param name="dwRenderFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.VideoRenderPrefs"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::GetRenderingPrefs']/*"/>	
        /// <msdn-id>ms701592</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::GetRenderingPrefs([Out] unsigned int* pdwRenderFlags)</unmanaged>	
        /// <unmanaged-short>IMFVideoDisplayControl::GetRenderingPrefs</unmanaged-short>	
        internal void GetRenderingPrefs(out int dwRenderFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwRenderFlagsRef_ = &dwRenderFlagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwRenderFlagsRef_, ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[This API is not supported and may be altered or unavailable in the future. ]</p><p> Sets or unsets full-screen rendering mode.</p><p>To implement full-screen playback, an application should simply resize the video window to cover the entire area of the monitor. Also set the window to be a topmost window, so that the application receives all mouse-click messages. For more information about topmost windows, see the documentation for the <strong>SetWindowPos</strong> function.</p>	
        /// </summary>	
        /// <param name="fFullscreen">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p> The video renderer has been shut down. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> The default EVR presenter implements full-screen mode using Direct3D exclusive mode. </p><p> If you use this  method  to switch to full-screen mode, set the application window to be a topmost window and resize the window to cover the entire monitor. This ensures that the application window receives all mouse-click messages. Also set the keyboard focus to the application window. When you switch out of full-screen mode, restore the window's original size and position. </p><p> By default, the cursor is still visible in full-screen mode. To hide the cursor, call <strong>ShowCursor</strong>. </p><p>The transition to and from full-screen mode occurs asynchronously. To get the current mode, call <strong><see cref="SharpDX.MediaFoundation.VideoDisplayControl.GetFullscreen"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::SetFullscreen']/*"/>	
        /// <msdn-id>ms701561</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::SetFullscreen([In] BOOL fFullscreen)</unmanaged>	
        /// <unmanaged-short>IMFVideoDisplayControl::SetFullscreen</unmanaged-short>	
        internal void SetFullscreen(SharpDX.Mathematics.Interop.RawBool fFullscreen)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint6(_nativePointer, fFullscreen, ((void**)(*(void**)_nativePointer))[17]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Queries whether the enhanced video renderer (EVR) is currently in full-screen mode. </p>	
        /// </summary>	
        /// <param name="fFullscreenRef"><dd> <p>Receives a Boolean value. If <strong>TRUE</strong>, the EVR is in full-screen mode. If <strong><see cref="SharpDX.Result.False"/></strong>, the EVR will display the video inside the application-provided clipping window.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The EVR is currently switching between full-screen and windowed mode.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoDisplayControl::GetFullscreen']/*"/>	
        /// <msdn-id>ms704817</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoDisplayControl::GetFullscreen([Out] BOOL* pfFullscreen)</unmanaged>	
        /// <unmanaged-short>IMFVideoDisplayControl::GetFullscreen</unmanaged-short>	
        internal void GetFullscreen(out SharpDX.Mathematics.Interop.RawBool fFullscreenRef)
        {
            unsafe
            {
                fFullscreenRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fFullscreenRef_ = &fFullscreenRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, fFullscreenRef_, ((void**)(*(void**)_nativePointer))[18]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a description of a video format.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If the major type of a media type is <see cref="SharpDX.MediaFoundation.MediaTypeGuids.Video"/>, you can query the media type object for the <strong><see cref="SharpDX.MediaFoundation.VideoMediaType"/></strong> interface.</p><p>Applications should avoid using this interface except when a method or function requires an <strong><see cref="SharpDX.MediaFoundation.VideoMediaType"/></strong> reference as a parameter. You can get all of the format information from a video media type through the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface, which <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> inherits.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoMediaType']/*"/>	
    /// <msdn-id>aa473814</msdn-id>	
    /// <unmanaged>IMFVideoMediaType</unmanaged>	
    /// <unmanaged-short>IMFVideoMediaType</unmanaged-short>	
    [Guid("b99f381f-a8f9-47a2-a5af-ca3a225a3890")]
    public partial class VideoMediaType : SharpDX.MediaFoundation.MediaType
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.VideoMediaType"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoMediaType(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.VideoMediaType"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.VideoMediaType(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.VideoMediaType(nativePointer);
        }


        /// <summary>	
        /// <p>Represents a description of a video format.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If the major type of a media type is <see cref="SharpDX.MediaFoundation.MediaTypeGuids.Video"/>, you can query the media type object for the <strong><see cref="SharpDX.MediaFoundation.VideoMediaType"/></strong> interface.</p><p>Applications should avoid using this interface except when a method or function requires an <strong><see cref="SharpDX.MediaFoundation.VideoMediaType"/></strong> reference as a parameter. You can get all of the format information from a video media type through the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface, which <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> inherits.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoMediaType::GetVideoFormat']/*"/>	
        /// <msdn-id>aa473814</msdn-id>	
        /// <unmanaged>GetVideoFormat</unmanaged>	
        /// <unmanaged-short>GetVideoFormat</unmanaged-short>	
        /// <unmanaged>const MFVIDEOFORMAT* IMFVideoMediaType::GetVideoFormat()</unmanaged>
        public SharpDX.MediaFoundation.VideoFormat VideoFormat
        {
            get { return GetVideoFormat(); }
        }

        /// <summary>	
        /// <p>Represents a description of a video format.</p>	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <remarks>	
        /// <p>If the major type of a media type is <see cref="SharpDX.MediaFoundation.MediaTypeGuids.Video"/>, you can query the media type object for the <strong><see cref="SharpDX.MediaFoundation.VideoMediaType"/></strong> interface.</p><p>Applications should avoid using this interface except when a method or function requires an <strong><see cref="SharpDX.MediaFoundation.VideoMediaType"/></strong> reference as a parameter. You can get all of the format information from a video media type through the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface, which <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> inherits.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoMediaType::GetVideoFormat']/*"/>	
        /// <msdn-id>aa473814</msdn-id>	
        /// <unmanaged>const MFVIDEOFORMAT* IMFVideoMediaType::GetVideoFormat()</unmanaged>	
        /// <unmanaged-short>IMFVideoMediaType::GetVideoFormat</unmanaged-short>	
        internal SharpDX.MediaFoundation.VideoFormat GetVideoFormat()
        {
            unsafe
            {
                SharpDX.MediaFoundation.VideoFormat __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.CalliSharpDXMediaFoundationVideoFormat(_nativePointer, ((void**)(*(void**)_nativePointer))[38]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>[This API is not supported and may be altered or unavailable in the future. Instead, applications should set the <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.DefaultStride"/></strong> attribute on the media type to specify the surface stride and then call <strong><see cref="SharpDX.MediaFoundation.MediaType.GetRepresentation"/></strong>.]</p><p> Retrieves an alternative representation of the media type.</p>	
        /// </summary>	
        /// <param name="guidRepresentation">No documentation.</param>	
        /// <param name="vRepresentationOut">No documentation.</param>	
        /// <param name="lStride">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is equivalent to <strong><see cref="SharpDX.MediaFoundation.MediaType.GetRepresentation"/></strong> but includes the <em>lStride</em> parameter.</p><p>Instead of calling this method, applications should set the <strong><see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.DefaultStride"/></strong> attribute on the media type to specify the surface stride and then call <strong><see cref="SharpDX.MediaFoundation.MediaType.GetRepresentation"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoMediaType::GetVideoRepresentation']/*"/>	
        /// <msdn-id>bb970371</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoMediaType::GetVideoRepresentation([In] GUID guidRepresentation,[Out] void** ppvRepresentation,[In] int lStride)</unmanaged>	
        /// <unmanaged-short>IMFVideoMediaType::GetVideoRepresentation</unmanaged-short>	
        public void GetVideoRepresentation(System.Guid guidRepresentation, out System.IntPtr vRepresentationOut, int lStride)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* vRepresentationOut_ = &vRepresentationOut)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, guidRepresentation, vRepresentationOut_, lStride, ((void**)(*(void**)_nativePointer))[39]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Controls how the Enhanced Video Renderer (EVR) mixes video substreams. Applications can use this interface to control video mixing during playback.</p><p>The EVR mixer implements this interface. To get a reference to the interface, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong>. The service identifier <see cref="System.Guid"/> is MR_VIDEO_MIXER_SERVICE. Call <strong>GetService</strong> on any of the following objects:</p><ul> <li> The Media Session, if the topology contains an instance of the EVR. </li> <li> The EVR media sink. </li> <li> The DirectShow EVR filter. </li> <li> The EVR mixer. </li> </ul><p>If you implement a custom mixer for the EVR, the mixer can optionally expose this interface as a service.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoMixerControl']/*"/>	
    /// <msdn-id>ms700190</msdn-id>	
    /// <unmanaged>IMFVideoMixerControl</unmanaged>	
    /// <unmanaged-short>IMFVideoMixerControl</unmanaged-short>	
    [Guid("A5C6C53F-C202-4aa5-9695-175BA8C508A5")]
    public partial class VideoMixerControl : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.VideoMixerControl"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoMixerControl(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.VideoMixerControl"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.VideoMixerControl(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.VideoMixerControl(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Sets the z-order of a video stream.</p>	
        /// </summary>	
        /// <param name="dwStreamID"><dd> <p>Identifier of the stream. For the EVR media sink, the stream identifier is defined when the <strong><see cref="SharpDX.MediaFoundation.MediaSink.AddStreamSink"/></strong> method is called. For the DirectShow EVR filter, the stream identifier corresponds to the pin index. The reference stream is always stream 0.</p> </dd></param>	
        /// <param name="dwZ"><dd> <p>Z-order value. The z-order of the reference stream must be zero. The maximum z-order value is the number of streams minus one.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The value of <em>dwZ</em> is larger than the maximum z-order value.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid z-order for this stream. For the reference stream, <em>dwZ</em> must be zero. For all other streams, <em>dwZ</em> must be greater than zero.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>Invalid stream identifier.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The EVR draws the video streams in the order of their z-order values, starting with zero. The reference stream must be first in the z-order, and the remaining streams can be in any order.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoMixerControl::SetStreamZOrder']/*"/>	
        /// <msdn-id>ms697453</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoMixerControl::SetStreamZOrder([In] unsigned int dwStreamID,[In] unsigned int dwZ)</unmanaged>	
        /// <unmanaged-short>IMFVideoMixerControl::SetStreamZOrder</unmanaged-short>	
        public void SetStreamZOrder(int dwStreamID, int dwZ)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamID, dwZ, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the z-order of a video stream.</p>	
        /// </summary>	
        /// <param name="dwStreamID"><dd> <p>Identifier of the stream. For the EVR media sink, the stream identifier is defined when the <strong><see cref="SharpDX.MediaFoundation.MediaSink.AddStreamSink"/></strong> method is called. For the DirectShow EVR filter, the stream identifier corresponds to the pin index. The reference stream is always stream 0.</p> </dd></param>	
        /// <param name="dwZRef"><dd> <p>Receives the z-order value.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>Invalid stream identifier.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoMixerControl::GetStreamZOrder']/*"/>	
        /// <msdn-id>ms701614</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoMixerControl::GetStreamZOrder([In] unsigned int dwStreamID,[Out] unsigned int* pdwZ)</unmanaged>	
        /// <unmanaged-short>IMFVideoMixerControl::GetStreamZOrder</unmanaged-short>	
        public void GetStreamZOrder(int dwStreamID, out int dwZRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwZRef_ = &dwZRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamID, dwZRef_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the position of a video stream within the composition rectangle. </p>	
        /// </summary>	
        /// <param name="dwStreamID"><dd> <p>Identifier of the stream. For the EVR media sink, the stream identifier is defined when the <strong><see cref="SharpDX.MediaFoundation.MediaSink.AddStreamSink"/></strong> method is called. For the DirectShow EVR filter, the stream identifier corresponds to the pin index. The reference stream is always stream 0.</p> </dd></param>	
        /// <param name="nrcOutputRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure that defines the bounding rectangle for the video stream.</p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> The coordinates of the bounding rectangle given in <em>pnrcOutput</em> are not valid. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> The mixer draws each video stream inside a bounding rectangle that is specified relative to the final video image. This bounding rectangle is given in <em>normalized</em> coordinates. For more information, see <strong><see cref="SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure. </p><p> The coordinates of the bounding rectangle must fall within the range [0.0, 1.0]. Also, the X and Y coordinates of the upper-left corner cannot exceed the X and Y coordinates of the lower-right corner. In other words, the bounding rectangle must fit entirely within the composition rectangle and cannot be flipped vertically or horizontally. </p><p>The following diagram shows how the EVR mixes substreams.</p><p>The output rectangle for the stream is specified by calling <strong>SetStreamOutputRect</strong>. The source rectangle is specified by calling <strong><see cref="SharpDX.MediaFoundation.VideoDisplayControl.SetVideoPosition"/></strong>. The mixer applies the output rectangle first, when it mixes the streams into a single bounding rectangle. This bounding rectangle is called <em>composition space</em>. Then the presenter applies the source rectangle to the composited image.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoMixerControl::SetStreamOutputRect']/*"/>	
        /// <msdn-id>ms698959</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoMixerControl::SetStreamOutputRect([In] unsigned int dwStreamID,[In] const MFVideoNormalizedRect* pnrcOutput)</unmanaged>	
        /// <unmanaged-short>IMFVideoMixerControl::SetStreamOutputRect</unmanaged-short>	
        public void SetStreamOutputRect(int dwStreamID, SharpDX.MediaFoundation.VideoNormalizedRect nrcOutputRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamID, &nrcOutputRef, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the position of a video stream within the composition rectangle.</p>	
        /// </summary>	
        /// <param name="dwStreamID"><dd> <p>The identifier of the stream. For the EVR media sink, the stream identifier is defined when the <strong><see cref="SharpDX.MediaFoundation.MediaSink.AddStreamSink"/></strong> method is called. For the DirectShow EVR filter, the stream identifier corresponds to the pin index. The reference stream is always stream 0.</p> </dd></param>	
        /// <param name="nrcOutputRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure that receives the bounding rectangle, in normalized coordinates.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>Invalid stream identifier.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoMixerControl::GetStreamOutputRect']/*"/>	
        /// <msdn-id>ms698911</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoMixerControl::GetStreamOutputRect([In] unsigned int dwStreamID,[Out] MFVideoNormalizedRect* pnrcOutput)</unmanaged>	
        /// <unmanaged-short>IMFVideoMixerControl::GetStreamOutputRect</unmanaged-short>	
        public void GetStreamOutputRect(int dwStreamID, out SharpDX.MediaFoundation.VideoNormalizedRect nrcOutputRef)
        {
            unsafe
            {
                nrcOutputRef = new SharpDX.MediaFoundation.VideoNormalizedRect();
                SharpDX.Result __result__;
                fixed (void* nrcOutputRef_ = &nrcOutputRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwStreamID, nrcOutputRef_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Controls preferences for video deinterlacing.</p><p> The default video mixer for the Enhanced Video Renderer (EVR) implements this interface.</p><p>To get a reference to the interface, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> on any of the following objects, using the <strong>MR_VIDEO_MIXER_SERVICE</strong> service identifier:</p><ul> <li>The Media Session, if the topology contains an instance of the EVR.</li> <li>The EVR media sink.</li> <li>The  DirectShow EVR filter.</li> <li>The EVR mixer.</li> </ul>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoMixerControl2']/*"/>	
    /// <msdn-id>dd374894</msdn-id>	
    /// <unmanaged>IMFVideoMixerControl2</unmanaged>	
    /// <unmanaged-short>IMFVideoMixerControl2</unmanaged-short>	
    [Guid("8459616d-966e-4930-b658-54fa7e5a16d3")]
    public partial class VideoMixerControl2 : SharpDX.MediaFoundation.VideoMixerControl
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.VideoMixerControl2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoMixerControl2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.VideoMixerControl2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.VideoMixerControl2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.VideoMixerControl2(nativePointer);
        }


        /// <summary>	
        /// <p>Gets or sets the current preferences for video deinterlacing.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoMixerControl2::GetMixingPrefs']/*"/>	
        /// <msdn-id>dd374896</msdn-id>	
        /// <unmanaged>GetMixingPrefs / SetMixingPrefs</unmanaged>	
        /// <unmanaged-short>GetMixingPrefs</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoMixerControl2::GetMixingPrefs([Out] unsigned int* pdwMixFlags)</unmanaged>
        public int MixingPrefs
        {
            get { int __output__; GetMixingPrefs(out __output__); return __output__; }
            set { SetMixingPrefs(value); }
        }

        /// <summary>	
        /// <p>Sets the preferences for video deinterlacing.</p>	
        /// </summary>	
        /// <param name="dwMixFlags"><dd> <p>Bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.VideoMixPrefs"/></strong> enumeration. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoMixerControl2::SetMixingPrefs']/*"/>	
        /// <msdn-id>dd374898</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoMixerControl2::SetMixingPrefs([In] unsigned int dwMixFlags)</unmanaged>	
        /// <unmanaged-short>IMFVideoMixerControl2::SetMixingPrefs</unmanaged-short>	
        internal void SetMixingPrefs(int dwMixFlags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwMixFlags, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the current preferences for video deinterlacing.</p>	
        /// </summary>	
        /// <param name="dwMixFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="SharpDX.MediaFoundation.VideoMixPrefs"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoMixerControl2::GetMixingPrefs']/*"/>	
        /// <msdn-id>dd374896</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoMixerControl2::GetMixingPrefs([Out] unsigned int* pdwMixFlags)</unmanaged>	
        /// <unmanaged-short>IMFVideoMixerControl2::GetMixingPrefs</unmanaged-short>	
        internal void GetMixingPrefs(out int dwMixFlagsRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwMixFlagsRef_ = &dwMixFlagsRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwMixFlagsRef_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Maps a position on an input video stream to the corresponding position on an output video stream.</p><p>To obtain a reference to this interface, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> on the renderer with the service <see cref="System.Guid"/> MR_VIDEO_RENDER_SERVICE.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoPositionMapper']/*"/>	
    /// <msdn-id>ms695386</msdn-id>	
    /// <unmanaged>IMFVideoPositionMapper</unmanaged>	
    /// <unmanaged-short>IMFVideoPositionMapper</unmanaged-short>	
    [Guid("1F6A9F17-E70B-4e24-8AE4-0B2C3BA7A4AE")]
    public partial class VideoPositionMapper : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.VideoPositionMapper"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoPositionMapper(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.VideoPositionMapper"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.VideoPositionMapper(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.VideoPositionMapper(nativePointer);
        }


        /// <summary>	
        /// <p>Maps output image coordinates to input image coordinates. This method provides the reverse transformation for components that map coordinates on the input image to different coordinates on the output image. </p>	
        /// </summary>	
        /// <param name="xOut"><dd> <p> X-coordinate of the output image, normalized to the range [0...1]. </p> </dd></param>	
        /// <param name="yOut"><dd> <p> Y-coordinate of the output image, normalized to the range [0...1]. </p> </dd></param>	
        /// <param name="dwOutputStreamIndex"><dd> <p> Output stream index for the coordinate mapping. </p> </dd></param>	
        /// <param name="dwInputStreamIndex"><dd> <p> Input stream index for the coordinate mapping. </p> </dd></param>	
        /// <param name="xInRef"><dd> <p> Receives the mapped x-coordinate of the input image, normalized to the range [0...1]. </p> </dd></param>	
        /// <param name="yInRef"><dd> <p> Receives the mapped y-coordinate of the input image, normalized to the range [0...1]. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p> The video renderer has been shut down. </p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>In the following diagram, R(dest) is the destination rectangle for the video. You can obtain this rectangle by calling <strong><see cref="SharpDX.MediaFoundation.VideoDisplayControl.GetVideoPosition"/></strong>. The rectangle R1 is a substream within the video. The point P has pixel coordinates (x,y) relative to R(dest).</p><p></p><p>The position of P relative to R(dest) in <em>normalized</em> coordinates is calculated as follows:</p><code>float xn = float(x + 0.5) / widthDest;	
        /// float xy = float(y + 0.5) / heightDest;	
        /// </code><p>where <em>widthDest</em> and <em>heightDest</em> are the width and height of R(dest) in pixels.</p><p>To calculate the position of P relative to R1, call <strong>MapOutputCoordinateToInputStream</strong> as follows:</p><code>float x1 = 0, y1 = 0;	
        /// hr = pMap-&gt;MapOutputCoordinateToInputStream(xn, yn, 0, dwInputStreamIndex, &amp;x1, &amp;y1);</code><p>The values returned in <em>x1</em> and <em>y1</em> are normalized to the range [0...1]. To convert back to pixel coordinates, scale these values by the size of R1:</p><code>int scaledx = int(floor(x1 * widthR1));	
        /// int scaledy = int(floor(xy * heightR1));</code><p>Note that <em>x1</em> and <em>y1</em> might fall outside the range [0...1] if P lies outside of R1.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoPositionMapper::MapOutputCoordinateToInputStream']/*"/>	
        /// <msdn-id>ms703892</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoPositionMapper::MapOutputCoordinateToInputStream([In] float xOut,[In] float yOut,[In] unsigned int dwOutputStreamIndex,[In] unsigned int dwInputStreamIndex,[Out] float* pxIn,[Out] float* pyIn)</unmanaged>	
        /// <unmanaged-short>IMFVideoPositionMapper::MapOutputCoordinateToInputStream</unmanaged-short>	
        public void MapOutputCoordinateToInputStream(float xOut, float yOut, int dwOutputStreamIndex, int dwInputStreamIndex, out float xInRef, out float yInRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* xInRef_ = &xInRef)
                fixed (void* yInRef_ = &yInRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, xOut, yOut, dwOutputStreamIndex, dwInputStreamIndex, xInRef_, yInRef_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a video presenter. A <em>video presenter</em> is an object that receives video frames, typically from a video mixer, and presents them in some way, typically by rendering them to the display. The enhanced video renderer (EVR) provides a default video presenter, and applications can implement custom presenters.</p><p>The video presenter receives video frames as soon as they are available from upstream. The video presenter is responsible for presenting frames at the correct time and for synchronizing with the presentation clock.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoPresenter']/*"/>	
    /// <msdn-id>ms700214</msdn-id>	
    /// <unmanaged>IMFVideoPresenter</unmanaged>	
    /// <unmanaged-short>IMFVideoPresenter</unmanaged-short>	
    [Guid("29AFF080-182A-4a5d-AF3B-448F3A6346CB")]
    public partial interface VideoPresenter : SharpDX.MediaFoundation.ClockStateSink
    {


        /// <summary>	
        /// <p> </p><p>Sends a message to the video presenter. Messages are used to signal the presenter that it must perform some action, or that some event has occurred.</p>	
        /// </summary>	
        /// <param name="eMessage"><dd> <p>Specifies the message as a member of the <strong><see cref="SharpDX.MediaFoundation.VpMessageType"/></strong> enumeration.</p> </dd></param>	
        /// <param name="ulParam"><dd> <p>Message parameter. The meaning of this parameter depends on the message type.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoPresenter::ProcessMessage']/*"/>	
        /// <msdn-id>bb970573</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoPresenter::ProcessMessage([In] MFVP_MESSAGE_TYPE eMessage,[In] ULONG_PTR ulParam)</unmanaged>	
        /// <unmanaged-short>IMFVideoPresenter::ProcessMessage</unmanaged-short>	
        /* public void ProcessMessage(SharpDX.MediaFoundation.VpMessageType eMessage, System.IntPtr ulParam) */

        /// <summary>	
        /// <p> </p><p>Retrieves the presenter's media type.</p>	
        /// </summary>	
        /// <param name="mediaTypeOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.VideoMediaType"/></strong> interface. The caller must release the interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotInitializeD"/></strong></dt> </dl> </td><td> <p>The media type is not set.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method returns the media type that the presenter sets for the mixer's output type. It describes the format of the composited image.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoPresenter::GetCurrentMediaType']/*"/>	
        /// <msdn-id>ms697032</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoPresenter::GetCurrentMediaType([Out] IMFVideoMediaType** ppMediaType)</unmanaged>	
        /// <unmanaged-short>IMFVideoPresenter::GetCurrentMediaType</unmanaged-short>	
        /* internal void GetCurrentMediaType(out SharpDX.MediaFoundation.VideoMediaType mediaTypeOut) */
    }
    /// <summary>	
    /// <p>Configures the <strong>Video Processor MFT</strong>.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface controls how the <strong>Video Processor MFT</strong> generates output frames.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl']/*"/>	
    /// <msdn-id>hh448069</msdn-id>	
    /// <unmanaged>IMFVideoProcessorControl</unmanaged>	
    /// <unmanaged-short>IMFVideoProcessorControl</unmanaged-short>	
    [Guid("A3F675D5-6119-4f7f-A100-1D8B280F0EFB")]
    public partial class VideoProcessorControl : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.VideoProcessorControl"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoProcessorControl(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.VideoProcessorControl"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.VideoProcessorControl(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.VideoProcessorControl(nativePointer);
        }


        /// <summary>	
        /// <p>Sets the border color.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl::SetBorderColor']/*"/>	
        /// <msdn-id>hh448070</msdn-id>	
        /// <unmanaged>SetBorderColor</unmanaged>	
        /// <unmanaged-short>SetBorderColor</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl::SetBorderColor([In, Optional] MFARGB* pBorderColor)</unmanaged>
        public SharpDX.Mathematics.Interop.RawColorBGRA BorderColor
        {
            set { SetBorderColor(value); }
        }

        /// <summary>	
        /// <p>Sets the source rectangle. The source rectangle is the portion of the input frame that is blitted to the destination surface.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>See <strong>Video Processor MFT</strong> for info regarding source and destination rectangles in the <strong>Video Processor MFT</strong>.   </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl::SetSourceRectangle']/*"/>	
        /// <msdn-id>hh448075</msdn-id>	
        /// <unmanaged>SetSourceRectangle</unmanaged>	
        /// <unmanaged-short>SetSourceRectangle</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl::SetSourceRectangle([In, Optional] RECT* pSrcRect)</unmanaged>
        public SharpDX.Mathematics.Interop.RawRectangle SourceRectangle
        {
            set { SetSourceRectangle(value); }
        }

        /// <summary>	
        /// <p>Sets the destination rectangle. The destination rectangle is the portion of the output surface where the source rectangle is blitted.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>See <strong>Video Processor MFT</strong> for info regarding source and destination rectangles in the <strong>Video Processor MFT</strong>.   </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl::SetDestinationRectangle']/*"/>	
        /// <msdn-id>hh448072</msdn-id>	
        /// <unmanaged>SetDestinationRectangle</unmanaged>	
        /// <unmanaged-short>SetDestinationRectangle</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl::SetDestinationRectangle([In, Optional] RECT* pDstRect)</unmanaged>
        public SharpDX.Mathematics.Interop.RawRectangle DestinationRectangle
        {
            set { SetDestinationRectangle(value); }
        }

        /// <summary>	
        /// <p>Specifies whether to flip the video image.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl::SetMirror']/*"/>	
        /// <msdn-id>hh448073</msdn-id>	
        /// <unmanaged>SetMirror</unmanaged>	
        /// <unmanaged-short>SetMirror</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl::SetMirror([In] MF_VIDEO_PROCESSOR_MIRROR eMirror)</unmanaged>
        public SharpDX.MediaFoundation.VideoProcessorMirror Mirror
        {
            set { SetMirror(value); }
        }

        /// <summary>	
        /// <p>Specifies whether to rotate the video to the correct orientation.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The original orientation of the video is specified by the <see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.VideoRotation"/> attribute of the input media type.</p><p> If <em>eRotation</em> is <strong><see cref="SharpDX.MediaFoundation.VideoProcessorRotation.RotationNone"/></strong>, the video processor does not correct the orientation of the output video. If the original video is rotated, and <em>eRotation</em> is <strong><see cref="SharpDX.MediaFoundation.VideoProcessorRotation.RotationNormal"/></strong>, the video processor corrects the orientation, so that the ouput video is not rotated. The video processor letterboxes the output as needed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl::SetRotation']/*"/>	
        /// <msdn-id>hh448074</msdn-id>	
        /// <unmanaged>SetRotation</unmanaged>	
        /// <unmanaged-short>SetRotation</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl::SetRotation([In] MF_VIDEO_PROCESSOR_ROTATION eRotation)</unmanaged>
        public SharpDX.MediaFoundation.VideoProcessorRotation Rotation
        {
            set { SetRotation(value); }
        }

        /// <summary>	
        /// <p>Specifies the amount of downsampling to perform on the output.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl::SetConstrictionSize']/*"/>	
        /// <msdn-id>hh448071</msdn-id>	
        /// <unmanaged>SetConstrictionSize</unmanaged>	
        /// <unmanaged-short>SetConstrictionSize</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl::SetConstrictionSize([In, Optional] SIZE* pConstrictionSize)</unmanaged>
        public SharpDX.Size2 ConstrictionSize
        {
            set { SetConstrictionSize(value); }
        }

        /// <summary>	
        /// <p>Sets the border color.</p>	
        /// </summary>	
        /// <param name="borderColorRef"><dd> <p>A reference to an <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that specifies the border color as an ARGB (alpha, red, green, blue) value.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl::SetBorderColor']/*"/>	
        /// <msdn-id>hh448070</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl::SetBorderColor([In, Optional] MFARGB* pBorderColor)</unmanaged>	
        /// <unmanaged-short>IMFVideoProcessorControl::SetBorderColor</unmanaged-short>	
        internal void SetBorderColor(SharpDX.Mathematics.Interop.RawColorBGRA? borderColorRef)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawColorBGRA borderColorRef_;
                if (borderColorRef.HasValue)
                    borderColorRef_ = borderColorRef.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (borderColorRef.HasValue) ? &borderColorRef_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the source rectangle. The source rectangle is the portion of the input frame that is blitted to the destination surface.</p>	
        /// </summary>	
        /// <param name="srcRectRef"><dd> <p>A reference to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that specifies the source rectangle.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>See <strong>Video Processor MFT</strong> for info regarding source and destination rectangles in the <strong>Video Processor MFT</strong>.   </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl::SetSourceRectangle']/*"/>	
        /// <msdn-id>hh448075</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl::SetSourceRectangle([In, Optional] RECT* pSrcRect)</unmanaged>	
        /// <unmanaged-short>IMFVideoProcessorControl::SetSourceRectangle</unmanaged-short>	
        internal void SetSourceRectangle(SharpDX.Mathematics.Interop.RawRectangle? srcRectRef)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangle srcRectRef_;
                if (srcRectRef.HasValue)
                    srcRectRef_ = srcRectRef.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (srcRectRef.HasValue) ? &srcRectRef_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the destination rectangle. The destination rectangle is the portion of the output surface where the source rectangle is blitted.</p>	
        /// </summary>	
        /// <param name="dstRectRef"><dd> <p>A reference to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that specifies the destination rectangle.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>See <strong>Video Processor MFT</strong> for info regarding source and destination rectangles in the <strong>Video Processor MFT</strong>.   </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl::SetDestinationRectangle']/*"/>	
        /// <msdn-id>hh448072</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl::SetDestinationRectangle([In, Optional] RECT* pDstRect)</unmanaged>	
        /// <unmanaged-short>IMFVideoProcessorControl::SetDestinationRectangle</unmanaged-short>	
        internal void SetDestinationRectangle(SharpDX.Mathematics.Interop.RawRectangle? dstRectRef)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangle dstRectRef_;
                if (dstRectRef.HasValue)
                    dstRectRef_ = dstRectRef.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (dstRectRef.HasValue) ? &dstRectRef_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Specifies whether to flip the video image.</p>	
        /// </summary>	
        /// <param name="eMirror"><dd> <p>An <strong><see cref="SharpDX.MediaFoundation.VideoProcessorMirror"/></strong> value that specifies whether to flip the video image, either horizontally or vertically.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl::SetMirror']/*"/>	
        /// <msdn-id>hh448073</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl::SetMirror([In] MF_VIDEO_PROCESSOR_MIRROR eMirror)</unmanaged>	
        /// <unmanaged-short>IMFVideoProcessorControl::SetMirror</unmanaged-short>	
        internal void SetMirror(SharpDX.MediaFoundation.VideoProcessorMirror eMirror)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)eMirror), ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Specifies whether to rotate the video to the correct orientation.</p>	
        /// </summary>	
        /// <param name="eRotation"><dd> <p>A <strong><see cref="SharpDX.MediaFoundation.VideoProcessorRotation"/></strong> value that specifies whether to rotate the image.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The original orientation of the video is specified by the <see cref="SharpDX.MediaFoundation.MediaTypeAttributeKeys.VideoRotation"/> attribute of the input media type.</p><p> If <em>eRotation</em> is <strong><see cref="SharpDX.MediaFoundation.VideoProcessorRotation.RotationNone"/></strong>, the video processor does not correct the orientation of the output video. If the original video is rotated, and <em>eRotation</em> is <strong><see cref="SharpDX.MediaFoundation.VideoProcessorRotation.RotationNormal"/></strong>, the video processor corrects the orientation, so that the ouput video is not rotated. The video processor letterboxes the output as needed.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl::SetRotation']/*"/>	
        /// <msdn-id>hh448074</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl::SetRotation([In] MF_VIDEO_PROCESSOR_ROTATION eRotation)</unmanaged>	
        /// <unmanaged-short>IMFVideoProcessorControl::SetRotation</unmanaged-short>	
        internal void SetRotation(SharpDX.MediaFoundation.VideoProcessorRotation eRotation)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, unchecked((int)eRotation), ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Specifies the amount of downsampling to perform on the output.</p>	
        /// </summary>	
        /// <param name="constrictionSizeRef"><dd> <p>The sampling size. To disable constriction, set this parameter to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl::SetConstrictionSize']/*"/>	
        /// <msdn-id>hh448071</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl::SetConstrictionSize([In, Optional] SIZE* pConstrictionSize)</unmanaged>	
        /// <unmanaged-short>IMFVideoProcessorControl::SetConstrictionSize</unmanaged-short>	
        internal void SetConstrictionSize(SharpDX.Size2? constrictionSizeRef)
        {
            unsafe
            {
                SharpDX.Size2 constrictionSizeRef_;
                if (constrictionSizeRef.HasValue)
                    constrictionSizeRef_ = constrictionSizeRef.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (constrictionSizeRef.HasValue) ? &constrictionSizeRef_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Configures the <strong>Video Processor MFT</strong>.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface controls how the <strong>Video Processor MFT</strong> generates output frames.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl2']/*"/>	
    /// <msdn-id>dn800741</msdn-id>	
    /// <unmanaged>IMFVideoProcessorControl2</unmanaged>	
    /// <unmanaged-short>IMFVideoProcessorControl2</unmanaged-short>	
    [Guid("BDE633D3-E1DC-4a7f-A693-BBAE399C4A20")]
    public partial class VideoProcessorControl2 : SharpDX.MediaFoundation.VideoProcessorControl
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.VideoProcessorControl2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoProcessorControl2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.VideoProcessorControl2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.VideoProcessorControl2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.VideoProcessorControl2(nativePointer);
        }


        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Overrides the rotation operation that is performed in the video processor.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl2::SetRotationOverride']/*"/>	
        /// <msdn-id>dn800744</msdn-id>	
        /// <unmanaged>SetRotationOverride</unmanaged>	
        /// <unmanaged-short>SetRotationOverride</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl2::SetRotationOverride([In] unsigned int uiRotation)</unmanaged>
        public int RotationOverride
        {
            set { SetRotationOverride(value); }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Returns the list of supported effects in the currently configured video processor.</p>	
        /// </summary>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl2::GetSupportedHardwareEffects']/*"/>	
        /// <msdn-id>dn800743</msdn-id>	
        /// <unmanaged>GetSupportedHardwareEffects</unmanaged>	
        /// <unmanaged-short>GetSupportedHardwareEffects</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl2::GetSupportedHardwareEffects([Out] unsigned int* puiSupport)</unmanaged>
        public int SupportedHardwareEffects
        {
            get { int __output__; GetSupportedHardwareEffects(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Overrides the rotation operation that is performed in the video processor.</p>	
        /// </summary>	
        /// <param name="uiRotation"><dd>  <p>Rotation value in degrees.  Typically, you can only use values from the <strong><see cref="SharpDX.MediaFoundation.VideoRotationFormat"/></strong> enumeration.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl2::SetRotationOverride']/*"/>	
        /// <msdn-id>dn800744</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl2::SetRotationOverride([In] unsigned int uiRotation)</unmanaged>	
        /// <unmanaged-short>IMFVideoProcessorControl2::SetRotationOverride</unmanaged-short>	
        internal void SetRotationOverride(int uiRotation)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, uiRotation, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Enables effects that were implemented with <strong>IDirectXVideoProcessor::VideoProcessorBlt</strong>. </p>	
        /// </summary>	
        /// <param name="fEnabled">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl2::EnableHardwareEffects']/*"/>	
        /// <msdn-id>dn800742</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl2::EnableHardwareEffects([In] BOOL fEnabled)</unmanaged>	
        /// <unmanaged-short>IMFVideoProcessorControl2::EnableHardwareEffects</unmanaged-short>	
        public void EnableHardwareEffects(SharpDX.Mathematics.Interop.RawBool fEnabled)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint6(_nativePointer, fEnabled, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Returns the list of supported effects in the currently configured video processor.</p>	
        /// </summary>	
        /// <param name="uiSupportRef"><dd>  <p>A combination of <strong><see cref="SharpDX.Direct3D11.VideoProcessorAutoStreamCaps"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies the list of suppported effect capabilities.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoProcessorControl2::GetSupportedHardwareEffects']/*"/>	
        /// <msdn-id>dn800743</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoProcessorControl2::GetSupportedHardwareEffects([Out] unsigned int* puiSupport)</unmanaged>	
        /// <unmanaged-short>IMFVideoProcessorControl2::GetSupportedHardwareEffects</unmanaged-short>	
        internal void GetSupportedHardwareEffects(out int uiSupportRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* uiSupportRef_ = &uiSupportRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, uiSupportRef_, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Sets a new mixer or presenter for the Enhanced Video Renderer (EVR).</p><p>Both the EVR media sink and the DirectShow EVR filter implement this interface. To get a reference to the interface, call <strong>QueryInterface</strong> on the media sink or the filter. Do not use <strong><see cref="SharpDX.MediaFoundation.ServiceProvider"/></strong> to get a reference to this interface.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The EVR activation object returned by the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateVideoRendererActivate"/></strong> function does not expose this interface. Instead, the activation object supports attributes that specify a custom mixer or presenter. For more information, see Enhanced Video Renderer Attributes.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoRenderer']/*"/>	
    /// <msdn-id>ms698954</msdn-id>	
    /// <unmanaged>IMFVideoRenderer</unmanaged>	
    /// <unmanaged-short>IMFVideoRenderer</unmanaged-short>	
    [Guid("DFDFD197-A9CA-43d8-B341-6AF3503792CD")]
    public partial class VideoRenderer : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.VideoRenderer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoRenderer(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.VideoRenderer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.VideoRenderer(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.VideoRenderer(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Sets a new mixer or presenter for the enhanced video renderer (EVR).</p>	
        /// </summary>	
        /// <param name="videoMixerRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.Transform"/></strong> interface of the mixer to use. This parameter can be <strong><c>null</c></strong>. If this parameter is <strong><c>null</c></strong>, the EVR uses its default mixer.</p> </dd></param>	
        /// <param name="videoPresenterRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.VideoPresenter"/></strong> interface of the presenter to use. This parameter can be <strong><c>null</c></strong>. If this parameter is <strong><c>null</c></strong>, the EVR uses its default presenter.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Either the mixer or the presenter is invalid.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/></strong></dt> </dl> </td><td> <p>The mixer and presenter cannot be replaced in the current state. (EVR media sink.)</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> <tr><td> <dl> <dt><strong>VFW_E_WRONG_STATE</strong></dt> </dl> </td><td> <p>One or more input pins are connected. (DirectShow EVR filter.)</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method directly after creating the EVR, before you do any of the following:</p><ul> <li> <p>Call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> on the EVR.</p> </li> <li> <p>Call <strong><see cref="SharpDX.MediaFoundation.FilterConfig.SetNumberOfStreams"/></strong> on the EVR.</p> </li> <li> <p>Connect any pins on the EVR filter, or set any media types on EVR media sink.</p> </li> </ul><p>The EVR filter returns VFW_E_WRONG_STATE if any of the filter's pins are connected. The EVR media sink returns <see cref="SharpDX.MediaFoundation.ResultCode.InvalidRequest"/> if a media type is set on any of the streams, or the presentation clock is running or paused.</p><p>The device identifiers for the mixer and the presenter must match. The <strong><see cref="SharpDX.MediaFoundation.VideoDeviceID.GetDeviceID"/></strong> method returns the device identifier. If they do not match, the method returns E_INVALIDARG.</p><p>If the video renderer is in the protected media path (PMP), the mixer and presenter objects must be certified safe components and pass any trust authority verification that is being enforced. Otherwise, this method will fail.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoRenderer::InitializeRenderer']/*"/>	
        /// <msdn-id>ms704667</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoRenderer::InitializeRenderer([In, Optional] IMFTransform* pVideoMixer,[In, Optional] IMFVideoPresenter* pVideoPresenter)</unmanaged>	
        /// <unmanaged-short>IMFVideoRenderer::InitializeRenderer</unmanaged-short>	
        internal void InitializeRenderer_(SharpDX.MediaFoundation.Transform videoMixerRef, System.IntPtr videoPresenterRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((videoMixerRef == null) ? IntPtr.Zero : videoMixerRef.NativePointer), (void*)videoPresenterRef, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Allocates video samples for a video media sink.</p><p>The stream sinks on the enhanced video renderer (EVR) expose this interface as a service. To obtain a reference to the interface, call <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> using the service identifier <see cref="SharpDX.MediaFoundation.MediaServiceKeys.VideoAcceleration"/>. Custom media sinks can also implement this interface. The Media Session uses this interface to allocate samples for the EVR, unless the upstream decoder supports DirectX Video Acceleration (DXVA).</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoSampleAllocator']/*"/>	
    /// <msdn-id>aa473823</msdn-id>	
    /// <unmanaged>IMFVideoSampleAllocator</unmanaged>	
    /// <unmanaged-short>IMFVideoSampleAllocator</unmanaged-short>	
    [Guid("86cbc910-e533-4751-8e3b-f19b5b806a03")]
    public partial class VideoSampleAllocator : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.VideoSampleAllocator"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoSampleAllocator(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.VideoSampleAllocator"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.VideoSampleAllocator(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.VideoSampleAllocator(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Specifies the Direct3D device manager for the video media sink to use.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The media sink uses the Direct3D device manager to obtain a reference to the Direct3D device, which it uses to allocate Direct3D surfaces. The device manager enables multiple objects in the pipeline (such as a video renderer and a video decoder) to share the same Direct3D device.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoSampleAllocator::SetDirectXManager']/*"/>	
        /// <msdn-id>aa473819</msdn-id>	
        /// <unmanaged>SetDirectXManager</unmanaged>	
        /// <unmanaged-short>SetDirectXManager</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoSampleAllocator::SetDirectXManager([In] IUnknown* pManager)</unmanaged>
        public SharpDX.ComObject DirectXManager
        {
            set { SetDirectXManager(value); }
        }

        /// <summary>	
        /// <p> </p><p>Specifies the Direct3D device manager for the video media sink to use.</p>	
        /// </summary>	
        /// <param name="managerRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of the Direct3D device manager. The media sink queries this reference for the <strong>IDirect3DDeviceManager9</strong> interface.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The media sink uses the Direct3D device manager to obtain a reference to the Direct3D device, which it uses to allocate Direct3D surfaces. The device manager enables multiple objects in the pipeline (such as a video renderer and a video decoder) to share the same Direct3D device.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoSampleAllocator::SetDirectXManager']/*"/>	
        /// <msdn-id>aa473819</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoSampleAllocator::SetDirectXManager([In] IUnknown* pManager)</unmanaged>	
        /// <unmanaged-short>IMFVideoSampleAllocator::SetDirectXManager</unmanaged-short>	
        internal void SetDirectXManager(SharpDX.ComObject managerRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((managerRef == null) ? IntPtr.Zero : managerRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Releases all of the video samples that have been allocated.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoSampleAllocator::UninitializeSampleAllocator']/*"/>	
        /// <msdn-id>aa473807</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoSampleAllocator::UninitializeSampleAllocator()</unmanaged>	
        /// <unmanaged-short>IMFVideoSampleAllocator::UninitializeSampleAllocator</unmanaged-short>	
        public void UninitializeSampleAllocator()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Specifies the number of samples to allocate and the media type for the samples. </p>	
        /// </summary>	
        /// <param name="cRequestedFrames"><dd> <p> Number of samples to allocate.		 </p> </dd></param>	
        /// <param name="mediaTypeRef"><dd> <p> Pointer to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of a media type that describes the video format. </p> </dd></param>	
        /// <returns><p> The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.InvalidMediaType"/></strong></dt> </dl> </td><td> <p>Invalid media type.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoSampleAllocator::InitializeSampleAllocator']/*"/>	
        /// <msdn-id>bb970496</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoSampleAllocator::InitializeSampleAllocator([In] unsigned int cRequestedFrames,[In] IMFMediaType* pMediaType)</unmanaged>	
        /// <unmanaged-short>IMFVideoSampleAllocator::InitializeSampleAllocator</unmanaged-short>	
        public void InitializeSampleAllocator(int cRequestedFrames, SharpDX.MediaFoundation.MediaType mediaTypeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cRequestedFrames, (void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets a video sample from the allocator. </p>	
        /// </summary>	
        /// <param name="sampleOut"><dd> <p>Receives a reference to the <strong><see cref="SharpDX.MediaFoundation.Sample"/></strong> interface. The caller must release the interface. </p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.NotInitializeD"/></strong></dt> </dl> </td><td> <p>The allocator was not initialized. Call <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocator.InitializeSampleAllocator"/></strong> or <strong>InitializeSampleAllocatorEx::InitializeSampleAllocatorEx</strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.SampleallocatorEmpty"/></strong></dt> </dl> </td><td> <p> No samples are available. </p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoSampleAllocator::AllocateSample']/*"/>	
        /// <msdn-id>bb970553</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoSampleAllocator::AllocateSample([In] IMFSample** ppSample)</unmanaged>	
        /// <unmanaged-short>IMFVideoSampleAllocator::AllocateSample</unmanaged-short>	
        public void AllocateSample(out SharpDX.MediaFoundation.Sample sampleOut)
        {
            unsafe
            {
                IntPtr sampleOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &sampleOut_, ((void**)(*(void**)_nativePointer))[6]);
                sampleOut = (sampleOut_ == IntPtr.Zero) ? null : new SharpDX.MediaFoundation.Sample(sampleOut_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables an application to track video samples allocated by the enhanced video renderer (EVR).</p><p>The stream sinks on the EVR expose this interface as a service. To get a reference to the interface, call the <strong><see cref="SharpDX.MediaFoundation.ServiceProvider.GetService"/></strong> method, using the <strong><see cref="SharpDX.MediaFoundation.MediaServiceKeys.VideoAcceleration"/></strong> service identifier.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoSampleAllocatorCallback']/*"/>	
    /// <msdn-id>dd374900</msdn-id>	
    /// <unmanaged>IMFVideoSampleAllocatorCallback</unmanaged>	
    /// <unmanaged-short>IMFVideoSampleAllocatorCallback</unmanaged-short>	
    [Guid("992388B4-3372-4f67-8B6F-C84C071F4751")]
    public partial class VideoSampleAllocatorCallback : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.VideoSampleAllocatorCallback"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoSampleAllocatorCallback(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.VideoSampleAllocatorCallback"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.VideoSampleAllocatorCallback(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.VideoSampleAllocatorCallback(nativePointer);
        }


        /// <summary>	
        /// <p>Sets the callback object that receives notification whenever a video sample is returned to the allocator.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>To get a video sample from the allocator, call the <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocator.AllocateSample"/></strong> method. When the sample is released, it returns to the pool of available samples. When this happens, the allocator invokes the <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocatorNotify.NotifyRelease"/></strong> callback.</p><p>The allocator holds at most one callback reference. Calling this method again replaces the previous callback reference.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoSampleAllocatorCallback::SetCallback']/*"/>	
        /// <msdn-id>dd374904</msdn-id>	
        /// <unmanaged>SetCallback</unmanaged>	
        /// <unmanaged-short>SetCallback</unmanaged-short>	
        /// <unmanaged>HRESULT IMFVideoSampleAllocatorCallback::SetCallback([In] IMFVideoSampleAllocatorNotify* pNotify)</unmanaged>
        public SharpDX.MediaFoundation.VideoSampleAllocatorNotify Callback
        {
            set { SetCallback(value); }
        }

        /// <summary>	
        /// <p>Sets the callback object that receives notification whenever a video sample is returned to the allocator.</p>	
        /// </summary>	
        /// <param name="notifyRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocatorNotify"/></strong> interface that receives notification, or <strong><c>null</c></strong> to remove the callback.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To get a video sample from the allocator, call the <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocator.AllocateSample"/></strong> method. When the sample is released, it returns to the pool of available samples. When this happens, the allocator invokes the <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocatorNotify.NotifyRelease"/></strong> callback.</p><p>The allocator holds at most one callback reference. Calling this method again replaces the previous callback reference.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoSampleAllocatorCallback::SetCallback']/*"/>	
        /// <msdn-id>dd374904</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoSampleAllocatorCallback::SetCallback([In] IMFVideoSampleAllocatorNotify* pNotify)</unmanaged>	
        /// <unmanaged-short>IMFVideoSampleAllocatorCallback::SetCallback</unmanaged-short>	
        internal void SetCallback(SharpDX.MediaFoundation.VideoSampleAllocatorNotify notifyRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((notifyRef == null) ? IntPtr.Zero : notifyRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the number of video samples that are currently available for use.</p>	
        /// </summary>	
        /// <param name="lSamplesRef"><dd> <p>Receives the number of available samples.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To get a video sample from the allocator, call the <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocator.AllocateSample"/></strong> method. The <strong>AllocateSample</strong> method removes a sample from the sample pool and returns it to the caller. When a sample is released, it returns to the pool. The <strong>GetFreeSampleCount</strong> method returns the count of samples that remain in the sample pool.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoSampleAllocatorCallback::GetFreeSampleCount']/*"/>	
        /// <msdn-id>dd374902</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoSampleAllocatorCallback::GetFreeSampleCount([In] int* plSamples)</unmanaged>	
        /// <unmanaged-short>IMFVideoSampleAllocatorCallback::GetFreeSampleCount</unmanaged-short>	
        public void GetFreeSampleCount(int lSamplesRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, &lSamplesRef, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Allocates video samples that contain Microsoft Direct3D?11 texture surfaces.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>You can use this interface to allocateDirect3D?11 video samples, rather than allocate the texture surfaces and media samples directly. To get a reference to this interface, call the <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateVideoSampleAllocatorEx"/></strong> function. </p><p>To allocate video samples, perform the following steps:</p><ol> <li>Obtain a reference to the <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> interface. For a Media Foundation transform (MFT), this step occurs during the <strong><see cref="SharpDX.MediaFoundation.TMessageType.SetD3DManager"/></strong> event.</li> <li>Call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateVideoSampleAllocatorEx"/></strong> to create the allocator object and get a reference to the <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocatorEx"/></strong> interface.</li> <li>Call <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocator.SetDirectXManager"/></strong> on the allocator to set the <strong><see cref="SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> reference on the allocator.</li> <li>Call <strong><see cref="SharpDX.MediaFoundation.MediaFactory.CreateAttributes"/></strong> to get a reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface.</li> <li>Set the <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.D3D11Usage"/> and <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.D3D11Bindflags"/> attributes.</li> <li>Call <strong>IMFVideoSampleAllocator::InitializeSampleAllocatorEx</strong>.</li> </ol>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoSampleAllocatorEx']/*"/>	
    /// <msdn-id>hh448076</msdn-id>	
    /// <unmanaged>IMFVideoSampleAllocatorEx</unmanaged>	
    /// <unmanaged-short>IMFVideoSampleAllocatorEx</unmanaged-short>	
    [Guid("545b3a48-3283-4f62-866f-a62d8f598f9f")]
    public partial class VideoSampleAllocatorEx : SharpDX.MediaFoundation.VideoSampleAllocator
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.VideoSampleAllocatorEx"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoSampleAllocatorEx(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.VideoSampleAllocatorEx"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.VideoSampleAllocatorEx(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.VideoSampleAllocatorEx(nativePointer);
        }


        /// <summary>	
        /// <p>Initializes the video sample allocator object.</p>	
        /// </summary>	
        /// <param name="cInitialSamples"><dd> <p>The initial number of samples to allocate. </p> </dd></param>	
        /// <param name="cMaximumSamples"><dd> <p>The maximum number of samples to allocate.</p> </dd></param>	
        /// <param name="attributesRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this interface to configure the allocator. Currently, the following configuration attributes are defined:</p> <ul> <li> <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.BuffersPerSample"/> </li> <li> <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.D3D11Bindflags"/> </li> <li> <see cref="SharpDX.MediaFoundation.TransformAttributeKeys.D3D11Usage"/> </li> <li> MF_SA_D3D11_SHARED </li> <li> MF_SA_D3D11_SHARED_WITHOUT_MUTEX </li> </ul> </dd></param>	
        /// <param name="mediaTypeRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.MediaType"/></strong> interface of a media type that describes the video format. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoSampleAllocatorEx::InitializeSampleAllocatorEx']/*"/>	
        /// <msdn-id>hh448077</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoSampleAllocatorEx::InitializeSampleAllocatorEx([In] unsigned int cInitialSamples,[In] unsigned int cMaximumSamples,[In, Optional] IMFAttributes* pAttributes,[In] IMFMediaType* pMediaType)</unmanaged>	
        /// <unmanaged-short>IMFVideoSampleAllocatorEx::InitializeSampleAllocatorEx</unmanaged-short>	
        public void InitializeSampleAllocatorEx(int cInitialSamples, int cMaximumSamples, SharpDX.MediaFoundation.MediaAttributes attributesRef, SharpDX.MediaFoundation.MediaType mediaTypeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, cInitialSamples, cMaximumSamples, (void*)((attributesRef == null) ? IntPtr.Zero : attributesRef.NativePointer), (void*)((mediaTypeRef == null) ? IntPtr.Zero : mediaTypeRef.NativePointer), ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The callback for the <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocatorCallback"/></strong> interface.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoSampleAllocatorNotify']/*"/>	
    /// <msdn-id>dd374906</msdn-id>	
    /// <unmanaged>IMFVideoSampleAllocatorNotify</unmanaged>	
    /// <unmanaged-short>IMFVideoSampleAllocatorNotify</unmanaged-short>	
    [Guid("A792CDBE-C374-4e89-8335-278E7B9956A4")]
    public partial class VideoSampleAllocatorNotify : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.VideoSampleAllocatorNotify"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoSampleAllocatorNotify(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.VideoSampleAllocatorNotify"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.VideoSampleAllocatorNotify(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.VideoSampleAllocatorNotify(nativePointer);
        }


        /// <summary>	
        /// <p>Called when a video sample is returned to the allocator.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To get a video sample from the allocator, call the <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocator.AllocateSample"/></strong> method. When the sample is released and then returned to the pool of available samples, the allocator invokes the <strong>NotifyRelease</strong> method. </p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoSampleAllocatorNotify::NotifyRelease']/*"/>	
        /// <msdn-id>dd374908</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoSampleAllocatorNotify::NotifyRelease()</unmanaged>	
        /// <unmanaged-short>IMFVideoSampleAllocatorNotify::NotifyRelease</unmanaged-short>	
        public void NotifyRelease()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The callback for the <strong><see cref="SharpDX.MediaFoundation.VideoSampleAllocatorCallback"/></strong> interface.</p>	
    /// </summary>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoSampleAllocatorNotifyEx']/*"/>	
    /// <msdn-id>mt627756</msdn-id>	
    /// <unmanaged>IMFVideoSampleAllocatorNotifyEx</unmanaged>	
    /// <unmanaged-short>IMFVideoSampleAllocatorNotifyEx</unmanaged-short>	
    [Guid("3978AA1A-6D5B-4B7F-A340-90899189AE34")]
    public partial class VideoSampleAllocatorNotifyEx : SharpDX.MediaFoundation.VideoSampleAllocatorNotify
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.VideoSampleAllocatorNotifyEx"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VideoSampleAllocatorNotifyEx(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.VideoSampleAllocatorNotifyEx"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.VideoSampleAllocatorNotifyEx(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.VideoSampleAllocatorNotifyEx(nativePointer);
        }


        /// <summary>	
        /// <p>Called when allocator samples are released for pruning by the allocator, or when the allocator is removed.</p>	
        /// </summary>	
        /// <param name="midlIMFVideoSampleAllocatorNotifyEx0000"><dd> <p>The sample to be pruned.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFVideoSampleAllocatorNotifyEx::NotifyPrune']/*"/>	
        /// <msdn-id>mt627757</msdn-id>	
        /// <unmanaged>HRESULT IMFVideoSampleAllocatorNotifyEx::NotifyPrune([In] IMFSample* __MIDL__IMFVideoSampleAllocatorNotifyEx0000)</unmanaged>	
        /// <unmanaged-short>IMFVideoSampleAllocatorNotifyEx::NotifyPrune</unmanaged-short>	
        public void NotifyPrune(SharpDX.MediaFoundation.Sample midlIMFVideoSampleAllocatorNotifyEx0000)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((midlIMFVideoSampleAllocatorNotifyEx0000 == null) ? IntPtr.Zero : midlIMFVideoSampleAllocatorNotifyEx0000.NativePointer), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Completes an asynchronous request to register the topology work queues with the Multimedia Class Scheduler Service (MMCSS).</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Call this method when the <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices.BeginRegisterTopologyWorkQueuesWithMMCSS_"/></strong> method completes asynchronously.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServices']/*"/>	
    /// <msdn-id>ms696983</msdn-id>	
    /// <unmanaged>IMFWorkQueueServices</unmanaged>	
    /// <unmanaged-short>IMFWorkQueueServices</unmanaged-short>	
    [Guid("35FE1BB8-A3A9-40fe-BBEC-EB569C9CCCA3")]
    public partial class WorkQueueServices : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.WorkQueueServices"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public WorkQueueServices(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.WorkQueueServices"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.WorkQueueServices(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.WorkQueueServices(nativePointer);
        }


        /// <summary>	
        /// <p> </p><p>Registers the topology work queues with the Multimedia Class Scheduler Service (MMCSS).</p>	
        /// </summary>	
        /// <param name="callbackRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>	
        /// <param name="stateRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Each source node in the topology defines one branch of the topology. The branch includes every topology node that receives data from that node. An application can assign each branch of a topology its own work queue and then associate those work queues with MMCSS tasks. </p><p>To use this method, perform the following steps.</p><ol> <li>Create the topology.</li> <li>Set the following attributes on the source nodes in the topology.<ul> <li> <strong><see cref="SharpDX.MediaFoundation.TopologyNodeAttributeKeys.WorkqueueId"/></strong>. Specifies an identifier for the work queue. The Media Session will allocate a new work queue.</li> <li> <strong><see cref="SharpDX.MediaFoundation.TopologyNodeAttributeKeys.WorkqueueMmcssClass"/></strong>. Specifies the MMCSS class. </li> <li> <strong><see cref="SharpDX.MediaFoundation.TopologyNodeAttributeKeys.WorkqueueMmcssTaskid"/></strong>. Specifies the MMCSS task identifier (optional). If this attribute is not set, MMCSS assigns a new task identifier. </li> </ul> </li> <li>Queue the topology by calling <strong><see cref="SharpDX.MediaFoundation.MediaSession.SetTopology"/></strong>.</li> <li>Wait for the <see cref="SharpDX.MediaFoundation.MediaEventTypes.SessionTopologyStatus"/> event with the <strong><see cref="SharpDX.MediaFoundation.TopologyStatus.Ready"/></strong> status.</li> <li>Call <strong>BeginRegisterTopologyWorkQueuesWithMMCSS</strong>. This method registers all of the topology work queues with MMCSS.</li> </ol><p>The <strong>BeginRegisterTopologyWorkQueuesWithMMCSS</strong> method is asynchronous. When the operation completes, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. Within the callback method, call <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices.EndRegisterTopologyWorkQueuesWithMMCSS"/></strong> to complete the asynchronous request. After this operation completes, the Media Session automatically registers the work queues for every new topology that is queued on the Media Session. The application does not need to call the method again for new topologies.</p><p>To unregister the topology work queues from MMCSS, call <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices.BeginUnregisterTopologyWorkQueuesWithMMCSS_"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServices::BeginRegisterTopologyWorkQueuesWithMMCSS']/*"/>	
        /// <msdn-id>ms697485</msdn-id>	
        /// <unmanaged>HRESULT IMFWorkQueueServices::BeginRegisterTopologyWorkQueuesWithMMCSS([In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>	
        /// <unmanaged-short>IMFWorkQueueServices::BeginRegisterTopologyWorkQueuesWithMMCSS</unmanaged-short>	
        internal void BeginRegisterTopologyWorkQueuesWithMMCSS_(System.IntPtr callbackRef, SharpDX.ComObject stateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)callbackRef, (void*)((stateRef == null) ? IntPtr.Zero : stateRef.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Completes an asynchronous request to register the topology work queues with the Multimedia Class Scheduler Service (MMCSS).</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method when the <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices.BeginRegisterTopologyWorkQueuesWithMMCSS_"/></strong> method completes asynchronously.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServices::EndRegisterTopologyWorkQueuesWithMMCSS']/*"/>	
        /// <msdn-id>ms696983</msdn-id>	
        /// <unmanaged>HRESULT IMFWorkQueueServices::EndRegisterTopologyWorkQueuesWithMMCSS([In] IMFAsyncResult* pResult)</unmanaged>	
        /// <unmanaged-short>IMFWorkQueueServices::EndRegisterTopologyWorkQueuesWithMMCSS</unmanaged-short>	
        public void EndRegisterTopologyWorkQueuesWithMMCSS(SharpDX.MediaFoundation.AsyncResult resultRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Unregisters the topology work queues from the Multimedia Class Scheduler Service (MMCSS).</p>	
        /// </summary>	
        /// <param name="callbackRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>	
        /// <param name="stateRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is asynchronous. When the operation completes, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, the application should call <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices.EndUnregisterTopologyWorkQueuesWithMMCSS"/></strong> to complete the asynchronous request.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServices::BeginUnregisterTopologyWorkQueuesWithMMCSS']/*"/>	
        /// <msdn-id>ms702139</msdn-id>	
        /// <unmanaged>HRESULT IMFWorkQueueServices::BeginUnregisterTopologyWorkQueuesWithMMCSS([In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>	
        /// <unmanaged-short>IMFWorkQueueServices::BeginUnregisterTopologyWorkQueuesWithMMCSS</unmanaged-short>	
        internal void BeginUnregisterTopologyWorkQueuesWithMMCSS_(System.IntPtr callbackRef, SharpDX.ComObject stateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)callbackRef, (void*)((stateRef == null) ? IntPtr.Zero : stateRef.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Completes an asynchronous request to unregister the topology work queues from the Multimedia Class Scheduler Service (MMCSS).</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method when the <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices.BeginRegisterTopologyWorkQueuesWithMMCSS_"/></strong> method completes asynchronously.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServices::EndUnregisterTopologyWorkQueuesWithMMCSS']/*"/>	
        /// <msdn-id>ms698872</msdn-id>	
        /// <unmanaged>HRESULT IMFWorkQueueServices::EndUnregisterTopologyWorkQueuesWithMMCSS([In] IMFAsyncResult* pResult)</unmanaged>	
        /// <unmanaged-short>IMFWorkQueueServices::EndUnregisterTopologyWorkQueuesWithMMCSS</unmanaged-short>	
        public void EndUnregisterTopologyWorkQueuesWithMMCSS(SharpDX.MediaFoundation.AsyncResult resultRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the Multimedia Class Scheduler Service (MMCSS) class for a specified branch of the current topology.</p>	
        /// </summary>	
        /// <param name="dwTopologyWorkQueueId"><dd> <p>Identifies the work queue assigned to this topology branch. The application defines this value by setting the <strong><see cref="SharpDX.MediaFoundation.TopologyNodeAttributeKeys.WorkqueueId"/></strong> attribute on the source node for the branch.</p> </dd></param>	
        /// <param name="wszClassRef"><dd> <p>Pointer to a buffer that receives the name of the MMCSS class. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="cchClassRef"><dd> <p>On input, specifies the size of the <em>pwszClass</em> buffer, in characters. On output, receives the required size of the buffer, in characters. The size includes the terminating null character.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>There is no work queue with the specified identifier.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.BufferTooSmall"/></strong></dt> </dl> </td><td> <p>The <em>pwszClass</em> buffer is too small to receive the class name.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServices::GetTopologyWorkQueueMMCSSClass']/*"/>	
        /// <msdn-id>ms704762</msdn-id>	
        /// <unmanaged>HRESULT IMFWorkQueueServices::GetTopologyWorkQueueMMCSSClass([In] unsigned int dwTopologyWorkQueueId,[Out, Buffer] wchar_t* pwszClass,[InOut] unsigned int* pcchClass)</unmanaged>	
        /// <unmanaged-short>IMFWorkQueueServices::GetTopologyWorkQueueMMCSSClass</unmanaged-short>	
        public void GetTopologyWorkQueueMMCSSClass(int dwTopologyWorkQueueId, System.IntPtr wszClassRef, ref int cchClassRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cchClassRef_ = &cchClassRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwTopologyWorkQueueId, (void*)wszClassRef, cchClassRef_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the Multimedia Class Scheduler Service (MMCSS) task identifier for a specified branch of the current topology.</p>	
        /// </summary>	
        /// <param name="dwTopologyWorkQueueId"><dd> <p>Identifies the work queue assigned to this topology branch. The application defines this value by setting the <strong><see cref="SharpDX.MediaFoundation.TopologyNodeAttributeKeys.WorkqueueId"/></strong> attribute on the source node for the branch.</p> </dd></param>	
        /// <param name="dwTaskIdRef"><dd> <p>Receives the task identifier.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServices::GetTopologyWorkQueueMMCSSTaskId']/*"/>	
        /// <msdn-id>ms694202</msdn-id>	
        /// <unmanaged>HRESULT IMFWorkQueueServices::GetTopologyWorkQueueMMCSSTaskId([In] unsigned int dwTopologyWorkQueueId,[Out] unsigned int* pdwTaskId)</unmanaged>	
        /// <unmanaged-short>IMFWorkQueueServices::GetTopologyWorkQueueMMCSSTaskId</unmanaged-short>	
        public void GetTopologyWorkQueueMMCSSTaskId(int dwTopologyWorkQueueId, out int dwTaskIdRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwTaskIdRef_ = &dwTaskIdRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwTopologyWorkQueueId, dwTaskIdRef_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Associates a platform work queue with a Multimedia Class Scheduler Service (MMCSS) task. </p>	
        /// </summary>	
        /// <param name="dwPlatformWorkQueue"><dd> <p> The platform work queue to register with MMCSS. See Work Queue Identifiers. To register all of the standard work queues to the same MMCSS task, set this parameter to <strong><see cref="SharpDX.MediaFoundation.WorkQueueType.All"/></strong>.</p> </dd></param>	
        /// <param name="wszClass"><dd> <p>The name of the MMCSS task to be performed. </p> </dd></param>	
        /// <param name="dwTaskId"><dd> <p> The unique task identifier. To obtain a new task identifier, set this value to zero. </p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>A reference to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>	
        /// <param name="stateRef"><dd> <p>A reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method is asynchronous. When the operation completes, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, the application should call <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices.EndRegisterPlatformWorkQueueWithMMCSS"/></strong> to complete the asynchronous request.</p><p>To unregister the work queue from the MMCSS class, call <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices.BeginUnregisterPlatformWorkQueueWithMMCSS_"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServices::BeginRegisterPlatformWorkQueueWithMMCSS']/*"/>	
        /// <msdn-id>ms702114</msdn-id>	
        /// <unmanaged>HRESULT IMFWorkQueueServices::BeginRegisterPlatformWorkQueueWithMMCSS([In] unsigned int dwPlatformWorkQueue,[In] const wchar_t* wszClass,[In] unsigned int dwTaskId,[In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>	
        /// <unmanaged-short>IMFWorkQueueServices::BeginRegisterPlatformWorkQueueWithMMCSS</unmanaged-short>	
        internal void BeginRegisterPlatformWorkQueueWithMMCSS_(int dwPlatformWorkQueue, string wszClass, int dwTaskId, System.IntPtr callbackRef, SharpDX.ComObject stateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* wszClass_ = wszClass)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwPlatformWorkQueue, (void*)wszClass_, dwTaskId, (void*)callbackRef, (void*)((stateRef == null) ? IntPtr.Zero : stateRef.NativePointer), ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Completes an asynchronous request to associate a platform work queue with a Multimedia Class Scheduler Service (MMCSS) task.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.</p> </dd></param>	
        /// <param name="dwTaskIdRef"><dd> <p>The unique task identifier.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this function when the <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices.BeginRegisterPlatformWorkQueueWithMMCSS_"/></strong> method completes asynchronously.</p><p>To unregister the work queue from the MMCSS class, call <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices.BeginUnregisterPlatformWorkQueueWithMMCSS_"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServices::EndRegisterPlatformWorkQueueWithMMCSS']/*"/>	
        /// <msdn-id>ms702284</msdn-id>	
        /// <unmanaged>HRESULT IMFWorkQueueServices::EndRegisterPlatformWorkQueueWithMMCSS([In] IMFAsyncResult* pResult,[Out] unsigned int* pdwTaskId)</unmanaged>	
        /// <unmanaged-short>IMFWorkQueueServices::EndRegisterPlatformWorkQueueWithMMCSS</unmanaged-short>	
        public void EndRegisterPlatformWorkQueueWithMMCSS(SharpDX.MediaFoundation.AsyncResult resultRef, out int dwTaskIdRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwTaskIdRef_ = &dwTaskIdRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), dwTaskIdRef_, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Unregisters a platform work queue from a Multimedia Class Scheduler Service (MMCSS) task.</p>	
        /// </summary>	
        /// <param name="dwPlatformWorkQueue"><dd> <p>Platform work queue to register with MMCSS. See <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices.BeginRegisterPlatformWorkQueueWithMMCSS_"/></strong>.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>	
        /// <param name="stateRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is asynchronous. When the operation completes, the callback object's <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method is called. At that point, the application should call <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices.EndUnregisterPlatformWorkQueueWithMMCSS"/></strong> to complete the asynchronous request.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServices::BeginUnregisterPlatformWorkQueueWithMMCSS']/*"/>	
        /// <msdn-id>ms704603</msdn-id>	
        /// <unmanaged>HRESULT IMFWorkQueueServices::BeginUnregisterPlatformWorkQueueWithMMCSS([In] unsigned int dwPlatformWorkQueue,[In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>	
        /// <unmanaged-short>IMFWorkQueueServices::BeginUnregisterPlatformWorkQueueWithMMCSS</unmanaged-short>	
        internal void BeginUnregisterPlatformWorkQueueWithMMCSS_(int dwPlatformWorkQueue, System.IntPtr callbackRef, SharpDX.ComObject stateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwPlatformWorkQueue, (void*)callbackRef, (void*)((stateRef == null) ? IntPtr.Zero : stateRef.NativePointer), ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Completes an asynchronous request to unregister a platform work queue from a Multimedia Class Scheduler Service (MMCSS) task.</p>	
        /// </summary>	
        /// <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="SharpDX.MediaFoundation.IAsyncCallback.Invoke"/></strong> method.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Call this method when the <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices.BeginUnregisterPlatformWorkQueueWithMMCSS_"/></strong> method completes asynchronously.</p>	
        /// </remarks>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServices::EndUnregisterPlatformWorkQueueWithMMCSS']/*"/>	
        /// <msdn-id>ms704734</msdn-id>	
        /// <unmanaged>HRESULT IMFWorkQueueServices::EndUnregisterPlatformWorkQueueWithMMCSS([In] IMFAsyncResult* pResult)</unmanaged>	
        /// <unmanaged-short>IMFWorkQueueServices::EndUnregisterPlatformWorkQueueWithMMCSS</unmanaged-short>	
        public void EndUnregisterPlatformWorkQueueWithMMCSS(SharpDX.MediaFoundation.AsyncResult resultRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, (void*)((resultRef == null) ? IntPtr.Zero : resultRef.NativePointer), ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the Multimedia Class Scheduler Service (MMCSS) class for a specified platform work queue.</p>	
        /// </summary>	
        /// <param name="dwPlatformWorkQueueId"><dd> <p>Platform work queue to query. See <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices.BeginRegisterPlatformWorkQueueWithMMCSS_"/></strong>.</p> </dd></param>	
        /// <param name="wszClassRef"><dd> <p>Pointer to a buffer that receives the name of the MMCSS class. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="cchClassRef"><dd> <p>On input, specifies the size of the pwszClass buffer, in characters. On output, receives the required size of the buffer, in characters. The size includes the terminating null character.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.MediaFoundation.ResultCode.BufferTooSmall"/></strong></dt> </dl> </td><td> <p>The <em>pwszClass</em> buffer is too small to receive the class name.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServices::GetPlaftormWorkQueueMMCSSClass']/*"/>	
        /// <msdn-id>ms705624</msdn-id>	
        /// <unmanaged>HRESULT IMFWorkQueueServices::GetPlaftormWorkQueueMMCSSClass([In] unsigned int dwPlatformWorkQueueId,[Out, Buffer] wchar_t* pwszClass,[InOut] unsigned int* pcchClass)</unmanaged>	
        /// <unmanaged-short>IMFWorkQueueServices::GetPlaftormWorkQueueMMCSSClass</unmanaged-short>	
        public void GetPlaftormWorkQueueMMCSSClass(int dwPlatformWorkQueueId, System.IntPtr wszClassRef, ref int cchClassRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* cchClassRef_ = &cchClassRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwPlatformWorkQueueId, (void*)wszClassRef, cchClassRef_, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> </p><p>Retrieves the Multimedia Class Scheduler Service (MMCSS) task identifier for a specified platform work queue.</p>	
        /// </summary>	
        /// <param name="dwPlatformWorkQueueId"><dd> <p>Platform work queue to query. See <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices.BeginRegisterPlatformWorkQueueWithMMCSS_"/></strong>.</p> </dd></param>	
        /// <param name="dwTaskIdRef"><dd> <p>Receives the task identifier.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServices::GetPlatformWorkQueueMMCSSTaskId']/*"/>	
        /// <msdn-id>ms700183</msdn-id>	
        /// <unmanaged>HRESULT IMFWorkQueueServices::GetPlatformWorkQueueMMCSSTaskId([In] unsigned int dwPlatformWorkQueueId,[Out] unsigned int* pdwTaskId)</unmanaged>	
        /// <unmanaged-short>IMFWorkQueueServices::GetPlatformWorkQueueMMCSSTaskId</unmanaged-short>	
        public void GetPlatformWorkQueueMMCSSTaskId(int dwPlatformWorkQueueId, out int dwTaskIdRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dwTaskIdRef_ = &dwTaskIdRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwPlatformWorkQueueId, dwTaskIdRef_, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Extends the <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices"/></strong> interface.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface allows applications to control	
    /// both platform and topology work queues.</p><p>The <strong><see cref="SharpDX.MediaFoundation.WorkQueueServices"/></strong> can be obtained from the session by querying     for the <strong><see cref="SharpDX.MediaFoundation.MediaServiceKeys.WorkQueue"/></strong> service.</p>	
    /// </remarks>	
    /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServicesEx']/*"/>	
    /// <msdn-id>jj128325</msdn-id>	
    /// <unmanaged>IMFWorkQueueServicesEx</unmanaged>	
    /// <unmanaged-short>IMFWorkQueueServicesEx</unmanaged-short>	
    [Guid("96bf961b-40fe-42f1-ba9d-320238b49700")]
    public partial class WorkQueueServicesEx : SharpDX.MediaFoundation.WorkQueueServices
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.MediaFoundation.WorkQueueServicesEx"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public WorkQueueServicesEx(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.MediaFoundation.WorkQueueServicesEx"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.MediaFoundation.WorkQueueServicesEx(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.MediaFoundation.WorkQueueServicesEx(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves the Multimedia Class Scheduler Service (MMCSS)  string associated with the given topology work queue.</p>	
        /// </summary>	
        /// <param name="dwTopologyWorkQueueId"><dd> <p>The id of the topology work queue. </p> </dd></param>	
        /// <param name="lPriorityRef"><dd> <p>Pointer to the buffer the work queue's MMCSS task id will be copied to.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServicesEx::GetTopologyWorkQueueMMCSSPriority']/*"/>	
        /// <msdn-id>jj128328</msdn-id>	
        /// <unmanaged>HRESULT IMFWorkQueueServicesEx::GetTopologyWorkQueueMMCSSPriority([In] unsigned int dwTopologyWorkQueueId,[Out] int* plPriority)</unmanaged>	
        /// <unmanaged-short>IMFWorkQueueServicesEx::GetTopologyWorkQueueMMCSSPriority</unmanaged-short>	
        public void GetTopologyWorkQueueMMCSSPriority(int dwTopologyWorkQueueId, out int lPriorityRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* lPriorityRef_ = &lPriorityRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwTopologyWorkQueueId, lPriorityRef_, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Registers a platform work queue with Multimedia Class Scheduler Service (MMCSS) using the specified class and task id.</p>	
        /// </summary>	
        /// <param name="dwPlatformWorkQueue"><dd> <p>The id of one of the standard platform work queues.</p> </dd></param>	
        /// <param name="wszClass"><dd> <p>The MMCSS class which the work queue should be registered with.</p> </dd></param>	
        /// <param name="dwTaskId"><dd> <p> The task id which the work queue should be registered with. If <em>dwTaskId</em> is 0, a new MMCSS bucket will be created.</p> </dd></param>	
        /// <param name="lPriority"><dd> <p>The priority.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>Standard callback used for async operations in Media Foundation.</p> </dd></param>	
        /// <param name="stateRef"><dd> <p>Standard state used for async operations in Media Foundation.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServicesEx::BeginRegisterPlatformWorkQueueWithMMCSSEx']/*"/>	
        /// <msdn-id>jj128326</msdn-id>	
        /// <unmanaged>HRESULT IMFWorkQueueServicesEx::BeginRegisterPlatformWorkQueueWithMMCSSEx([In] unsigned int dwPlatformWorkQueue,[In] const wchar_t* wszClass,[In] unsigned int dwTaskId,[In] int lPriority,[In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>	
        /// <unmanaged-short>IMFWorkQueueServicesEx::BeginRegisterPlatformWorkQueueWithMMCSSEx</unmanaged-short>	
        internal void BeginRegisterPlatformWorkQueueWithMMCSSEx_(int dwPlatformWorkQueue, string wszClass, int dwTaskId, int lPriority, System.IntPtr callbackRef, SharpDX.ComObject stateRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (char* wszClass_ = wszClass)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwPlatformWorkQueue, (void*)wszClass_, dwTaskId, lPriority, (void*)callbackRef, (void*)((stateRef == null) ? IntPtr.Zero : stateRef.NativePointer), ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the priority of the Multimedia Class Scheduler Service (MMCSS)  priority associated with the specified platform work queue.</p>	
        /// </summary>	
        /// <param name="dwPlatformWorkQueueId"><dd> <p>Topology work queue id for which the info will be returned.</p> </dd></param>	
        /// <param name="lPriorityRef"><dd></dd></param>	
        /// <returns><p>Pointer to a buffer allocated by the caller that the work queue's MMCSS task id will be copied to.</p></returns>	
        /// <include file='.\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IMFWorkQueueServicesEx::GetPlatformWorkQueueMMCSSPriority']/*"/>	
        /// <msdn-id>jj128327</msdn-id>	
        /// <unmanaged>HRESULT IMFWorkQueueServicesEx::GetPlatformWorkQueueMMCSSPriority([In] unsigned int dwPlatformWorkQueueId,[Out] int* plPriority)</unmanaged>	
        /// <unmanaged-short>IMFWorkQueueServicesEx::GetPlatformWorkQueueMMCSSPriority</unmanaged-short>	
        public void GetPlatformWorkQueueMMCSSPriority(int dwPlatformWorkQueueId, out int lPriorityRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* lPriorityRef_ = &lPriorityRef)
                    __result__ =
                    SharpDX.MediaFoundation.LocalInterop.Calliint(_nativePointer, dwPlatformWorkQueueId, lPriorityRef_, ((void**)(*(void**)_nativePointer))[17]);
                __result__.CheckError();
            }
        }
    }
}

