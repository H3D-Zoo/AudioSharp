// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.Win32 namespace.
//     This code was generated by a tool.
//     Date : 2017/7/15 0:31:20
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.Win32 {

// Disable warning : XML comment is not placed on a valid language element
#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574
    /// <summary>	
    /// <p> The 	
    /// <strong><see cref="SharpDX.Win32.IStream"/></strong> interface lets you read and write data to stream objects. Stream objects contain the data in a structured storage object, where storages provide the structure. Simple data can be written directly to a stream but, most frequently, streams are elements nested within a storage object. They are similar to standard files.</p><p>The 	
    /// <strong><see cref="SharpDX.Win32.IStream"/></strong> interface defines methods similar to the MS-DOS FAT file functions. For example, each stream object has its own access rights and a seek reference. The main difference between a DOS file and a stream object is that in the latter case, streams are opened using an 	
    /// <strong><see cref="SharpDX.Win32.IStream"/></strong> interface reference rather than a file handle.</p><p>The methods in this interface present your object's data as a contiguous sequence of bytes that you can read or write. There are also methods for committing and reverting changes on streams that are open in transacted mode and methods for restricting access to a range of bytes in the stream.</p><p>Streams can remain open for long periods of time without consuming file-system resources. The <strong>IUnknown::Release</strong> method is similar to a close function on a file. Once released, the stream object is no longer valid and cannot be used.</p><p>Clients of asynchronous monikers can choose between a data-pull or data-push model for driving an asynchronous 	
    /// <strong>IMoniker::BindToStorage</strong> operation and for receiving asynchronous notifications. See 	
    /// URL Monikers for more information. The following table compares the behavior of asynchronous 	
    /// <strong><see cref="SharpDX.Win32.IStreamBase.Read"/></strong> and 	
    /// <strong><see cref="SharpDX.Win32.IStream.Seek"/></strong> calls returned in <strong>IBindStatusCallback::OnDataAvailable</strong> in these two download models:</p>	
    /// </summary>	
    /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream']/*"/>	
    /// <msdn-id>aa380034</msdn-id>	
    /// <unmanaged>IStream</unmanaged>	
    /// <unmanaged-short>IStream</unmanaged-short>	
    [Guid("0000000c-0000-0000-C000-000000000046")]
    public partial class ComStream : SharpDX.Win32.ComStreamBase, SharpDX.Win32.IStream {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Win32.ComStream"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ComStream(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Win32.ComStream"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Win32.ComStream(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Win32.ComStream(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> The <strong>Seek</strong> method changes the seek reference to a new location.  The new location is relative to either the beginning of the stream, the end of the stream, or the current seek reference.</p>	
        /// </summary>	
        /// <param name="dlibMove"><dd> <p>The displacement to be added to the location indicated by the <em>dwOrigin</em> parameter. If <em>dwOrigin</em> is <strong>STREAM_SEEK_SET</strong>, this is interpreted as an unsigned value rather than a signed value.</p> </dd></param>	
        /// <param name="dwOrigin"><dd> <p>The origin for the displacement specified in <em>dlibMove</em>. The origin can be the beginning of the file (<strong>STREAM_SEEK_SET</strong>), the current seek reference (<strong>STREAM_SEEK_CUR</strong>), or the end of the file (<strong>STREAM_SEEK_END</strong>). For more information about values, see the <strong>STREAM_SEEK</strong> enumeration.</p> </dd></param>	
        /// <returns><dd> <p>A reference to the location where this method writes the value of the new seek reference from the beginning of the stream. </p> <p>You can set this reference to <strong><c>null</c></strong>. In this case, this method does not provide the new seek reference.</p> </dd></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Win32.IStream.Seek"/></strong> changes the seek reference so that subsequent read and write operations can be performed at a different location in the stream object. It is an error to seek before the beginning of the stream. It is not, however, an error to seek past the end of the stream. Seeking past the end of the stream is useful for subsequent write operations, as the stream byte range will be extended to the new seek position immediately before the write is complete.</p><p>You can also use this method to obtain the current value of the seek reference by calling this method with the <em>dwOrigin</em> parameter set to <strong>STREAM_SEEK_CUR</strong> and the <em>dlibMove</em> parameter set to 0 so that the seek reference is not changed. The current seek reference is returned in the <em>plibNewPosition</em> parameter.</p>	
        /// </remarks>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::Seek']/*"/>	
        /// <msdn-id>aa380043</msdn-id>	
        /// <unmanaged>HRESULT IStream::Seek([In] LARGE_INTEGER dlibMove,[In] SHARPDX_SEEKORIGIN dwOrigin,[Out, Optional] ULARGE_INTEGER* plibNewPosition)</unmanaged>	
        /// <unmanaged-short>IStream::Seek</unmanaged-short>	
        public long Seek(long dlibMove, System.IO.SeekOrigin dwOrigin) {
            unsafe {
                long libNewPositionRef;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.LocalInterop.Calliint(_nativePointer, dlibMove, unchecked((int)dwOrigin), &libNewPositionRef,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
                return libNewPositionRef;
            }
        }
        
        /// <summary>	
        /// <p>The <strong>SetSize</strong> method changes the size of the stream object.</p>	
        /// </summary>	
        /// <param name="libNewSize"><dd> <p>Specifies the new size, in bytes, of the stream.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> <dd> <p>The size of the stream object was successfully changed.</p> </dd> <dt><strong>E_PENDING</strong></dt> <dd> <p>Asynchronous Storage only: Part or all of the stream's data is currently unavailable. For more information, see <strong>IFillLockBytes</strong> and Asynchronous Storage.</p> </dd> <dt><strong>STG_E_MEDIUMFULL</strong></dt> <dd> <p>The stream size is not changed because there is no space left on the storage device.</p> </dd> <dt><strong>STG_E_INVALIDFUNCTION</strong></dt> <dd> <p>The value of the <em>libNewSize</em> parameter is not supported by the implementation. Not all streams support greater than 2?? bytes. If a stream does not support more than 2?? bytes, the high <strong>DWORD</strong> data type of <em>libNewSize</em> must be zero. If it is nonzero, the implementation may return STG_E_INVALIDFUNCTION. In general, COM-based implementations of the  <strong><see cref="SharpDX.Win32.IStream"/></strong> interface do not support streams larger than 2?? bytes.</p> </dd> <dt><strong>STG_E_REVERTED</strong></dt> <dd> <p>The object has been invalidated by a revert operation above it in the transaction tree.</p> </dd> </dl></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Win32.IStream.SetSize"/></strong> changes the size of the stream object. Call this method to preallocate space for the stream. If the <em>libNewSize</em> parameter is larger than the current stream size, the stream is extended to the indicated size by filling the intervening space with bytes of undefined value. This operation is similar to the 	
        /// <strong><see cref="SharpDX.Win32.IStreamBase.Write"/></strong> method if the seek reference is past the current end of the stream.</p><p>If the <em>libNewSize</em> parameter is smaller than the current stream, the stream is truncated to the indicated size.</p><p>The seek reference is not affected by the change in stream size.</p><p>Calling <strong><see cref="SharpDX.Win32.IStream.SetSize"/></strong> can be an effective way to obtain a large chunk of contiguous space.</p>	
        /// </remarks>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::SetSize']/*"/>	
        /// <msdn-id>aa380044</msdn-id>	
        /// <unmanaged>HRESULT IStream::SetSize([In] ULARGE_INTEGER libNewSize)</unmanaged>	
        /// <unmanaged-short>IStream::SetSize</unmanaged-short>	
        public void SetSize(long libNewSize) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.LocalInterop.Calliint(_nativePointer, libNewSize,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>The <strong>CopyTo</strong> method copies a specified number of bytes from the current seek reference in the stream to the current seek reference in another stream.</p>	
        /// </summary>	
        /// <param name="stmRef"><dd> <p>A reference to the destination stream. The stream pointed to by <em>pstm</em> can be a new stream or a clone of the source stream.</p> </dd></param>	
        /// <param name="cb"><dd> <p>The number of bytes to copy from the source stream.</p> </dd></param>	
        /// <param name="cbWrittenRef"><dd> <p>A reference to the location where this method writes the actual number of bytes written to the destination. You can set this reference to <strong><c>null</c></strong>. In this case, this method does not provide the actual number of bytes written.</p> </dd></param>	
        /// <returns><dd> <p>A reference to the location where this method writes the actual number of bytes read from the source. You can set this reference to <strong><c>null</c></strong>. In this case, this method does not provide the actual number of bytes read.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The <strong>CopyTo</strong> method copies the specified bytes from one stream to another. It can also be used to copy a stream to itself. The seek reference in each stream instance is adjusted for the number of bytes read or written. This method is equivalent to reading <em>cb</em> bytes into memory using 	
        /// <strong><see cref="SharpDX.Win32.IStreamBase.Read"/></strong> and then immediately writing them to the destination stream using 	
        /// <strong><see cref="SharpDX.Win32.IStreamBase.Write"/></strong>, although <strong><see cref="SharpDX.Win32.IStream.CopyTo_"/></strong> will be more efficient.</p><p>The destination stream can be a clone of the source stream created by calling the 	
        /// <strong><see cref="SharpDX.Win32.IStream.Clone"/></strong> method.</p><p>If <strong><see cref="SharpDX.Win32.IStream.CopyTo_"/></strong> returns an error, you cannot assume that the seek references are valid for either the source or destination. Additionally, the values of <em>pcbRead</em> and <em>pcbWritten</em> are not meaningful even though they are returned.</p><p>If <strong><see cref="SharpDX.Win32.IStream.CopyTo_"/></strong> returns successfully, the actual number of bytes read and written are the same.</p><p>To copy the remainder of the source from the current seek reference, specify the maximum large integer value for the <em>cb</em> parameter. If the seek reference is the beginning of the stream, this operation copies the entire stream.</p>	
        /// </remarks>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::CopyTo']/*"/>	
        /// <msdn-id>aa380038</msdn-id>	
        /// <unmanaged>HRESULT IStream::CopyTo([In] IStream* pstm,[In] ULARGE_INTEGER cb,[Out] ULARGE_INTEGER* pcbRead,[Out] ULARGE_INTEGER* pcbWritten)</unmanaged>	
        /// <unmanaged-short>IStream::CopyTo</unmanaged-short>	
        internal long CopyTo_(System.IntPtr stmRef, long cb, out long cbWrittenRef) {
            unsafe {
                long cbReadRef;
                SharpDX.Result __result__;
                fixed (void* cbWrittenRef_ = &cbWrittenRef)
                    __result__= 
    				SharpDX.LocalInterop.Calliint(_nativePointer, (void*)stmRef, cb, &cbReadRef, cbWrittenRef_,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
                return cbReadRef;
            }
        }
        
        /// <summary>	
        /// <p>The <strong>Commit</strong> method ensures that any changes made to a stream object open in transacted mode are reflected in the parent storage. If the stream object is open in direct mode, <strong><see cref="SharpDX.Win32.IStream.Commit"/></strong> has no effect other than flushing all memory buffers to the next-level storage object. The COM compound file implementation of streams does not support opening streams in transacted mode.</p>	
        /// </summary>	
        /// <param name="grfCommitFlags"><dd> <p>Controls how the changes for the stream object are committed. See the <strong><see cref="SharpDX.Win32.CommitFlags"/></strong> enumeration for a definition of these values.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> <dd> <p>Changes to the stream object were successfully committed to the parent level.</p> </dd> <dt><strong>E_PENDING</strong></dt> <dd> <p>Asynchronous Storage only: Part or all of the stream's data is currently unavailable. For more information see <strong>IFillLockBytes</strong> and Asynchronous Storage.</p> </dd> <dt><strong>STG_E_MEDIUMFULL</strong></dt> <dd> <p>The commit operation failed due to lack of space on the storage device.</p> </dd> <dt><strong>STG_E_REVERTED</strong></dt> <dd> <p>The object has been invalidated by a revert operation above it in the transaction tree.</p> </dd> </dl></returns>	
        /// <remarks>	
        /// <p>The <strong>Commit</strong> method ensures that changes to a stream object opened in transacted mode are reflected in the parent storage. Changes that have been made to the stream since it was opened or last committed are reflected to the parent storage object. If the parent is opened in transacted mode, the parent may revert at a later time, rolling back the changes to this stream object. The compound file implementation does not support the opening of streams in transacted mode, so this method has very little effect other than to flush memory buffers. For more information, see 	
        /// <see cref="SharpDX.Win32.IStream"/> - Compound File Implementation.</p><p>If the stream is open in direct mode, this method ensures that any memory buffers have been flushed out to the underlying storage object. This is much like a flush in traditional file systems.</p><p>The <strong><see cref="SharpDX.Win32.IStream.Commit"/></strong> method is useful on a direct mode stream when the implementation of the 	
        /// <strong><see cref="SharpDX.Win32.IStream"/></strong> interface is a wrapper for underlying file system APIs. In this case, <strong><see cref="SharpDX.Win32.IStream.Commit"/></strong> would be connected to the file system's flush call.</p>	
        /// </remarks>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::Commit']/*"/>	
        /// <msdn-id>aa380036</msdn-id>	
        /// <unmanaged>HRESULT IStream::Commit([In] STGC grfCommitFlags)</unmanaged>	
        /// <unmanaged-short>IStream::Commit</unmanaged-short>	
        public void Commit(SharpDX.Win32.CommitFlags grfCommitFlags) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.LocalInterop.Calliint(_nativePointer, unchecked((int)grfCommitFlags),((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>The <strong>Revert</strong> method discards all changes that have been made to a transacted stream since the last 	
        /// <strong><see cref="SharpDX.Win32.IStream.Commit"/></strong> call. On streams open in direct mode and streams using the COM compound file implementation of <strong><see cref="SharpDX.Win32.IStream.Revert"/></strong>, this method has no effect.</p>	
        /// </summary>	
        /// <returns><p>This method can return one of these values.</p><dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> <dd> <p>The stream was successfully reverted to its previous version.</p> </dd> <dt><strong>E_PENDING</strong></dt> <dd> <p>Asynchronous Storage only: Part or all of the stream's data is currently unavailable. For more information see <strong>IFillLockBytes</strong> and Asynchronous Storage.</p> </dd> </dl></returns>	
        /// <remarks>	
        /// <p>The <strong>Revert</strong> method discards changes made to a transacted stream since the last commit operation.</p>	
        /// </remarks>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::Revert']/*"/>	
        /// <msdn-id>aa380042</msdn-id>	
        /// <unmanaged>HRESULT IStream::Revert()</unmanaged>	
        /// <unmanaged-short>IStream::Revert</unmanaged-short>	
        public void Revert() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="libOffset">No documentation.</param>	
        /// <param name="cb">No documentation.</param>	
        /// <param name="dwLockType">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::LockRegion']/*"/>	
        /// <unmanaged>HRESULT IStream::LockRegion([In] ULARGE_INTEGER libOffset,[In] ULARGE_INTEGER cb,[In] LOCKTYPE dwLockType)</unmanaged>	
        /// <unmanaged-short>IStream::LockRegion</unmanaged-short>	
        public void LockRegion(long libOffset, long cb, SharpDX.Win32.LockType dwLockType) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.LocalInterop.Calliint(_nativePointer, libOffset, cb, unchecked((int)dwLockType),((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="libOffset">No documentation.</param>	
        /// <param name="cb">No documentation.</param>	
        /// <param name="dwLockType">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::UnlockRegion']/*"/>	
        /// <unmanaged>HRESULT IStream::UnlockRegion([In] ULARGE_INTEGER libOffset,[In] ULARGE_INTEGER cb,[In] LOCKTYPE dwLockType)</unmanaged>	
        /// <unmanaged-short>IStream::UnlockRegion</unmanaged-short>	
        public void UnlockRegion(long libOffset, long cb, SharpDX.Win32.LockType dwLockType) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.LocalInterop.Calliint(_nativePointer, libOffset, cb, unchecked((int)dwLockType),((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> The <strong>Stat</strong> method retrieves the 	
        /// <strong><see cref="SharpDX.Win32.StorageStatistics"/></strong> structure for this stream.</p>	
        /// </summary>	
        /// <param name="grfStatFlag">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Win32.IStream.GetStatistics"/></strong> retrieves a reference to the 	
        /// <strong><see cref="SharpDX.Win32.StorageStatistics"/></strong> structure that contains information about this open stream. When this stream is within a structured storage and 	
        /// <strong>IStorage::EnumElements</strong> is called, it creates an enumerator object with the 	
        /// <strong>IEnumSTATSTG</strong> interface on it, which can be called to enumerate the storages and streams through the 	
        /// <strong><see cref="SharpDX.Win32.StorageStatistics"/></strong> structures associated with each of them.</p>	
        /// </remarks>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::Stat']/*"/>	
        /// <msdn-id>aa380045</msdn-id>	
        /// <unmanaged>HRESULT IStream::Stat([Out] STATSTG* pstatstg,[In] STATFLAG grfStatFlag)</unmanaged>	
        /// <unmanaged-short>IStream::Stat</unmanaged-short>	
        public SharpDX.Win32.StorageStatistics GetStatistics(SharpDX.Win32.StorageStatisticsFlags grfStatFlag) {
            unsafe {
                SharpDX.Win32.StorageStatistics statstgRef;
                var statstgRef_ = new SharpDX.Win32.StorageStatistics.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.LocalInterop.Calliint(_nativePointer, &statstgRef_, unchecked((int)grfStatFlag),((void**)(*(void**)_nativePointer))[12]);		
                statstgRef = new SharpDX.Win32.StorageStatistics();
                statstgRef.__MarshalFrom(ref statstgRef_);
                __result__.CheckError();
                return statstgRef;
            }
        }
        
        /// <summary>	
        /// <p> The <strong>Clone</strong> method creates a new stream object with its own seek reference that references the same bytes as the original stream.</p>	
        /// </summary>	
        /// <returns><dd> <p>When successful, reference to the location of an <strong><see cref="SharpDX.Win32.IStream"/></strong> reference to the new stream object. If an error occurs, this parameter is <strong><c>null</c></strong>.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The <strong>Clone</strong> method creates a new stream object for accessing the same bytes but using a separate seek reference. The new stream object sees the same data as the source-stream object. Changes written to one object are immediately visible in the other. Range locking is shared between the stream objects.</p><p>The initial setting of the seek reference in the cloned stream instance is the same as the current setting of the seek reference in the original stream at the time of the clone operation.</p>	
        /// </remarks>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::Clone']/*"/>	
        /// <msdn-id>aa380035</msdn-id>	
        /// <unmanaged>HRESULT IStream::Clone([Out] IStream** ppstm)</unmanaged>	
        /// <unmanaged-short>IStream::Clone</unmanaged-short>	
        public SharpDX.Win32.IStream Clone() {
            unsafe {
                SharpDX.Win32.IStream stmOut;
                IntPtr stmOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.LocalInterop.Calliint(_nativePointer, &stmOut_,((void**)(*(void**)_nativePointer))[13]);		
                stmOut= (stmOut_ == IntPtr.Zero)?null:new SharpDX.Win32.ComStream(stmOut_);	
                __result__.CheckError();
                return stmOut;
            }
        }
    }
    /// <summary>	
    /// <p> The 	
    /// <strong><see cref="SharpDX.Win32.IStreamBase"/></strong> interface supports simplified sequential access to stream objects. The 	
    /// <strong><see cref="SharpDX.Win32.IStream"/></strong> interface inherits its 	
    /// <strong>Read</strong> and 	
    /// <strong>Write</strong> methods from 	
    /// <strong><see cref="SharpDX.Win32.IStreamBase"/></strong>.</p>	
    /// </summary>	
    /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ISequentialStream']/*"/>	
    /// <msdn-id>aa380010</msdn-id>	
    /// <unmanaged>ISequentialStream</unmanaged>	
    /// <unmanaged-short>ISequentialStream</unmanaged-short>	
    [Guid("0c733a30-2a1c-11ce-ade5-00aa0044773d")]
    public partial class ComStreamBase : SharpDX.ComObjectCallback, SharpDX.Win32.IStreamBase {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Win32.ComStreamBase"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ComStreamBase(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Win32.ComStreamBase"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Win32.ComStreamBase(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Win32.ComStreamBase(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Reads a specified number of bytes from the stream object into memory starting at the current read/write location within the stream.</p>	
        /// </summary>	
        /// <param name="vRef"><dd><p>[in]Points to the buffer into which the stream is read. If an error occurs, this value is <c>null</c>.</p></dd></param>	
        /// <param name="cb"><dd><p>[in]Specifies the number of bytes of data to attempt to read from the stream object.</p></dd></param>	
        /// <returns><dd><p>[out]Pointer to a location where this method writes the actual number of bytes read from the stream object. You can set this reference to <c>null</c> to indicate that you are not interested in this value. In this case, this method does not provide the actual number of bytes read.</p></dd></returns>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ISequentialStream::Read']/*"/>	
        /// <msdn-id>ms713642</msdn-id>	
        /// <unmanaged>HRESULT ISequentialStream::Read([Out, Buffer] void* pv,[In] unsigned int cb,[Out, Optional] unsigned int* pcbRead)</unmanaged>	
        /// <unmanaged-short>ISequentialStream::Read</unmanaged-short>	
        public int Read(System.IntPtr vRef, int cb) {
            unsafe {
                int cbReadRef;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.LocalInterop.Calliint(_nativePointer, (void*)vRef, cb, &cbReadRef,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
                return cbReadRef;
            }
        }
        
        /// <summary>	
        /// <p>Writes a specified number of bytes into the stream object starting at the current read/write location within the stream.</p>	
        /// </summary>	
        /// <param name="vRef"><dd><p>[in] Points to the buffer into which the stream should be written.</p></dd></param>	
        /// <param name="cb"><dd><p>[in] The number of bytes of data to attempt to write into the stream.</p></dd></param>	
        /// <returns><dd><p>[out] Pointer to a location where this method writes the actual number of bytes written to the stream object. The caller can set this reference to <c>null</c>, in which case this method does not provide the actual number of bytes written.</p></dd></returns>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ISequentialStream::Write']/*"/>	
        /// <msdn-id>ms711215</msdn-id>	
        /// <unmanaged>HRESULT ISequentialStream::Write([In, Buffer] const void* pv,[In] unsigned int cb,[Out, Optional] unsigned int* pcbWritten)</unmanaged>	
        /// <unmanaged-short>ISequentialStream::Write</unmanaged-short>	
        public int Write(System.IntPtr vRef, int cb) {
            unsafe {
                int cbWrittenRef;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.LocalInterop.Calliint(_nativePointer, (void*)vRef, cb, &cbWrittenRef,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
                return cbWrittenRef;
            }
        }
    }
    /// <summary>	
    /// <p> The 	
    /// <strong><see cref="SharpDX.Win32.IStream"/></strong> interface lets you read and write data to stream objects. Stream objects contain the data in a structured storage object, where storages provide the structure. Simple data can be written directly to a stream but, most frequently, streams are elements nested within a storage object. They are similar to standard files.</p><p>The 	
    /// <strong><see cref="SharpDX.Win32.IStream"/></strong> interface defines methods similar to the MS-DOS FAT file functions. For example, each stream object has its own access rights and a seek reference. The main difference between a DOS file and a stream object is that in the latter case, streams are opened using an 	
    /// <strong><see cref="SharpDX.Win32.IStream"/></strong> interface reference rather than a file handle.</p><p>The methods in this interface present your object's data as a contiguous sequence of bytes that you can read or write. There are also methods for committing and reverting changes on streams that are open in transacted mode and methods for restricting access to a range of bytes in the stream.</p><p>Streams can remain open for long periods of time without consuming file-system resources. The <strong>IUnknown::Release</strong> method is similar to a close function on a file. Once released, the stream object is no longer valid and cannot be used.</p><p>Clients of asynchronous monikers can choose between a data-pull or data-push model for driving an asynchronous 	
    /// <strong>IMoniker::BindToStorage</strong> operation and for receiving asynchronous notifications. See 	
    /// URL Monikers for more information. The following table compares the behavior of asynchronous 	
    /// <strong><see cref="SharpDX.Win32.IStreamBase.Read"/></strong> and 	
    /// <strong><see cref="SharpDX.Win32.IStream.Seek"/></strong> calls returned in <strong>IBindStatusCallback::OnDataAvailable</strong> in these two download models:</p>	
    /// </summary>	
    /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream']/*"/>	
    /// <msdn-id>aa380034</msdn-id>	
    /// <unmanaged>IStream</unmanaged>	
    /// <unmanaged-short>IStream</unmanaged-short>	
    [Guid("0000000c-0000-0000-C000-000000000046")]
    public partial interface IStream : SharpDX.Win32.IStreamBase {
        
        
        /// <summary>	
        /// <p> The <strong>Seek</strong> method changes the seek reference to a new location.  The new location is relative to either the beginning of the stream, the end of the stream, or the current seek reference.</p>	
        /// </summary>	
        /// <param name="dlibMove"><dd> <p>The displacement to be added to the location indicated by the <em>dwOrigin</em> parameter. If <em>dwOrigin</em> is <strong>STREAM_SEEK_SET</strong>, this is interpreted as an unsigned value rather than a signed value.</p> </dd></param>	
        /// <param name="dwOrigin"><dd> <p>The origin for the displacement specified in <em>dlibMove</em>. The origin can be the beginning of the file (<strong>STREAM_SEEK_SET</strong>), the current seek reference (<strong>STREAM_SEEK_CUR</strong>), or the end of the file (<strong>STREAM_SEEK_END</strong>). For more information about values, see the <strong>STREAM_SEEK</strong> enumeration.</p> </dd></param>	
        /// <returns><dd> <p>A reference to the location where this method writes the value of the new seek reference from the beginning of the stream. </p> <p>You can set this reference to <strong><c>null</c></strong>. In this case, this method does not provide the new seek reference.</p> </dd></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Win32.IStream.Seek"/></strong> changes the seek reference so that subsequent read and write operations can be performed at a different location in the stream object. It is an error to seek before the beginning of the stream. It is not, however, an error to seek past the end of the stream. Seeking past the end of the stream is useful for subsequent write operations, as the stream byte range will be extended to the new seek position immediately before the write is complete.</p><p>You can also use this method to obtain the current value of the seek reference by calling this method with the <em>dwOrigin</em> parameter set to <strong>STREAM_SEEK_CUR</strong> and the <em>dlibMove</em> parameter set to 0 so that the seek reference is not changed. The current seek reference is returned in the <em>plibNewPosition</em> parameter.</p>	
        /// </remarks>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::Seek']/*"/>	
        /// <msdn-id>aa380043</msdn-id>	
        /// <unmanaged>HRESULT IStream::Seek([In] LARGE_INTEGER dlibMove,[In] SHARPDX_SEEKORIGIN dwOrigin,[Out, Optional] ULARGE_INTEGER* plibNewPosition)</unmanaged>	
        /// <unmanaged-short>IStream::Seek</unmanaged-short>	
        /* public long Seek(long dlibMove, System.IO.SeekOrigin dwOrigin) */
        
        /// <summary>	
        /// <p>The <strong>SetSize</strong> method changes the size of the stream object.</p>	
        /// </summary>	
        /// <param name="libNewSize"><dd> <p>Specifies the new size, in bytes, of the stream.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> <dd> <p>The size of the stream object was successfully changed.</p> </dd> <dt><strong>E_PENDING</strong></dt> <dd> <p>Asynchronous Storage only: Part or all of the stream's data is currently unavailable. For more information, see <strong>IFillLockBytes</strong> and Asynchronous Storage.</p> </dd> <dt><strong>STG_E_MEDIUMFULL</strong></dt> <dd> <p>The stream size is not changed because there is no space left on the storage device.</p> </dd> <dt><strong>STG_E_INVALIDFUNCTION</strong></dt> <dd> <p>The value of the <em>libNewSize</em> parameter is not supported by the implementation. Not all streams support greater than 2?? bytes. If a stream does not support more than 2?? bytes, the high <strong>DWORD</strong> data type of <em>libNewSize</em> must be zero. If it is nonzero, the implementation may return STG_E_INVALIDFUNCTION. In general, COM-based implementations of the  <strong><see cref="SharpDX.Win32.IStream"/></strong> interface do not support streams larger than 2?? bytes.</p> </dd> <dt><strong>STG_E_REVERTED</strong></dt> <dd> <p>The object has been invalidated by a revert operation above it in the transaction tree.</p> </dd> </dl></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Win32.IStream.SetSize"/></strong> changes the size of the stream object. Call this method to preallocate space for the stream. If the <em>libNewSize</em> parameter is larger than the current stream size, the stream is extended to the indicated size by filling the intervening space with bytes of undefined value. This operation is similar to the 	
        /// <strong><see cref="SharpDX.Win32.IStreamBase.Write"/></strong> method if the seek reference is past the current end of the stream.</p><p>If the <em>libNewSize</em> parameter is smaller than the current stream, the stream is truncated to the indicated size.</p><p>The seek reference is not affected by the change in stream size.</p><p>Calling <strong><see cref="SharpDX.Win32.IStream.SetSize"/></strong> can be an effective way to obtain a large chunk of contiguous space.</p>	
        /// </remarks>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::SetSize']/*"/>	
        /// <msdn-id>aa380044</msdn-id>	
        /// <unmanaged>HRESULT IStream::SetSize([In] ULARGE_INTEGER libNewSize)</unmanaged>	
        /// <unmanaged-short>IStream::SetSize</unmanaged-short>	
        /* public void SetSize(long libNewSize) */
        
        /// <summary>	
        /// <p>The <strong>CopyTo</strong> method copies a specified number of bytes from the current seek reference in the stream to the current seek reference in another stream.</p>	
        /// </summary>	
        /// <param name="stmRef"><dd> <p>A reference to the destination stream. The stream pointed to by <em>pstm</em> can be a new stream or a clone of the source stream.</p> </dd></param>	
        /// <param name="cb"><dd> <p>The number of bytes to copy from the source stream.</p> </dd></param>	
        /// <param name="cbWrittenRef"><dd> <p>A reference to the location where this method writes the actual number of bytes written to the destination. You can set this reference to <strong><c>null</c></strong>. In this case, this method does not provide the actual number of bytes written.</p> </dd></param>	
        /// <returns><dd> <p>A reference to the location where this method writes the actual number of bytes read from the source. You can set this reference to <strong><c>null</c></strong>. In this case, this method does not provide the actual number of bytes read.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The <strong>CopyTo</strong> method copies the specified bytes from one stream to another. It can also be used to copy a stream to itself. The seek reference in each stream instance is adjusted for the number of bytes read or written. This method is equivalent to reading <em>cb</em> bytes into memory using 	
        /// <strong><see cref="SharpDX.Win32.IStreamBase.Read"/></strong> and then immediately writing them to the destination stream using 	
        /// <strong><see cref="SharpDX.Win32.IStreamBase.Write"/></strong>, although <strong><see cref="SharpDX.Win32.IStream.CopyTo_"/></strong> will be more efficient.</p><p>The destination stream can be a clone of the source stream created by calling the 	
        /// <strong><see cref="SharpDX.Win32.IStream.Clone"/></strong> method.</p><p>If <strong><see cref="SharpDX.Win32.IStream.CopyTo_"/></strong> returns an error, you cannot assume that the seek references are valid for either the source or destination. Additionally, the values of <em>pcbRead</em> and <em>pcbWritten</em> are not meaningful even though they are returned.</p><p>If <strong><see cref="SharpDX.Win32.IStream.CopyTo_"/></strong> returns successfully, the actual number of bytes read and written are the same.</p><p>To copy the remainder of the source from the current seek reference, specify the maximum large integer value for the <em>cb</em> parameter. If the seek reference is the beginning of the stream, this operation copies the entire stream.</p>	
        /// </remarks>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::CopyTo']/*"/>	
        /// <msdn-id>aa380038</msdn-id>	
        /// <unmanaged>HRESULT IStream::CopyTo([In] IStream* pstm,[In] ULARGE_INTEGER cb,[Out] ULARGE_INTEGER* pcbRead,[Out] ULARGE_INTEGER* pcbWritten)</unmanaged>	
        /// <unmanaged-short>IStream::CopyTo</unmanaged-short>	
        /* internal long CopyTo_(System.IntPtr stmRef, long cb, out long cbWrittenRef) */
        
        /// <summary>	
        /// <p>The <strong>Commit</strong> method ensures that any changes made to a stream object open in transacted mode are reflected in the parent storage. If the stream object is open in direct mode, <strong><see cref="SharpDX.Win32.IStream.Commit"/></strong> has no effect other than flushing all memory buffers to the next-level storage object. The COM compound file implementation of streams does not support opening streams in transacted mode.</p>	
        /// </summary>	
        /// <param name="grfCommitFlags"><dd> <p>Controls how the changes for the stream object are committed. See the <strong><see cref="SharpDX.Win32.CommitFlags"/></strong> enumeration for a definition of these values.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> <dd> <p>Changes to the stream object were successfully committed to the parent level.</p> </dd> <dt><strong>E_PENDING</strong></dt> <dd> <p>Asynchronous Storage only: Part or all of the stream's data is currently unavailable. For more information see <strong>IFillLockBytes</strong> and Asynchronous Storage.</p> </dd> <dt><strong>STG_E_MEDIUMFULL</strong></dt> <dd> <p>The commit operation failed due to lack of space on the storage device.</p> </dd> <dt><strong>STG_E_REVERTED</strong></dt> <dd> <p>The object has been invalidated by a revert operation above it in the transaction tree.</p> </dd> </dl></returns>	
        /// <remarks>	
        /// <p>The <strong>Commit</strong> method ensures that changes to a stream object opened in transacted mode are reflected in the parent storage. Changes that have been made to the stream since it was opened or last committed are reflected to the parent storage object. If the parent is opened in transacted mode, the parent may revert at a later time, rolling back the changes to this stream object. The compound file implementation does not support the opening of streams in transacted mode, so this method has very little effect other than to flush memory buffers. For more information, see 	
        /// <see cref="SharpDX.Win32.IStream"/> - Compound File Implementation.</p><p>If the stream is open in direct mode, this method ensures that any memory buffers have been flushed out to the underlying storage object. This is much like a flush in traditional file systems.</p><p>The <strong><see cref="SharpDX.Win32.IStream.Commit"/></strong> method is useful on a direct mode stream when the implementation of the 	
        /// <strong><see cref="SharpDX.Win32.IStream"/></strong> interface is a wrapper for underlying file system APIs. In this case, <strong><see cref="SharpDX.Win32.IStream.Commit"/></strong> would be connected to the file system's flush call.</p>	
        /// </remarks>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::Commit']/*"/>	
        /// <msdn-id>aa380036</msdn-id>	
        /// <unmanaged>HRESULT IStream::Commit([In] STGC grfCommitFlags)</unmanaged>	
        /// <unmanaged-short>IStream::Commit</unmanaged-short>	
        /* public void Commit(SharpDX.Win32.CommitFlags grfCommitFlags) */
        
        /// <summary>	
        /// <p>The <strong>Revert</strong> method discards all changes that have been made to a transacted stream since the last 	
        /// <strong><see cref="SharpDX.Win32.IStream.Commit"/></strong> call. On streams open in direct mode and streams using the COM compound file implementation of <strong><see cref="SharpDX.Win32.IStream.Revert"/></strong>, this method has no effect.</p>	
        /// </summary>	
        /// <returns><p>This method can return one of these values.</p><dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> <dd> <p>The stream was successfully reverted to its previous version.</p> </dd> <dt><strong>E_PENDING</strong></dt> <dd> <p>Asynchronous Storage only: Part or all of the stream's data is currently unavailable. For more information see <strong>IFillLockBytes</strong> and Asynchronous Storage.</p> </dd> </dl></returns>	
        /// <remarks>	
        /// <p>The <strong>Revert</strong> method discards changes made to a transacted stream since the last commit operation.</p>	
        /// </remarks>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::Revert']/*"/>	
        /// <msdn-id>aa380042</msdn-id>	
        /// <unmanaged>HRESULT IStream::Revert()</unmanaged>	
        /// <unmanaged-short>IStream::Revert</unmanaged-short>	
        /* public void Revert() */
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="libOffset">No documentation.</param>	
        /// <param name="cb">No documentation.</param>	
        /// <param name="dwLockType">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::LockRegion']/*"/>	
        /// <unmanaged>HRESULT IStream::LockRegion([In] ULARGE_INTEGER libOffset,[In] ULARGE_INTEGER cb,[In] LOCKTYPE dwLockType)</unmanaged>	
        /// <unmanaged-short>IStream::LockRegion</unmanaged-short>	
        /* public void LockRegion(long libOffset, long cb, SharpDX.Win32.LockType dwLockType) */
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="libOffset">No documentation.</param>	
        /// <param name="cb">No documentation.</param>	
        /// <param name="dwLockType">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::UnlockRegion']/*"/>	
        /// <unmanaged>HRESULT IStream::UnlockRegion([In] ULARGE_INTEGER libOffset,[In] ULARGE_INTEGER cb,[In] LOCKTYPE dwLockType)</unmanaged>	
        /// <unmanaged-short>IStream::UnlockRegion</unmanaged-short>	
        /* public void UnlockRegion(long libOffset, long cb, SharpDX.Win32.LockType dwLockType) */
        
        /// <summary>	
        /// <p> The <strong>Stat</strong> method retrieves the 	
        /// <strong><see cref="SharpDX.Win32.StorageStatistics"/></strong> structure for this stream.</p>	
        /// </summary>	
        /// <param name="grfStatFlag">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Win32.IStream.GetStatistics"/></strong> retrieves a reference to the 	
        /// <strong><see cref="SharpDX.Win32.StorageStatistics"/></strong> structure that contains information about this open stream. When this stream is within a structured storage and 	
        /// <strong>IStorage::EnumElements</strong> is called, it creates an enumerator object with the 	
        /// <strong>IEnumSTATSTG</strong> interface on it, which can be called to enumerate the storages and streams through the 	
        /// <strong><see cref="SharpDX.Win32.StorageStatistics"/></strong> structures associated with each of them.</p>	
        /// </remarks>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::Stat']/*"/>	
        /// <msdn-id>aa380045</msdn-id>	
        /// <unmanaged>HRESULT IStream::Stat([Out] STATSTG* pstatstg,[In] STATFLAG grfStatFlag)</unmanaged>	
        /// <unmanaged-short>IStream::Stat</unmanaged-short>	
        /* public SharpDX.Win32.StorageStatistics GetStatistics(SharpDX.Win32.StorageStatisticsFlags grfStatFlag) */
        
        /// <summary>	
        /// <p> The <strong>Clone</strong> method creates a new stream object with its own seek reference that references the same bytes as the original stream.</p>	
        /// </summary>	
        /// <returns><dd> <p>When successful, reference to the location of an <strong><see cref="SharpDX.Win32.IStream"/></strong> reference to the new stream object. If an error occurs, this parameter is <strong><c>null</c></strong>.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The <strong>Clone</strong> method creates a new stream object for accessing the same bytes but using a separate seek reference. The new stream object sees the same data as the source-stream object. Changes written to one object are immediately visible in the other. Range locking is shared between the stream objects.</p><p>The initial setting of the seek reference in the cloned stream instance is the same as the current setting of the seek reference in the original stream at the time of the clone operation.</p>	
        /// </remarks>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IStream::Clone']/*"/>	
        /// <msdn-id>aa380035</msdn-id>	
        /// <unmanaged>HRESULT IStream::Clone([Out] IStream** ppstm)</unmanaged>	
        /// <unmanaged-short>IStream::Clone</unmanaged-short>	
        /* public SharpDX.Win32.IStream Clone() */
    }
    /// <summary>	
    /// <p> The 	
    /// <strong><see cref="SharpDX.Win32.IStreamBase"/></strong> interface supports simplified sequential access to stream objects. The 	
    /// <strong><see cref="SharpDX.Win32.IStream"/></strong> interface inherits its 	
    /// <strong>Read</strong> and 	
    /// <strong>Write</strong> methods from 	
    /// <strong><see cref="SharpDX.Win32.IStreamBase"/></strong>.</p>	
    /// </summary>	
    /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ISequentialStream']/*"/>	
    /// <msdn-id>aa380010</msdn-id>	
    /// <unmanaged>ISequentialStream</unmanaged>	
    /// <unmanaged-short>ISequentialStream</unmanaged-short>	
    [Guid("0c733a30-2a1c-11ce-ade5-00aa0044773d")]
    public partial interface IStreamBase : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p>Reads a specified number of bytes from the stream object into memory starting at the current read/write location within the stream.</p>	
        /// </summary>	
        /// <param name="vRef"><dd><p>[in]Points to the buffer into which the stream is read. If an error occurs, this value is <c>null</c>.</p></dd></param>	
        /// <param name="cb"><dd><p>[in]Specifies the number of bytes of data to attempt to read from the stream object.</p></dd></param>	
        /// <returns><dd><p>[out]Pointer to a location where this method writes the actual number of bytes read from the stream object. You can set this reference to <c>null</c> to indicate that you are not interested in this value. In this case, this method does not provide the actual number of bytes read.</p></dd></returns>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ISequentialStream::Read']/*"/>	
        /// <msdn-id>ms713642</msdn-id>	
        /// <unmanaged>HRESULT ISequentialStream::Read([Out, Buffer] void* pv,[In] unsigned int cb,[Out, Optional] unsigned int* pcbRead)</unmanaged>	
        /// <unmanaged-short>ISequentialStream::Read</unmanaged-short>	
        /* public int Read(System.IntPtr vRef, int cb) */
        
        /// <summary>	
        /// <p>Writes a specified number of bytes into the stream object starting at the current read/write location within the stream.</p>	
        /// </summary>	
        /// <param name="vRef"><dd><p>[in] Points to the buffer into which the stream should be written.</p></dd></param>	
        /// <param name="cb"><dd><p>[in] The number of bytes of data to attempt to write into the stream.</p></dd></param>	
        /// <returns><dd><p>[out] Pointer to a location where this method writes the actual number of bytes written to the stream object. The caller can set this reference to <c>null</c>, in which case this method does not provide the actual number of bytes written.</p></dd></returns>	
        /// <include file='..\..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ISequentialStream::Write']/*"/>	
        /// <msdn-id>ms711215</msdn-id>	
        /// <unmanaged>HRESULT ISequentialStream::Write([In, Buffer] const void* pv,[In] unsigned int cb,[Out, Optional] unsigned int* pcbWritten)</unmanaged>	
        /// <unmanaged-short>ISequentialStream::Write</unmanaged-short>	
        /* public int Write(System.IntPtr vRef, int cb) */
    }
}

